// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPool, VkDescriptorPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebuffer, VkFramebuffer)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPool, VkCommandPool)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugMarkerMarkerInfoEXT, VkDebugMarkerMarkerInfoEXT);

struct VkDebugMarkerMarkerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerMarkerInfoEXT,true,true> {
    VkDebugMarkerMarkerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerMarkerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pMarkerName)>("pMarkerName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationImageCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV);

struct VkDedicatedAllocationImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationImageCreateInfoNV,true,true> {
    VkDedicatedAllocationImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationBufferCreateInfoNV);

struct VkDedicatedAllocationBufferCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationBufferCreateInfoNV,true,true> {
    VkDedicatedAllocationBufferCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationBufferCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationMemoryAllocateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV);

struct VkDedicatedAllocationMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationMemoryAllocateInfoNV,true,true> {
    VkDedicatedAllocationMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);

struct VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackFeaturesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedback)>("transformFeedback");
        addField<DAS_BIND_MANAGED_FIELD(geometryStreams)>("geometryStreams");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);

struct VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackPropertiesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreams)>("maxTransformFeedbackStreams");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBuffers)>("maxTransformFeedbackBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferSize)>("maxTransformFeedbackBufferSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreamDataSize)>("maxTransformFeedbackStreamDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataSize)>("maxTransformFeedbackBufferDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataStride)>("maxTransformFeedbackBufferDataStride");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackQueries)>("transformFeedbackQueries");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackStreamsLinesTriangles)>("transformFeedbackStreamsLinesTriangles");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackRasterizationStreamSelect)>("transformFeedbackRasterizationStreamSelect");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackDraw)>("transformFeedbackDraw");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateStreamCreateInfoEXT, VkPipelineRasterizationStateStreamCreateInfoEXT);

struct VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateStreamCreateInfoEXT,true,true> {
    VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateStreamCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationStream)>("rasterizationStream");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewHandleInfoNVX, VkImageViewHandleInfoNVX);

struct VkImageViewHandleInfoNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewHandleInfoNVX,true,true> {
    VkImageViewHandleInfoNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewHandleInfoNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewAddressPropertiesNVX, VkImageViewAddressPropertiesNVX);

struct VkImageViewAddressPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewAddressPropertiesNVX,true,true> {
    VkImageViewAddressPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewAddressPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTextureLODGatherFormatPropertiesAMD, VkTextureLODGatherFormatPropertiesAMD);

struct VkTextureLODGatherFormatPropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkTextureLODGatherFormatPropertiesAMD,true,true> {
    VkTextureLODGatherFormatPropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTextureLODGatherFormatPropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsTextureGatherLODBiasAMD)>("supportsTextureGatherLODBiasAMD");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderResourceUsageAMD, VkShaderResourceUsageAMD);

struct VkShaderResourceUsageAMDAnnotation
: public ManagedStructureAnnotation<VkShaderResourceUsageAMD,true,true> {
    VkShaderResourceUsageAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderResourceUsageAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(numUsedVgprs)>("numUsedVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numUsedSgprs)>("numUsedSgprs");
        addField<DAS_BIND_MANAGED_FIELD(ldsSizePerLocalWorkGroup)>("ldsSizePerLocalWorkGroup");
        addField<DAS_BIND_MANAGED_FIELD(ldsUsageSizeInBytes)>("ldsUsageSizeInBytes");
        addField<DAS_BIND_MANAGED_FIELD(scratchMemUsageInBytes)>("scratchMemUsageInBytes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderStatisticsInfoAMD, VkShaderStatisticsInfoAMD);

struct VkShaderStatisticsInfoAMDAnnotation
: public ManagedStructureAnnotation<VkShaderStatisticsInfoAMD,true,true> {
    VkShaderStatisticsInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderStatisticsInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shaderStageMask)>("shaderStageMask");
        addField<DAS_BIND_MANAGED_FIELD(resourceUsage)>("resourceUsage");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalVgprs)>("numPhysicalVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalSgprs)>("numPhysicalSgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableVgprs)>("numAvailableVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableSgprs)>("numAvailableSgprs");
        addField<DAS_BIND_MANAGED_FIELD(computeWorkGroupSize)>("computeWorkGroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV);

struct VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCornerSampledImageFeaturesNV,true,true> {
    VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCornerSampledImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cornerSampledImage)>("cornerSampledImage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalImageFormatPropertiesNV, VkExternalImageFormatPropertiesNV);

struct VkExternalImageFormatPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatPropertiesNV,true,true> {
    VkExternalImageFormatPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryImageCreateInfoNV, VkExternalMemoryImageCreateInfoNV);

struct VkExternalMemoryImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfoNV,true,true> {
    VkExternalMemoryImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportMemoryAllocateInfoNV, VkExportMemoryAllocateInfoNV);

struct VkExportMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfoNV,true,true> {
    VkExportMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFlagsEXT, VkValidationFlagsEXT);

struct VkValidationFlagsEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFlagsEXT,true,true> {
    VkValidationFlagsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFlagsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationCheckCount)>("disabledValidationCheckCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationChecks)>("pDisabledValidationChecks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,true,true> {
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_HDR)>("textureCompressionASTC_HDR");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewASTCDecodeModeEXT, VkImageViewASTCDecodeModeEXT);

struct VkImageViewASTCDecodeModeEXTAnnotation
: public ManagedStructureAnnotation<VkImageViewASTCDecodeModeEXT,true,true> {
    VkImageViewASTCDecodeModeEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewASTCDecodeModeEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeMode)>("decodeMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);

struct VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceASTCDecodeFeaturesEXT,true,true> {
    VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceASTCDecodeFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeModeSharedExponent)>("decodeModeSharedExponent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingBeginInfoEXT);

struct VkConditionalRenderingBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkConditionalRenderingBeginInfoEXT,true,true> {
    VkConditionalRenderingBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConditionalRenderingBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);

struct VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConditionalRenderingFeaturesEXT,true,true> {
    VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConditionalRenderingFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRendering)>("conditionalRendering");
        addField<DAS_BIND_MANAGED_FIELD(inheritedConditionalRendering)>("inheritedConditionalRendering");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceConditionalRenderingInfoEXT);

struct VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceConditionalRenderingInfoEXT,true,true> {
    VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceConditionalRenderingInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRenderingEnable)>("conditionalRenderingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewportWScalingNV, VkViewportWScalingNV);

struct VkViewportWScalingNVAnnotation
: public ManagedStructureAnnotation<VkViewportWScalingNV,true,true> {
    VkViewportWScalingNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportWScalingNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(xcoeff)>("xcoeff");
        addField<DAS_BIND_MANAGED_FIELD(ycoeff)>("ycoeff");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportWScalingStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV);

struct VkPipelineViewportWScalingStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportWScalingStateCreateInfoNV,true,true> {
    VkPipelineViewportWScalingStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportWScalingStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewportWScalingEnable)>("viewportWScalingEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportWScalings)>("pViewportWScalings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilities2EXT, VkSurfaceCapabilities2EXT);

struct VkSurfaceCapabilities2EXTAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2EXT,true,true> {
    VkSurfaceCapabilities2EXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2EXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
        addField<DAS_BIND_MANAGED_FIELD(supportedSurfaceCounters)>("supportedSurfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPowerInfoEXT, VkDisplayPowerInfoEXT);

struct VkDisplayPowerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayPowerInfoEXT,true,true> {
    VkDisplayPowerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPowerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(powerState)>("powerState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceEventInfoEXT, VkDeviceEventInfoEXT);

struct VkDeviceEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceEventInfoEXT,true,true> {
    VkDeviceEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceEvent)>("deviceEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayEventInfoEXT, VkDisplayEventInfoEXT);

struct VkDisplayEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayEventInfoEXT,true,true> {
    VkDisplayEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayEvent)>("displayEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCounterCreateInfoEXT, VkSwapchainCounterCreateInfoEXT);

struct VkSwapchainCounterCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSwapchainCounterCreateInfoEXT,true,true> {
    VkSwapchainCounterCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCounterCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCounters)>("surfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRefreshCycleDurationGOOGLE, VkRefreshCycleDurationGOOGLE);

struct VkRefreshCycleDurationGOOGLEAnnotation
: public ManagedStructureAnnotation<VkRefreshCycleDurationGOOGLE,true,true> {
    VkRefreshCycleDurationGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRefreshCycleDurationGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(refreshDuration)>("refreshDuration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPastPresentationTimingGOOGLE, VkPastPresentationTimingGOOGLE);

struct VkPastPresentationTimingGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPastPresentationTimingGOOGLE,true,true> {
    VkPastPresentationTimingGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPastPresentationTimingGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(actualPresentTime)>("actualPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(earliestPresentTime)>("earliestPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(presentMargin)>("presentMargin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimeGOOGLE, VkPresentTimeGOOGLE);

struct VkPresentTimeGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimeGOOGLE,true,true> {
    VkPresentTimeGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimeGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimesInfoGOOGLE, VkPresentTimesInfoGOOGLE);

struct VkPresentTimesInfoGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimesInfoGOOGLE,true,true> {
    VkPresentTimesInfoGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimesInfoGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pTimes)>("pTimes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_9(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkDescriptorBindingFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSemaphoreWaitFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPresentModeKHR>());
    module.addEnumeration(make_smart<EnumerationVkColorSpaceKHR>());
    module.addEnumeration(make_smart<EnumerationVkSurfaceTransformFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkCompositeAlphaFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkSwapchainCreateFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkDeviceGroupPresentModeFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkDisplayPlaneAlphaFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterUnitKHR>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterScopeKHR>());
}

void addVulkanGeneratedOpaqueStructs_9(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorPool>>("VkDescriptorPool", "VkDescriptorPool"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkFramebuffer>>("VkFramebuffer", "VkFramebuffer"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkCommandPool>>("VkCommandPool", "VkCommandPool"));
}

void addVulkanGeneratedStructs_9(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkDebugMarkerMarkerInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDedicatedAllocationImageCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDedicatedAllocationBufferCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDedicatedAllocationMemoryAllocateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewHandleInfoNVXAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewAddressPropertiesNVXAnnotation>(lib));
    module.addAnnotation(make_smart<VkTextureLODGatherFormatPropertiesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkShaderResourceUsageAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkShaderStatisticsInfoAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalImageFormatPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalMemoryImageCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExportMemoryAllocateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkValidationFlagsEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewASTCDecodeModeEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkConditionalRenderingBeginInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkViewportWScalingNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineViewportWScalingStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceCapabilities2EXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayPowerInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceEventInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayEventInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSwapchainCounterCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRefreshCycleDurationGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPastPresentationTimingGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentTimeGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentTimesInfoGOOGLEAnnotation>(lib));
}

void addVulkanGeneratedFunctions_9(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkCmdDrawIndexed)>(module, lib, "vkCmdDrawIndexed",
        SideEffects::worstDefault, "vkCmdDrawIndexed");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndirect)>(module, lib, "vkCmdDrawIndirect",
        SideEffects::worstDefault, "vkCmdDrawIndirect");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirect)>(module, lib, "vkCmdDrawIndexedIndirect",
        SideEffects::worstDefault, "vkCmdDrawIndexedIndirect");
    addExtern<DAS_BIND_FUN(vkCmdDispatch)>(module, lib, "vkCmdDispatch",
        SideEffects::worstDefault, "vkCmdDispatch");
    addExtern<DAS_BIND_FUN(vkCmdDispatchIndirect)>(module, lib, "vkCmdDispatchIndirect",
        SideEffects::worstDefault, "vkCmdDispatchIndirect");
    addExtern<DAS_BIND_FUN(vkCmdCopyBuffer)>(module, lib, "vkCmdCopyBuffer",
        SideEffects::worstDefault, "vkCmdCopyBuffer");
    addExtern<DAS_BIND_FUN(vkCmdCopyImage)>(module, lib, "vkCmdCopyImage",
        SideEffects::worstDefault, "vkCmdCopyImage");
    addExtern<DAS_BIND_FUN(vkCmdBlitImage)>(module, lib, "vkCmdBlitImage",
        SideEffects::worstDefault, "vkCmdBlitImage");
    addExtern<DAS_BIND_FUN(vkCmdCopyBufferToImage)>(module, lib, "vkCmdCopyBufferToImage",
        SideEffects::worstDefault, "vkCmdCopyBufferToImage");
    addExtern<DAS_BIND_FUN(vkCmdCopyImageToBuffer)>(module, lib, "vkCmdCopyImageToBuffer",
        SideEffects::worstDefault, "vkCmdCopyImageToBuffer");
    addExtern<DAS_BIND_FUN(vkCmdUpdateBuffer)>(module, lib, "vkCmdUpdateBuffer",
        SideEffects::worstDefault, "vkCmdUpdateBuffer");
    addExtern<DAS_BIND_FUN(vkCmdFillBuffer)>(module, lib, "vkCmdFillBuffer",
        SideEffects::worstDefault, "vkCmdFillBuffer");
}

void addVulkanGeneratedConsts_9(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_depth_clip_enable", 1);
    addConstant(module, "VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_swapchain_colorspace", 1);
    addConstant(module, "VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION", 4);
    addConstant(module, "VK_EXT_hdr_metadata", 1);
    addConstant(module, "VK_EXT_HDR_METADATA_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_external_memory_dma_buf", 1);
    addConstant(module, "VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_queue_family_foreign", 1);
    addConstant(module, "VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION", 1);
    addConstant(module, "VK_QUEUE_FAMILY_FOREIGN_EXT", (~0U-2));
    addConstant(module, "VK_EXT_debug_utils", 1);
    addConstant(module, "VK_EXT_DEBUG_UTILS_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_sampler_filter_minmax", 1);
    addConstant(module, "VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_gpu_shader_int16", 1);
    addConstant(module, "VK_AMD_GPU_SHADER_INT16_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_mixed_attachment_samples", 1);
    addConstant(module, "VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_fragment_mask", 1);
    addConstant(module, "VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_inline_uniform_block", 1);
    addConstant(module, "VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_shader_stencil_export", 1);
    addConstant(module, "VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_sample_locations", 1);
}
