// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPool, VkCommandPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversion, VkSamplerYcbcrConversion)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationBufferCreateInfoNV);

struct VkDedicatedAllocationBufferCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationBufferCreateInfoNV,true,true> {
    VkDedicatedAllocationBufferCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationBufferCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationMemoryAllocateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV);

struct VkDedicatedAllocationMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationMemoryAllocateInfoNV,true,true> {
    VkDedicatedAllocationMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);

struct VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackFeaturesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedback)>("transformFeedback");
        addField<DAS_BIND_MANAGED_FIELD(geometryStreams)>("geometryStreams");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);

struct VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackPropertiesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreams)>("maxTransformFeedbackStreams");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBuffers)>("maxTransformFeedbackBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferSize)>("maxTransformFeedbackBufferSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreamDataSize)>("maxTransformFeedbackStreamDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataSize)>("maxTransformFeedbackBufferDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataStride)>("maxTransformFeedbackBufferDataStride");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackQueries)>("transformFeedbackQueries");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackStreamsLinesTriangles)>("transformFeedbackStreamsLinesTriangles");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackRasterizationStreamSelect)>("transformFeedbackRasterizationStreamSelect");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackDraw)>("transformFeedbackDraw");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateStreamCreateInfoEXT, VkPipelineRasterizationStateStreamCreateInfoEXT);

struct VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateStreamCreateInfoEXT,true,true> {
    VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateStreamCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationStream)>("rasterizationStream");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewHandleInfoNVX, VkImageViewHandleInfoNVX);

struct VkImageViewHandleInfoNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewHandleInfoNVX,true,true> {
    VkImageViewHandleInfoNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewHandleInfoNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewAddressPropertiesNVX, VkImageViewAddressPropertiesNVX);

struct VkImageViewAddressPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewAddressPropertiesNVX,true,true> {
    VkImageViewAddressPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewAddressPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTextureLODGatherFormatPropertiesAMD, VkTextureLODGatherFormatPropertiesAMD);

struct VkTextureLODGatherFormatPropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkTextureLODGatherFormatPropertiesAMD,true,true> {
    VkTextureLODGatherFormatPropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTextureLODGatherFormatPropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsTextureGatherLODBiasAMD)>("supportsTextureGatherLODBiasAMD");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderResourceUsageAMD, VkShaderResourceUsageAMD);

struct VkShaderResourceUsageAMDAnnotation
: public ManagedStructureAnnotation<VkShaderResourceUsageAMD,true,true> {
    VkShaderResourceUsageAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderResourceUsageAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(numUsedVgprs)>("numUsedVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numUsedSgprs)>("numUsedSgprs");
        addField<DAS_BIND_MANAGED_FIELD(ldsSizePerLocalWorkGroup)>("ldsSizePerLocalWorkGroup");
        addField<DAS_BIND_MANAGED_FIELD(ldsUsageSizeInBytes)>("ldsUsageSizeInBytes");
        addField<DAS_BIND_MANAGED_FIELD(scratchMemUsageInBytes)>("scratchMemUsageInBytes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderStatisticsInfoAMD, VkShaderStatisticsInfoAMD);

struct VkShaderStatisticsInfoAMDAnnotation
: public ManagedStructureAnnotation<VkShaderStatisticsInfoAMD,true,true> {
    VkShaderStatisticsInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderStatisticsInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shaderStageMask)>("shaderStageMask");
        addField<DAS_BIND_MANAGED_FIELD(resourceUsage)>("resourceUsage");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalVgprs)>("numPhysicalVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalSgprs)>("numPhysicalSgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableVgprs)>("numAvailableVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableSgprs)>("numAvailableSgprs");
        addField<DAS_BIND_MANAGED_FIELD(computeWorkGroupSize)>("computeWorkGroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV);

struct VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCornerSampledImageFeaturesNV,true,true> {
    VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCornerSampledImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cornerSampledImage)>("cornerSampledImage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalImageFormatPropertiesNV, VkExternalImageFormatPropertiesNV);

struct VkExternalImageFormatPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatPropertiesNV,true,true> {
    VkExternalImageFormatPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryImageCreateInfoNV, VkExternalMemoryImageCreateInfoNV);

struct VkExternalMemoryImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfoNV,true,true> {
    VkExternalMemoryImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportMemoryAllocateInfoNV, VkExportMemoryAllocateInfoNV);

struct VkExportMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfoNV,true,true> {
    VkExportMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFlagsEXT, VkValidationFlagsEXT);

struct VkValidationFlagsEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFlagsEXT,true,true> {
    VkValidationFlagsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFlagsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationCheckCount)>("disabledValidationCheckCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationChecks)>("pDisabledValidationChecks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,true,true> {
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_HDR)>("textureCompressionASTC_HDR");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewASTCDecodeModeEXT, VkImageViewASTCDecodeModeEXT);

struct VkImageViewASTCDecodeModeEXTAnnotation
: public ManagedStructureAnnotation<VkImageViewASTCDecodeModeEXT,true,true> {
    VkImageViewASTCDecodeModeEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewASTCDecodeModeEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeMode)>("decodeMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);

struct VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceASTCDecodeFeaturesEXT,true,true> {
    VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceASTCDecodeFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeModeSharedExponent)>("decodeModeSharedExponent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingBeginInfoEXT);

struct VkConditionalRenderingBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkConditionalRenderingBeginInfoEXT,true,true> {
    VkConditionalRenderingBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConditionalRenderingBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);

struct VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConditionalRenderingFeaturesEXT,true,true> {
    VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConditionalRenderingFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRendering)>("conditionalRendering");
        addField<DAS_BIND_MANAGED_FIELD(inheritedConditionalRendering)>("inheritedConditionalRendering");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceConditionalRenderingInfoEXT);

struct VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceConditionalRenderingInfoEXT,true,true> {
    VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceConditionalRenderingInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRenderingEnable)>("conditionalRenderingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewportWScalingNV, VkViewportWScalingNV);

struct VkViewportWScalingNVAnnotation
: public ManagedStructureAnnotation<VkViewportWScalingNV,true,true> {
    VkViewportWScalingNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportWScalingNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(xcoeff)>("xcoeff");
        addField<DAS_BIND_MANAGED_FIELD(ycoeff)>("ycoeff");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportWScalingStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV);

struct VkPipelineViewportWScalingStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportWScalingStateCreateInfoNV,true,true> {
    VkPipelineViewportWScalingStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportWScalingStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewportWScalingEnable)>("viewportWScalingEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportWScalings)>("pViewportWScalings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilities2EXT, VkSurfaceCapabilities2EXT);

struct VkSurfaceCapabilities2EXTAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2EXT,true,true> {
    VkSurfaceCapabilities2EXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2EXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
        addField<DAS_BIND_MANAGED_FIELD(supportedSurfaceCounters)>("supportedSurfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPowerInfoEXT, VkDisplayPowerInfoEXT);

struct VkDisplayPowerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayPowerInfoEXT,true,true> {
    VkDisplayPowerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPowerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(powerState)>("powerState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceEventInfoEXT, VkDeviceEventInfoEXT);

struct VkDeviceEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceEventInfoEXT,true,true> {
    VkDeviceEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceEvent)>("deviceEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayEventInfoEXT, VkDisplayEventInfoEXT);

struct VkDisplayEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayEventInfoEXT,true,true> {
    VkDisplayEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayEvent)>("displayEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCounterCreateInfoEXT, VkSwapchainCounterCreateInfoEXT);

struct VkSwapchainCounterCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSwapchainCounterCreateInfoEXT,true,true> {
    VkSwapchainCounterCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCounterCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCounters)>("surfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRefreshCycleDurationGOOGLE, VkRefreshCycleDurationGOOGLE);

struct VkRefreshCycleDurationGOOGLEAnnotation
: public ManagedStructureAnnotation<VkRefreshCycleDurationGOOGLE,true,true> {
    VkRefreshCycleDurationGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRefreshCycleDurationGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(refreshDuration)>("refreshDuration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPastPresentationTimingGOOGLE, VkPastPresentationTimingGOOGLE);

struct VkPastPresentationTimingGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPastPresentationTimingGOOGLE,true,true> {
    VkPastPresentationTimingGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPastPresentationTimingGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(actualPresentTime)>("actualPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(earliestPresentTime)>("earliestPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(presentMargin)>("presentMargin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimeGOOGLE, VkPresentTimeGOOGLE);

struct VkPresentTimeGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimeGOOGLE,true,true> {
    VkPresentTimeGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimeGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimesInfoGOOGLE, VkPresentTimesInfoGOOGLE);

struct VkPresentTimesInfoGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimesInfoGOOGLE,true,true> {
    VkPresentTimesInfoGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimesInfoGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pTimes)>("pTimes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);

struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,true,true> {
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(perViewPositionAllComponents)>("perViewPositionAllComponents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewportSwizzleNV, VkViewportSwizzleNV);

struct VkViewportSwizzleNVAnnotation
: public ManagedStructureAnnotation<VkViewportSwizzleNV,true,true> {
    VkViewportSwizzleNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportSwizzleNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
        addField<DAS_BIND_MANAGED_FIELD(w)>("w");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_9(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkDescriptorBindingFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSemaphoreWaitFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPresentModeKHR>());
    module.addEnumeration(make_smart<EnumerationVkColorSpaceKHR>());
    module.addEnumeration(make_smart<EnumerationVkSurfaceTransformFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkCompositeAlphaFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkSwapchainCreateFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkDeviceGroupPresentModeFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkDisplayPlaneAlphaFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterUnitKHR>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterScopeKHR>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkCommandPool>>("VkCommandPool", "VkCommandPool"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkSamplerYcbcrConversion>>("VkSamplerYcbcrConversion", "VkSamplerYcbcrConversion"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkDedicatedAllocationBufferCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDedicatedAllocationMemoryAllocateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewHandleInfoNVXAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewAddressPropertiesNVXAnnotation>(lib));
    module.addAnnotation(make_smart<VkTextureLODGatherFormatPropertiesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkShaderResourceUsageAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkShaderStatisticsInfoAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalImageFormatPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalMemoryImageCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkExportMemoryAllocateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkValidationFlagsEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewASTCDecodeModeEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkConditionalRenderingBeginInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkViewportWScalingNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineViewportWScalingStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceCapabilities2EXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayPowerInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceEventInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayEventInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSwapchainCounterCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRefreshCycleDurationGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPastPresentationTimingGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentTimeGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentTimesInfoGOOGLEAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation>(lib));
    module.addAnnotation(make_smart<VkViewportSwizzleNVAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkUpdateDescriptorSetWithTemplate)>(*this, lib, "vkUpdateDescriptorSetWithTemplate",
        SideEffects::worstDefault, "vkUpdateDescriptorSetWithTemplate");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalBufferProperties)>(*this, lib, "vkGetPhysicalDeviceExternalBufferProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalBufferProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalFenceProperties)>(*this, lib, "vkGetPhysicalDeviceExternalFenceProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalFenceProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalSemaphoreProperties)>(*this, lib, "vkGetPhysicalDeviceExternalSemaphoreProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalSemaphoreProperties");
    addExtern<DAS_BIND_FUN(vkGetDescriptorSetLayoutSupport)>(*this, lib, "vkGetDescriptorSetLayoutSupport",
        SideEffects::worstDefault, "vkGetDescriptorSetLayoutSupport");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndirectCount)>(*this, lib, "vkCmdDrawIndirectCount",
        SideEffects::worstDefault, "vkCmdDrawIndirectCount");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirectCount)>(*this, lib, "vkCmdDrawIndexedIndirectCount",
        SideEffects::worstDefault, "vkCmdDrawIndexedIndirectCount");
    addExtern<DAS_BIND_FUN(vkCreateRenderPass2)>(*this, lib, "vkCreateRenderPass2",
        SideEffects::worstDefault, "vkCreateRenderPass2");
    addExtern<DAS_BIND_FUN(vkCmdBeginRenderPass2)>(*this, lib, "vkCmdBeginRenderPass2",
        SideEffects::worstDefault, "vkCmdBeginRenderPass2");
    addExtern<DAS_BIND_FUN(vkCmdNextSubpass2)>(*this, lib, "vkCmdNextSubpass2",
        SideEffects::worstDefault, "vkCmdNextSubpass2");
    addExtern<DAS_BIND_FUN(vkCmdEndRenderPass2)>(*this, lib, "vkCmdEndRenderPass2",
        SideEffects::worstDefault, "vkCmdEndRenderPass2");
    addExtern<DAS_BIND_FUN(vkResetQueryPool)>(*this, lib, "vkResetQueryPool",
        SideEffects::worstDefault, "vkResetQueryPool");
    addExtern<DAS_BIND_FUN(vkGetSemaphoreCounterValue)>(*this, lib, "vkGetSemaphoreCounterValue",
        SideEffects::worstDefault, "vkGetSemaphoreCounterValue");
    addExtern<DAS_BIND_FUN(vkWaitSemaphores)>(*this, lib, "vkWaitSemaphores",
        SideEffects::worstDefault, "vkWaitSemaphores");
    addExtern<DAS_BIND_FUN(vkSignalSemaphore)>(*this, lib, "vkSignalSemaphore",
        SideEffects::worstDefault, "vkSignalSemaphore");
    addExtern<DAS_BIND_FUN(vkGetBufferDeviceAddress)>(*this, lib, "vkGetBufferDeviceAddress",
        SideEffects::worstDefault, "vkGetBufferDeviceAddress");
    addExtern<DAS_BIND_FUN(vkGetBufferOpaqueCaptureAddress)>(*this, lib, "vkGetBufferOpaqueCaptureAddress",
        SideEffects::worstDefault, "vkGetBufferOpaqueCaptureAddress");
    addExtern<DAS_BIND_FUN(vkGetDeviceMemoryOpaqueCaptureAddress)>(*this, lib, "vkGetDeviceMemoryOpaqueCaptureAddress",
        SideEffects::worstDefault, "vkGetDeviceMemoryOpaqueCaptureAddress");

    //
    // macro constants
    //

    addConstant(*this,"VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_shader_subgroup_extended_types",1);
    addConstant(*this,"VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_8bit_storage",1);
    addConstant(*this,"VK_KHR_8BIT_STORAGE_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_shader_atomic_int64",1);
    addConstant(*this,"VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_shader_clock",1);
    addConstant(*this,"VK_KHR_SHADER_CLOCK_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_driver_properties",1);
    addConstant(*this,"VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION",1);
    addConstant(*this,"VK_MAX_DRIVER_NAME_SIZE_KHR",VK_MAX_DRIVER_NAME_SIZE);
    addConstant(*this,"VK_MAX_DRIVER_INFO_SIZE_KHR",VK_MAX_DRIVER_INFO_SIZE);
    addConstant(*this,"VK_KHR_shader_float_controls",1);
    addConstant(*this,"VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION",4);
    addConstant(*this,"VK_KHR_depth_stencil_resolve",1);
    addConstant(*this,"VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_swapchain_mutable_format",1);
    addConstant(*this,"VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_timeline_semaphore",1);
    addConstant(*this,"VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION",2);
    addConstant(*this,"VK_KHR_vulkan_memory_model",1);
    addConstant(*this,"VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION",3);
    addConstant(*this,"VK_KHR_shader_terminate_invocation",1);
    addConstant(*this,"VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_fragment_shading_rate",1);
    addConstant(*this,"VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_spirv_1_4",1);
    addConstant(*this,"VK_KHR_SPIRV_1_4_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_surface_protected_capabilities",1);
    addConstant(*this,"VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_separate_depth_stencil_layouts",1);
    addConstant(*this,"VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_uniform_buffer_standard_layout",1);
    addConstant(*this,"VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_buffer_device_address",1);
    addConstant(*this,"VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_deferred_host_operations",1);
    addConstant(*this,"VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION",4);
    addConstant(*this,"VK_KHR_pipeline_executable_properties",1);
    addConstant(*this,"VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_pipeline_library",1);
    addConstant(*this,"VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_shader_non_semantic_info",1);
    addConstant(*this,"VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_copy_commands2",1);
};
