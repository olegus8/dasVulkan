// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueue, VkQueue)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphore, VkSemaphore)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateCreateInfo, VkPipelineRasterizationStateCreateInfo);

struct VkPipelineRasterizationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateCreateInfo,true,true> {
    VkPipelineRasterizationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClampEnable)>("depthClampEnable");
        addField<DAS_BIND_MANAGED_FIELD(rasterizerDiscardEnable)>("rasterizerDiscardEnable");
        addField<DAS_BIND_MANAGED_FIELD(polygonMode)>("polygonMode");
        addField<DAS_BIND_MANAGED_FIELD(cullMode)>("cullMode");
        addField<DAS_BIND_MANAGED_FIELD(frontFace)>("frontFace");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasEnable)>("depthBiasEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasConstantFactor)>("depthBiasConstantFactor");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasSlopeFactor)>("depthBiasSlopeFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineWidth)>("lineWidth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineMultisampleStateCreateInfo, VkPipelineMultisampleStateCreateInfo);

struct VkPipelineMultisampleStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineMultisampleStateCreateInfo,true,true> {
    VkPipelineMultisampleStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineMultisampleStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(sampleShadingEnable)>("sampleShadingEnable");
        addField<DAS_BIND_MANAGED_FIELD(minSampleShading)>("minSampleShading");
        addField<DAS_BIND_MANAGED_FIELD(pSampleMask)>("pSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(alphaToCoverageEnable)>("alphaToCoverageEnable");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOneEnable)>("alphaToOneEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkStencilOpState, VkStencilOpState);

struct VkStencilOpStateAnnotation
: public ManagedStructureAnnotation<VkStencilOpState,true,true> {
    VkStencilOpStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStencilOpState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(failOp)>("failOp");
        addField<DAS_BIND_MANAGED_FIELD(passOp)>("passOp");
        addField<DAS_BIND_MANAGED_FIELD(depthFailOp)>("depthFailOp");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(compareMask)>("compareMask");
        addField<DAS_BIND_MANAGED_FIELD(writeMask)>("writeMask");
        addField<DAS_BIND_MANAGED_FIELD(reference)>("reference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDepthStencilStateCreateInfo, VkPipelineDepthStencilStateCreateInfo);

struct VkPipelineDepthStencilStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDepthStencilStateCreateInfo,true,true> {
    VkPipelineDepthStencilStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDepthStencilStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthTestEnable)>("depthTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthWriteEnable)>("depthWriteEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthCompareOp)>("depthCompareOp");
        addField<DAS_BIND_MANAGED_FIELD(depthBoundsTestEnable)>("depthBoundsTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(stencilTestEnable)>("stencilTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(front)>("front");
        addField<DAS_BIND_MANAGED_FIELD(back)>("back");
        addField<DAS_BIND_MANAGED_FIELD(minDepthBounds)>("minDepthBounds");
        addField<DAS_BIND_MANAGED_FIELD(maxDepthBounds)>("maxDepthBounds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendAttachmentState, VkPipelineColorBlendAttachmentState);

struct VkPipelineColorBlendAttachmentStateAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAttachmentState,true,true> {
    VkPipelineColorBlendAttachmentStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAttachmentState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(blendEnable)>("blendEnable");
        addField<DAS_BIND_MANAGED_FIELD(srcColorBlendFactor)>("srcColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstColorBlendFactor)>("dstColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(colorBlendOp)>("colorBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(srcAlphaBlendFactor)>("srcAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstAlphaBlendFactor)>("dstAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(alphaBlendOp)>("alphaBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(colorWriteMask)>("colorWriteMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendStateCreateInfo, VkPipelineColorBlendStateCreateInfo);

struct VkPipelineColorBlendStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendStateCreateInfo,true,true> {
    VkPipelineColorBlendStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(logicOpEnable)>("logicOpEnable");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(blendConstants)>("blendConstants");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDynamicStateCreateInfo, VkPipelineDynamicStateCreateInfo);

struct VkPipelineDynamicStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDynamicStateCreateInfo,true,true> {
    VkPipelineDynamicStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDynamicStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(dynamicStateCount)>("dynamicStateCount");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicStates)>("pDynamicStates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsPipelineCreateInfo, VkGraphicsPipelineCreateInfo);

struct VkGraphicsPipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineCreateInfo,true,true> {
    VkGraphicsPipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pInputAssemblyState)>("pInputAssemblyState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
        addField<DAS_BIND_MANAGED_FIELD(pViewportState)>("pViewportState");
        addField<DAS_BIND_MANAGED_FIELD(pRasterizationState)>("pRasterizationState");
        addField<DAS_BIND_MANAGED_FIELD(pMultisampleState)>("pMultisampleState");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilState)>("pDepthStencilState");
        addField<DAS_BIND_MANAGED_FIELD(pColorBlendState)>("pColorBlendState");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPushConstantRange, VkPushConstantRange);

struct VkPushConstantRangeAnnotation
: public ManagedStructureAnnotation<VkPushConstantRange,true,true> {
    VkPushConstantRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPushConstantRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayoutCreateInfo, VkPipelineLayoutCreateInfo);

struct VkPipelineLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineLayoutCreateInfo,true,true> {
    VkPipelineLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(setLayoutCount)>("setLayoutCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
        addField<DAS_BIND_MANAGED_FIELD(pushConstantRangeCount)>("pushConstantRangeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPushConstantRanges)>("pPushConstantRanges");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerCreateInfo, VkSamplerCreateInfo);

struct VkSamplerCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerCreateInfo,true,true> {
    VkSamplerCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(magFilter)>("magFilter");
        addField<DAS_BIND_MANAGED_FIELD(minFilter)>("minFilter");
        addField<DAS_BIND_MANAGED_FIELD(mipmapMode)>("mipmapMode");
        addField<DAS_BIND_MANAGED_FIELD(addressModeU)>("addressModeU");
        addField<DAS_BIND_MANAGED_FIELD(addressModeV)>("addressModeV");
        addField<DAS_BIND_MANAGED_FIELD(addressModeW)>("addressModeW");
        addField<DAS_BIND_MANAGED_FIELD(mipLodBias)>("mipLodBias");
        addField<DAS_BIND_MANAGED_FIELD(anisotropyEnable)>("anisotropyEnable");
        addField<DAS_BIND_MANAGED_FIELD(maxAnisotropy)>("maxAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(compareEnable)>("compareEnable");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(minLod)>("minLod");
        addField<DAS_BIND_MANAGED_FIELD(maxLod)>("maxLod");
        addField<DAS_BIND_MANAGED_FIELD(borderColor)>("borderColor");
        addField<DAS_BIND_MANAGED_FIELD(unnormalizedCoordinates)>("unnormalizedCoordinates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyDescriptorSet, VkCopyDescriptorSet);

struct VkCopyDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkCopyDescriptorSet,true,true> {
    VkCopyDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSet)>("srcSet");
        addField<DAS_BIND_MANAGED_FIELD(srcBinding)>("srcBinding");
        addField<DAS_BIND_MANAGED_FIELD(srcArrayElement)>("srcArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorBufferInfo, VkDescriptorBufferInfo);

struct VkDescriptorBufferInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorBufferInfo,true,true> {
    VkDescriptorBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorImageInfo, VkDescriptorImageInfo);

struct VkDescriptorImageInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorImageInfo,true,true> {
    VkDescriptorImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(imageLayout)>("imageLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolSize, VkDescriptorPoolSize);

struct VkDescriptorPoolSizeAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolSize,true,true> {
    VkDescriptorPoolSizeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolSize", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolCreateInfo, VkDescriptorPoolCreateInfo);

struct VkDescriptorPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolCreateInfo,true,true> {
    VkDescriptorPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(maxSets)>("maxSets");
        addField<DAS_BIND_MANAGED_FIELD(poolSizeCount)>("poolSizeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPoolSizes)>("pPoolSizes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetAllocateInfo, VkDescriptorSetAllocateInfo);

struct VkDescriptorSetAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetAllocateInfo,true,true> {
    VkDescriptorSetAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorPool)>("descriptorPool");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutBinding, VkDescriptorSetLayoutBinding);

struct VkDescriptorSetLayoutBindingAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBinding,true,true> {
    VkDescriptorSetLayoutBindingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBinding", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pImmutableSamplers)>("pImmutableSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutCreateInfo);

struct VkDescriptorSetLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutCreateInfo,true,true> {
    VkDescriptorSetLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindings)>("pBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSet, VkWriteDescriptorSet);

struct VkWriteDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSet,true,true> {
    VkWriteDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(pImageInfo)>("pImageInfo");
        addField<DAS_BIND_MANAGED_FIELD(pBufferInfo)>("pBufferInfo");
        addField<DAS_BIND_MANAGED_FIELD(pTexelBufferView)>("pTexelBufferView");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescription, VkAttachmentDescription);

struct VkAttachmentDescriptionAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescription,true,true> {
    VkAttachmentDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReference, VkAttachmentReference);

struct VkAttachmentReferenceAnnotation
: public ManagedStructureAnnotation<VkAttachmentReference,true,true> {
    VkAttachmentReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferCreateInfo, VkFramebufferCreateInfo);

struct VkFramebufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferCreateInfo,true,true> {
    VkFramebufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layers)>("layers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescription, VkSubpassDescription);

struct VkSubpassDescriptionAnnotation
: public ManagedStructureAnnotation<VkSubpassDescription,true,true> {
    VkSubpassDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDependency, VkSubpassDependency);

struct VkSubpassDependencyAnnotation
: public ManagedStructureAnnotation<VkSubpassDependency,true,true> {
    VkSubpassDependencyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassCreateInfo, VkRenderPassCreateInfo);

struct VkRenderPassCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo,true,true> {
    VkRenderPassCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPoolCreateInfo, VkCommandPoolCreateInfo);

struct VkCommandPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandPoolCreateInfo,true,true> {
    VkCommandPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferAllocateInfo, VkCommandBufferAllocateInfo);

struct VkCommandBufferAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferAllocateInfo,true,true> {
    VkCommandBufferAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(commandPool)>("commandPool");
        addField<DAS_BIND_MANAGED_FIELD(level)>("level");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceInfo, VkCommandBufferInheritanceInfo);

struct VkCommandBufferInheritanceInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceInfo,true,true> {
    VkCommandBufferInheritanceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryEnable)>("occlusionQueryEnable");
        addField<DAS_BIND_MANAGED_FIELD(queryFlags)>("queryFlags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferBeginInfo, VkCommandBufferBeginInfo);

struct VkCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferBeginInfo,true,true> {
    VkCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pInheritanceInfo)>("pInheritanceInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCopy, VkBufferCopy);

struct VkBufferCopyAnnotation
: public ManagedStructureAnnotation<VkBufferCopy,true,true> {
    VkBufferCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresourceLayers, VkImageSubresourceLayers);

struct VkImageSubresourceLayersAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceLayers,true,true> {
    VkImageSubresourceLayersAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceLayers", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferImageCopy, VkBufferImageCopy);

struct VkBufferImageCopyAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy,true,true> {
    VkBufferImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearColorValue, VkClearColorValue);

struct VkClearColorValueAnnotation
: public ManagedStructureAnnotation<VkClearColorValue,true,true> {
    VkClearColorValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearColorValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_2(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkPrimitiveTopology>());
    module.addEnumeration(make_smart<EnumerationVkPolygonMode>());
    module.addEnumeration(make_smart<EnumerationVkStencilOp>());
    module.addEnumeration(make_smart<EnumerationVkLogicOp>());
    module.addEnumeration(make_smart<EnumerationVkBorderColor>());
    module.addEnumeration(make_smart<EnumerationVkFilter>());
    module.addEnumeration(make_smart<EnumerationVkSamplerAddressMode>());
    module.addEnumeration(make_smart<EnumerationVkSamplerMipmapMode>());
    module.addEnumeration(make_smart<EnumerationVkDescriptorType>());
    module.addEnumeration(make_smart<EnumerationVkAttachmentLoadOp>());
    module.addEnumeration(make_smart<EnumerationVkAttachmentStoreOp>());
}

void addVulkanGeneratedOpaqueStructs_2(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkQueue>>("VkQueue", "VkQueue"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkSemaphore>>("VkSemaphore", "VkSemaphore"));
}

void addVulkanGeneratedStructs_2(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkPipelineRasterizationStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineMultisampleStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkStencilOpStateAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineDepthStencilStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineColorBlendAttachmentStateAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineColorBlendStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineDynamicStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkGraphicsPipelineCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPushConstantRangeAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineLayoutCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCopyDescriptorSetAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorBufferInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorImageInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorPoolSizeAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorPoolCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetLayoutBindingAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetLayoutCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkWriteDescriptorSetAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentReferenceAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubpassDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubpassDependencyAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandPoolCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferInheritanceInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferBeginInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferCopyAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSubresourceLayersAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferImageCopyAnnotation>(lib));
    module.addAnnotation(make_smart<VkClearColorValueAnnotation>(lib));
}

void addVulkanGeneratedFunctions_2(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkFlushMappedMemoryRanges)>(module, lib, "vkFlushMappedMemoryRanges",
        SideEffects::worstDefault, "vkFlushMappedMemoryRanges");
    addExtern<DAS_BIND_FUN(vkInvalidateMappedMemoryRanges)>(module, lib, "vkInvalidateMappedMemoryRanges",
        SideEffects::worstDefault, "vkInvalidateMappedMemoryRanges");
    addExtern<DAS_BIND_FUN(vkGetDeviceMemoryCommitment)>(module, lib, "vkGetDeviceMemoryCommitment",
        SideEffects::worstDefault, "vkGetDeviceMemoryCommitment");
    addExtern<DAS_BIND_FUN(vkBindBufferMemory)>(module, lib, "vkBindBufferMemory",
        SideEffects::worstDefault, "vkBindBufferMemory");
    addExtern<DAS_BIND_FUN(vkBindImageMemory)>(module, lib, "vkBindImageMemory",
        SideEffects::worstDefault, "vkBindImageMemory");
    addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements)>(module, lib, "vkGetBufferMemoryRequirements",
        SideEffects::worstDefault, "vkGetBufferMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements)>(module, lib, "vkGetImageMemoryRequirements",
        SideEffects::worstDefault, "vkGetImageMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements)>(module, lib, "vkGetImageSparseMemoryRequirements",
        SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties)>(module, lib, "vkGetPhysicalDeviceSparseImageFormatProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties");
    addExtern<DAS_BIND_FUN(vkQueueBindSparse)>(module, lib, "vkQueueBindSparse",
        SideEffects::worstDefault, "vkQueueBindSparse");
    addExtern<DAS_BIND_FUN(vkCreateFence)>(module, lib, "vkCreateFence",
        SideEffects::worstDefault, "vkCreateFence");
    addExtern<DAS_BIND_FUN(vkDestroyFence)>(module, lib, "vkDestroyFence",
        SideEffects::worstDefault, "vkDestroyFence");
}

void addVulkanGeneratedConsts_2(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_LUID_SIZE_KHR", VK_LUID_SIZE);
    addConstant(module, "VK_KHR_external_memory", 1);
    addConstant(module, "VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION", 1);
    addConstant(module, "VK_QUEUE_FAMILY_EXTERNAL_KHR", VK_QUEUE_FAMILY_EXTERNAL);
    addConstant(module, "VK_KHR_external_memory_fd", 1);
    addConstant(module, "VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_external_semaphore_capabilities", 1);
    addConstant(module, "VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_external_semaphore", 1);
    addConstant(module, "VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_external_semaphore_fd", 1);
    addConstant(module, "VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_push_descriptor", 1);
    addConstant(module, "VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION", 2);
    addConstant(module, "VK_KHR_shader_float16_int8", 1);
    addConstant(module, "VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_16bit_storage", 1);
    addConstant(module, "VK_KHR_16BIT_STORAGE_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_incremental_present", 1);
    addConstant(module, "VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_descriptor_update_template", 1);
    addConstant(module, "VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_imageless_framebuffer", 1);
    addConstant(module, "VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_create_renderpass2", 1);
    addConstant(module, "VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_shared_presentable_image", 1);
}
