// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueue, VkQueue)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphore, VkSemaphore)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBuffer, VkCommandBuffer)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineMultisampleStateCreateInfo, VkPipelineMultisampleStateCreateInfo);

struct VkPipelineMultisampleStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineMultisampleStateCreateInfo,true,true> {
    VkPipelineMultisampleStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineMultisampleStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(sampleShadingEnable)>("sampleShadingEnable");
        addField<DAS_BIND_MANAGED_FIELD(minSampleShading)>("minSampleShading");
        addField<DAS_BIND_MANAGED_FIELD(pSampleMask)>("pSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(alphaToCoverageEnable)>("alphaToCoverageEnable");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOneEnable)>("alphaToOneEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkStencilOpState, VkStencilOpState);

struct VkStencilOpStateAnnotation
: public ManagedStructureAnnotation<VkStencilOpState,true,true> {
    VkStencilOpStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStencilOpState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(failOp)>("failOp");
        addField<DAS_BIND_MANAGED_FIELD(passOp)>("passOp");
        addField<DAS_BIND_MANAGED_FIELD(depthFailOp)>("depthFailOp");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(compareMask)>("compareMask");
        addField<DAS_BIND_MANAGED_FIELD(writeMask)>("writeMask");
        addField<DAS_BIND_MANAGED_FIELD(reference)>("reference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDepthStencilStateCreateInfo, VkPipelineDepthStencilStateCreateInfo);

struct VkPipelineDepthStencilStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDepthStencilStateCreateInfo,true,true> {
    VkPipelineDepthStencilStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDepthStencilStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthTestEnable)>("depthTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthWriteEnable)>("depthWriteEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthCompareOp)>("depthCompareOp");
        addField<DAS_BIND_MANAGED_FIELD(depthBoundsTestEnable)>("depthBoundsTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(stencilTestEnable)>("stencilTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(front)>("front");
        addField<DAS_BIND_MANAGED_FIELD(back)>("back");
        addField<DAS_BIND_MANAGED_FIELD(minDepthBounds)>("minDepthBounds");
        addField<DAS_BIND_MANAGED_FIELD(maxDepthBounds)>("maxDepthBounds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendAttachmentState, VkPipelineColorBlendAttachmentState);

struct VkPipelineColorBlendAttachmentStateAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAttachmentState,true,true> {
    VkPipelineColorBlendAttachmentStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAttachmentState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(blendEnable)>("blendEnable");
        addField<DAS_BIND_MANAGED_FIELD(srcColorBlendFactor)>("srcColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstColorBlendFactor)>("dstColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(colorBlendOp)>("colorBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(srcAlphaBlendFactor)>("srcAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstAlphaBlendFactor)>("dstAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(alphaBlendOp)>("alphaBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(colorWriteMask)>("colorWriteMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendStateCreateInfo, VkPipelineColorBlendStateCreateInfo);

struct VkPipelineColorBlendStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendStateCreateInfo,true,true> {
    VkPipelineColorBlendStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(logicOpEnable)>("logicOpEnable");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(blendConstants)>("blendConstants");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDynamicStateCreateInfo, VkPipelineDynamicStateCreateInfo);

struct VkPipelineDynamicStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDynamicStateCreateInfo,true,true> {
    VkPipelineDynamicStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDynamicStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(dynamicStateCount)>("dynamicStateCount");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicStates)>("pDynamicStates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsPipelineCreateInfo, VkGraphicsPipelineCreateInfo);

struct VkGraphicsPipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineCreateInfo,true,true> {
    VkGraphicsPipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pInputAssemblyState)>("pInputAssemblyState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
        addField<DAS_BIND_MANAGED_FIELD(pViewportState)>("pViewportState");
        addField<DAS_BIND_MANAGED_FIELD(pRasterizationState)>("pRasterizationState");
        addField<DAS_BIND_MANAGED_FIELD(pMultisampleState)>("pMultisampleState");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilState)>("pDepthStencilState");
        addField<DAS_BIND_MANAGED_FIELD(pColorBlendState)>("pColorBlendState");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPushConstantRange, VkPushConstantRange);

struct VkPushConstantRangeAnnotation
: public ManagedStructureAnnotation<VkPushConstantRange,true,true> {
    VkPushConstantRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPushConstantRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayoutCreateInfo, VkPipelineLayoutCreateInfo);

struct VkPipelineLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineLayoutCreateInfo,true,true> {
    VkPipelineLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(setLayoutCount)>("setLayoutCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
        addField<DAS_BIND_MANAGED_FIELD(pushConstantRangeCount)>("pushConstantRangeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPushConstantRanges)>("pPushConstantRanges");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerCreateInfo, VkSamplerCreateInfo);

struct VkSamplerCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerCreateInfo,true,true> {
    VkSamplerCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(magFilter)>("magFilter");
        addField<DAS_BIND_MANAGED_FIELD(minFilter)>("minFilter");
        addField<DAS_BIND_MANAGED_FIELD(mipmapMode)>("mipmapMode");
        addField<DAS_BIND_MANAGED_FIELD(addressModeU)>("addressModeU");
        addField<DAS_BIND_MANAGED_FIELD(addressModeV)>("addressModeV");
        addField<DAS_BIND_MANAGED_FIELD(addressModeW)>("addressModeW");
        addField<DAS_BIND_MANAGED_FIELD(mipLodBias)>("mipLodBias");
        addField<DAS_BIND_MANAGED_FIELD(anisotropyEnable)>("anisotropyEnable");
        addField<DAS_BIND_MANAGED_FIELD(maxAnisotropy)>("maxAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(compareEnable)>("compareEnable");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(minLod)>("minLod");
        addField<DAS_BIND_MANAGED_FIELD(maxLod)>("maxLod");
        addField<DAS_BIND_MANAGED_FIELD(borderColor)>("borderColor");
        addField<DAS_BIND_MANAGED_FIELD(unnormalizedCoordinates)>("unnormalizedCoordinates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyDescriptorSet, VkCopyDescriptorSet);

struct VkCopyDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkCopyDescriptorSet,true,true> {
    VkCopyDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSet)>("srcSet");
        addField<DAS_BIND_MANAGED_FIELD(srcBinding)>("srcBinding");
        addField<DAS_BIND_MANAGED_FIELD(srcArrayElement)>("srcArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorBufferInfo, VkDescriptorBufferInfo);

struct VkDescriptorBufferInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorBufferInfo,true,true> {
    VkDescriptorBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorImageInfo, VkDescriptorImageInfo);

struct VkDescriptorImageInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorImageInfo,true,true> {
    VkDescriptorImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(imageLayout)>("imageLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolSize, VkDescriptorPoolSize);

struct VkDescriptorPoolSizeAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolSize,true,true> {
    VkDescriptorPoolSizeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolSize", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolCreateInfo, VkDescriptorPoolCreateInfo);

struct VkDescriptorPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolCreateInfo,true,true> {
    VkDescriptorPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(maxSets)>("maxSets");
        addField<DAS_BIND_MANAGED_FIELD(poolSizeCount)>("poolSizeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPoolSizes)>("pPoolSizes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetAllocateInfo, VkDescriptorSetAllocateInfo);

struct VkDescriptorSetAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetAllocateInfo,true,true> {
    VkDescriptorSetAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorPool)>("descriptorPool");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutBinding, VkDescriptorSetLayoutBinding);

struct VkDescriptorSetLayoutBindingAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBinding,true,true> {
    VkDescriptorSetLayoutBindingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBinding", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pImmutableSamplers)>("pImmutableSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutCreateInfo);

struct VkDescriptorSetLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutCreateInfo,true,true> {
    VkDescriptorSetLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindings)>("pBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSet, VkWriteDescriptorSet);

struct VkWriteDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSet,true,true> {
    VkWriteDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(pImageInfo)>("pImageInfo");
        addField<DAS_BIND_MANAGED_FIELD(pBufferInfo)>("pBufferInfo");
        addField<DAS_BIND_MANAGED_FIELD(pTexelBufferView)>("pTexelBufferView");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescription, VkAttachmentDescription);

struct VkAttachmentDescriptionAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescription,true,true> {
    VkAttachmentDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReference, VkAttachmentReference);

struct VkAttachmentReferenceAnnotation
: public ManagedStructureAnnotation<VkAttachmentReference,true,true> {
    VkAttachmentReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferCreateInfo, VkFramebufferCreateInfo);

struct VkFramebufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferCreateInfo,true,true> {
    VkFramebufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layers)>("layers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescription, VkSubpassDescription);

struct VkSubpassDescriptionAnnotation
: public ManagedStructureAnnotation<VkSubpassDescription,true,true> {
    VkSubpassDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDependency, VkSubpassDependency);

struct VkSubpassDependencyAnnotation
: public ManagedStructureAnnotation<VkSubpassDependency,true,true> {
    VkSubpassDependencyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassCreateInfo, VkRenderPassCreateInfo);

struct VkRenderPassCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo,true,true> {
    VkRenderPassCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPoolCreateInfo, VkCommandPoolCreateInfo);

struct VkCommandPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandPoolCreateInfo,true,true> {
    VkCommandPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferAllocateInfo, VkCommandBufferAllocateInfo);

struct VkCommandBufferAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferAllocateInfo,true,true> {
    VkCommandBufferAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(commandPool)>("commandPool");
        addField<DAS_BIND_MANAGED_FIELD(level)>("level");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceInfo, VkCommandBufferInheritanceInfo);

struct VkCommandBufferInheritanceInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceInfo,true,true> {
    VkCommandBufferInheritanceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryEnable)>("occlusionQueryEnable");
        addField<DAS_BIND_MANAGED_FIELD(queryFlags)>("queryFlags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferBeginInfo, VkCommandBufferBeginInfo);

struct VkCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferBeginInfo,true,true> {
    VkCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pInheritanceInfo)>("pInheritanceInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCopy, VkBufferCopy);

struct VkBufferCopyAnnotation
: public ManagedStructureAnnotation<VkBufferCopy,true,true> {
    VkBufferCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresourceLayers, VkImageSubresourceLayers);

struct VkImageSubresourceLayersAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceLayers,true,true> {
    VkImageSubresourceLayersAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceLayers", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferImageCopy, VkBufferImageCopy);

struct VkBufferImageCopyAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy,true,true> {
    VkBufferImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearColorValue, VkClearColorValue);

struct VkClearColorValueAnnotation
: public ManagedStructureAnnotation<VkClearColorValue,true,true> {
    VkClearColorValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearColorValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearDepthStencilValue, VkClearDepthStencilValue);

struct VkClearDepthStencilValueAnnotation
: public ManagedStructureAnnotation<VkClearDepthStencilValue,true,true> {
    VkClearDepthStencilValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearDepthStencilValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
        addField<DAS_BIND_MANAGED_FIELD(stencil)>("stencil");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_2(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkPrimitiveTopology>());
    module.addEnumeration(make_smart<EnumerationVkPolygonMode>());
    module.addEnumeration(make_smart<EnumerationVkStencilOp>());
    module.addEnumeration(make_smart<EnumerationVkLogicOp>());
    module.addEnumeration(make_smart<EnumerationVkBorderColor>());
    module.addEnumeration(make_smart<EnumerationVkFilter>());
    module.addEnumeration(make_smart<EnumerationVkSamplerAddressMode>());
    module.addEnumeration(make_smart<EnumerationVkSamplerMipmapMode>());
    module.addEnumeration(make_smart<EnumerationVkDescriptorType>());
    module.addEnumeration(make_smart<EnumerationVkAttachmentLoadOp>());
    module.addEnumeration(make_smart<EnumerationVkAttachmentStoreOp>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkQueue>>("VkQueue", "VkQueue"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkSemaphore>>("VkSemaphore", "VkSemaphore"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkCommandBuffer>>("VkCommandBuffer", "VkCommandBuffer"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkPipelineMultisampleStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkStencilOpStateAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineDepthStencilStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineColorBlendAttachmentStateAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineColorBlendStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineDynamicStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkGraphicsPipelineCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPushConstantRangeAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineLayoutCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCopyDescriptorSetAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorBufferInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorImageInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorPoolSizeAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorPoolCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetLayoutBindingAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorSetLayoutCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkWriteDescriptorSetAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentReferenceAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubpassDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubpassDependencyAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandPoolCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferInheritanceInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferBeginInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferCopyAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSubresourceLayersAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferImageCopyAnnotation>(lib));
    module.addAnnotation(make_smart<VkClearColorValueAnnotation>(lib));
    module.addAnnotation(make_smart<VkClearDepthStencilValueAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkResetFences)>(*this, lib, "vkResetFences",
        SideEffects::worstDefault, "vkResetFences");
    addExtern<DAS_BIND_FUN(vkGetFenceStatus)>(*this, lib, "vkGetFenceStatus",
        SideEffects::worstDefault, "vkGetFenceStatus");
    addExtern<DAS_BIND_FUN(vkWaitForFences)>(*this, lib, "vkWaitForFences",
        SideEffects::worstDefault, "vkWaitForFences");
    addExtern<DAS_BIND_FUN(vkCreateSemaphore)>(*this, lib, "vkCreateSemaphore",
        SideEffects::worstDefault, "vkCreateSemaphore");
    addExtern<DAS_BIND_FUN(vkDestroySemaphore)>(*this, lib, "vkDestroySemaphore",
        SideEffects::worstDefault, "vkDestroySemaphore");
    addExtern<DAS_BIND_FUN(vkCreateEvent)>(*this, lib, "vkCreateEvent",
        SideEffects::worstDefault, "vkCreateEvent");
    addExtern<DAS_BIND_FUN(vkDestroyEvent)>(*this, lib, "vkDestroyEvent",
        SideEffects::worstDefault, "vkDestroyEvent");
    addExtern<DAS_BIND_FUN(vkGetEventStatus)>(*this, lib, "vkGetEventStatus",
        SideEffects::worstDefault, "vkGetEventStatus");
    addExtern<DAS_BIND_FUN(vkSetEvent)>(*this, lib, "vkSetEvent",
        SideEffects::worstDefault, "vkSetEvent");
    addExtern<DAS_BIND_FUN(vkResetEvent)>(*this, lib, "vkResetEvent",
        SideEffects::worstDefault, "vkResetEvent");
    addExtern<DAS_BIND_FUN(vkCreateQueryPool)>(*this, lib, "vkCreateQueryPool",
        SideEffects::worstDefault, "vkCreateQueryPool");
    addExtern<DAS_BIND_FUN(vkDestroyQueryPool)>(*this, lib, "vkDestroyQueryPool",
        SideEffects::worstDefault, "vkDestroyQueryPool");
    addExtern<DAS_BIND_FUN(vkGetQueryPoolResults)>(*this, lib, "vkGetQueryPoolResults",
        SideEffects::worstDefault, "vkGetQueryPoolResults");
    addExtern<DAS_BIND_FUN(vkCreateBuffer)>(*this, lib, "vkCreateBuffer",
        SideEffects::worstDefault, "vkCreateBuffer");
    addExtern<DAS_BIND_FUN(vkDestroyBuffer)>(*this, lib, "vkDestroyBuffer",
        SideEffects::worstDefault, "vkDestroyBuffer");
    addExtern<DAS_BIND_FUN(vkCreateBufferView)>(*this, lib, "vkCreateBufferView",
        SideEffects::worstDefault, "vkCreateBufferView");
    addExtern<DAS_BIND_FUN(vkDestroyBufferView)>(*this, lib, "vkDestroyBufferView",
        SideEffects::worstDefault, "vkDestroyBufferView");

    //
    // macro constants
    //

    addConstant(*this,"GLFW_KEY_F4",293);
    addConstant(*this,"GLFW_KEY_F5",294);
    addConstant(*this,"GLFW_KEY_F6",295);
    addConstant(*this,"GLFW_KEY_F7",296);
    addConstant(*this,"GLFW_KEY_F8",297);
    addConstant(*this,"GLFW_KEY_F9",298);
    addConstant(*this,"GLFW_KEY_F10",299);
    addConstant(*this,"GLFW_KEY_F11",300);
    addConstant(*this,"GLFW_KEY_F12",301);
    addConstant(*this,"GLFW_KEY_F13",302);
    addConstant(*this,"GLFW_KEY_F14",303);
    addConstant(*this,"GLFW_KEY_F15",304);
    addConstant(*this,"GLFW_KEY_F16",305);
    addConstant(*this,"GLFW_KEY_F17",306);
    addConstant(*this,"GLFW_KEY_F18",307);
    addConstant(*this,"GLFW_KEY_F19",308);
    addConstant(*this,"GLFW_KEY_F20",309);
    addConstant(*this,"GLFW_KEY_F21",310);
    addConstant(*this,"GLFW_KEY_F22",311);
    addConstant(*this,"GLFW_KEY_F23",312);
    addConstant(*this,"GLFW_KEY_F24",313);
    addConstant(*this,"GLFW_KEY_F25",314);
    addConstant(*this,"GLFW_KEY_KP_0",320);
    addConstant(*this,"GLFW_KEY_KP_1",321);
    addConstant(*this,"GLFW_KEY_KP_2",322);
    addConstant(*this,"GLFW_KEY_KP_3",323);
    addConstant(*this,"GLFW_KEY_KP_4",324);
    addConstant(*this,"GLFW_KEY_KP_5",325);
    addConstant(*this,"GLFW_KEY_KP_6",326);
    addConstant(*this,"GLFW_KEY_KP_7",327);
    addConstant(*this,"GLFW_KEY_KP_8",328);
    addConstant(*this,"GLFW_KEY_KP_9",329);
    addConstant(*this,"GLFW_KEY_KP_DECIMAL",330);
    addConstant(*this,"GLFW_KEY_KP_DIVIDE",331);
    addConstant(*this,"GLFW_KEY_KP_MULTIPLY",332);
    addConstant(*this,"GLFW_KEY_KP_SUBTRACT",333);
    addConstant(*this,"GLFW_KEY_KP_ADD",334);
    addConstant(*this,"GLFW_KEY_KP_ENTER",335);
    addConstant(*this,"GLFW_KEY_KP_EQUAL",336);
    addConstant(*this,"GLFW_KEY_LEFT_SHIFT",340);
    addConstant(*this,"GLFW_KEY_LEFT_CONTROL",341);
    addConstant(*this,"GLFW_KEY_LEFT_ALT",342);
    addConstant(*this,"GLFW_KEY_LEFT_SUPER",343);
    addConstant(*this,"GLFW_KEY_RIGHT_SHIFT",344);
    addConstant(*this,"GLFW_KEY_RIGHT_CONTROL",345);
};
