// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWmonitor_DasHandle, GLFWmonitor_DasHandle)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWwindow_DasHandle, GLFWwindow_DasHandle)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWcursor_DasHandle, GLFWcursor_DasHandle)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subsampledLoads)>("subsampledLoads");
        addField<DAS_BIND_MANAGED_FIELD(subsampledCoarseReconstructionEarlyAccess)>("subsampledCoarseReconstructionEarlyAccess");
        addField<DAS_BIND_MANAGED_FIELD(maxSubsampledArrayLayers)>("maxSubsampledArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSubsampledSamplers)>("maxDescriptorSetSubsampledSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyCommandTransformInfoQCOM, VkCopyCommandTransformInfoQCOM);

struct VkCopyCommandTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCopyCommandTransformInfoQCOM,true,true> {
    VkCopyCommandTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyCommandTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImageRobustnessFeaturesEXT, VkPhysicalDeviceImageRobustnessFeaturesEXT);

struct VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageRobustnessFeaturesEXT,true,true> {
    VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageRobustnessFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess)>("robustImageAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice4444FormatsFeaturesEXT);

struct VkPhysicalDevice4444FormatsFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice4444FormatsFeaturesEXT,true,true> {
    VkPhysicalDevice4444FormatsFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice4444FormatsFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(formatA4R4G4B4)>("formatA4R4G4B4");
        addField<DAS_BIND_MANAGED_FIELD(formatA4B4G4R4)>("formatA4B4G4R4");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceOrHostAddressKHR, VkDeviceOrHostAddressKHR);

struct VkDeviceOrHostAddressKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressKHR,true,true> {
    VkDeviceOrHostAddressKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceOrHostAddressConstKHR, VkDeviceOrHostAddressConstKHR);

struct VkDeviceOrHostAddressConstKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressConstKHR,true,true> {
    VkDeviceOrHostAddressConstKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressConstKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildRangeInfoKHR, VkAccelerationStructureBuildRangeInfoKHR);

struct VkAccelerationStructureBuildRangeInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildRangeInfoKHR,true,true> {
    VkAccelerationStructureBuildRangeInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildRangeInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(primitiveCount)>("primitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOffset)>("primitiveOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(transformOffset)>("transformOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryTrianglesDataKHR, VkAccelerationStructureGeometryTrianglesDataKHR);

struct VkAccelerationStructureGeometryTrianglesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryTrianglesDataKHR,true,true> {
    VkAccelerationStructureGeometryTrianglesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryTrianglesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexFormat)>("vertexFormat");
        addField<DAS_BIND_MANAGED_FIELD(vertexData)>("vertexData");
        addField<DAS_BIND_MANAGED_FIELD(vertexStride)>("vertexStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertex)>("maxVertex");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
        addField<DAS_BIND_MANAGED_FIELD(indexData)>("indexData");
        addField<DAS_BIND_MANAGED_FIELD(transformData)>("transformData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryAabbsDataKHR, VkAccelerationStructureGeometryAabbsDataKHR);

struct VkAccelerationStructureGeometryAabbsDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryAabbsDataKHR,true,true> {
    VkAccelerationStructureGeometryAabbsDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryAabbsDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryInstancesDataKHR, VkAccelerationStructureGeometryInstancesDataKHR);

struct VkAccelerationStructureGeometryInstancesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryInstancesDataKHR,true,true> {
    VkAccelerationStructureGeometryInstancesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryInstancesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(arrayOfPointers)>("arrayOfPointers");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryDataKHR, VkAccelerationStructureGeometryDataKHR);

struct VkAccelerationStructureGeometryDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryDataKHR,true,true> {
    VkAccelerationStructureGeometryDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(triangles)>("triangles");
        addField<DAS_BIND_MANAGED_FIELD(aabbs)>("aabbs");
        addField<DAS_BIND_MANAGED_FIELD(instances)>("instances");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryKHR, VkAccelerationStructureGeometryKHR);

struct VkAccelerationStructureGeometryKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryKHR,true,true> {
    VkAccelerationStructureGeometryKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(geometryType)>("geometryType");
        addField<DAS_BIND_MANAGED_FIELD(geometry)>("geometry");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildGeometryInfoKHR, VkAccelerationStructureBuildGeometryInfoKHR);

struct VkAccelerationStructureBuildGeometryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildGeometryInfoKHR,true,true> {
    VkAccelerationStructureBuildGeometryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildGeometryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
        addField<DAS_BIND_MANAGED_FIELD(srcAccelerationStructure)>("srcAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(dstAccelerationStructure)>("dstAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(geometryCount)>("geometryCount");
        addField<DAS_BIND_MANAGED_FIELD(pGeometries)>("pGeometries");
        addField<DAS_BIND_MANAGED_FIELD(ppGeometries)>("ppGeometries");
        addField<DAS_BIND_MANAGED_FIELD(scratchData)>("scratchData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureCreateInfoKHR, VkAccelerationStructureCreateInfoKHR);

struct VkAccelerationStructureCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureCreateInfoKHR,true,true> {
    VkAccelerationStructureCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(createFlags)>("createFlags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureKHR);

struct VkWriteDescriptorSetAccelerationStructureKHRAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetAccelerationStructureKHR,true,true> {
    VkWriteDescriptorSetAccelerationStructureKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetAccelerationStructureKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCount)>("accelerationStructureCount");
        addField<DAS_BIND_MANAGED_FIELD(pAccelerationStructures)>("pAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR);

struct VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructureFeaturesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructureFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCaptureReplay)>("accelerationStructureCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureIndirectBuild)>("accelerationStructureIndirectBuild");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureHostCommands)>("accelerationStructureHostCommands");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingAccelerationStructureUpdateAfterBind)>("descriptorBindingAccelerationStructureUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceAccelerationStructurePropertiesKHR);

struct VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructurePropertiesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructurePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryCount)>("maxGeometryCount");
        addField<DAS_BIND_MANAGED_FIELD(maxInstanceCount)>("maxInstanceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPrimitiveCount)>("maxPrimitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorAccelerationStructures)>("maxPerStageDescriptorAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindAccelerationStructures)>("maxPerStageDescriptorUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetAccelerationStructures)>("maxDescriptorSetAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindAccelerationStructures)>("maxDescriptorSetUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(minAccelerationStructureScratchOffsetAlignment)>("minAccelerationStructureScratchOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureDeviceAddressInfoKHR, VkAccelerationStructureDeviceAddressInfoKHR);

struct VkAccelerationStructureDeviceAddressInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureDeviceAddressInfoKHR,true,true> {
    VkAccelerationStructureDeviceAddressInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureDeviceAddressInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureVersionInfoKHR, VkAccelerationStructureVersionInfoKHR);

struct VkAccelerationStructureVersionInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureVersionInfoKHR,true,true> {
    VkAccelerationStructureVersionInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureVersionInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pVersionData)>("pVersionData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyAccelerationStructureToMemoryInfoKHR, VkCopyAccelerationStructureToMemoryInfoKHR);

struct VkCopyAccelerationStructureToMemoryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureToMemoryInfoKHR,true,true> {
    VkCopyAccelerationStructureToMemoryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureToMemoryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyMemoryToAccelerationStructureInfoKHR, VkCopyMemoryToAccelerationStructureInfoKHR);

struct VkCopyMemoryToAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyMemoryToAccelerationStructureInfoKHR,true,true> {
    VkCopyMemoryToAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyMemoryToAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyAccelerationStructureInfoKHR, VkCopyAccelerationStructureInfoKHR);

struct VkCopyAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureInfoKHR,true,true> {
    VkCopyAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildSizesInfoKHR, VkAccelerationStructureBuildSizesInfoKHR);

struct VkAccelerationStructureBuildSizesInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildSizesInfoKHR,true,true> {
    VkAccelerationStructureBuildSizesInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildSizesInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureSize)>("accelerationStructureSize");
        addField<DAS_BIND_MANAGED_FIELD(updateScratchSize)>("updateScratchSize");
        addField<DAS_BIND_MANAGED_FIELD(buildScratchSize)>("buildScratchSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingShaderGroupCreateInfoKHR, VkRayTracingShaderGroupCreateInfoKHR);

struct VkRayTracingShaderGroupCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingShaderGroupCreateInfoKHR,true,true> {
    VkRayTracingShaderGroupCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingShaderGroupCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(generalShader)>("generalShader");
        addField<DAS_BIND_MANAGED_FIELD(closestHitShader)>("closestHitShader");
        addField<DAS_BIND_MANAGED_FIELD(anyHitShader)>("anyHitShader");
        addField<DAS_BIND_MANAGED_FIELD(intersectionShader)>("intersectionShader");
        addField<DAS_BIND_MANAGED_FIELD(pShaderGroupCaptureReplayHandle)>("pShaderGroupCaptureReplayHandle");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingPipelineInterfaceCreateInfoKHR, VkRayTracingPipelineInterfaceCreateInfoKHR);

struct VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineInterfaceCreateInfoKHR,true,true> {
    VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineInterfaceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayPayloadSize)>("maxPipelineRayPayloadSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayHitAttributeSize)>("maxPipelineRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingPipelineCreateInfoKHR, VkRayTracingPipelineCreateInfoKHR);

struct VkRayTracingPipelineCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineCreateInfoKHR,true,true> {
    VkRayTracingPipelineCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayRecursionDepth)>("maxPipelineRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInfo)>("pLibraryInfo");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInterface)>("pLibraryInterface");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR);

struct VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelineFeaturesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelineFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipeline)>("rayTracingPipeline");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplay)>("rayTracingPipelineShaderGroupHandleCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplayMixed)>("rayTracingPipelineShaderGroupHandleCaptureReplayMixed");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineTraceRaysIndirect)>("rayTracingPipelineTraceRaysIndirect");
        addField<DAS_BIND_MANAGED_FIELD(rayTraversalPrimitiveCulling)>("rayTraversalPrimitiveCulling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR);

struct VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelinePropertiesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelinePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleSize)>("shaderGroupHandleSize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayRecursionDepth)>("maxRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxShaderGroupStride)>("maxShaderGroupStride");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupBaseAlignment)>("shaderGroupBaseAlignment");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleCaptureReplaySize)>("shaderGroupHandleCaptureReplaySize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayDispatchInvocationCount)>("maxRayDispatchInvocationCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleAlignment)>("shaderGroupHandleAlignment");
        addField<DAS_BIND_MANAGED_FIELD(maxRayHitAttributeSize)>("maxRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkStridedDeviceAddressRegionKHR, VkStridedDeviceAddressRegionKHR);

struct VkStridedDeviceAddressRegionKHRAnnotation
: public ManagedStructureAnnotation<VkStridedDeviceAddressRegionKHR,true,true> {
    VkStridedDeviceAddressRegionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStridedDeviceAddressRegionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTraceRaysIndirectCommandKHR, VkTraceRaysIndirectCommandKHR);

struct VkTraceRaysIndirectCommandKHRAnnotation
: public ManagedStructureAnnotation<VkTraceRaysIndirectCommandKHR,true,true> {
    VkTraceRaysIndirectCommandKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTraceRaysIndirectCommandKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayQueryFeaturesKHR);

struct VkPhysicalDeviceRayQueryFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayQueryFeaturesKHR,true,true> {
    VkPhysicalDeviceRayQueryFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayQueryFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayQuery)>("rayQuery");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWvidmode, GLFWvidmode);

struct GLFWvidmodeAnnotation
: public ManagedStructureAnnotation<GLFWvidmode,true,true> {
    GLFWvidmodeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWvidmode", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(redBits)>("redBits");
        addField<DAS_BIND_MANAGED_FIELD(greenBits)>("greenBits");
        addField<DAS_BIND_MANAGED_FIELD(blueBits)>("blueBits");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWgammaramp, GLFWgammaramp);

struct GLFWgammarampAnnotation
: public ManagedStructureAnnotation<GLFWgammaramp,true,true> {
    GLFWgammarampAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgammaramp", ml) {
        addField<DAS_BIND_MANAGED_FIELD(red)>("red");
        addField<DAS_BIND_MANAGED_FIELD(green)>("green");
        addField<DAS_BIND_MANAGED_FIELD(blue)>("blue");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWimage, GLFWimage);

struct GLFWimageAnnotation
: public ManagedStructureAnnotation<GLFWimage,true,true> {
    GLFWimageAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWimage", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(pixels)>("pixels");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWgamepadstate, GLFWgamepadstate);

struct GLFWgamepadstateAnnotation
: public ManagedStructureAnnotation<GLFWgamepadstate,true,true> {
    GLFWgamepadstateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgamepadstate", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buttons)>("buttons");
        addField<DAS_BIND_MANAGED_FIELD(axes)>("axes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_15(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkIndirectCommandsLayoutUsageFlagBitsNV>());
    module.addEnumeration(make_smart<EnumerationVkDeviceMemoryReportEventTypeEXT>());
    module.addEnumeration(make_smart<EnumerationVkPrivateDataSlotCreateFlagBitsEXT>());
    module.addEnumeration(make_smart<EnumerationVkDeviceDiagnosticsConfigFlagBitsNV>());
    module.addEnumeration(make_smart<EnumerationVkFragmentShadingRateTypeNV>());
    module.addEnumeration(make_smart<EnumerationVkFragmentShadingRateNV>());
    module.addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureModeKHR>());
    module.addEnumeration(make_smart<EnumerationVkAccelerationStructureBuildTypeKHR>());
    module.addEnumeration(make_smart<EnumerationVkAccelerationStructureCompatibilityKHR>());
    module.addEnumeration(make_smart<EnumerationVkAccelerationStructureCreateFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkShaderGroupShaderKHR>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<GLFWmonitor_DasHandle>>("GLFWmonitor_DasHandle", "GLFWmonitor_DasHandle"));
    module.addAnnotation(make_smart<VkHandleAnnotation<GLFWwindow_DasHandle>>("GLFWwindow_DasHandle", "GLFWwindow_DasHandle"));
    module.addAnnotation(make_smart<VkHandleAnnotation<GLFWcursor_DasHandle>>("GLFWcursor_DasHandle", "GLFWcursor_DasHandle"));

    //
    // structs
    //

    addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkCopyCommandTransformInfoQCOMAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDevice4444FormatsFeaturesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkDeviceOrHostAddressKHRAnnotation>(lib));
    addAnnotation(make_smart<VkDeviceOrHostAddressConstKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureBuildRangeInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureGeometryTrianglesDataKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureGeometryAabbsDataKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureGeometryInstancesDataKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureGeometryDataKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureGeometryKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureBuildGeometryInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureCreateInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkWriteDescriptorSetAccelerationStructureKHRAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureDeviceAddressInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureVersionInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkCopyAccelerationStructureToMemoryInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkCopyMemoryToAccelerationStructureInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkCopyAccelerationStructureInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkAccelerationStructureBuildSizesInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkRayTracingShaderGroupCreateInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkRayTracingPipelineCreateInfoKHRAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation>(lib));
    addAnnotation(make_smart<VkStridedDeviceAddressRegionKHRAnnotation>(lib));
    addAnnotation(make_smart<VkTraceRaysIndirectCommandKHRAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceRayQueryFeaturesKHRAnnotation>(lib));
    addAnnotation(make_smart<GLFWvidmodeAnnotation>(lib));
    addAnnotation(make_smart<GLFWgammarampAnnotation>(lib));
    addAnnotation(make_smart<GLFWimageAnnotation>(lib));
    addAnnotation(make_smart<GLFWgamepadstateAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(glfwUpdateGamepadMappings)>(*this, lib, "glfwUpdateGamepadMappings",
        SideEffects::worstDefault, "glfwUpdateGamepadMappings");
    addExtern<DAS_BIND_FUN(glfwGetGamepadName)>(*this, lib, "glfwGetGamepadName",
        SideEffects::worstDefault, "glfwGetGamepadName");
    addExtern<DAS_BIND_FUN(glfwGetGamepadState)>(*this, lib, "glfwGetGamepadState",
        SideEffects::worstDefault, "glfwGetGamepadState");
    addExtern<DAS_BIND_FUN(glfwSetClipboardString)>(*this, lib, "glfwSetClipboardString",
        SideEffects::worstDefault, "glfwSetClipboardString");
    addExtern<DAS_BIND_FUN(glfwGetClipboardString)>(*this, lib, "glfwGetClipboardString",
        SideEffects::worstDefault, "glfwGetClipboardString");
    addExtern<DAS_BIND_FUN(glfwGetTime)>(*this, lib, "glfwGetTime",
        SideEffects::worstDefault, "glfwGetTime");
    addExtern<DAS_BIND_FUN(glfwSetTime)>(*this, lib, "glfwSetTime",
        SideEffects::worstDefault, "glfwSetTime");
    addExtern<DAS_BIND_FUN(glfwGetTimerValue)>(*this, lib, "glfwGetTimerValue",
        SideEffects::worstDefault, "glfwGetTimerValue");
    addExtern<DAS_BIND_FUN(glfwGetTimerFrequency)>(*this, lib, "glfwGetTimerFrequency",
        SideEffects::worstDefault, "glfwGetTimerFrequency");
    addExtern<DAS_BIND_FUN(glfwMakeContextCurrent)>(*this, lib, "glfwMakeContextCurrent",
        SideEffects::worstDefault, "glfwMakeContextCurrent");
    addExtern<DAS_BIND_FUN(glfwGetCurrentContext)>(*this, lib, "glfwGetCurrentContext",
        SideEffects::worstDefault, "glfwGetCurrentContext");
    addExtern<DAS_BIND_FUN(glfwSwapBuffers)>(*this, lib, "glfwSwapBuffers",
        SideEffects::worstDefault, "glfwSwapBuffers");
    addExtern<DAS_BIND_FUN(glfwSwapInterval)>(*this, lib, "glfwSwapInterval",
        SideEffects::worstDefault, "glfwSwapInterval");
    addExtern<DAS_BIND_FUN(glfwExtensionSupported)>(*this, lib, "glfwExtensionSupported",
        SideEffects::worstDefault, "glfwExtensionSupported");
    addExtern<DAS_BIND_FUN(glfwVulkanSupported)>(*this, lib, "glfwVulkanSupported",
        SideEffects::worstDefault, "glfwVulkanSupported");
    addExtern<DAS_BIND_FUN(glfwGetRequiredInstanceExtensions)>(*this, lib, "glfwGetRequiredInstanceExtensions",
        SideEffects::worstDefault, "glfwGetRequiredInstanceExtensions");
    addExtern<DAS_BIND_FUN(glfwGetPhysicalDevicePresentationSupport)>(*this, lib, "glfwGetPhysicalDevicePresentationSupport",
        SideEffects::worstDefault, "glfwGetPhysicalDevicePresentationSupport");
    addExtern<DAS_BIND_FUN(glfwCreateWindowSurface)>(*this, lib, "glfwCreateWindowSurface",
        SideEffects::worstDefault, "glfwCreateWindowSurface");

    //
    // macro constants
    //

    addConstant(*this,"VK_EXT_host_query_reset",1);
    addConstant(*this,"VK_EXT_HOST_QUERY_RESET_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_index_type_uint8",1);
    addConstant(*this,"VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_extended_dynamic_state",1);
    addConstant(*this,"VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_shader_demote_to_helper_invocation",1);
    addConstant(*this,"VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION",1);
    addConstant(*this,"VK_NV_device_generated_commands",1);
    addConstant(*this,"VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION",3);
    addConstant(*this,"VK_EXT_texel_buffer_alignment",1);
    addConstant(*this,"VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION",1);
    addConstant(*this,"VK_QCOM_render_pass_transform",1);
    addConstant(*this,"VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_device_memory_report",1);
    addConstant(*this,"VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_robustness2",1);
    addConstant(*this,"VK_EXT_ROBUSTNESS_2_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_custom_border_color",1);
    addConstant(*this,"VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION",12);
    addConstant(*this,"VK_GOOGLE_user_type",1);
    addConstant(*this,"VK_GOOGLE_USER_TYPE_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_private_data",1);
    addConstant(*this,"VK_EXT_PRIVATE_DATA_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_pipeline_creation_cache_control",1);
    addConstant(*this,"VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION",3);
    addConstant(*this,"VK_NV_device_diagnostics_config",1);
    addConstant(*this,"VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION",1);
    addConstant(*this,"VK_QCOM_render_pass_store_ops",1);
    addConstant(*this,"VK_QCOM_render_pass_store_ops_SPEC_VERSION",2);
    addConstant(*this,"VK_NV_fragment_shading_rate_enums",1);
    addConstant(*this,"VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_fragment_density_map2",1);
    addConstant(*this,"VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION",1);
    addConstant(*this,"VK_QCOM_rotated_copy_commands",1);
    addConstant(*this,"VK_QCOM_rotated_copy_commands_SPEC_VERSION",0);
    addConstant(*this,"VK_EXT_image_robustness",1);
    addConstant(*this,"VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_4444_formats",1);
    addConstant(*this,"VK_EXT_4444_FORMATS_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_acceleration_structure",1);
    addConstant(*this,"VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION",11);
    addConstant(*this,"VK_KHR_ray_tracing_pipeline",1);
    addConstant(*this,"VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION",1);
    addConstant(*this,"VK_KHR_ray_query",1);
    addConstant(*this,"VK_KHR_RAY_QUERY_SPEC_VERSION",1);
};
