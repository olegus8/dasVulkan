// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeKHR, VkDisplayModeKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeferredOperationKHR, VkDeferredOperationKHR)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFilterCubicImageViewImageFormatPropertiesEXT, VkFilterCubicImageViewImageFormatPropertiesEXT);

struct VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkFilterCubicImageViewImageFormatPropertiesEXT,true,true> {
    VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFilterCubicImageViewImageFormatPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterCubic)>("filterCubic");
        addField<DAS_BIND_MANAGED_FIELD(filterCubicMinmax)>("filterCubicMinmax");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueGlobalPriorityCreateInfoEXT, VkDeviceQueueGlobalPriorityCreateInfoEXT);

struct VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueGlobalPriorityCreateInfoEXT,true,true> {
    VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueGlobalPriorityCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(globalPriority)>("globalPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImportMemoryHostPointerInfoEXT, VkImportMemoryHostPointerInfoEXT);

struct VkImportMemoryHostPointerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImportMemoryHostPointerInfoEXT,true,true> {
    VkImportMemoryHostPointerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportMemoryHostPointerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(pHostPointer)>("pHostPointer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryHostPointerPropertiesEXT, VkMemoryHostPointerPropertiesEXT);

struct VkMemoryHostPointerPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryHostPointerPropertiesEXT,true,true> {
    VkMemoryHostPointerPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHostPointerPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalMemoryHostPropertiesEXT,true,true> {
    VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalMemoryHostPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImportedHostPointerAlignment)>("minImportedHostPointerAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCompilerControlCreateInfoAMD, VkPipelineCompilerControlCreateInfoAMD);

struct VkPipelineCompilerControlCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineCompilerControlCreateInfoAMD,true,true> {
    VkPipelineCompilerControlCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCompilerControlCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compilerControlFlags)>("compilerControlFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCalibratedTimestampInfoEXT, VkCalibratedTimestampInfoEXT);

struct VkCalibratedTimestampInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCalibratedTimestampInfoEXT,true,true> {
    VkCalibratedTimestampInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCalibratedTimestampInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timeDomain)>("timeDomain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesAMD);

struct VkPhysicalDeviceShaderCorePropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCorePropertiesAMD,true,true> {
    VkPhysicalDeviceShaderCorePropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCorePropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderEngineCount)>("shaderEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderArraysPerEngineCount)>("shaderArraysPerEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(computeUnitsPerShaderArray)>("computeUnitsPerShaderArray");
        addField<DAS_BIND_MANAGED_FIELD(simdPerComputeUnit)>("simdPerComputeUnit");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontsPerSimd)>("wavefrontsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontSize)>("wavefrontSize");
        addField<DAS_BIND_MANAGED_FIELD(sgprsPerSimd)>("sgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minSgprAllocation)>("minSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxSgprAllocation)>("maxSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(sgprAllocationGranularity)>("sgprAllocationGranularity");
        addField<DAS_BIND_MANAGED_FIELD(vgprsPerSimd)>("vgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minVgprAllocation)>("minVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxVgprAllocation)>("maxVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(vgprAllocationGranularity)>("vgprAllocationGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOverallocationCreateInfoAMD, VkDeviceMemoryOverallocationCreateInfoAMD);

struct VkDeviceMemoryOverallocationCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOverallocationCreateInfoAMD,true,true> {
    VkDeviceMemoryOverallocationCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOverallocationCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(overallocationBehavior)>("overallocationBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexAttribDivisor)>("maxVertexAttribDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDivisorDescriptionEXT, VkVertexInputBindingDivisorDescriptionEXT);

struct VkVertexInputBindingDivisorDescriptionEXTAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDivisorDescriptionEXT,true,true> {
    VkVertexInputBindingDivisorDescriptionEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDivisorDescriptionEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(divisor)>("divisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputDivisorStateCreateInfoEXT, VkPipelineVertexInputDivisorStateCreateInfoEXT);

struct VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputDivisorStateCreateInfoEXT,true,true> {
    VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputDivisorStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDivisorCount)>("vertexBindingDivisorCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDivisors)>("pVertexBindingDivisors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateDivisor)>("vertexAttributeInstanceRateDivisor");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateZeroDivisor)>("vertexAttributeInstanceRateZeroDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackEXT);

struct VkPipelineCreationFeedbackEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackEXT,true,true> {
    VkPipelineCreationFeedbackEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(duration)>("duration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackCreateInfoEXT);

struct VkPipelineCreationFeedbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackCreateInfoEXT,true,true> {
    VkPipelineCreationFeedbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineCreationFeedback)>("pPipelineCreationFeedback");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStageCreationFeedbackCount)>("pipelineStageCreationFeedbackCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineStageCreationFeedbacks)>("pPipelineStageCreationFeedbacks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,true,true> {
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupQuads)>("computeDerivativeGroupQuads");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupLinear)>("computeDerivativeGroupLinear");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderFeaturesNV);

struct VkPhysicalDeviceMeshShaderFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderFeaturesNV,true,true> {
    VkPhysicalDeviceMeshShaderFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(taskShader)>("taskShader");
        addField<DAS_BIND_MANAGED_FIELD(meshShader)>("meshShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesNV);

struct VkPhysicalDeviceMeshShaderPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderPropertiesNV,true,true> {
    VkPhysicalDeviceMeshShaderPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawMeshTasksCount)>("maxDrawMeshTasksCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupInvocations)>("maxTaskWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupSize)>("maxTaskWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskTotalMemorySize)>("maxTaskTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskOutputCount)>("maxTaskOutputCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupInvocations)>("maxMeshWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupSize)>("maxMeshWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshTotalMemorySize)>("maxMeshTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputVertices)>("maxMeshOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputPrimitives)>("maxMeshOutputPrimitives");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshMultiviewViewCount)>("maxMeshMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerVertexGranularity)>("meshOutputPerVertexGranularity");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerPrimitiveGranularity)>("meshOutputPerPrimitiveGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawMeshTasksIndirectCommandNV, VkDrawMeshTasksIndirectCommandNV);

struct VkDrawMeshTasksIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkDrawMeshTasksIndirectCommandNV,true,true> {
    VkDrawMeshTasksIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawMeshTasksIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(taskCount)>("taskCount");
        addField<DAS_BIND_MANAGED_FIELD(firstTask)>("firstTask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderBarycentric)>("fragmentShaderBarycentric");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderImageFootprintFeaturesNV);

struct VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageFootprintFeaturesNV,true,true> {
    VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageFootprintFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFootprint)>("imageFootprint");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV);

struct VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportExclusiveScissorStateCreateInfoNV,true,true> {
    VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportExclusiveScissorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissorCount)>("exclusiveScissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pExclusiveScissors)>("pExclusiveScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExclusiveScissorFeaturesNV);

struct VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExclusiveScissorFeaturesNV,true,true> {
    VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExclusiveScissorFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissor)>("exclusiveScissor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyCheckpointPropertiesNV);

struct VkQueueFamilyCheckpointPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyCheckpointPropertiesNV,true,true> {
    VkQueueFamilyCheckpointPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyCheckpointPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(checkpointExecutionStageMask)>("checkpointExecutionStageMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCheckpointDataNV, VkCheckpointDataNV);

struct VkCheckpointDataNVAnnotation
: public ManagedStructureAnnotation<VkCheckpointDataNV,true,true> {
    VkCheckpointDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCheckpointDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(pCheckpointMarker)>("pCheckpointMarker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,true,true> {
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderIntegerFunctions2)>("shaderIntegerFunctions2");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueDataINTEL, VkPerformanceValueDataINTEL);

struct VkPerformanceValueDataINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueDataINTEL,true,true> {
    VkPerformanceValueDataINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueDataINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(value32)>("value32");
        addField<DAS_BIND_MANAGED_FIELD(value64)>("value64");
        addField<DAS_BIND_MANAGED_FIELD(valueFloat)>("valueFloat");
        addField<DAS_BIND_MANAGED_FIELD(valueBool)>("valueBool");
        addField<DAS_BIND_MANAGED_FIELD(valueString)>("valueString");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueINTEL, VkPerformanceValueINTEL);

struct VkPerformanceValueINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueINTEL,true,true> {
    VkPerformanceValueINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInitializePerformanceApiInfoINTEL, VkInitializePerformanceApiInfoINTEL);

struct VkInitializePerformanceApiInfoINTELAnnotation
: public ManagedStructureAnnotation<VkInitializePerformanceApiInfoINTEL,true,true> {
    VkInitializePerformanceApiInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInitializePerformanceApiInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolPerformanceQueryCreateInfoINTEL, VkQueryPoolPerformanceQueryCreateInfoINTEL);

struct VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceQueryCreateInfoINTEL,true,true> {
    VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceQueryCreateInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCountersSampling)>("performanceCountersSampling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceMarkerInfoINTEL, VkPerformanceMarkerInfoINTEL);

struct VkPerformanceMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceMarkerInfoINTEL,true,true> {
    VkPerformanceMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceStreamMarkerInfoINTEL, VkPerformanceStreamMarkerInfoINTEL);

struct VkPerformanceStreamMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceStreamMarkerInfoINTEL,true,true> {
    VkPerformanceStreamMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceStreamMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceOverrideInfoINTEL, VkPerformanceOverrideInfoINTEL);

struct VkPerformanceOverrideInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceOverrideInfoINTEL,true,true> {
    VkPerformanceOverrideInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceOverrideInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(enable)>("enable");
        addField<DAS_BIND_MANAGED_FIELD(parameter)>("parameter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceConfigurationAcquireInfoINTEL, VkPerformanceConfigurationAcquireInfoINTEL);

struct VkPerformanceConfigurationAcquireInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceConfigurationAcquireInfoINTEL,true,true> {
    VkPerformanceConfigurationAcquireInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceConfigurationAcquireInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_12(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkBlendOverlapEXT>());
    module.addEnumeration(make_smart<EnumerationVkCoverageModulationModeNV>());
    module.addEnumeration(make_smart<EnumerationVkValidationCacheHeaderVersionEXT>());
    module.addEnumeration(make_smart<EnumerationVkShadingRatePaletteEntryNV>());
    module.addEnumeration(make_smart<EnumerationVkCoarseSampleOrderTypeNV>());
    module.addEnumeration(make_smart<EnumerationVkRayTracingShaderGroupTypeKHR>());
    module.addEnumeration(make_smart<EnumerationVkGeometryTypeKHR>());
    module.addEnumeration(make_smart<EnumerationVkAccelerationStructureTypeKHR>());
    module.addEnumeration(make_smart<EnumerationVkCopyAccelerationStructureModeKHR>());
    module.addEnumeration(make_smart<EnumerationVkAccelerationStructureMemoryRequirementsTypeNV>());
    module.addEnumeration(make_smart<EnumerationVkGeometryFlagBitsKHR>());
}

void addVulkanGeneratedOpaqueStructs_12(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDisplayModeKHR>>("VkDisplayModeKHR", "VkDisplayModeKHR"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDeferredOperationKHR>>("VkDeferredOperationKHR", "VkDeferredOperationKHR"));
}

void addVulkanGeneratedStructs_12(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkImportMemoryHostPointerInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryHostPointerPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCompilerControlCreateInfoAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkCalibratedTimestampInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderCorePropertiesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceMemoryOverallocationCreateInfoAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkVertexInputBindingDivisorDescriptionEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCreationFeedbackEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCreationFeedbackCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMeshShaderFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMeshShaderPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDrawMeshTasksIndirectCommandNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkQueueFamilyCheckpointPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkCheckpointDataNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceValueDataINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceValueINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkInitializePerformanceApiInfoINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceMarkerInfoINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceStreamMarkerInfoINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceOverrideInfoINTELAnnotation>(lib));
    module.addAnnotation(make_smart<VkPerformanceConfigurationAcquireInfoINTELAnnotation>(lib));
}

void addVulkanGeneratedFunctions_12(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDeviceGroups)>(module, lib, "vkEnumeratePhysicalDeviceGroups",
        SideEffects::worstDefault, "vkEnumeratePhysicalDeviceGroups");
    addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements2)>(module, lib, "vkGetImageMemoryRequirements2",
        SideEffects::worstDefault, "vkGetImageMemoryRequirements2");
    addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements2)>(module, lib, "vkGetBufferMemoryRequirements2",
        SideEffects::worstDefault, "vkGetBufferMemoryRequirements2");
    addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements2)>(module, lib, "vkGetImageSparseMemoryRequirements2",
        SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures2)>(module, lib, "vkGetPhysicalDeviceFeatures2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties2)>(module, lib, "vkGetPhysicalDeviceProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceProperties2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties2)>(module, lib, "vkGetPhysicalDeviceFormatProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties2)>(module, lib, "vkGetPhysicalDeviceImageFormatProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties2)>(module, lib, "vkGetPhysicalDeviceQueueFamilyProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties2)>(module, lib, "vkGetPhysicalDeviceMemoryProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties2");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties2)>(module, lib, "vkGetPhysicalDeviceSparseImageFormatProperties2",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties2");
}

void addVulkanGeneratedConsts_12(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_mesh_shader", 1);
    addConstant(module, "VK_NV_MESH_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_fragment_shader_barycentric", 1);
    addConstant(module, "VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_shader_image_footprint", 1);
    addConstant(module, "VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION", 2);
    addConstant(module, "VK_NV_scissor_exclusive", 1);
    addConstant(module, "VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_device_diagnostic_checkpoints", 1);
    addConstant(module, "VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION", 2);
    addConstant(module, "VK_INTEL_shader_integer_functions2", 1);
    addConstant(module, "VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION", 1);
    addConstant(module, "VK_INTEL_performance_query", 1);
    addConstant(module, "VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_pci_bus_info", 1);
    addConstant(module, "VK_EXT_PCI_BUS_INFO_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_display_native_hdr", 1);
    addConstant(module, "VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_fragment_density_map", 1);
    addConstant(module, "VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_scalar_block_layout", 1);
    addConstant(module, "VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION", 1);
    addConstant(module, "VK_GOOGLE_hlsl_functionality1", 1);
    addConstant(module, "VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION", 1);
    addConstant(module, "VK_GOOGLE_decorate_string", 1);
    addConstant(module, "VK_GOOGLE_DECORATE_STRING_SPEC_VERSION", 1);
}
