// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module_generated.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugReportCallbackEXT, VkDebugReportCallbackEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerEXT, VkDebugUtilsMessengerEXT)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryHostPointerPropertiesEXT, VkMemoryHostPointerPropertiesEXT);

struct VkMemoryHostPointerPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryHostPointerPropertiesEXT,true,true> {
    VkMemoryHostPointerPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHostPointerPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalMemoryHostPropertiesEXT,true,true> {
    VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalMemoryHostPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImportedHostPointerAlignment)>("minImportedHostPointerAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCompilerControlCreateInfoAMD, VkPipelineCompilerControlCreateInfoAMD);

struct VkPipelineCompilerControlCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineCompilerControlCreateInfoAMD,true,true> {
    VkPipelineCompilerControlCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCompilerControlCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compilerControlFlags)>("compilerControlFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCalibratedTimestampInfoEXT, VkCalibratedTimestampInfoEXT);

struct VkCalibratedTimestampInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCalibratedTimestampInfoEXT,true,true> {
    VkCalibratedTimestampInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCalibratedTimestampInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timeDomain)>("timeDomain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesAMD);

struct VkPhysicalDeviceShaderCorePropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCorePropertiesAMD,true,true> {
    VkPhysicalDeviceShaderCorePropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCorePropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderEngineCount)>("shaderEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderArraysPerEngineCount)>("shaderArraysPerEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(computeUnitsPerShaderArray)>("computeUnitsPerShaderArray");
        addField<DAS_BIND_MANAGED_FIELD(simdPerComputeUnit)>("simdPerComputeUnit");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontsPerSimd)>("wavefrontsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontSize)>("wavefrontSize");
        addField<DAS_BIND_MANAGED_FIELD(sgprsPerSimd)>("sgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minSgprAllocation)>("minSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxSgprAllocation)>("maxSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(sgprAllocationGranularity)>("sgprAllocationGranularity");
        addField<DAS_BIND_MANAGED_FIELD(vgprsPerSimd)>("vgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minVgprAllocation)>("minVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxVgprAllocation)>("maxVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(vgprAllocationGranularity)>("vgprAllocationGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOverallocationCreateInfoAMD, VkDeviceMemoryOverallocationCreateInfoAMD);

struct VkDeviceMemoryOverallocationCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOverallocationCreateInfoAMD,true,true> {
    VkDeviceMemoryOverallocationCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOverallocationCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(overallocationBehavior)>("overallocationBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexAttribDivisor)>("maxVertexAttribDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDivisorDescriptionEXT, VkVertexInputBindingDivisorDescriptionEXT);

struct VkVertexInputBindingDivisorDescriptionEXTAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDivisorDescriptionEXT,true,true> {
    VkVertexInputBindingDivisorDescriptionEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDivisorDescriptionEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(divisor)>("divisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputDivisorStateCreateInfoEXT, VkPipelineVertexInputDivisorStateCreateInfoEXT);

struct VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputDivisorStateCreateInfoEXT,true,true> {
    VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputDivisorStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDivisorCount)>("vertexBindingDivisorCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDivisors)>("pVertexBindingDivisors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateDivisor)>("vertexAttributeInstanceRateDivisor");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateZeroDivisor)>("vertexAttributeInstanceRateZeroDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackEXT);

struct VkPipelineCreationFeedbackEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackEXT,true,true> {
    VkPipelineCreationFeedbackEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(duration)>("duration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackCreateInfoEXT);

struct VkPipelineCreationFeedbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackCreateInfoEXT,true,true> {
    VkPipelineCreationFeedbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineCreationFeedback)>("pPipelineCreationFeedback");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStageCreationFeedbackCount)>("pipelineStageCreationFeedbackCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineStageCreationFeedbacks)>("pPipelineStageCreationFeedbacks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,true,true> {
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupQuads)>("computeDerivativeGroupQuads");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupLinear)>("computeDerivativeGroupLinear");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderFeaturesNV);

struct VkPhysicalDeviceMeshShaderFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderFeaturesNV,true,true> {
    VkPhysicalDeviceMeshShaderFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(taskShader)>("taskShader");
        addField<DAS_BIND_MANAGED_FIELD(meshShader)>("meshShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesNV);

struct VkPhysicalDeviceMeshShaderPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderPropertiesNV,true,true> {
    VkPhysicalDeviceMeshShaderPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawMeshTasksCount)>("maxDrawMeshTasksCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupInvocations)>("maxTaskWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupSize)>("maxTaskWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskTotalMemorySize)>("maxTaskTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskOutputCount)>("maxTaskOutputCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupInvocations)>("maxMeshWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupSize)>("maxMeshWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshTotalMemorySize)>("maxMeshTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputVertices)>("maxMeshOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputPrimitives)>("maxMeshOutputPrimitives");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshMultiviewViewCount)>("maxMeshMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerVertexGranularity)>("meshOutputPerVertexGranularity");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerPrimitiveGranularity)>("meshOutputPerPrimitiveGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawMeshTasksIndirectCommandNV, VkDrawMeshTasksIndirectCommandNV);

struct VkDrawMeshTasksIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkDrawMeshTasksIndirectCommandNV,true,true> {
    VkDrawMeshTasksIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawMeshTasksIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(taskCount)>("taskCount");
        addField<DAS_BIND_MANAGED_FIELD(firstTask)>("firstTask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderBarycentric)>("fragmentShaderBarycentric");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderImageFootprintFeaturesNV);

struct VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageFootprintFeaturesNV,true,true> {
    VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageFootprintFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFootprint)>("imageFootprint");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV);

struct VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportExclusiveScissorStateCreateInfoNV,true,true> {
    VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportExclusiveScissorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissorCount)>("exclusiveScissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pExclusiveScissors)>("pExclusiveScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExclusiveScissorFeaturesNV);

struct VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExclusiveScissorFeaturesNV,true,true> {
    VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExclusiveScissorFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissor)>("exclusiveScissor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyCheckpointPropertiesNV);

struct VkQueueFamilyCheckpointPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyCheckpointPropertiesNV,true,true> {
    VkQueueFamilyCheckpointPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyCheckpointPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(checkpointExecutionStageMask)>("checkpointExecutionStageMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCheckpointDataNV, VkCheckpointDataNV);

struct VkCheckpointDataNVAnnotation
: public ManagedStructureAnnotation<VkCheckpointDataNV,true,true> {
    VkCheckpointDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCheckpointDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(pCheckpointMarker)>("pCheckpointMarker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,true,true> {
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderIntegerFunctions2)>("shaderIntegerFunctions2");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueDataINTEL, VkPerformanceValueDataINTEL);

struct VkPerformanceValueDataINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueDataINTEL,true,true> {
    VkPerformanceValueDataINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueDataINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(value32)>("value32");
        addField<DAS_BIND_MANAGED_FIELD(value64)>("value64");
        addField<DAS_BIND_MANAGED_FIELD(valueFloat)>("valueFloat");
        addField<DAS_BIND_MANAGED_FIELD(valueBool)>("valueBool");
        addField<DAS_BIND_MANAGED_FIELD(valueString)>("valueString");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueINTEL, VkPerformanceValueINTEL);

struct VkPerformanceValueINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueINTEL,true,true> {
    VkPerformanceValueINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInitializePerformanceApiInfoINTEL, VkInitializePerformanceApiInfoINTEL);

struct VkInitializePerformanceApiInfoINTELAnnotation
: public ManagedStructureAnnotation<VkInitializePerformanceApiInfoINTEL,true,true> {
    VkInitializePerformanceApiInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInitializePerformanceApiInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolPerformanceQueryCreateInfoINTEL, VkQueryPoolPerformanceQueryCreateInfoINTEL);

struct VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceQueryCreateInfoINTEL,true,true> {
    VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceQueryCreateInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCountersSampling)>("performanceCountersSampling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceMarkerInfoINTEL, VkPerformanceMarkerInfoINTEL);

struct VkPerformanceMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceMarkerInfoINTEL,true,true> {
    VkPerformanceMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceStreamMarkerInfoINTEL, VkPerformanceStreamMarkerInfoINTEL);

struct VkPerformanceStreamMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceStreamMarkerInfoINTEL,true,true> {
    VkPerformanceStreamMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceStreamMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceOverrideInfoINTEL, VkPerformanceOverrideInfoINTEL);

struct VkPerformanceOverrideInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceOverrideInfoINTEL,true,true> {
    VkPerformanceOverrideInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceOverrideInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(enable)>("enable");
        addField<DAS_BIND_MANAGED_FIELD(parameter)>("parameter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceConfigurationAcquireInfoINTEL, VkPerformanceConfigurationAcquireInfoINTEL);

struct VkPerformanceConfigurationAcquireInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceConfigurationAcquireInfoINTEL,true,true> {
    VkPerformanceConfigurationAcquireInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceConfigurationAcquireInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);

struct VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePCIBusInfoPropertiesEXT,true,true> {
    VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePCIBusInfoPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pciDomain)>("pciDomain");
        addField<DAS_BIND_MANAGED_FIELD(pciBus)>("pciBus");
        addField<DAS_BIND_MANAGED_FIELD(pciDevice)>("pciDevice");
        addField<DAS_BIND_MANAGED_FIELD(pciFunction)>("pciFunction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayNativeHdrSurfaceCapabilitiesAMD);

struct VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation
: public ManagedStructureAnnotation<VkDisplayNativeHdrSurfaceCapabilitiesAMD,true,true> {
    VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayNativeHdrSurfaceCapabilitiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingSupport)>("localDimmingSupport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainDisplayNativeHdrCreateInfoAMD);

struct VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkSwapchainDisplayNativeHdrCreateInfoAMD,true,true> {
    VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainDisplayNativeHdrCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingEnable)>("localDimmingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_12(Module & module, ModuleLibrary & lib)

    //
    // enums
    //

    addEnumeration(make_smart<EnumerationVkBlendOverlapEXT>());
    addEnumeration(make_smart<EnumerationVkCoverageModulationModeNV>());
    addEnumeration(make_smart<EnumerationVkValidationCacheHeaderVersionEXT>());
    addEnumeration(make_smart<EnumerationVkShadingRatePaletteEntryNV>());
    addEnumeration(make_smart<EnumerationVkCoarseSampleOrderTypeNV>());
    addEnumeration(make_smart<EnumerationVkRayTracingShaderGroupTypeKHR>());
    addEnumeration(make_smart<EnumerationVkGeometryTypeKHR>());
    addEnumeration(make_smart<EnumerationVkAccelerationStructureTypeKHR>());
    addEnumeration(make_smart<EnumerationVkCopyAccelerationStructureModeKHR>());
    addEnumeration(make_smart<EnumerationVkAccelerationStructureMemoryRequirementsTypeNV>());
    addEnumeration(make_smart<EnumerationVkGeometryFlagBitsKHR>());

    //
    // opaque structs
    //

    addAnnotation(make_smart<VkHandleAnnotation<VkDebugReportCallbackEXT>>("VkDebugReportCallbackEXT", "VkDebugReportCallbackEXT"));
    addAnnotation(make_smart<VkHandleAnnotation<VkDebugUtilsMessengerEXT>>("VkDebugUtilsMessengerEXT", "VkDebugUtilsMessengerEXT"));

    //
    // structs
    //

    addAnnotation(make_smart<VkMemoryHostPointerPropertiesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineCompilerControlCreateInfoAMDAnnotation>(lib));
    addAnnotation(make_smart<VkCalibratedTimestampInfoEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderCorePropertiesAMDAnnotation>(lib));
    addAnnotation(make_smart<VkDeviceMemoryOverallocationCreateInfoAMDAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkVertexInputBindingDivisorDescriptionEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineCreationFeedbackEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineCreationFeedbackCreateInfoEXTAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceMeshShaderFeaturesNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceMeshShaderPropertiesNVAnnotation>(lib));
    addAnnotation(make_smart<VkDrawMeshTasksIndirectCommandNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation>(lib));
    addAnnotation(make_smart<VkQueueFamilyCheckpointPropertiesNVAnnotation>(lib));
    addAnnotation(make_smart<VkCheckpointDataNVAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceValueDataINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceValueINTELAnnotation>(lib));
    addAnnotation(make_smart<VkInitializePerformanceApiInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceMarkerInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceStreamMarkerInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceOverrideInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPerformanceConfigurationAcquireInfoINTELAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation>(lib));
    addAnnotation(make_smart<VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation>(lib));
    addAnnotation(make_smart<VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(glfwWindowShouldClose)>(*this, lib, "glfwWindowShouldClose",
        SideEffects::worstDefault, "glfwWindowShouldClose");
    addExtern<DAS_BIND_FUN(glfwSetWindowShouldClose)>(*this, lib, "glfwSetWindowShouldClose",
        SideEffects::worstDefault, "glfwSetWindowShouldClose");
    addExtern<DAS_BIND_FUN(glfwSetWindowTitle)>(*this, lib, "glfwSetWindowTitle",
        SideEffects::worstDefault, "glfwSetWindowTitle");
    addExtern<DAS_BIND_FUN(glfwSetWindowIcon)>(*this, lib, "glfwSetWindowIcon",
        SideEffects::worstDefault, "glfwSetWindowIcon");
    addExtern<DAS_BIND_FUN(glfwGetWindowPos)>(*this, lib, "glfwGetWindowPos",
        SideEffects::worstDefault, "glfwGetWindowPos");
    addExtern<DAS_BIND_FUN(glfwSetWindowPos)>(*this, lib, "glfwSetWindowPos",
        SideEffects::worstDefault, "glfwSetWindowPos");
    addExtern<DAS_BIND_FUN(glfwGetWindowSize)>(*this, lib, "glfwGetWindowSize",
        SideEffects::worstDefault, "glfwGetWindowSize");
    addExtern<DAS_BIND_FUN(glfwSetWindowSizeLimits)>(*this, lib, "glfwSetWindowSizeLimits",
        SideEffects::worstDefault, "glfwSetWindowSizeLimits");
    addExtern<DAS_BIND_FUN(glfwSetWindowAspectRatio)>(*this, lib, "glfwSetWindowAspectRatio",
        SideEffects::worstDefault, "glfwSetWindowAspectRatio");
    addExtern<DAS_BIND_FUN(glfwSetWindowSize)>(*this, lib, "glfwSetWindowSize",
        SideEffects::worstDefault, "glfwSetWindowSize");
    addExtern<DAS_BIND_FUN(glfwGetFramebufferSize)>(*this, lib, "glfwGetFramebufferSize",
        SideEffects::worstDefault, "glfwGetFramebufferSize");
    addExtern<DAS_BIND_FUN(glfwGetWindowFrameSize)>(*this, lib, "glfwGetWindowFrameSize",
        SideEffects::worstDefault, "glfwGetWindowFrameSize");
    addExtern<DAS_BIND_FUN(glfwGetWindowContentScale)>(*this, lib, "glfwGetWindowContentScale",
        SideEffects::worstDefault, "glfwGetWindowContentScale");
    addExtern<DAS_BIND_FUN(glfwGetWindowOpacity)>(*this, lib, "glfwGetWindowOpacity",
        SideEffects::worstDefault, "glfwGetWindowOpacity");
    addExtern<DAS_BIND_FUN(glfwSetWindowOpacity)>(*this, lib, "glfwSetWindowOpacity",
        SideEffects::worstDefault, "glfwSetWindowOpacity");
    addExtern<DAS_BIND_FUN(glfwIconifyWindow)>(*this, lib, "glfwIconifyWindow",
        SideEffects::worstDefault, "glfwIconifyWindow");
    addExtern<DAS_BIND_FUN(glfwRestoreWindow)>(*this, lib, "glfwRestoreWindow",
        SideEffects::worstDefault, "glfwRestoreWindow");
    addExtern<DAS_BIND_FUN(glfwMaximizeWindow)>(*this, lib, "glfwMaximizeWindow",
        SideEffects::worstDefault, "glfwMaximizeWindow");

    //
    // macro constants
    //

    addConstant(*this,"VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_queue_family_foreign",1);
    addConstant(*this,"VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION",1);
    addConstant(*this,"VK_QUEUE_FAMILY_FOREIGN_EXT",(~0U-2));
    addConstant(*this,"VK_EXT_debug_utils",1);
    addConstant(*this,"VK_EXT_DEBUG_UTILS_SPEC_VERSION",2);
    addConstant(*this,"VK_EXT_sampler_filter_minmax",1);
    addConstant(*this,"VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION",2);
    addConstant(*this,"VK_AMD_gpu_shader_int16",1);
    addConstant(*this,"VK_AMD_GPU_SHADER_INT16_SPEC_VERSION",2);
    addConstant(*this,"VK_AMD_mixed_attachment_samples",1);
    addConstant(*this,"VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION",1);
    addConstant(*this,"VK_AMD_shader_fragment_mask",1);
    addConstant(*this,"VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_inline_uniform_block",1);
    addConstant(*this,"VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_shader_stencil_export",1);
    addConstant(*this,"VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_sample_locations",1);
    addConstant(*this,"VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_blend_operation_advanced",1);
    addConstant(*this,"VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION",2);
    addConstant(*this,"VK_NV_fragment_coverage_to_color",1);
    addConstant(*this,"VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION",1);
    addConstant(*this,"VK_NV_framebuffer_mixed_samples",1);
    addConstant(*this,"VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION",1);
    addConstant(*this,"VK_NV_fill_rectangle",1);
    addConstant(*this,"VK_NV_FILL_RECTANGLE_SPEC_VERSION",1);
    addConstant(*this,"VK_NV_shader_sm_builtins",1);
    addConstant(*this,"VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_post_depth_coverage",1);
    addConstant(*this,"VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_image_drm_format_modifier",1);
    addConstant(*this,"VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_validation_cache",1);
    addConstant(*this,"VK_EXT_VALIDATION_CACHE_SPEC_VERSION",1);
    addConstant(*this,"VK_EXT_descriptor_indexing",1);
    addConstant(*this,"VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION",2);
    addConstant(*this,"VK_EXT_shader_viewport_index_layer",1);
    addConstant(*this,"VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION",1);
    addConstant(*this,"VK_NV_shading_rate_image",1);
    addConstant(*this,"VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION",3);
    addConstant(*this,"VK_NV_ray_tracing",1);
    addConstant(*this,"VK_NV_RAY_TRACING_SPEC_VERSION",3);
    addConstant(*this,"VK_SHADER_UNUSED_KHR",(~0U));
    addConstant(*this,"VK_SHADER_UNUSED_NV",VK_SHADER_UNUSED_KHR);
};
