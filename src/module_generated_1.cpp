// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module_generated.h.inc"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInstance, VkInstance)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice, VkPhysicalDevice)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDevice, VkDevice)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryRequirements, VkMemoryRequirements);

struct VkMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryRequirements,true,true> {
    VkMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(alignment)>("alignment");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseMemoryBind, VkSparseMemoryBind);

struct VkSparseMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseMemoryBind,true,true> {
    VkSparseMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(resourceOffset)>("resourceOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseBufferMemoryBindInfo, VkSparseBufferMemoryBindInfo);

struct VkSparseBufferMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseBufferMemoryBindInfo,true,true> {
    VkSparseBufferMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseBufferMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageOpaqueMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo);

struct VkSparseImageOpaqueMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageOpaqueMemoryBindInfo,true,true> {
    VkSparseImageOpaqueMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageOpaqueMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresource, VkImageSubresource);

struct VkImageSubresourceAnnotation
: public ManagedStructureAnnotation<VkImageSubresource,true,true> {
    VkImageSubresourceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresource", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayer)>("arrayLayer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBind, VkSparseImageMemoryBind);

struct VkSparseImageMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBind,true,true> {
    VkSparseImageMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subresource)>("subresource");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBindInfo, VkSparseImageMemoryBindInfo);

struct VkSparseImageMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBindInfo,true,true> {
    VkSparseImageMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindSparseInfo, VkBindSparseInfo);

struct VkBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkBindSparseInfo,true,true> {
    VkBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(bufferBindCount)>("bufferBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBufferBinds)>("pBufferBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageOpaqueBindCount)>("imageOpaqueBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageOpaqueBinds)>("pImageOpaqueBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageBindCount)>("imageBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageBinds)>("pImageBinds");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageFormatProperties, VkSparseImageFormatProperties);

struct VkSparseImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties,true,true> {
    VkSparseImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(imageGranularity)>("imageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryRequirements, VkSparseImageMemoryRequirements);

struct VkSparseImageMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements,true,true> {
    VkSparseImageMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailFirstLod)>("imageMipTailFirstLod");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailSize)>("imageMipTailSize");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailOffset)>("imageMipTailOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailStride)>("imageMipTailStride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFenceCreateInfo, VkFenceCreateInfo);

struct VkFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFenceCreateInfo,true,true> {
    VkFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreCreateInfo, VkSemaphoreCreateInfo);

struct VkSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreCreateInfo,true,true> {
    VkSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkEventCreateInfo, VkEventCreateInfo);

struct VkEventCreateInfoAnnotation
: public ManagedStructureAnnotation<VkEventCreateInfo,true,true> {
    VkEventCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkEventCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolCreateInfo, VkQueryPoolCreateInfo);

struct VkQueryPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkQueryPoolCreateInfo,true,true> {
    VkQueryPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queryType)>("queryType");
        addField<DAS_BIND_MANAGED_FIELD(queryCount)>("queryCount");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCreateInfo, VkBufferCreateInfo);

struct VkBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferCreateInfo,true,true> {
    VkBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferViewCreateInfo, VkBufferViewCreateInfo);

struct VkBufferViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferViewCreateInfo,true,true> {
    VkBufferViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageCreateInfo, VkImageCreateInfo);

struct VkImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageCreateInfo,true,true> {
    VkImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(imageType)>("imageType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(mipLevels)>("mipLevels");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayers)>("arrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubresourceLayout, VkSubresourceLayout);

struct VkSubresourceLayoutAnnotation
: public ManagedStructureAnnotation<VkSubresourceLayout,true,true> {
    VkSubresourceLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubresourceLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(rowPitch)>("rowPitch");
        addField<DAS_BIND_MANAGED_FIELD(arrayPitch)>("arrayPitch");
        addField<DAS_BIND_MANAGED_FIELD(depthPitch)>("depthPitch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComponentMapping, VkComponentMapping);

struct VkComponentMappingAnnotation
: public ManagedStructureAnnotation<VkComponentMapping,true,true> {
    VkComponentMappingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComponentMapping", ml) {
        addField<DAS_BIND_MANAGED_FIELD(r)>("r");
        addField<DAS_BIND_MANAGED_FIELD(g)>("g");
        addField<DAS_BIND_MANAGED_FIELD(b)>("b");
        addField<DAS_BIND_MANAGED_FIELD(a)>("a");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewCreateInfo, VkImageViewCreateInfo);

struct VkImageViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewCreateInfo,true,true> {
    VkImageViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(viewType)>("viewType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModuleCreateInfo, VkShaderModuleCreateInfo);

struct VkShaderModuleCreateInfoAnnotation
: public ManagedStructureAnnotation<VkShaderModuleCreateInfo,true,true> {
    VkShaderModuleCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(codeSize)>("codeSize");
        addField<DAS_BIND_MANAGED_FIELD(pCode)>("pCode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCacheCreateInfo, VkPipelineCacheCreateInfo);

struct VkPipelineCacheCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineCacheCreateInfo,true,true> {
    VkPipelineCacheCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCacheCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationMapEntry, VkSpecializationMapEntry);

struct VkSpecializationMapEntryAnnotation
: public ManagedStructureAnnotation<VkSpecializationMapEntry,true,true> {
    VkSpecializationMapEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationMapEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(constantID)>("constantID");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationInfo, VkSpecializationInfo);

struct VkSpecializationInfoAnnotation
: public ManagedStructureAnnotation<VkSpecializationInfo,true,true> {
    VkSpecializationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(mapEntryCount)>("mapEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pMapEntries)>("pMapEntries");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageCreateInfo, VkPipelineShaderStageCreateInfo);

struct VkPipelineShaderStageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageCreateInfo,true,true> {
    VkPipelineShaderStageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(module)>("module_");
        addField<DAS_BIND_MANAGED_FIELD(pName)>("pName");
        addField<DAS_BIND_MANAGED_FIELD(pSpecializationInfo)>("pSpecializationInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComputePipelineCreateInfo, VkComputePipelineCreateInfo);

struct VkComputePipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkComputePipelineCreateInfo,true,true> {
    VkComputePipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComputePipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDescription, VkVertexInputBindingDescription);

struct VkVertexInputBindingDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDescription,true,true> {
    VkVertexInputBindingDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(inputRate)>("inputRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputAttributeDescription, VkVertexInputAttributeDescription);

struct VkVertexInputAttributeDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputAttributeDescription,true,true> {
    VkVertexInputAttributeDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputAttributeDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(location)>("location");
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputStateCreateInfo, VkPipelineVertexInputStateCreateInfo);

struct VkPipelineVertexInputStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputStateCreateInfo,true,true> {
    VkPipelineVertexInputStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDescriptionCount)>("vertexBindingDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDescriptions)>("pVertexBindingDescriptions");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeDescriptionCount)>("vertexAttributeDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexAttributeDescriptions)>("pVertexAttributeDescriptions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineInputAssemblyStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo);

struct VkPipelineInputAssemblyStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineInputAssemblyStateCreateInfo,true,true> {
    VkPipelineInputAssemblyStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInputAssemblyStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(topology)>("topology");
        addField<DAS_BIND_MANAGED_FIELD(primitiveRestartEnable)>("primitiveRestartEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineTessellationStateCreateInfo, VkPipelineTessellationStateCreateInfo);

struct VkPipelineTessellationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationStateCreateInfo,true,true> {
    VkPipelineTessellationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(patchControlPoints)>("patchControlPoints");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewport, VkViewport);

struct VkViewportAnnotation
: public ManagedStructureAnnotation<VkViewport,true,true> {
    VkViewportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(minDepth)>("minDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxDepth)>("maxDepth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportStateCreateInfo, VkPipelineViewportStateCreateInfo);

struct VkPipelineViewportStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportStateCreateInfo,true,true> {
    VkPipelineViewportStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewports)>("pViewports");
        addField<DAS_BIND_MANAGED_FIELD(scissorCount)>("scissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pScissors)>("pScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateCreateInfo, VkPipelineRasterizationStateCreateInfo);

struct VkPipelineRasterizationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateCreateInfo,true,true> {
    VkPipelineRasterizationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClampEnable)>("depthClampEnable");
        addField<DAS_BIND_MANAGED_FIELD(rasterizerDiscardEnable)>("rasterizerDiscardEnable");
        addField<DAS_BIND_MANAGED_FIELD(polygonMode)>("polygonMode");
        addField<DAS_BIND_MANAGED_FIELD(cullMode)>("cullMode");
        addField<DAS_BIND_MANAGED_FIELD(frontFace)>("frontFace");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasEnable)>("depthBiasEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasConstantFactor)>("depthBiasConstantFactor");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasSlopeFactor)>("depthBiasSlopeFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineWidth)>("lineWidth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_1(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkPhysicalDeviceType>());
    module.addEnumeration(make_smart<EnumerationVkQueryType>());
    module.addEnumeration(make_smart<EnumerationVkSharingMode>());
    module.addEnumeration(make_smart<EnumerationVkComponentSwizzle>());
    module.addEnumeration(make_smart<EnumerationVkImageViewType>());
    module.addEnumeration(make_smart<EnumerationVkBlendFactor>());
    module.addEnumeration(make_smart<EnumerationVkBlendOp>());
    module.addEnumeration(make_smart<EnumerationVkCompareOp>());
    module.addEnumeration(make_smart<EnumerationVkDynamicState>());
    module.addEnumeration(make_smart<EnumerationVkFrontFace>());
    module.addEnumeration(make_smart<EnumerationVkVertexInputRate>());

    //
    // opaque structs
    //

    addAnnotation(make_smart<VkHandleAnnotation<VkInstance>>("VkInstance", "VkInstance"));
    addAnnotation(make_smart<VkHandleAnnotation<VkPhysicalDevice>>("VkPhysicalDevice", "VkPhysicalDevice"));
    addAnnotation(make_smart<VkHandleAnnotation<VkDevice>>("VkDevice", "VkDevice"));

    //
    // structs
    //

    addAnnotation(make_smart<VkMemoryRequirementsAnnotation>(lib));
    addAnnotation(make_smart<VkSparseMemoryBindAnnotation>(lib));
    addAnnotation(make_smart<VkSparseBufferMemoryBindInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSparseImageOpaqueMemoryBindInfoAnnotation>(lib));
    addAnnotation(make_smart<VkImageSubresourceAnnotation>(lib));
    addAnnotation(make_smart<VkSparseImageMemoryBindAnnotation>(lib));
    addAnnotation(make_smart<VkSparseImageMemoryBindInfoAnnotation>(lib));
    addAnnotation(make_smart<VkBindSparseInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSparseImageFormatPropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkSparseImageMemoryRequirementsAnnotation>(lib));
    addAnnotation(make_smart<VkFenceCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSemaphoreCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkEventCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkQueryPoolCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkBufferCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkBufferViewCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkImageCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSubresourceLayoutAnnotation>(lib));
    addAnnotation(make_smart<VkComponentMappingAnnotation>(lib));
    addAnnotation(make_smart<VkImageViewCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkShaderModuleCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineCacheCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSpecializationMapEntryAnnotation>(lib));
    addAnnotation(make_smart<VkSpecializationInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineShaderStageCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkComputePipelineCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkVertexInputBindingDescriptionAnnotation>(lib));
    addAnnotation(make_smart<VkVertexInputAttributeDescriptionAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineVertexInputStateCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineInputAssemblyStateCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineTessellationStateCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkViewportAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineViewportStateCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPipelineRasterizationStateCreateInfoAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkQueueWaitIdle)>(*this, lib, "vkQueueWaitIdle",
        SideEffects::worstDefault, "vkQueueWaitIdle");
    addExtern<DAS_BIND_FUN(vkDeviceWaitIdle)>(*this, lib, "vkDeviceWaitIdle",
        SideEffects::worstDefault, "vkDeviceWaitIdle");
    addExtern<DAS_BIND_FUN(vkAllocateMemory)>(*this, lib, "vkAllocateMemory",
        SideEffects::worstDefault, "vkAllocateMemory");
    addExtern<DAS_BIND_FUN(vkFreeMemory)>(*this, lib, "vkFreeMemory",
        SideEffects::worstDefault, "vkFreeMemory");
    addExtern<DAS_BIND_FUN(vkMapMemory)>(*this, lib, "vkMapMemory",
        SideEffects::worstDefault, "vkMapMemory");
    addExtern<DAS_BIND_FUN(vkUnmapMemory)>(*this, lib, "vkUnmapMemory",
        SideEffects::worstDefault, "vkUnmapMemory");
    addExtern<DAS_BIND_FUN(vkFlushMappedMemoryRanges)>(*this, lib, "vkFlushMappedMemoryRanges",
        SideEffects::worstDefault, "vkFlushMappedMemoryRanges");
    addExtern<DAS_BIND_FUN(vkInvalidateMappedMemoryRanges)>(*this, lib, "vkInvalidateMappedMemoryRanges",
        SideEffects::worstDefault, "vkInvalidateMappedMemoryRanges");
    addExtern<DAS_BIND_FUN(vkGetDeviceMemoryCommitment)>(*this, lib, "vkGetDeviceMemoryCommitment",
        SideEffects::worstDefault, "vkGetDeviceMemoryCommitment");
    addExtern<DAS_BIND_FUN(vkBindBufferMemory)>(*this, lib, "vkBindBufferMemory",
        SideEffects::worstDefault, "vkBindBufferMemory");
    addExtern<DAS_BIND_FUN(vkBindImageMemory)>(*this, lib, "vkBindImageMemory",
        SideEffects::worstDefault, "vkBindImageMemory");
    addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements)>(*this, lib, "vkGetBufferMemoryRequirements",
        SideEffects::worstDefault, "vkGetBufferMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements)>(*this, lib, "vkGetImageMemoryRequirements",
        SideEffects::worstDefault, "vkGetImageMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements)>(*this, lib, "vkGetImageSparseMemoryRequirements",
        SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties");
    addExtern<DAS_BIND_FUN(vkQueueBindSparse)>(*this, lib, "vkQueueBindSparse",
        SideEffects::worstDefault, "vkQueueBindSparse");
    addExtern<DAS_BIND_FUN(vkCreateFence)>(*this, lib, "vkCreateFence",
        SideEffects::worstDefault, "vkCreateFence");
    addExtern<DAS_BIND_FUN(vkDestroyFence)>(*this, lib, "vkDestroyFence",
        SideEffects::worstDefault, "vkDestroyFence");

    //
    // macro constants
    //

    addConstant(*this,"GLFW_KEY_J",74);
    addConstant(*this,"GLFW_KEY_K",75);
    addConstant(*this,"GLFW_KEY_L",76);
    addConstant(*this,"GLFW_KEY_M",77);
    addConstant(*this,"GLFW_KEY_N",78);
    addConstant(*this,"GLFW_KEY_O",79);
    addConstant(*this,"GLFW_KEY_P",80);
    addConstant(*this,"GLFW_KEY_Q",81);
    addConstant(*this,"GLFW_KEY_R",82);
    addConstant(*this,"GLFW_KEY_S",83);
    addConstant(*this,"GLFW_KEY_T",84);
    addConstant(*this,"GLFW_KEY_U",85);
    addConstant(*this,"GLFW_KEY_V",86);
    addConstant(*this,"GLFW_KEY_W",87);
    addConstant(*this,"GLFW_KEY_X",88);
    addConstant(*this,"GLFW_KEY_Y",89);
    addConstant(*this,"GLFW_KEY_Z",90);
    addConstant(*this,"GLFW_KEY_LEFT_BRACKET",91  /* [ */);
    addConstant(*this,"GLFW_KEY_BACKSLASH",92  /* \ */);
    addConstant(*this,"GLFW_KEY_RIGHT_BRACKET",93  /* ] */);
    addConstant(*this,"GLFW_KEY_GRAVE_ACCENT",96  /* ` */);
    addConstant(*this,"GLFW_KEY_WORLD_1",161 /* non-US #1 */);
    addConstant(*this,"GLFW_KEY_WORLD_2",162 /* non-US #2 */);
    addConstant(*this,"GLFW_KEY_ESCAPE",256);
    addConstant(*this,"GLFW_KEY_ENTER",257);
    addConstant(*this,"GLFW_KEY_TAB",258);
    addConstant(*this,"GLFW_KEY_BACKSPACE",259);
    addConstant(*this,"GLFW_KEY_INSERT",260);
    addConstant(*this,"GLFW_KEY_DELETE",261);
    addConstant(*this,"GLFW_KEY_RIGHT",262);
    addConstant(*this,"GLFW_KEY_LEFT",263);
    addConstant(*this,"GLFW_KEY_DOWN",264);
    addConstant(*this,"GLFW_KEY_UP",265);
    addConstant(*this,"GLFW_KEY_PAGE_UP",266);
    addConstant(*this,"GLFW_KEY_PAGE_DOWN",267);
    addConstant(*this,"GLFW_KEY_HOME",268);
    addConstant(*this,"GLFW_KEY_END",269);
    addConstant(*this,"GLFW_KEY_CAPS_LOCK",280);
    addConstant(*this,"GLFW_KEY_SCROLL_LOCK",281);
    addConstant(*this,"GLFW_KEY_NUM_LOCK",282);
    addConstant(*this,"GLFW_KEY_PRINT_SCREEN",283);
    addConstant(*this,"GLFW_KEY_PAUSE",284);
    addConstant(*this,"GLFW_KEY_F1",290);
    addConstant(*this,"GLFW_KEY_F2",291);
    addConstant(*this,"GLFW_KEY_F3",292);
};
