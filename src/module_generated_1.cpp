// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4100)   // unreferenced formal parameter
#endif
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInstance, VkInstance)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice, VkPhysicalDevice)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDevice, VkDevice)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryAllocateInfo, VkMemoryAllocateInfo);

struct VkMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateInfo,true,true> {
    VkMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allocationSize)>("allocationSize");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeIndex)>("memoryTypeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryRequirements, VkMemoryRequirements);

struct VkMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryRequirements,true,true> {
    VkMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(alignment)>("alignment");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseMemoryBind, VkSparseMemoryBind);

struct VkSparseMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseMemoryBind,true,true> {
    VkSparseMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(resourceOffset)>("resourceOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseBufferMemoryBindInfo, VkSparseBufferMemoryBindInfo);

struct VkSparseBufferMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseBufferMemoryBindInfo,true,true> {
    VkSparseBufferMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseBufferMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageOpaqueMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo);

struct VkSparseImageOpaqueMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageOpaqueMemoryBindInfo,true,true> {
    VkSparseImageOpaqueMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageOpaqueMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresource, VkImageSubresource);

struct VkImageSubresourceAnnotation
: public ManagedStructureAnnotation<VkImageSubresource,true,true> {
    VkImageSubresourceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresource", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayer)>("arrayLayer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBind, VkSparseImageMemoryBind);

struct VkSparseImageMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBind,true,true> {
    VkSparseImageMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subresource)>("subresource");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBindInfo, VkSparseImageMemoryBindInfo);

struct VkSparseImageMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBindInfo,true,true> {
    VkSparseImageMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindSparseInfo, VkBindSparseInfo);

struct VkBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkBindSparseInfo,true,true> {
    VkBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(bufferBindCount)>("bufferBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBufferBinds)>("pBufferBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageOpaqueBindCount)>("imageOpaqueBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageOpaqueBinds)>("pImageOpaqueBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageBindCount)>("imageBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageBinds)>("pImageBinds");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageFormatProperties, VkSparseImageFormatProperties);

struct VkSparseImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties,true,true> {
    VkSparseImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(imageGranularity)>("imageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryRequirements, VkSparseImageMemoryRequirements);

struct VkSparseImageMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements,true,true> {
    VkSparseImageMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailFirstLod)>("imageMipTailFirstLod");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailSize)>("imageMipTailSize");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailOffset)>("imageMipTailOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailStride)>("imageMipTailStride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFenceCreateInfo, VkFenceCreateInfo);

struct VkFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFenceCreateInfo,true,true> {
    VkFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreCreateInfo, VkSemaphoreCreateInfo);

struct VkSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreCreateInfo,true,true> {
    VkSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkEventCreateInfo, VkEventCreateInfo);

struct VkEventCreateInfoAnnotation
: public ManagedStructureAnnotation<VkEventCreateInfo,true,true> {
    VkEventCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkEventCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolCreateInfo, VkQueryPoolCreateInfo);

struct VkQueryPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkQueryPoolCreateInfo,true,true> {
    VkQueryPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queryType)>("queryType");
        addField<DAS_BIND_MANAGED_FIELD(queryCount)>("queryCount");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCreateInfo, VkBufferCreateInfo);

struct VkBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferCreateInfo,true,true> {
    VkBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferViewCreateInfo, VkBufferViewCreateInfo);

struct VkBufferViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferViewCreateInfo,true,true> {
    VkBufferViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageCreateInfo, VkImageCreateInfo);

struct VkImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageCreateInfo,true,true> {
    VkImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(imageType)>("imageType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(mipLevels)>("mipLevels");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayers)>("arrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubresourceLayout, VkSubresourceLayout);

struct VkSubresourceLayoutAnnotation
: public ManagedStructureAnnotation<VkSubresourceLayout,true,true> {
    VkSubresourceLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubresourceLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(rowPitch)>("rowPitch");
        addField<DAS_BIND_MANAGED_FIELD(arrayPitch)>("arrayPitch");
        addField<DAS_BIND_MANAGED_FIELD(depthPitch)>("depthPitch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComponentMapping, VkComponentMapping);

struct VkComponentMappingAnnotation
: public ManagedStructureAnnotation<VkComponentMapping,true,true> {
    VkComponentMappingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComponentMapping", ml) {
        addField<DAS_BIND_MANAGED_FIELD(r)>("r");
        addField<DAS_BIND_MANAGED_FIELD(g)>("g");
        addField<DAS_BIND_MANAGED_FIELD(b)>("b");
        addField<DAS_BIND_MANAGED_FIELD(a)>("a");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewCreateInfo, VkImageViewCreateInfo);

struct VkImageViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewCreateInfo,true,true> {
    VkImageViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(viewType)>("viewType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModuleCreateInfo, VkShaderModuleCreateInfo);

struct VkShaderModuleCreateInfoAnnotation
: public ManagedStructureAnnotation<VkShaderModuleCreateInfo,true,true> {
    VkShaderModuleCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(codeSize)>("codeSize");
        addField<DAS_BIND_MANAGED_FIELD(pCode)>("pCode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCacheCreateInfo, VkPipelineCacheCreateInfo);

struct VkPipelineCacheCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineCacheCreateInfo,true,true> {
    VkPipelineCacheCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCacheCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationMapEntry, VkSpecializationMapEntry);

struct VkSpecializationMapEntryAnnotation
: public ManagedStructureAnnotation<VkSpecializationMapEntry,true,true> {
    VkSpecializationMapEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationMapEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(constantID)>("constantID");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationInfo, VkSpecializationInfo);

struct VkSpecializationInfoAnnotation
: public ManagedStructureAnnotation<VkSpecializationInfo,true,true> {
    VkSpecializationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(mapEntryCount)>("mapEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pMapEntries)>("pMapEntries");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageCreateInfo, VkPipelineShaderStageCreateInfo);

struct VkPipelineShaderStageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageCreateInfo,true,true> {
    VkPipelineShaderStageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(module)>("module_");
        addField<DAS_BIND_MANAGED_FIELD(pName)>("pName");
        addField<DAS_BIND_MANAGED_FIELD(pSpecializationInfo)>("pSpecializationInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComputePipelineCreateInfo, VkComputePipelineCreateInfo);

struct VkComputePipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkComputePipelineCreateInfo,true,true> {
    VkComputePipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComputePipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDescription, VkVertexInputBindingDescription);

struct VkVertexInputBindingDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDescription,true,true> {
    VkVertexInputBindingDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(inputRate)>("inputRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputAttributeDescription, VkVertexInputAttributeDescription);

struct VkVertexInputAttributeDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputAttributeDescription,true,true> {
    VkVertexInputAttributeDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputAttributeDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(location)>("location");
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputStateCreateInfo, VkPipelineVertexInputStateCreateInfo);

struct VkPipelineVertexInputStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputStateCreateInfo,true,true> {
    VkPipelineVertexInputStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDescriptionCount)>("vertexBindingDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDescriptions)>("pVertexBindingDescriptions");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeDescriptionCount)>("vertexAttributeDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexAttributeDescriptions)>("pVertexAttributeDescriptions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineInputAssemblyStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo);

struct VkPipelineInputAssemblyStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineInputAssemblyStateCreateInfo,true,true> {
    VkPipelineInputAssemblyStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInputAssemblyStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(topology)>("topology");
        addField<DAS_BIND_MANAGED_FIELD(primitiveRestartEnable)>("primitiveRestartEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineTessellationStateCreateInfo, VkPipelineTessellationStateCreateInfo);

struct VkPipelineTessellationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationStateCreateInfo,true,true> {
    VkPipelineTessellationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(patchControlPoints)>("patchControlPoints");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewport, VkViewport);

struct VkViewportAnnotation
: public ManagedStructureAnnotation<VkViewport,true,true> {
    VkViewportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(minDepth)>("minDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxDepth)>("maxDepth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportStateCreateInfo, VkPipelineViewportStateCreateInfo);

struct VkPipelineViewportStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportStateCreateInfo,true,true> {
    VkPipelineViewportStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewports)>("pViewports");
        addField<DAS_BIND_MANAGED_FIELD(scissorCount)>("scissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pScissors)>("pScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_1(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkPhysicalDeviceType>());
    module.addEnumeration(make_smart<EnumerationVkQueryType>());
    module.addEnumeration(make_smart<EnumerationVkSharingMode>());
    module.addEnumeration(make_smart<EnumerationVkComponentSwizzle>());
    module.addEnumeration(make_smart<EnumerationVkImageViewType>());
    module.addEnumeration(make_smart<EnumerationVkBlendFactor>());
    module.addEnumeration(make_smart<EnumerationVkBlendOp>());
    module.addEnumeration(make_smart<EnumerationVkCompareOp>());
    module.addEnumeration(make_smart<EnumerationVkDynamicState>());
    module.addEnumeration(make_smart<EnumerationVkFrontFace>());
    module.addEnumeration(make_smart<EnumerationVkVertexInputRate>());
}

void addVulkanGeneratedOpaqueStructs_1(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkInstance>>("VkInstance", "VkInstance"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPhysicalDevice>>("VkPhysicalDevice", "VkPhysicalDevice"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDevice>>("VkDevice", "VkDevice"));
}

void addVulkanGeneratedStructs_1(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkMemoryAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryRequirementsAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseMemoryBindAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseBufferMemoryBindInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseImageOpaqueMemoryBindInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSubresourceAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseImageMemoryBindAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseImageMemoryBindInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindSparseInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseImageFormatPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkSparseImageMemoryRequirementsAnnotation>(lib));
    module.addAnnotation(make_smart<VkFenceCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkEventCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkQueryPoolCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferViewCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubresourceLayoutAnnotation>(lib));
    module.addAnnotation(make_smart<VkComponentMappingAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkShaderModuleCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCacheCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSpecializationMapEntryAnnotation>(lib));
    module.addAnnotation(make_smart<VkSpecializationInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineShaderStageCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkComputePipelineCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkVertexInputBindingDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkVertexInputAttributeDescriptionAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineVertexInputStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineInputAssemblyStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineTessellationStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkViewportAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineViewportStateCreateInfoAnnotation>(lib));
}

void addVulkanGeneratedFunctions_1(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkEnumerateInstanceExtensionProperties)>(module, lib, "vkEnumerateInstanceExtensionProperties",
        SideEffects::worstDefault, "vkEnumerateInstanceExtensionProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateDeviceExtensionProperties)>(module, lib, "vkEnumerateDeviceExtensionProperties",
        SideEffects::worstDefault, "vkEnumerateDeviceExtensionProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateInstanceLayerProperties)>(module, lib, "vkEnumerateInstanceLayerProperties",
        SideEffects::worstDefault, "vkEnumerateInstanceLayerProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateDeviceLayerProperties)>(module, lib, "vkEnumerateDeviceLayerProperties",
        SideEffects::worstDefault, "vkEnumerateDeviceLayerProperties");
    addExtern<DAS_BIND_FUN(vkGetDeviceQueue)>(module, lib, "vkGetDeviceQueue",
        SideEffects::worstDefault, "vkGetDeviceQueue");
    addExtern<DAS_BIND_FUN(vkQueueSubmit)>(module, lib, "vkQueueSubmit",
        SideEffects::worstDefault, "vkQueueSubmit");
    addExtern<DAS_BIND_FUN(vkQueueWaitIdle)>(module, lib, "vkQueueWaitIdle",
        SideEffects::worstDefault, "vkQueueWaitIdle");
    addExtern<DAS_BIND_FUN(vkDeviceWaitIdle)>(module, lib, "vkDeviceWaitIdle",
        SideEffects::worstDefault, "vkDeviceWaitIdle");
    addExtern<DAS_BIND_FUN(vkAllocateMemory)>(module, lib, "vkAllocateMemory",
        SideEffects::worstDefault, "vkAllocateMemory");
    addExtern<DAS_BIND_FUN(vkFreeMemory)>(module, lib, "vkFreeMemory",
        SideEffects::worstDefault, "vkFreeMemory");
    addExtern<DAS_BIND_FUN(vkMapMemory)>(module, lib, "vkMapMemory",
        SideEffects::worstDefault, "vkMapMemory");
    addExtern<DAS_BIND_FUN(vkUnmapMemory)>(module, lib, "vkUnmapMemory",
        SideEffects::worstDefault, "vkUnmapMemory");
}

void addVulkanGeneratedConsts_1(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_MAX_DRIVER_NAME_SIZE", 256);
    addConstant(module, "VK_MAX_DRIVER_INFO_SIZE", 256);
    addConstant(module, "VK_KHR_surface", 1);
    addConstant(module, "VK_KHR_SURFACE_SPEC_VERSION", 25);
    addConstant(module, "VK_KHR_swapchain", 1);
    addConstant(module, "VK_KHR_SWAPCHAIN_SPEC_VERSION", 70);
    addConstant(module, "VK_KHR_display", 1);
    addConstant(module, "VK_KHR_DISPLAY_SPEC_VERSION", 23);
    addConstant(module, "VK_KHR_display_swapchain", 1);
    addConstant(module, "VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION", 10);
    addConstant(module, "VK_KHR_sampler_mirror_clamp_to_edge", 1);
    addConstant(module, "VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION", 3);
    addConstant(module, "VK_KHR_multiview", 1);
    addConstant(module, "VK_KHR_MULTIVIEW_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_get_physical_device_properties2", 1);
    addConstant(module, "VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION", 2);
    addConstant(module, "VK_KHR_device_group", 1);
    addConstant(module, "VK_KHR_DEVICE_GROUP_SPEC_VERSION", 4);
    addConstant(module, "VK_KHR_shader_draw_parameters", 1);
    addConstant(module, "VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION", 1);
    addConstant(module, "VK_KHR_maintenance1", 1);
    addConstant(module, "VK_KHR_MAINTENANCE1_SPEC_VERSION", 2);
    addConstant(module, "VK_KHR_device_group_creation", 1);
    addConstant(module, "VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION", 1);
    addConstant(module, "VK_MAX_DEVICE_GROUP_SIZE_KHR", VK_MAX_DEVICE_GROUP_SIZE);
    addConstant(module, "VK_KHR_external_memory_capabilities", 1);
    addConstant(module, "VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION", 1);
}
