// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplate, VkDescriptorUpdateTemplate)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceKHR, VkSurfaceKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainKHR, VkSwapchainKHR)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportSwizzleStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV);

struct VkPipelineViewportSwizzleStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportSwizzleStateCreateInfoNV,true,true> {
    VkPipelineViewportSwizzleStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportSwizzleStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportSwizzles)>("pViewportSwizzles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT);

struct VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiscardRectanglePropertiesEXT,true,true> {
    VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiscardRectanglePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDiscardRectangles)>("maxDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT);

struct VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineDiscardRectangleStateCreateInfoEXT,true,true> {
    VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDiscardRectangleStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleMode)>("discardRectangleMode");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleCount)>("discardRectangleCount");
        addField<DAS_BIND_MANAGED_FIELD(pDiscardRectangles)>("pDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT);

struct VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConservativeRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConservativeRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOverestimationSize)>("primitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(maxExtraPrimitiveOverestimationSize)>("maxExtraPrimitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSizeGranularity)>("extraPrimitiveOverestimationSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(primitiveUnderestimation)>("primitiveUnderestimation");
        addField<DAS_BIND_MANAGED_FIELD(conservativePointAndLineRasterization)>("conservativePointAndLineRasterization");
        addField<DAS_BIND_MANAGED_FIELD(degenerateTrianglesRasterized)>("degenerateTrianglesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(degenerateLinesRasterized)>("degenerateLinesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(fullyCoveredFragmentShaderInputVariable)>("fullyCoveredFragmentShaderInputVariable");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationPostDepthCoverage)>("conservativeRasterizationPostDepthCoverage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationConservativeStateCreateInfoEXT);

struct VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationConservativeStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationConservativeStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationMode)>("conservativeRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSize)>("extraPrimitiveOverestimationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT);

struct VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthClipEnableFeaturesEXT,true,true> {
    VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthClipEnableFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT);

struct VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationDepthClipStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationDepthClipStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkXYColorEXT, VkXYColorEXT);

struct VkXYColorEXTAnnotation
: public ManagedStructureAnnotation<VkXYColorEXT,true,true> {
    VkXYColorEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkXYColorEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkHdrMetadataEXT, VkHdrMetadataEXT);

struct VkHdrMetadataEXTAnnotation
: public ManagedStructureAnnotation<VkHdrMetadataEXT,true,true> {
    VkHdrMetadataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHdrMetadataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryRed)>("displayPrimaryRed");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryGreen)>("displayPrimaryGreen");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryBlue)>("displayPrimaryBlue");
        addField<DAS_BIND_MANAGED_FIELD(whitePoint)>("whitePoint");
        addField<DAS_BIND_MANAGED_FIELD(maxLuminance)>("maxLuminance");
        addField<DAS_BIND_MANAGED_FIELD(minLuminance)>("minLuminance");
        addField<DAS_BIND_MANAGED_FIELD(maxContentLightLevel)>("maxContentLightLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxFrameAverageLightLevel)>("maxFrameAverageLightLevel");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsLabelEXT, VkDebugUtilsLabelEXT);

struct VkDebugUtilsLabelEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsLabelEXT,true,true> {
    VkDebugUtilsLabelEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsLabelEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pLabelName)>("pLabelName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectNameInfoEXT);

struct VkDebugUtilsObjectNameInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectNameInfoEXT,true,true> {
    VkDebugUtilsObjectNameInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectNameInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(pObjectName)>("pObjectName");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerCallbackDataEXT, VkDebugUtilsMessengerCallbackDataEXT);

struct VkDebugUtilsMessengerCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCallbackDataEXT,true,true> {
    VkDebugUtilsMessengerCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pMessageIdName)>("pMessageIdName");
        addField<DAS_BIND_MANAGED_FIELD(messageIdNumber)>("messageIdNumber");
        addField<DAS_BIND_MANAGED_FIELD(pMessage)>("pMessage");
        addField<DAS_BIND_MANAGED_FIELD(queueLabelCount)>("queueLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueLabels)>("pQueueLabels");
        addField<DAS_BIND_MANAGED_FIELD(cmdBufLabelCount)>("cmdBufLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pCmdBufLabels)>("pCmdBufLabels");
        addField<DAS_BIND_MANAGED_FIELD(objectCount)>("objectCount");
        addField<DAS_BIND_MANAGED_FIELD(pObjects)>("pObjects");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT);

struct VkDebugUtilsMessengerCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCreateInfoEXT,true,true> {
    VkDebugUtilsMessengerCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(messageSeverity)>("messageSeverity");
        addField<DAS_BIND_MANAGED_FIELD(messageType)>("messageType");
        addField<DAS_BIND_MANAGED_FIELD(pfnUserCallback)>("pfnUserCallback");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsObjectTagInfoEXT, VkDebugUtilsObjectTagInfoEXT);

struct VkDebugUtilsObjectTagInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectTagInfoEXT,true,true> {
    VkDebugUtilsObjectTagInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectTagInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(tagName)>("tagName");
        addField<DAS_BIND_MANAGED_FIELD(tagSize)>("tagSize");
        addField<DAS_BIND_MANAGED_FIELD(pTag)>("pTag");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT);

struct VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockFeaturesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(inlineUniformBlock)>("inlineUniformBlock");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingInlineUniformBlockUpdateAfterBind)>("descriptorBindingInlineUniformBlockUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT);

struct VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockPropertiesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockSize)>("maxInlineUniformBlockSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInlineUniformBlocks)>("maxPerStageDescriptorInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)>("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInlineUniformBlocks)>("maxDescriptorSetInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)>("maxDescriptorSetUpdateAfterBindInlineUniformBlocks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSetInlineUniformBlockEXT, VkWriteDescriptorSetInlineUniformBlockEXT);

struct VkWriteDescriptorSetInlineUniformBlockEXTAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetInlineUniformBlockEXT,true,true> {
    VkWriteDescriptorSetInlineUniformBlockEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetInlineUniformBlockEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolInlineUniformBlockCreateInfoEXT, VkDescriptorPoolInlineUniformBlockCreateInfoEXT);

struct VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolInlineUniformBlockCreateInfoEXT,true,true> {
    VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolInlineUniformBlockCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockBindings)>("maxInlineUniformBlockBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSampleLocationEXT, VkSampleLocationEXT);

struct VkSampleLocationEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationEXT,true,true> {
    VkSampleLocationEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSampleLocationsInfoEXT, VkSampleLocationsInfoEXT);

struct VkSampleLocationsInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationsInfoEXT,true,true> {
    VkSampleLocationsInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationsInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsPerPixel)>("sampleLocationsPerPixel");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationGridSize)>("sampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsCount)>("sampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pSampleLocations)>("pSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentSampleLocationsEXT, VkAttachmentSampleLocationsEXT);

struct VkAttachmentSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkAttachmentSampleLocationsEXT,true,true> {
    VkAttachmentSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachmentIndex)>("attachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassSampleLocationsEXT, VkSubpassSampleLocationsEXT);

struct VkSubpassSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkSubpassSampleLocationsEXT,true,true> {
    VkSubpassSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpassIndex)>("subpassIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassSampleLocationsBeginInfoEXT);

struct VkRenderPassSampleLocationsBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassSampleLocationsBeginInfoEXT,true,true> {
    VkRenderPassSampleLocationsBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassSampleLocationsBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentInitialSampleLocationsCount)>("attachmentInitialSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentInitialSampleLocations)>("pAttachmentInitialSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(postSubpassSampleLocationsCount)>("postSubpassSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pPostSubpassSampleLocations)>("pPostSubpassSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineSampleLocationsStateCreateInfoEXT, VkPipelineSampleLocationsStateCreateInfoEXT);

struct VkPipelineSampleLocationsStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineSampleLocationsStateCreateInfoEXT,true,true> {
    VkPipelineSampleLocationsStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineSampleLocationsStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsEnable)>("sampleLocationsEnable");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT);

struct VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSampleLocationsPropertiesEXT,true,true> {
    VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSampleLocationsPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSampleCounts)>("sampleLocationSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationCoordinateRange)>("sampleLocationCoordinateRange");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSubPixelBits)>("sampleLocationSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(variableSampleLocations)>("variableSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMultisamplePropertiesEXT, VkMultisamplePropertiesEXT);

struct VkMultisamplePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMultisamplePropertiesEXT,true,true> {
    VkMultisamplePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMultisamplePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCoherentOperations)>("advancedBlendCoherentOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendMaxColorAttachments)>("advancedBlendMaxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendIndependentBlend)>("advancedBlendIndependentBlend");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedSrcColor)>("advancedBlendNonPremultipliedSrcColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedDstColor)>("advancedBlendNonPremultipliedDstColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCorrelatedOverlap)>("advancedBlendCorrelatedOverlap");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendAllOperations)>("advancedBlendAllOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendAdvancedStateCreateInfoEXT, VkPipelineColorBlendAdvancedStateCreateInfoEXT);

struct VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAdvancedStateCreateInfoEXT,true,true> {
    VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAdvancedStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcPremultiplied)>("srcPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(dstPremultiplied)>("dstPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(blendOverlap)>("blendOverlap");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageToColorStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV);

struct VkPipelineCoverageToColorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageToColorStateCreateInfoNV,true,true> {
    VkPipelineCoverageToColorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageToColorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorEnable)>("coverageToColorEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorLocation)>("coverageToColorLocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageModulationStateCreateInfoNV);

struct VkPipelineCoverageModulationStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageModulationStateCreateInfoNV,true,true> {
    VkPipelineCoverageModulationStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageModulationStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationMode)>("coverageModulationMode");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableEnable)>("coverageModulationTableEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableCount)>("coverageModulationTableCount");
        addField<DAS_BIND_MANAGED_FIELD(pCoverageModulationTable)>("pCoverageModulationTable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);

struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMCount)>("shaderSMCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderWarpsPerSM)>("shaderWarpsPerSM");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);

struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMBuiltins)>("shaderSMBuiltins");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrmFormatModifierPropertiesEXT, VkDrmFormatModifierPropertiesEXT);

struct VkDrmFormatModifierPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesEXT,true,true> {
    VkDrmFormatModifierPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierPlaneCount)>("drmFormatModifierPlaneCount");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierTilingFeatures)>("drmFormatModifierTilingFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrmFormatModifierPropertiesListEXT, VkDrmFormatModifierPropertiesListEXT);

struct VkDrmFormatModifierPropertiesListEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesListEXT,true,true> {
    VkDrmFormatModifierPropertiesListEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesListEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierCount)>("drmFormatModifierCount");
        addField<DAS_BIND_MANAGED_FIELD(pDrmFormatModifierProperties)>("pDrmFormatModifierProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_10(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterStorageKHR>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceCounterDescriptionFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkAcquireProfilingLockFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkFragmentShadingRateCombinerOpKHR>());
    module.addEnumeration(make_smart<EnumerationVkPipelineExecutableStatisticFormatKHR>());
    module.addEnumeration(make_smart<EnumerationVkDebugReportObjectTypeEXT>());
    module.addEnumeration(make_smart<EnumerationVkDebugReportFlagBitsEXT>());
    module.addEnumeration(make_smart<EnumerationVkRasterizationOrderAMD>());
    module.addEnumeration(make_smart<EnumerationVkShaderInfoTypeAMD>());
    module.addEnumeration(make_smart<EnumerationVkExternalMemoryHandleTypeFlagBitsNV>());
    module.addEnumeration(make_smart<EnumerationVkExternalMemoryFeatureFlagBitsNV>());
}

void addVulkanGeneratedOpaqueStructs_10(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorUpdateTemplate>>("VkDescriptorUpdateTemplate", "VkDescriptorUpdateTemplate"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkSurfaceKHR>>("VkSurfaceKHR", "VkSurfaceKHR"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkSwapchainKHR>>("VkSwapchainKHR", "VkSwapchainKHR"));
}

void addVulkanGeneratedStructs_10(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkPipelineViewportSwizzleStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkXYColorEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkHdrMetadataEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDebugUtilsLabelEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDebugUtilsObjectNameInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDebugUtilsMessengerCallbackDataEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDebugUtilsMessengerCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDebugUtilsObjectTagInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkWriteDescriptorSetInlineUniformBlockEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSampleLocationEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSampleLocationsInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentSampleLocationsEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubpassSampleLocationsEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassSampleLocationsBeginInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineSampleLocationsStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkMultisamplePropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCoverageToColorStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCoverageModulationStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDrmFormatModifierPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDrmFormatModifierPropertiesListEXTAnnotation>(lib));
}

void addVulkanGeneratedFunctions_10(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkDestroySurfaceKHR)>(module, lib, "vkDestroySurfaceKHR",
        SideEffects::worstDefault, "vkDestroySurfaceKHR");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceSupportKHR)>(module, lib, "vkGetPhysicalDeviceSurfaceSupportKHR",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceSupportKHR");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)>(module, lib, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceFormatsKHR)>(module, lib, "vkGetPhysicalDeviceSurfaceFormatsKHR",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceFormatsKHR");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfacePresentModesKHR)>(module, lib, "vkGetPhysicalDeviceSurfacePresentModesKHR",
        SideEffects::worstDefault, "vkGetPhysicalDeviceSurfacePresentModesKHR");
    addExtern<DAS_BIND_FUN(vkCreateSwapchainKHR)>(module, lib, "vkCreateSwapchainKHR",
        SideEffects::worstDefault, "vkCreateSwapchainKHR");
    addExtern<DAS_BIND_FUN(vkDestroySwapchainKHR)>(module, lib, "vkDestroySwapchainKHR",
        SideEffects::worstDefault, "vkDestroySwapchainKHR");
    addExtern<DAS_BIND_FUN(vkGetSwapchainImagesKHR)>(module, lib, "vkGetSwapchainImagesKHR",
        SideEffects::worstDefault, "vkGetSwapchainImagesKHR");
    addExtern<DAS_BIND_FUN(vkAcquireNextImageKHR)>(module, lib, "vkAcquireNextImageKHR",
        SideEffects::worstDefault, "vkAcquireNextImageKHR");
    addExtern<DAS_BIND_FUN(vkQueuePresentKHR)>(module, lib, "vkQueuePresentKHR",
        SideEffects::worstDefault, "vkQueuePresentKHR");
    addExtern<DAS_BIND_FUN(vkCreateDebugUtilsMessengerEXT)>(module, lib, "vkCreateDebugUtilsMessengerEXT",
        SideEffects::worstDefault, "vkCreateDebugUtilsMessengerEXT");
    addExtern<DAS_BIND_FUN(vkDestroyDebugUtilsMessengerEXT)>(module, lib, "vkDestroyDebugUtilsMessengerEXT",
        SideEffects::worstDefault, "vkDestroyDebugUtilsMessengerEXT");
    addExtern<DAS_BIND_FUN(glfwInit)>(module, lib, "glfwInit",
        SideEffects::worstDefault, "glfwInit");
    addExtern<DAS_BIND_FUN(glfwTerminate)>(module, lib, "glfwTerminate",
        SideEffects::worstDefault, "glfwTerminate");
    addExtern<DAS_BIND_FUN(glfwInitHint)>(module, lib, "glfwInitHint",
        SideEffects::worstDefault, "glfwInitHint");
    addExtern<DAS_BIND_FUN(glfwGetVersion)>(module, lib, "glfwGetVersion",
        SideEffects::worstDefault, "glfwGetVersion");
    addExtern<DAS_BIND_FUN(glfwGetVersionString)>(module, lib, "glfwGetVersionString",
        SideEffects::worstDefault, "glfwGetVersionString");
}

void addVulkanGeneratedConsts_10(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_KHR_COPY_COMMANDS_2_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_debug_report", 1);
    addConstant(module, "VK_EXT_DEBUG_REPORT_SPEC_VERSION", 9);
    addConstant(module, "VK_NV_glsl_shader", 1);
    addConstant(module, "VK_NV_GLSL_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_depth_range_unrestricted", 1);
    addConstant(module, "VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION", 1);
    addConstant(module, "VK_IMG_filter_cubic", 1);
    addConstant(module, "VK_IMG_FILTER_CUBIC_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_rasterization_order", 1);
    addConstant(module, "VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_trinary_minmax", 1);
    addConstant(module, "VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_explicit_vertex_parameter", 1);
    addConstant(module, "VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_debug_marker", 1);
    addConstant(module, "VK_EXT_DEBUG_MARKER_SPEC_VERSION", 4);
    addConstant(module, "VK_AMD_gcn_shader", 1);
    addConstant(module, "VK_AMD_GCN_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_dedicated_allocation", 1);
    addConstant(module, "VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_transform_feedback", 1);
    addConstant(module, "VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION", 1);
    addConstant(module, "VK_NVX_image_view_handle", 1);
    addConstant(module, "VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_draw_indirect_count", 1);
    addConstant(module, "VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_negative_viewport_height", 1);
    addConstant(module, "VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_gpu_shader_half_float", 1);
    addConstant(module, "VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_shader_ballot", 1);
    addConstant(module, "VK_AMD_SHADER_BALLOT_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_texture_gather_bias_lod", 1);
    addConstant(module, "VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_info", 1);
    addConstant(module, "VK_AMD_SHADER_INFO_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_image_load_store_lod", 1);
    addConstant(module, "VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_corner_sampled_image", 1);
    addConstant(module, "VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION", 2);
    addConstant(module, "VK_IMG_format_pvrtc", 1);
    addConstant(module, "VK_IMG_FORMAT_PVRTC_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_external_memory_capabilities", 1);
    addConstant(module, "VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION", 1);
}
