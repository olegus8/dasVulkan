// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutNV, VkIndirectCommandsLayoutNV)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPrivateDataSlotEXT, VkPrivateDataSlotEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureKHR, VkAccelerationStructureKHR)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceGeneratedCommands)>("deviceGeneratedCommands");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsShaderGroupCreateInfoNV, VkGraphicsShaderGroupCreateInfoNV);

struct VkGraphicsShaderGroupCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsShaderGroupCreateInfoNV,true,true> {
    VkGraphicsShaderGroupCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsShaderGroupCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsPipelineShaderGroupsCreateInfoNV, VkGraphicsPipelineShaderGroupsCreateInfoNV);

struct VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineShaderGroupsCreateInfoNV,true,true> {
    VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineShaderGroupsCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCount)>("pipelineCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelines)>("pPipelines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindShaderGroupIndirectCommandNV, VkBindShaderGroupIndirectCommandNV);

struct VkBindShaderGroupIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindShaderGroupIndirectCommandNV,true,true> {
    VkBindShaderGroupIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindShaderGroupIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(groupIndex)>("groupIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindIndexBufferIndirectCommandNV, VkBindIndexBufferIndirectCommandNV);

struct VkBindIndexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindIndexBufferIndirectCommandNV,true,true> {
    VkBindIndexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindIndexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindVertexBufferIndirectCommandNV, VkBindVertexBufferIndirectCommandNV);

struct VkBindVertexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindVertexBufferIndirectCommandNV,true,true> {
    VkBindVertexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindVertexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSetStateFlagsIndirectCommandNV, VkSetStateFlagsIndirectCommandNV);

struct VkSetStateFlagsIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkSetStateFlagsIndirectCommandNV,true,true> {
    VkSetStateFlagsIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSetStateFlagsIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsStreamNV, VkIndirectCommandsStreamNV);

struct VkIndirectCommandsStreamNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsStreamNV,true,true> {
    VkIndirectCommandsStreamNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsStreamNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutTokenNV, VkIndirectCommandsLayoutTokenNV);

struct VkIndirectCommandsLayoutTokenNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutTokenNV,true,true> {
    VkIndirectCommandsLayoutTokenNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutTokenNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(tokenType)>("tokenType");
        addField<DAS_BIND_MANAGED_FIELD(stream)>("stream");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingUnit)>("vertexBindingUnit");
        addField<DAS_BIND_MANAGED_FIELD(vertexDynamicStride)>("vertexDynamicStride");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantPipelineLayout)>("pushconstantPipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantShaderStageFlags)>("pushconstantShaderStageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantOffset)>("pushconstantOffset");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantSize)>("pushconstantSize");
        addField<DAS_BIND_MANAGED_FIELD(indirectStateFlags)>("indirectStateFlags");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeCount)>("indexTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypes)>("pIndexTypes");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypeValues)>("pIndexTypeValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutCreateInfoNV, VkIndirectCommandsLayoutCreateInfoNV);

struct VkIndirectCommandsLayoutCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutCreateInfoNV,true,true> {
    VkIndirectCommandsLayoutCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(tokenCount)>("tokenCount");
        addField<DAS_BIND_MANAGED_FIELD(pTokens)>("pTokens");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreamStrides)>("pStreamStrides");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeneratedCommandsInfoNV, VkGeneratedCommandsInfoNV);

struct VkGeneratedCommandsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsInfoNV,true,true> {
    VkGeneratedCommandsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreams)>("pStreams");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCount)>("sequencesCount");
        addField<DAS_BIND_MANAGED_FIELD(preprocessBuffer)>("preprocessBuffer");
        addField<DAS_BIND_MANAGED_FIELD(preprocessOffset)>("preprocessOffset");
        addField<DAS_BIND_MANAGED_FIELD(preprocessSize)>("preprocessSize");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountBuffer)>("sequencesCountBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountOffset)>("sequencesCountOffset");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexBuffer)>("sequencesIndexBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexOffset)>("sequencesIndexOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeneratedCommandsMemoryRequirementsInfoNV, VkGeneratedCommandsMemoryRequirementsInfoNV);

struct VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsMemoryRequirementsInfoNV,true,true> {
    VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsMemoryRequirementsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(maxSequencesCount)>("maxSequencesCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(texelBufferAlignment)>("texelBufferAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetAlignmentBytes)>("storageTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetSingleTexelAlignment)>("storageTexelBufferOffsetSingleTexelAlignment");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetAlignmentBytes)>("uniformTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetSingleTexelAlignment)>("uniformTexelBufferOffsetSingleTexelAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassTransformBeginInfoQCOM, VkRenderPassTransformBeginInfoQCOM);

struct VkRenderPassTransformBeginInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkRenderPassTransformBeginInfoQCOM,true,true> {
    VkRenderPassTransformBeginInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassTransformBeginInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, VkCommandBufferInheritanceRenderPassTransformInfoQCOM);

struct VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceRenderPassTransformInfoQCOM,true,true> {
    VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceRenderPassTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(renderArea)>("renderArea");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);

struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,true,true> {
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMemoryReport)>("deviceMemoryReport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryReportCallbackDataEXT, VkDeviceMemoryReportCallbackDataEXT);

struct VkDeviceMemoryReportCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryReportCallbackDataEXT,true,true> {
    VkDeviceMemoryReportCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryReportCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(memoryObjectId)>("memoryObjectId");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDeviceMemoryReportCreateInfoEXT);

struct VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceDeviceMemoryReportCreateInfoEXT,true,true> {
    VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDeviceMemoryReportCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRobustness2FeaturesEXT, VkPhysicalDeviceRobustness2FeaturesEXT);

struct VkPhysicalDeviceRobustness2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2FeaturesEXT,true,true> {
    VkPhysicalDeviceRobustness2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess2)>("robustBufferAccess2");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess2)>("robustImageAccess2");
        addField<DAS_BIND_MANAGED_FIELD(nullDescriptor)>("nullDescriptor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceRobustness2PropertiesEXT);

struct VkPhysicalDeviceRobustness2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2PropertiesEXT,true,true> {
    VkPhysicalDeviceRobustness2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustStorageBufferAccessSizeAlignment)>("robustStorageBufferAccessSizeAlignment");
        addField<DAS_BIND_MANAGED_FIELD(robustUniformBufferAccessSizeAlignment)>("robustUniformBufferAccessSizeAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerCustomBorderColorCreateInfoEXT, VkSamplerCustomBorderColorCreateInfoEXT);

struct VkSamplerCustomBorderColorCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSamplerCustomBorderColorCreateInfoEXT,true,true> {
    VkSamplerCustomBorderColorCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCustomBorderColorCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColor)>("customBorderColor");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceCustomBorderColorPropertiesEXT);

struct VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorPropertiesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxCustomBorderColorSamplers)>("maxCustomBorderColorSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT);

struct VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorFeaturesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColors)>("customBorderColors");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColorWithoutFormat)>("customBorderColorWithoutFormat");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePrivateDataFeaturesEXT, VkPhysicalDevicePrivateDataFeaturesEXT);

struct VkPhysicalDevicePrivateDataFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePrivateDataFeaturesEXT,true,true> {
    VkPhysicalDevicePrivateDataFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePrivateDataFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateData)>("privateData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDevicePrivateDataCreateInfoEXT, VkDevicePrivateDataCreateInfoEXT);

struct VkDevicePrivateDataCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDevicePrivateDataCreateInfoEXT,true,true> {
    VkDevicePrivateDataCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDevicePrivateDataCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateDataSlotRequestCount)>("privateDataSlotRequestCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPrivateDataSlotCreateInfoEXT, VkPrivateDataSlotCreateInfoEXT);

struct VkPrivateDataSlotCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPrivateDataSlotCreateInfoEXT,true,true> {
    VkPrivateDataSlotCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPrivateDataSlotCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);

struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT,true,true> {
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCreationCacheControl)>("pipelineCreationCacheControl");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDiagnosticsConfigFeaturesNV);

struct VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiagnosticsConfigFeaturesNV,true,true> {
    VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiagnosticsConfigFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(diagnosticsConfig)>("diagnosticsConfig");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceDiagnosticsConfigCreateInfoNV);

struct VkDeviceDiagnosticsConfigCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDeviceDiagnosticsConfigCreateInfoNV,true,true> {
    VkDeviceDiagnosticsConfigCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDiagnosticsConfigCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateEnums)>("fragmentShadingRateEnums");
        addField<DAS_BIND_MANAGED_FIELD(supersampleFragmentShadingRates)>("supersampleFragmentShadingRates");
        addField<DAS_BIND_MANAGED_FIELD(noInvocationFragmentShadingRates)>("noInvocationFragmentShadingRates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateInvocationCount)>("maxFragmentShadingRateInvocationCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateEnumStateCreateInfoNV);

struct VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineFragmentShadingRateEnumStateCreateInfoNV,true,true> {
    VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineFragmentShadingRateEnumStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateType)>("shadingRateType");
        addField<DAS_BIND_MANAGED_FIELD(shadingRate)>("shadingRate");
        addField<DAS_BIND_MANAGED_FIELD(combinerOps)>("combinerOps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDeferred)>("fragmentDensityMapDeferred");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_14(Module & module, ModuleLibrary & lib) {

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkPerformanceValueTypeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkShaderCorePropertiesFlagBitsAMD>());
    module.addEnumeration(make_smart<EnumerationVkToolPurposeFlagBitsEXT>());
    module.addEnumeration(make_smart<EnumerationVkValidationFeatureEnableEXT>());
    module.addEnumeration(make_smart<EnumerationVkValidationFeatureDisableEXT>());
    module.addEnumeration(make_smart<EnumerationVkComponentTypeNV>());
    module.addEnumeration(make_smart<EnumerationVkScopeNV>());
    module.addEnumeration(make_smart<EnumerationVkCoverageReductionModeNV>());
    module.addEnumeration(make_smart<EnumerationVkLineRasterizationModeEXT>());
    module.addEnumeration(make_smart<EnumerationVkIndirectCommandsTokenTypeNV>());
    module.addEnumeration(make_smart<EnumerationVkIndirectStateFlagBitsNV>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkIndirectCommandsLayoutNV>>("VkIndirectCommandsLayoutNV", "VkIndirectCommandsLayoutNV"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPrivateDataSlotEXT>>("VkPrivateDataSlotEXT", "VkPrivateDataSlotEXT"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureKHR>>("VkAccelerationStructureKHR", "VkAccelerationStructureKHR"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkGraphicsShaderGroupCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindShaderGroupIndirectCommandNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindIndexBufferIndirectCommandNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindVertexBufferIndirectCommandNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkSetStateFlagsIndirectCommandNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkIndirectCommandsStreamNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkIndirectCommandsLayoutTokenNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkIndirectCommandsLayoutCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkGeneratedCommandsInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassTransformBeginInfoQCOMAnnotation>(lib));
    module.addAnnotation(make_smart<VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceMemoryReportCallbackDataEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceRobustness2FeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceRobustness2PropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerCustomBorderColorCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDevicePrivateDataFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDevicePrivateDataCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPrivateDataSlotCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceDiagnosticsConfigCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(glfwGetKeyScancode)>(module, lib, "glfwGetKeyScancode",
        SideEffects::worstDefault, "glfwGetKeyScancode");
    addExtern<DAS_BIND_FUN(glfwGetKey)>(module, lib, "glfwGetKey",
        SideEffects::worstDefault, "glfwGetKey");
    addExtern<DAS_BIND_FUN(glfwGetMouseButton)>(module, lib, "glfwGetMouseButton",
        SideEffects::worstDefault, "glfwGetMouseButton");
    addExtern<DAS_BIND_FUN(glfwGetCursorPos)>(module, lib, "glfwGetCursorPos",
        SideEffects::worstDefault, "glfwGetCursorPos");
    addExtern<DAS_BIND_FUN(glfwSetCursorPos)>(module, lib, "glfwSetCursorPos",
        SideEffects::worstDefault, "glfwSetCursorPos");
    addExtern<DAS_BIND_FUN(glfwCreateCursor)>(module, lib, "glfwCreateCursor",
        SideEffects::worstDefault, "glfwCreateCursor");
    addExtern<DAS_BIND_FUN(glfwCreateStandardCursor)>(module, lib, "glfwCreateStandardCursor",
        SideEffects::worstDefault, "glfwCreateStandardCursor");
    addExtern<DAS_BIND_FUN(glfwDestroyCursor)>(module, lib, "glfwDestroyCursor",
        SideEffects::worstDefault, "glfwDestroyCursor");
    addExtern<DAS_BIND_FUN(glfwSetCursor)>(module, lib, "glfwSetCursor",
        SideEffects::worstDefault, "glfwSetCursor");
    addExtern<DAS_BIND_FUN(glfwJoystickPresent)>(module, lib, "glfwJoystickPresent",
        SideEffects::worstDefault, "glfwJoystickPresent");
    addExtern<DAS_BIND_FUN(glfwGetJoystickAxes)>(module, lib, "glfwGetJoystickAxes",
        SideEffects::worstDefault, "glfwGetJoystickAxes");
    addExtern<DAS_BIND_FUN(glfwGetJoystickButtons)>(module, lib, "glfwGetJoystickButtons",
        SideEffects::worstDefault, "glfwGetJoystickButtons");
    addExtern<DAS_BIND_FUN(glfwGetJoystickHats)>(module, lib, "glfwGetJoystickHats",
        SideEffects::worstDefault, "glfwGetJoystickHats");
    addExtern<DAS_BIND_FUN(glfwGetJoystickName)>(module, lib, "glfwGetJoystickName",
        SideEffects::worstDefault, "glfwGetJoystickName");
    addExtern<DAS_BIND_FUN(glfwGetJoystickGUID)>(module, lib, "glfwGetJoystickGUID",
        SideEffects::worstDefault, "glfwGetJoystickGUID");
    addExtern<DAS_BIND_FUN(glfwSetJoystickUserPointer)>(module, lib, "glfwSetJoystickUserPointer",
        SideEffects::worstDefault, "glfwSetJoystickUserPointer");
    addExtern<DAS_BIND_FUN(glfwGetJoystickUserPointer)>(module, lib, "glfwGetJoystickUserPointer",
        SideEffects::worstDefault, "glfwGetJoystickUserPointer");
    addExtern<DAS_BIND_FUN(glfwJoystickIsGamepad)>(module, lib, "glfwJoystickIsGamepad",
        SideEffects::worstDefault, "glfwJoystickIsGamepad");

    //
    // macro constants
    //

    addConstant(module, "VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_fragment_density_map", 1);
    addConstant(module, "VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_scalar_block_layout", 1);
    addConstant(module, "VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION", 1);
    addConstant(module, "VK_GOOGLE_hlsl_functionality1", 1);
    addConstant(module, "VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION", 1);
    addConstant(module, "VK_GOOGLE_decorate_string", 1);
    addConstant(module, "VK_GOOGLE_DECORATE_STRING_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_subgroup_size_control", 1);
    addConstant(module, "VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_shader_core_properties2", 1);
    addConstant(module, "VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_device_coherent_memory", 1);
    addConstant(module, "VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_shader_image_atomic_int64", 1);
    addConstant(module, "VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_memory_budget", 1);
    addConstant(module, "VK_EXT_MEMORY_BUDGET_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_memory_priority", 1);
    addConstant(module, "VK_EXT_MEMORY_PRIORITY_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_dedicated_allocation_image_aliasing", 1);
    addConstant(module, "VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_buffer_device_address", 1);
    addConstant(module, "VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_tooling_info", 1);
    addConstant(module, "VK_EXT_TOOLING_INFO_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_separate_stencil_usage", 1);
    addConstant(module, "VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_validation_features", 1);
    addConstant(module, "VK_EXT_VALIDATION_FEATURES_SPEC_VERSION", 4);
    addConstant(module, "VK_NV_cooperative_matrix", 1);
    addConstant(module, "VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_coverage_reduction_mode", 1);
    addConstant(module, "VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_fragment_shader_interlock", 1);
    addConstant(module, "VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_ycbcr_image_arrays", 1);
    addConstant(module, "VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_headless_surface", 1);
    addConstant(module, "VK_EXT_HEADLESS_SURFACE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_line_rasterization", 1);
    addConstant(module, "VK_EXT_LINE_RASTERIZATION_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_shader_atomic_float", 1);
    addConstant(module, "VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION", 1);
};
