// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationCacheEXT, VkValidationCacheEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureNV, VkAccelerationStructureNV)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceConfigurationINTEL, VkPerformanceConfigurationINTEL)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMap)>("fragmentDensityMap");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDynamic)>("fragmentDensityMapDynamic");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapNonSubsampledImages)>("fragmentDensityMapNonSubsampledImages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapPropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentDensityTexelSize)>("minFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDensityTexelSize)>("maxFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityInvocations)>("fragmentDensityInvocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT);

struct VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassFragmentDensityMapCreateInfoEXT,true,true> {
    VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassFragmentDensityMapCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapAttachment)>("fragmentDensityMapAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSizeControl)>("subgroupSizeControl");
        addField<DAS_BIND_MANAGED_FIELD(computeFullSubgroups)>("computeFullSubgroups");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minSubgroupSize)>("minSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxSubgroupSize)>("maxSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkgroupSubgroups)>("maxComputeWorkgroupSubgroups");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSizeStages)>("requiredSubgroupSizeStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT,true,true> {
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSize)>("requiredSubgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCoreProperties2AMD);

struct VkPhysicalDeviceShaderCoreProperties2AMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCoreProperties2AMD,true,true> {
    VkPhysicalDeviceShaderCoreProperties2AMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCoreProperties2AMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderCoreFeatures)>("shaderCoreFeatures");
        addField<DAS_BIND_MANAGED_FIELD(activeComputeUnitCount)>("activeComputeUnitCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceCoherentMemoryFeaturesAMD);

struct VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoherentMemoryFeaturesAMD,true,true> {
    VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoherentMemoryFeaturesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceCoherentMemory)>("deviceCoherentMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);

struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,true,true> {
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageInt64Atomics)>("shaderImageInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageInt64Atomics)>("sparseImageInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);

struct VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryBudgetPropertiesEXT,true,true> {
    VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryBudgetPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(heapBudget)>("heapBudget");
        addField<DAS_BIND_MANAGED_FIELD(heapUsage)>("heapUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);

struct VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryPriorityFeaturesEXT,true,true> {
    VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryPriorityFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryPriority)>("memoryPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryPriorityAllocateInfoEXT, VkMemoryPriorityAllocateInfoEXT);

struct VkMemoryPriorityAllocateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryPriorityAllocateInfoEXT,true,true> {
    VkMemoryPriorityAllocateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryPriorityAllocateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(priority)>("priority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,true,true> {
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocationImageAliasing)>("dedicatedAllocationImageAliasing");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressCreateInfoEXT);

struct VkBufferDeviceAddressCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressCreateInfoEXT,true,true> {
    VkBufferDeviceAddressCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceToolPropertiesEXT, VkPhysicalDeviceToolPropertiesEXT);

struct VkPhysicalDeviceToolPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceToolPropertiesEXT,true,true> {
    VkPhysicalDeviceToolPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceToolPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(version)>("version");
        addField<DAS_BIND_MANAGED_FIELD(purposes)>("purposes");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFeaturesEXT, VkValidationFeaturesEXT);

struct VkValidationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFeaturesEXT,true,true> {
    VkValidationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(enabledValidationFeatureCount)>("enabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledValidationFeatures)>("pEnabledValidationFeatures");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationFeatureCount)>("disabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationFeatures)>("pDisabledValidationFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCooperativeMatrixPropertiesNV, VkCooperativeMatrixPropertiesNV);

struct VkCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkCooperativeMatrixPropertiesNV,true,true> {
    VkCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(MSize)>("MSize");
        addField<DAS_BIND_MANAGED_FIELD(NSize)>("NSize");
        addField<DAS_BIND_MANAGED_FIELD(KSize)>("KSize");
        addField<DAS_BIND_MANAGED_FIELD(AType)>("AType");
        addField<DAS_BIND_MANAGED_FIELD(BType)>("BType");
        addField<DAS_BIND_MANAGED_FIELD(CType)>("CType");
        addField<DAS_BIND_MANAGED_FIELD(DType)>("DType");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixFeaturesNV);

struct VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixFeaturesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrix)>("cooperativeMatrix");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixRobustBufferAccess)>("cooperativeMatrixRobustBufferAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV);

struct VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixPropertiesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixSupportedStages)>("cooperativeMatrixSupportedStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV);

struct VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoverageReductionModeFeaturesNV,true,true> {
    VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoverageReductionModeFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageReductionStateCreateInfoNV, VkPipelineCoverageReductionStateCreateInfoNV);

struct VkPipelineCoverageReductionStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageReductionStateCreateInfoNV,true,true> {
    VkPipelineCoverageReductionStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageReductionStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferMixedSamplesCombinationNV, VkFramebufferMixedSamplesCombinationNV);

struct VkFramebufferMixedSamplesCombinationNVAnnotation
: public ManagedStructureAnnotation<VkFramebufferMixedSamplesCombinationNV,true,true> {
    VkFramebufferMixedSamplesCombinationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferMixedSamplesCombinationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(depthStencilSamples)>("depthStencilSamples");
        addField<DAS_BIND_MANAGED_FIELD(colorSamples)>("colorSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderSampleInterlock)>("fragmentShaderSampleInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderPixelInterlock)>("fragmentShaderPixelInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderShadingRateInterlock)>("fragmentShaderShadingRateInterlock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,true,true> {
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrImageArrays)>("ycbcrImageArrays");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkHeadlessSurfaceCreateInfoEXT, VkHeadlessSurfaceCreateInfoEXT);

struct VkHeadlessSurfaceCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkHeadlessSurfaceCreateInfoEXT,true,true> {
    VkHeadlessSurfaceCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHeadlessSurfaceCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);

struct VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationFeaturesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rectangularLines)>("rectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(bresenhamLines)>("bresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(smoothLines)>("smoothLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledRectangularLines)>("stippledRectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledBresenhamLines)>("stippledBresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledSmoothLines)>("stippledSmoothLines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);

struct VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineSubPixelPrecisionBits)>("lineSubPixelPrecisionBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationLineStateCreateInfoEXT, VkPipelineRasterizationLineStateCreateInfoEXT);

struct VkPipelineRasterizationLineStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationLineStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationLineStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationLineStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineRasterizationMode)>("lineRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(stippledLineEnable)>("stippledLineEnable");
        addField<DAS_BIND_MANAGED_FIELD(lineStippleFactor)>("lineStippleFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineStipplePattern)>("lineStipplePattern");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);

struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32Atomics)>("shaderBufferFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32AtomicAdd)>("shaderBufferFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64Atomics)>("shaderBufferFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64AtomicAdd)>("shaderBufferFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32Atomics)>("shaderSharedFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32AtomicAdd)>("shaderSharedFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64Atomics)>("shaderSharedFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64AtomicAdd)>("shaderSharedFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32Atomics)>("shaderImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32AtomicAdd)>("shaderImageFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32Atomics)>("sparseImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32AtomicAdd)>("sparseImageFloat32AtomicAdd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIndexTypeUint8FeaturesEXT,true,true> {
    VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIndexTypeUint8FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeUint8)>("indexTypeUint8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);

struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,true,true> {
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(extendedDynamicState)>("extendedDynamicState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);

struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDemoteToHelperInvocation)>("shaderDemoteToHelperInvocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGraphicsShaderGroupCount)>("maxGraphicsShaderGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectSequenceCount)>("maxIndirectSequenceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenCount)>("maxIndirectCommandsTokenCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamCount)>("maxIndirectCommandsStreamCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenOffset)>("maxIndirectCommandsTokenOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamStride)>("maxIndirectCommandsStreamStride");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesCountBufferOffsetAlignment)>("minSequencesCountBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesIndexBufferOffsetAlignment)>("minSequencesIndexBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minIndirectCommandsBufferOffsetAlignment)>("minIndirectCommandsBufferOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_13(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkGeometryInstanceFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkQueueGlobalPriorityEXT>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCompilerControlFlagBitsAMD>());
    module.addEnumeration(make_smart<EnumerationVkTimeDomainEXT>());
    module.addEnumeration(make_smart<EnumerationVkMemoryOverallocationBehaviorAMD>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCreationFeedbackFlagBitsEXT>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceConfigurationTypeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkQueryPoolSamplingModeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceOverrideTypeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceParameterTypeINTEL>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkValidationCacheEXT>>("VkValidationCacheEXT", "VkValidationCacheEXT"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureNV>>("VkAccelerationStructureNV", "VkAccelerationStructureNV"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPerformanceConfigurationINTEL>>("VkPerformanceConfigurationINTEL", "VkPerformanceConfigurationINTEL"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderCoreProperties2AMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryPriorityAllocateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferDeviceAddressCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceToolPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkValidationFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkCooperativeMatrixPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCoverageReductionStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferMixedSamplesCombinationNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkHeadlessSurfaceCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationLineStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(glfwShowWindow)>(module, lib, "glfwShowWindow",
        SideEffects::worstDefault, "glfwShowWindow");
    addExtern<DAS_BIND_FUN(glfwHideWindow)>(module, lib, "glfwHideWindow",
        SideEffects::worstDefault, "glfwHideWindow");
    addExtern<DAS_BIND_FUN(glfwFocusWindow)>(module, lib, "glfwFocusWindow",
        SideEffects::worstDefault, "glfwFocusWindow");
    addExtern<DAS_BIND_FUN(glfwRequestWindowAttention)>(module, lib, "glfwRequestWindowAttention",
        SideEffects::worstDefault, "glfwRequestWindowAttention");
    addExtern<DAS_BIND_FUN(glfwGetWindowMonitor)>(module, lib, "glfwGetWindowMonitor",
        SideEffects::worstDefault, "glfwGetWindowMonitor");
    addExtern<DAS_BIND_FUN(glfwSetWindowMonitor)>(module, lib, "glfwSetWindowMonitor",
        SideEffects::worstDefault, "glfwSetWindowMonitor");
    addExtern<DAS_BIND_FUN(glfwGetWindowAttrib)>(module, lib, "glfwGetWindowAttrib",
        SideEffects::worstDefault, "glfwGetWindowAttrib");
    addExtern<DAS_BIND_FUN(glfwSetWindowAttrib)>(module, lib, "glfwSetWindowAttrib",
        SideEffects::worstDefault, "glfwSetWindowAttrib");
    addExtern<DAS_BIND_FUN(glfwGetWindowUserPointer)>(module, lib, "glfwGetWindowUserPointer",
        SideEffects::worstDefault, "glfwGetWindowUserPointer");
    addExtern<DAS_BIND_FUN(glfwPollEvents)>(module, lib, "glfwPollEvents",
        SideEffects::worstDefault, "glfwPollEvents");
    addExtern<DAS_BIND_FUN(glfwWaitEvents)>(module, lib, "glfwWaitEvents",
        SideEffects::worstDefault, "glfwWaitEvents");
    addExtern<DAS_BIND_FUN(glfwWaitEventsTimeout)>(module, lib, "glfwWaitEventsTimeout",
        SideEffects::worstDefault, "glfwWaitEventsTimeout");
    addExtern<DAS_BIND_FUN(glfwPostEmptyEvent)>(module, lib, "glfwPostEmptyEvent",
        SideEffects::worstDefault, "glfwPostEmptyEvent");
    addExtern<DAS_BIND_FUN(glfwGetInputMode)>(module, lib, "glfwGetInputMode",
        SideEffects::worstDefault, "glfwGetInputMode");
    addExtern<DAS_BIND_FUN(glfwSetInputMode)>(module, lib, "glfwSetInputMode",
        SideEffects::worstDefault, "glfwSetInputMode");
    addExtern<DAS_BIND_FUN(glfwRawMouseMotionSupported)>(module, lib, "glfwRawMouseMotionSupported",
        SideEffects::worstDefault, "glfwRawMouseMotionSupported");
    addExtern<DAS_BIND_FUN(glfwGetKeyName)>(module, lib, "glfwGetKeyName",
        SideEffects::worstDefault, "glfwGetKeyName");

    //
    // macro constants
    //

    addConstant(module, "VK_NV_representative_fragment_test", 1);
    addConstant(module, "VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_filter_cubic", 1);
    addConstant(module, "VK_EXT_FILTER_CUBIC_SPEC_VERSION", 3);
    addConstant(module, "VK_QCOM_render_pass_shader_resolve", 1);
    addConstant(module, "VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION", 4);
    addConstant(module, "VK_EXT_global_priority", 1);
    addConstant(module, "VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_external_memory_host", 1);
    addConstant(module, "VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_buffer_marker", 1);
    addConstant(module, "VK_AMD_BUFFER_MARKER_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_pipeline_compiler_control", 1);
    addConstant(module, "VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_calibrated_timestamps", 1);
    addConstant(module, "VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_core_properties", 1);
    addConstant(module, "VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_memory_overallocation_behavior", 1);
    addConstant(module, "VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_vertex_attribute_divisor", 1);
    addConstant(module, "VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION", 3);
    addConstant(module, "VK_EXT_pipeline_creation_feedback", 1);
    addConstant(module, "VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_shader_subgroup_partitioned", 1);
    addConstant(module, "VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_compute_shader_derivatives", 1);
    addConstant(module, "VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_mesh_shader", 1);
    addConstant(module, "VK_NV_MESH_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_fragment_shader_barycentric", 1);
    addConstant(module, "VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_shader_image_footprint", 1);
    addConstant(module, "VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION", 2);
    addConstant(module, "VK_NV_scissor_exclusive", 1);
    addConstant(module, "VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_device_diagnostic_checkpoints", 1);
    addConstant(module, "VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION", 2);
    addConstant(module, "VK_INTEL_shader_integer_functions2", 1);
    addConstant(module, "VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION", 1);
    addConstant(module, "VK_INTEL_performance_query", 1);
    addConstant(module, "VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_pci_bus_info", 1);
    addConstant(module, "VK_EXT_PCI_BUS_INFO_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_display_native_hdr", 1);
};
