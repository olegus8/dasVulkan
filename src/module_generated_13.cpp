// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugReportCallbackEXT, VkDebugReportCallbackEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerEXT, VkDebugUtilsMessengerEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationCacheEXT, VkValidationCacheEXT)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);

struct VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePCIBusInfoPropertiesEXT,true,true> {
    VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePCIBusInfoPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pciDomain)>("pciDomain");
        addField<DAS_BIND_MANAGED_FIELD(pciBus)>("pciBus");
        addField<DAS_BIND_MANAGED_FIELD(pciDevice)>("pciDevice");
        addField<DAS_BIND_MANAGED_FIELD(pciFunction)>("pciFunction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayNativeHdrSurfaceCapabilitiesAMD);

struct VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation
: public ManagedStructureAnnotation<VkDisplayNativeHdrSurfaceCapabilitiesAMD,true,true> {
    VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayNativeHdrSurfaceCapabilitiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingSupport)>("localDimmingSupport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainDisplayNativeHdrCreateInfoAMD);

struct VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkSwapchainDisplayNativeHdrCreateInfoAMD,true,true> {
    VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainDisplayNativeHdrCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingEnable)>("localDimmingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMap)>("fragmentDensityMap");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDynamic)>("fragmentDensityMapDynamic");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapNonSubsampledImages)>("fragmentDensityMapNonSubsampledImages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapPropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentDensityTexelSize)>("minFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDensityTexelSize)>("maxFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityInvocations)>("fragmentDensityInvocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT);

struct VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassFragmentDensityMapCreateInfoEXT,true,true> {
    VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassFragmentDensityMapCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapAttachment)>("fragmentDensityMapAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSizeControl)>("subgroupSizeControl");
        addField<DAS_BIND_MANAGED_FIELD(computeFullSubgroups)>("computeFullSubgroups");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minSubgroupSize)>("minSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxSubgroupSize)>("maxSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkgroupSubgroups)>("maxComputeWorkgroupSubgroups");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSizeStages)>("requiredSubgroupSizeStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT,true,true> {
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSize)>("requiredSubgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCoreProperties2AMD);

struct VkPhysicalDeviceShaderCoreProperties2AMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCoreProperties2AMD,true,true> {
    VkPhysicalDeviceShaderCoreProperties2AMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCoreProperties2AMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderCoreFeatures)>("shaderCoreFeatures");
        addField<DAS_BIND_MANAGED_FIELD(activeComputeUnitCount)>("activeComputeUnitCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceCoherentMemoryFeaturesAMD);

struct VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoherentMemoryFeaturesAMD,true,true> {
    VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoherentMemoryFeaturesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceCoherentMemory)>("deviceCoherentMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);

struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,true,true> {
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageInt64Atomics)>("shaderImageInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageInt64Atomics)>("sparseImageInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);

struct VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryBudgetPropertiesEXT,true,true> {
    VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryBudgetPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(heapBudget)>("heapBudget");
        addField<DAS_BIND_MANAGED_FIELD(heapUsage)>("heapUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);

struct VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryPriorityFeaturesEXT,true,true> {
    VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryPriorityFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryPriority)>("memoryPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryPriorityAllocateInfoEXT, VkMemoryPriorityAllocateInfoEXT);

struct VkMemoryPriorityAllocateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryPriorityAllocateInfoEXT,true,true> {
    VkMemoryPriorityAllocateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryPriorityAllocateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(priority)>("priority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,true,true> {
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocationImageAliasing)>("dedicatedAllocationImageAliasing");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressCreateInfoEXT);

struct VkBufferDeviceAddressCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressCreateInfoEXT,true,true> {
    VkBufferDeviceAddressCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceToolPropertiesEXT, VkPhysicalDeviceToolPropertiesEXT);

struct VkPhysicalDeviceToolPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceToolPropertiesEXT,true,true> {
    VkPhysicalDeviceToolPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceToolPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(version)>("version");
        addField<DAS_BIND_MANAGED_FIELD(purposes)>("purposes");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFeaturesEXT, VkValidationFeaturesEXT);

struct VkValidationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFeaturesEXT,true,true> {
    VkValidationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(enabledValidationFeatureCount)>("enabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledValidationFeatures)>("pEnabledValidationFeatures");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationFeatureCount)>("disabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationFeatures)>("pDisabledValidationFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCooperativeMatrixPropertiesNV, VkCooperativeMatrixPropertiesNV);

struct VkCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkCooperativeMatrixPropertiesNV,true,true> {
    VkCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(MSize)>("MSize");
        addField<DAS_BIND_MANAGED_FIELD(NSize)>("NSize");
        addField<DAS_BIND_MANAGED_FIELD(KSize)>("KSize");
        addField<DAS_BIND_MANAGED_FIELD(AType)>("AType");
        addField<DAS_BIND_MANAGED_FIELD(BType)>("BType");
        addField<DAS_BIND_MANAGED_FIELD(CType)>("CType");
        addField<DAS_BIND_MANAGED_FIELD(DType)>("DType");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixFeaturesNV);

struct VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixFeaturesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrix)>("cooperativeMatrix");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixRobustBufferAccess)>("cooperativeMatrixRobustBufferAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV);

struct VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixPropertiesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixSupportedStages)>("cooperativeMatrixSupportedStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV);

struct VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoverageReductionModeFeaturesNV,true,true> {
    VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoverageReductionModeFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageReductionStateCreateInfoNV, VkPipelineCoverageReductionStateCreateInfoNV);

struct VkPipelineCoverageReductionStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageReductionStateCreateInfoNV,true,true> {
    VkPipelineCoverageReductionStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageReductionStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferMixedSamplesCombinationNV, VkFramebufferMixedSamplesCombinationNV);

struct VkFramebufferMixedSamplesCombinationNVAnnotation
: public ManagedStructureAnnotation<VkFramebufferMixedSamplesCombinationNV,true,true> {
    VkFramebufferMixedSamplesCombinationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferMixedSamplesCombinationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(depthStencilSamples)>("depthStencilSamples");
        addField<DAS_BIND_MANAGED_FIELD(colorSamples)>("colorSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderSampleInterlock)>("fragmentShaderSampleInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderPixelInterlock)>("fragmentShaderPixelInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderShadingRateInterlock)>("fragmentShaderShadingRateInterlock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,true,true> {
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrImageArrays)>("ycbcrImageArrays");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkHeadlessSurfaceCreateInfoEXT, VkHeadlessSurfaceCreateInfoEXT);

struct VkHeadlessSurfaceCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkHeadlessSurfaceCreateInfoEXT,true,true> {
    VkHeadlessSurfaceCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHeadlessSurfaceCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);

struct VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationFeaturesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rectangularLines)>("rectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(bresenhamLines)>("bresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(smoothLines)>("smoothLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledRectangularLines)>("stippledRectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledBresenhamLines)>("stippledBresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledSmoothLines)>("stippledSmoothLines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);

struct VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineSubPixelPrecisionBits)>("lineSubPixelPrecisionBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationLineStateCreateInfoEXT, VkPipelineRasterizationLineStateCreateInfoEXT);

struct VkPipelineRasterizationLineStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationLineStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationLineStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationLineStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineRasterizationMode)>("lineRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(stippledLineEnable)>("stippledLineEnable");
        addField<DAS_BIND_MANAGED_FIELD(lineStippleFactor)>("lineStippleFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineStipplePattern)>("lineStipplePattern");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);

struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32Atomics)>("shaderBufferFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32AtomicAdd)>("shaderBufferFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64Atomics)>("shaderBufferFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64AtomicAdd)>("shaderBufferFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32Atomics)>("shaderSharedFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32AtomicAdd)>("shaderSharedFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64Atomics)>("shaderSharedFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64AtomicAdd)>("shaderSharedFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32Atomics)>("shaderImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32AtomicAdd)>("shaderImageFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32Atomics)>("sparseImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32AtomicAdd)>("sparseImageFloat32AtomicAdd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIndexTypeUint8FeaturesEXT,true,true> {
    VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIndexTypeUint8FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeUint8)>("indexTypeUint8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_13(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkGeometryInstanceFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureFlagBitsKHR>());
    module.addEnumeration(make_smart<EnumerationVkQueueGlobalPriorityEXT>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCompilerControlFlagBitsAMD>());
    module.addEnumeration(make_smart<EnumerationVkTimeDomainEXT>());
    module.addEnumeration(make_smart<EnumerationVkMemoryOverallocationBehaviorAMD>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCreationFeedbackFlagBitsEXT>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceConfigurationTypeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkQueryPoolSamplingModeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceOverrideTypeINTEL>());
    module.addEnumeration(make_smart<EnumerationVkPerformanceParameterTypeINTEL>());
}

void addVulkanGeneratedOpaqueStructs_13(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDebugReportCallbackEXT>>("VkDebugReportCallbackEXT", "VkDebugReportCallbackEXT"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkDebugUtilsMessengerEXT>>("VkDebugUtilsMessengerEXT", "VkDebugUtilsMessengerEXT"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkValidationCacheEXT>>("VkValidationCacheEXT", "VkValidationCacheEXT"));
}

void addVulkanGeneratedStructs_13(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderCoreProperties2AMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryPriorityAllocateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferDeviceAddressCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceToolPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkValidationFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkCooperativeMatrixPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineCoverageReductionStateCreateInfoNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferMixedSamplesCombinationNVAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkHeadlessSurfaceCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineRasterizationLineStateCreateInfoEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation>(lib));
}

void addVulkanGeneratedFunctions_13(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkTrimCommandPool)>(module, lib, "vkTrimCommandPool",
        SideEffects::worstDefault, "vkTrimCommandPool");
    addExtern<DAS_BIND_FUN(vkGetDeviceQueue2)>(module, lib, "vkGetDeviceQueue2",
        SideEffects::worstDefault, "vkGetDeviceQueue2");
    addExtern<DAS_BIND_FUN(vkCreateSamplerYcbcrConversion)>(module, lib, "vkCreateSamplerYcbcrConversion",
        SideEffects::worstDefault, "vkCreateSamplerYcbcrConversion");
    addExtern<DAS_BIND_FUN(vkDestroySamplerYcbcrConversion)>(module, lib, "vkDestroySamplerYcbcrConversion",
        SideEffects::worstDefault, "vkDestroySamplerYcbcrConversion");
    addExtern<DAS_BIND_FUN(vkCreateDescriptorUpdateTemplate)>(module, lib, "vkCreateDescriptorUpdateTemplate",
        SideEffects::worstDefault, "vkCreateDescriptorUpdateTemplate");
    addExtern<DAS_BIND_FUN(vkDestroyDescriptorUpdateTemplate)>(module, lib, "vkDestroyDescriptorUpdateTemplate",
        SideEffects::worstDefault, "vkDestroyDescriptorUpdateTemplate");
    addExtern<DAS_BIND_FUN(vkUpdateDescriptorSetWithTemplate)>(module, lib, "vkUpdateDescriptorSetWithTemplate",
        SideEffects::worstDefault, "vkUpdateDescriptorSetWithTemplate");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalBufferProperties)>(module, lib, "vkGetPhysicalDeviceExternalBufferProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalBufferProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalFenceProperties)>(module, lib, "vkGetPhysicalDeviceExternalFenceProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalFenceProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalSemaphoreProperties)>(module, lib, "vkGetPhysicalDeviceExternalSemaphoreProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceExternalSemaphoreProperties");
    addExtern<DAS_BIND_FUN(vkGetDescriptorSetLayoutSupport)>(module, lib, "vkGetDescriptorSetLayoutSupport",
        SideEffects::worstDefault, "vkGetDescriptorSetLayoutSupport");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndirectCount)>(module, lib, "vkCmdDrawIndirectCount",
        SideEffects::worstDefault, "vkCmdDrawIndirectCount");
}

void addVulkanGeneratedConsts_13(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_EXT_subgroup_size_control", 1);
    addConstant(module, "VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_shader_core_properties2", 1);
    addConstant(module, "VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_device_coherent_memory", 1);
    addConstant(module, "VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_shader_image_atomic_int64", 1);
    addConstant(module, "VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_memory_budget", 1);
    addConstant(module, "VK_EXT_MEMORY_BUDGET_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_memory_priority", 1);
    addConstant(module, "VK_EXT_MEMORY_PRIORITY_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_dedicated_allocation_image_aliasing", 1);
    addConstant(module, "VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_buffer_device_address", 1);
    addConstant(module, "VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION", 2);
    addConstant(module, "VK_EXT_tooling_info", 1);
    addConstant(module, "VK_EXT_TOOLING_INFO_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_separate_stencil_usage", 1);
    addConstant(module, "VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_validation_features", 1);
    addConstant(module, "VK_EXT_VALIDATION_FEATURES_SPEC_VERSION", 4);
    addConstant(module, "VK_NV_cooperative_matrix", 1);
    addConstant(module, "VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_coverage_reduction_mode", 1);
    addConstant(module, "VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_fragment_shader_interlock", 1);
}
