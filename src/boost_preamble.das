// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_view(
    var boost_struct : auto(BOOST_T);
    b : block<(vk_struct : auto(VK_T))>
)
    var vk_struct : VK_T
    unsafe
        vk_struct <- boost_struct |> vk_view_create_unsafe()
    b |> invoke(vk_view)
    boost_struct |> vk_view_destroy()

def boost_value_to_vk(b : auto(T)) : T
    return b

def vk_value_to_boost(v : auto(T)) : T
    return v

def vk_value_to_boost(v : int8[]) : string
    unsafe
        let s := reinterpret<string>(addr(v[0]))
        return s

def array_addr_unsafe(var ar : array<auto(T)>) : T?
    unsafe
        return length(ar) > 0 ? addr(ar[0]) : [[T ?]]

def addr_unsafe(v)
    unsafe
        return addr(v)

//
// Device
//

def finalize(var device : Device)
    let vk_device = boost_value_to_vk(device)
    vk_device |> vkDeviceWaitIdle()
    vk_device |> vkDestroyDevice(null)
    memzero(device)

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def boost_value_to_vk(b : SurfaceKHR) : VkSurfaceKHR
    return b.surface_khr

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)
