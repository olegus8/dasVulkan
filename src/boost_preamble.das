// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_p_view(
    p_boost_struct : auto(BOOST_T)?;
    b : block<(p_vk_struct : auto(VK_T)?)>
)
    if p_boost_struct == null
        b |> invoke([[VK_T?]])
    else
        *p_boost_struct |> with_view() <| $(vk_struct)
            unsafe
                b |> invoke(addr(vk_struct))

def boost_value_to_vk(b : auto(T)) : T
    return b

def vk_value_to_boost(v : auto(T)) : T
    return v

def vk_value_to_boost(v : int8[]) : string
    unsafe
        let s := reinterpret<string>(addr(v[0]))
        return s

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def boost_value_to_vk(b : SurfaceKHR) : VkSurfaceKHR
    return b.surface_khr

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)
