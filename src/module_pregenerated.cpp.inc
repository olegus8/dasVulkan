// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162

//
// enums
//

namespace das
{
    template <> struct cast < VkResult > : cast_enum < VkResult > {};
};

class EnumerationVkResult : public das::Enumeration {
public:
    EnumerationVkResult() : das::Enumeration("VkResult") {
        external = true;
        cppName = "VkResult";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkResult >::type >::type;
        VkResult enumArray[] = {
            VkResult::VK_SUCCESS,
            VkResult::VK_NOT_READY,
            VkResult::VK_TIMEOUT,
            VkResult::VK_EVENT_SET,
            VkResult::VK_EVENT_RESET,
            VkResult::VK_INCOMPLETE,
            VkResult::VK_ERROR_OUT_OF_HOST_MEMORY,
            VkResult::VK_ERROR_OUT_OF_DEVICE_MEMORY,
            VkResult::VK_ERROR_INITIALIZATION_FAILED,
            VkResult::VK_ERROR_DEVICE_LOST,
            VkResult::VK_ERROR_MEMORY_MAP_FAILED,
            VkResult::VK_ERROR_LAYER_NOT_PRESENT,
            VkResult::VK_ERROR_EXTENSION_NOT_PRESENT,
            VkResult::VK_ERROR_FEATURE_NOT_PRESENT,
            VkResult::VK_ERROR_INCOMPATIBLE_DRIVER,
            VkResult::VK_ERROR_TOO_MANY_OBJECTS,
            VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED,
            VkResult::VK_ERROR_FRAGMENTED_POOL,
            VkResult::VK_ERROR_UNKNOWN,
            VkResult::VK_ERROR_OUT_OF_POOL_MEMORY,
            VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE,
            VkResult::VK_ERROR_FRAGMENTATION,
            VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
            VkResult::VK_ERROR_SURFACE_LOST_KHR,
            VkResult::VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
            VkResult::VK_SUBOPTIMAL_KHR,
            VkResult::VK_ERROR_OUT_OF_DATE_KHR,
            VkResult::VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
            VkResult::VK_ERROR_VALIDATION_FAILED_EXT,
            VkResult::VK_ERROR_INVALID_SHADER_NV,
            VkResult::VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
            VkResult::VK_ERROR_NOT_PERMITTED_EXT,
            VkResult::VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
            VkResult::VK_THREAD_IDLE_KHR,
            VkResult::VK_THREAD_DONE_KHR,
            VkResult::VK_OPERATION_DEFERRED_KHR,
            VkResult::VK_OPERATION_NOT_DEFERRED_KHR,
            VkResult::VK_PIPELINE_COMPILE_REQUIRED_EXT,
            VkResult::VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
            VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
            VkResult::VK_ERROR_FRAGMENTATION_EXT,
            VkResult::VK_ERROR_INVALID_DEVICE_ADDRESS_EXT,
            VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,
            VkResult::VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT,
            VkResult::VK_RESULT_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SUCCESS",
            "VK_NOT_READY",
            "VK_TIMEOUT",
            "VK_EVENT_SET",
            "VK_EVENT_RESET",
            "VK_INCOMPLETE",
            "VK_ERROR_OUT_OF_HOST_MEMORY",
            "VK_ERROR_OUT_OF_DEVICE_MEMORY",
            "VK_ERROR_INITIALIZATION_FAILED",
            "VK_ERROR_DEVICE_LOST",
            "VK_ERROR_MEMORY_MAP_FAILED",
            "VK_ERROR_LAYER_NOT_PRESENT",
            "VK_ERROR_EXTENSION_NOT_PRESENT",
            "VK_ERROR_FEATURE_NOT_PRESENT",
            "VK_ERROR_INCOMPATIBLE_DRIVER",
            "VK_ERROR_TOO_MANY_OBJECTS",
            "VK_ERROR_FORMAT_NOT_SUPPORTED",
            "VK_ERROR_FRAGMENTED_POOL",
            "VK_ERROR_UNKNOWN",
            "VK_ERROR_OUT_OF_POOL_MEMORY",
            "VK_ERROR_INVALID_EXTERNAL_HANDLE",
            "VK_ERROR_FRAGMENTATION",
            "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS",
            "VK_ERROR_SURFACE_LOST_KHR",
            "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
            "VK_SUBOPTIMAL_KHR",
            "VK_ERROR_OUT_OF_DATE_KHR",
            "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
            "VK_ERROR_VALIDATION_FAILED_EXT",
            "VK_ERROR_INVALID_SHADER_NV",
            "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT",
            "VK_ERROR_NOT_PERMITTED_EXT",
            "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT",
            "VK_THREAD_IDLE_KHR",
            "VK_THREAD_DONE_KHR",
            "VK_OPERATION_DEFERRED_KHR",
            "VK_OPERATION_NOT_DEFERRED_KHR",
            "VK_PIPELINE_COMPILE_REQUIRED_EXT",
            "VK_ERROR_OUT_OF_POOL_MEMORY_KHR",
            "VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR",
            "VK_ERROR_FRAGMENTATION_EXT",
            "VK_ERROR_INVALID_DEVICE_ADDRESS_EXT",
            "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR",
            "VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT",
            "VK_RESULT_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 45; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkResult > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkResult");
        }
    };
}
namespace das
{
    template <> struct cast < VkStructureType > : cast_enum < VkStructureType > {};
};

class EnumerationVkStructureType : public das::Enumeration {
public:
    EnumerationVkStructureType() : das::Enumeration("VkStructureType") {
        external = true;
        cppName = "VkStructureType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkStructureType >::type >::type;
        VkStructureType enumArray[] = {
            VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_BARRIER,
            VkStructureType::VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
            VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
            VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
            VkStructureType::VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
            VkStructureType::VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
            VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
            VkStructureType::VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
            VkStructureType::VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR,
            VkStructureType::VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
            VkStructureType::VK_STRUCTURE_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_STRUCTURE_TYPE_APPLICATION_INFO",
            "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_SUBMIT_INFO",
            "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE",
            "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO",
            "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO",
            "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO",
            "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO",
            "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO",
            "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO",
            "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO",
            "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET",
            "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO",
            "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO",
            "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO",
            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO",
            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER",
            "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER",
            "VK_STRUCTURE_TYPE_MEMORY_BARRIER",
            "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
            "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
            "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS",
            "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO",
            "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
            "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
            "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2",
            "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2",
            "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
            "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
            "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
            "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
            "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO",
            "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
            "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
            "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES",
            "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
            "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
            "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES",
            "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
            "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
            "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO",
            "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2",
            "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2",
            "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2",
            "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2",
            "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2",
            "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_SUBPASS_END_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
            "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
            "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
            "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
            "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
            "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
            "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
            "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO",
            "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO",
            "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO",
            "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
            "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO",
            "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
            "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
            "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
            "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
            "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR",
            "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD",
            "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX",
            "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD",
            "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV",
            "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV",
            "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV",
            "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV",
            "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV",
            "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT",
            "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR",
            "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT",
            "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT",
            "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT",
            "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT",
            "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_HDR_METADATA_EXT",
            "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR",
            "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR",
            "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR",
            "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR",
            "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR",
            "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
            "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK",
            "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK",
            "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT",
            "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID",
            "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID",
            "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID",
            "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID",
            "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID",
            "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT",
            "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR",
            "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR",
            "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR",
            "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_GEOMETRY_NV",
            "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV",
            "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV",
            "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV",
            "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT",
            "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT",
            "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD",
            "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD",
            "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP",
            "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV",
            "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV",
            "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL",
            "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL",
            "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD",
            "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD",
            "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV",
            "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT",
            "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT",
            "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT",
            "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV",
            "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV",
            "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM",
            "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV",
            "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV",
            "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR",
            "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES",
            "VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR",
            "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR",
            "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR",
            "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR",
            "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR",
            "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR",
            "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR",
            "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR",
            "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR",
            "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR",
            "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR",
            "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR",
            "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR",
            "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR",
            "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR",
            "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR",
            "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR",
            "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT",
            "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR",
            "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR",
            "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR",
            "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR",
            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT",
            "VK_STRUCTURE_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 586; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkStructureType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkStructureType");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageLayout > : cast_enum < VkImageLayout > {};
};

class EnumerationVkImageLayout : public das::Enumeration {
public:
    EnumerationVkImageLayout() : das::Enumeration("VkImageLayout") {
        external = true;
        cppName = "VkImageLayout";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageLayout >::type >::type;
        VkImageLayout enumArray[] = {
            VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED,
            VkImageLayout::VK_IMAGE_LAYOUT_GENERAL,
            VkImageLayout::VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_PREINITIALIZED,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
            VkImageLayout::VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV,
            VkImageLayout::VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR,
            VkImageLayout::VK_IMAGE_LAYOUT_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_LAYOUT_UNDEFINED",
            "VK_IMAGE_LAYOUT_GENERAL",
            "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL",
            "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL",
            "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL",
            "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL",
            "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL",
            "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL",
            "VK_IMAGE_LAYOUT_PREINITIALIZED",
            "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
            "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
            "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL",
            "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL",
            "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL",
            "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL",
            "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR",
            "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR",
            "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV",
            "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT",
            "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR",
            "VK_IMAGE_LAYOUT_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 27; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageLayout > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageLayout");
        }
    };
}
namespace das
{
    template <> struct cast < VkObjectType > : cast_enum < VkObjectType > {};
};

class EnumerationVkObjectType : public das::Enumeration {
public:
    EnumerationVkObjectType() : das::Enumeration("VkObjectType") {
        external = true;
        cppName = "VkObjectType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkObjectType >::type >::type;
        VkObjectType enumArray[] = {
            VkObjectType::VK_OBJECT_TYPE_UNKNOWN,
            VkObjectType::VK_OBJECT_TYPE_INSTANCE,
            VkObjectType::VK_OBJECT_TYPE_PHYSICAL_DEVICE,
            VkObjectType::VK_OBJECT_TYPE_DEVICE,
            VkObjectType::VK_OBJECT_TYPE_QUEUE,
            VkObjectType::VK_OBJECT_TYPE_SEMAPHORE,
            VkObjectType::VK_OBJECT_TYPE_COMMAND_BUFFER,
            VkObjectType::VK_OBJECT_TYPE_FENCE,
            VkObjectType::VK_OBJECT_TYPE_DEVICE_MEMORY,
            VkObjectType::VK_OBJECT_TYPE_BUFFER,
            VkObjectType::VK_OBJECT_TYPE_IMAGE,
            VkObjectType::VK_OBJECT_TYPE_EVENT,
            VkObjectType::VK_OBJECT_TYPE_QUERY_POOL,
            VkObjectType::VK_OBJECT_TYPE_BUFFER_VIEW,
            VkObjectType::VK_OBJECT_TYPE_IMAGE_VIEW,
            VkObjectType::VK_OBJECT_TYPE_SHADER_MODULE,
            VkObjectType::VK_OBJECT_TYPE_PIPELINE_CACHE,
            VkObjectType::VK_OBJECT_TYPE_PIPELINE_LAYOUT,
            VkObjectType::VK_OBJECT_TYPE_RENDER_PASS,
            VkObjectType::VK_OBJECT_TYPE_PIPELINE,
            VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
            VkObjectType::VK_OBJECT_TYPE_SAMPLER,
            VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_POOL,
            VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_SET,
            VkObjectType::VK_OBJECT_TYPE_FRAMEBUFFER,
            VkObjectType::VK_OBJECT_TYPE_COMMAND_POOL,
            VkObjectType::VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
            VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
            VkObjectType::VK_OBJECT_TYPE_SURFACE_KHR,
            VkObjectType::VK_OBJECT_TYPE_SWAPCHAIN_KHR,
            VkObjectType::VK_OBJECT_TYPE_DISPLAY_KHR,
            VkObjectType::VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
            VkObjectType::VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
            VkObjectType::VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
            VkObjectType::VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR,
            VkObjectType::VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
            VkObjectType::VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV,
            VkObjectType::VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
            VkObjectType::VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR,
            VkObjectType::VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV,
            VkObjectType::VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT,
            VkObjectType::VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
            VkObjectType::VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
            VkObjectType::VK_OBJECT_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_OBJECT_TYPE_UNKNOWN",
            "VK_OBJECT_TYPE_INSTANCE",
            "VK_OBJECT_TYPE_PHYSICAL_DEVICE",
            "VK_OBJECT_TYPE_DEVICE",
            "VK_OBJECT_TYPE_QUEUE",
            "VK_OBJECT_TYPE_SEMAPHORE",
            "VK_OBJECT_TYPE_COMMAND_BUFFER",
            "VK_OBJECT_TYPE_FENCE",
            "VK_OBJECT_TYPE_DEVICE_MEMORY",
            "VK_OBJECT_TYPE_BUFFER",
            "VK_OBJECT_TYPE_IMAGE",
            "VK_OBJECT_TYPE_EVENT",
            "VK_OBJECT_TYPE_QUERY_POOL",
            "VK_OBJECT_TYPE_BUFFER_VIEW",
            "VK_OBJECT_TYPE_IMAGE_VIEW",
            "VK_OBJECT_TYPE_SHADER_MODULE",
            "VK_OBJECT_TYPE_PIPELINE_CACHE",
            "VK_OBJECT_TYPE_PIPELINE_LAYOUT",
            "VK_OBJECT_TYPE_RENDER_PASS",
            "VK_OBJECT_TYPE_PIPELINE",
            "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT",
            "VK_OBJECT_TYPE_SAMPLER",
            "VK_OBJECT_TYPE_DESCRIPTOR_POOL",
            "VK_OBJECT_TYPE_DESCRIPTOR_SET",
            "VK_OBJECT_TYPE_FRAMEBUFFER",
            "VK_OBJECT_TYPE_COMMAND_POOL",
            "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION",
            "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE",
            "VK_OBJECT_TYPE_SURFACE_KHR",
            "VK_OBJECT_TYPE_SWAPCHAIN_KHR",
            "VK_OBJECT_TYPE_DISPLAY_KHR",
            "VK_OBJECT_TYPE_DISPLAY_MODE_KHR",
            "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT",
            "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT",
            "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR",
            "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT",
            "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV",
            "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL",
            "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR",
            "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV",
            "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT",
            "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR",
            "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR",
            "VK_OBJECT_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 44; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkObjectType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkObjectType");
        }
    };
}
namespace das
{
    template <> struct cast < VkVendorId > : cast_enum < VkVendorId > {};
};

class EnumerationVkVendorId : public das::Enumeration {
public:
    EnumerationVkVendorId() : das::Enumeration("VkVendorId") {
        external = true;
        cppName = "VkVendorId";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkVendorId >::type >::type;
        VkVendorId enumArray[] = {
            VkVendorId::VK_VENDOR_ID_VIV,
            VkVendorId::VK_VENDOR_ID_VSI,
            VkVendorId::VK_VENDOR_ID_KAZAN,
            VkVendorId::VK_VENDOR_ID_CODEPLAY,
            VkVendorId::VK_VENDOR_ID_MESA,
            VkVendorId::VK_VENDOR_ID_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_VENDOR_ID_VIV",
            "VK_VENDOR_ID_VSI",
            "VK_VENDOR_ID_KAZAN",
            "VK_VENDOR_ID_CODEPLAY",
            "VK_VENDOR_ID_MESA",
            "VK_VENDOR_ID_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkVendorId > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkVendorId");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineCacheHeaderVersion > : cast_enum < VkPipelineCacheHeaderVersion > {};
};

class EnumerationVkPipelineCacheHeaderVersion : public das::Enumeration {
public:
    EnumerationVkPipelineCacheHeaderVersion() : das::Enumeration("VkPipelineCacheHeaderVersion") {
        external = true;
        cppName = "VkPipelineCacheHeaderVersion";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineCacheHeaderVersion >::type >::type;
        VkPipelineCacheHeaderVersion enumArray[] = {
            VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
            VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_CACHE_HEADER_VERSION_ONE",
            "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineCacheHeaderVersion > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineCacheHeaderVersion");
        }
    };
}
namespace das
{
    template <> struct cast < VkSystemAllocationScope > : cast_enum < VkSystemAllocationScope > {};
};

class EnumerationVkSystemAllocationScope : public das::Enumeration {
public:
    EnumerationVkSystemAllocationScope() : das::Enumeration("VkSystemAllocationScope") {
        external = true;
        cppName = "VkSystemAllocationScope";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSystemAllocationScope >::type >::type;
        VkSystemAllocationScope enumArray[] = {
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
            VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND",
            "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT",
            "VK_SYSTEM_ALLOCATION_SCOPE_CACHE",
            "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE",
            "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE",
            "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSystemAllocationScope > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSystemAllocationScope");
        }
    };
}
namespace das
{
    template <> struct cast < VkInternalAllocationType > : cast_enum < VkInternalAllocationType > {};
};

class EnumerationVkInternalAllocationType : public das::Enumeration {
public:
    EnumerationVkInternalAllocationType() : das::Enumeration("VkInternalAllocationType") {
        external = true;
        cppName = "VkInternalAllocationType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkInternalAllocationType >::type >::type;
        VkInternalAllocationType enumArray[] = {
            VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
            VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE",
            "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkInternalAllocationType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkInternalAllocationType");
        }
    };
}
namespace das
{
    template <> struct cast < VkFormat > : cast_enum < VkFormat > {};
};

class EnumerationVkFormat : public das::Enumeration {
public:
    EnumerationVkFormat() : das::Enumeration("VkFormat") {
        external = true;
        cppName = "VkFormat";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFormat >::type >::type;
        VkFormat enumArray[] = {
            VkFormat::VK_FORMAT_UNDEFINED,
            VkFormat::VK_FORMAT_R4G4_UNORM_PACK8,
            VkFormat::VK_FORMAT_R4G4B4A4_UNORM_PACK16,
            VkFormat::VK_FORMAT_B4G4R4A4_UNORM_PACK16,
            VkFormat::VK_FORMAT_R5G6B5_UNORM_PACK16,
            VkFormat::VK_FORMAT_B5G6R5_UNORM_PACK16,
            VkFormat::VK_FORMAT_R5G5B5A1_UNORM_PACK16,
            VkFormat::VK_FORMAT_B5G5R5A1_UNORM_PACK16,
            VkFormat::VK_FORMAT_A1R5G5B5_UNORM_PACK16,
            VkFormat::VK_FORMAT_R8_UNORM,
            VkFormat::VK_FORMAT_R8_SNORM,
            VkFormat::VK_FORMAT_R8_USCALED,
            VkFormat::VK_FORMAT_R8_SSCALED,
            VkFormat::VK_FORMAT_R8_UINT,
            VkFormat::VK_FORMAT_R8_SINT,
            VkFormat::VK_FORMAT_R8_SRGB,
            VkFormat::VK_FORMAT_R8G8_UNORM,
            VkFormat::VK_FORMAT_R8G8_SNORM,
            VkFormat::VK_FORMAT_R8G8_USCALED,
            VkFormat::VK_FORMAT_R8G8_SSCALED,
            VkFormat::VK_FORMAT_R8G8_UINT,
            VkFormat::VK_FORMAT_R8G8_SINT,
            VkFormat::VK_FORMAT_R8G8_SRGB,
            VkFormat::VK_FORMAT_R8G8B8_UNORM,
            VkFormat::VK_FORMAT_R8G8B8_SNORM,
            VkFormat::VK_FORMAT_R8G8B8_USCALED,
            VkFormat::VK_FORMAT_R8G8B8_SSCALED,
            VkFormat::VK_FORMAT_R8G8B8_UINT,
            VkFormat::VK_FORMAT_R8G8B8_SINT,
            VkFormat::VK_FORMAT_R8G8B8_SRGB,
            VkFormat::VK_FORMAT_B8G8R8_UNORM,
            VkFormat::VK_FORMAT_B8G8R8_SNORM,
            VkFormat::VK_FORMAT_B8G8R8_USCALED,
            VkFormat::VK_FORMAT_B8G8R8_SSCALED,
            VkFormat::VK_FORMAT_B8G8R8_UINT,
            VkFormat::VK_FORMAT_B8G8R8_SINT,
            VkFormat::VK_FORMAT_B8G8R8_SRGB,
            VkFormat::VK_FORMAT_R8G8B8A8_UNORM,
            VkFormat::VK_FORMAT_R8G8B8A8_SNORM,
            VkFormat::VK_FORMAT_R8G8B8A8_USCALED,
            VkFormat::VK_FORMAT_R8G8B8A8_SSCALED,
            VkFormat::VK_FORMAT_R8G8B8A8_UINT,
            VkFormat::VK_FORMAT_R8G8B8A8_SINT,
            VkFormat::VK_FORMAT_R8G8B8A8_SRGB,
            VkFormat::VK_FORMAT_B8G8R8A8_UNORM,
            VkFormat::VK_FORMAT_B8G8R8A8_SNORM,
            VkFormat::VK_FORMAT_B8G8R8A8_USCALED,
            VkFormat::VK_FORMAT_B8G8R8A8_SSCALED,
            VkFormat::VK_FORMAT_B8G8R8A8_UINT,
            VkFormat::VK_FORMAT_B8G8R8A8_SINT,
            VkFormat::VK_FORMAT_B8G8R8A8_SRGB,
            VkFormat::VK_FORMAT_A8B8G8R8_UNORM_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_SNORM_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_USCALED_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_UINT_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_SINT_PACK32,
            VkFormat::VK_FORMAT_A8B8G8R8_SRGB_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_UNORM_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_SNORM_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_USCALED_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_UINT_PACK32,
            VkFormat::VK_FORMAT_A2R10G10B10_SINT_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_UNORM_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_SNORM_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_USCALED_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_UINT_PACK32,
            VkFormat::VK_FORMAT_A2B10G10R10_SINT_PACK32,
            VkFormat::VK_FORMAT_R16_UNORM,
            VkFormat::VK_FORMAT_R16_SNORM,
            VkFormat::VK_FORMAT_R16_USCALED,
            VkFormat::VK_FORMAT_R16_SSCALED,
            VkFormat::VK_FORMAT_R16_UINT,
            VkFormat::VK_FORMAT_R16_SINT,
            VkFormat::VK_FORMAT_R16_SFLOAT,
            VkFormat::VK_FORMAT_R16G16_UNORM,
            VkFormat::VK_FORMAT_R16G16_SNORM,
            VkFormat::VK_FORMAT_R16G16_USCALED,
            VkFormat::VK_FORMAT_R16G16_SSCALED,
            VkFormat::VK_FORMAT_R16G16_UINT,
            VkFormat::VK_FORMAT_R16G16_SINT,
            VkFormat::VK_FORMAT_R16G16_SFLOAT,
            VkFormat::VK_FORMAT_R16G16B16_UNORM,
            VkFormat::VK_FORMAT_R16G16B16_SNORM,
            VkFormat::VK_FORMAT_R16G16B16_USCALED,
            VkFormat::VK_FORMAT_R16G16B16_SSCALED,
            VkFormat::VK_FORMAT_R16G16B16_UINT,
            VkFormat::VK_FORMAT_R16G16B16_SINT,
            VkFormat::VK_FORMAT_R16G16B16_SFLOAT,
            VkFormat::VK_FORMAT_R16G16B16A16_UNORM,
            VkFormat::VK_FORMAT_R16G16B16A16_SNORM,
            VkFormat::VK_FORMAT_R16G16B16A16_USCALED,
            VkFormat::VK_FORMAT_R16G16B16A16_SSCALED,
            VkFormat::VK_FORMAT_R16G16B16A16_UINT,
            VkFormat::VK_FORMAT_R16G16B16A16_SINT,
            VkFormat::VK_FORMAT_R16G16B16A16_SFLOAT,
            VkFormat::VK_FORMAT_R32_UINT,
            VkFormat::VK_FORMAT_R32_SINT,
            VkFormat::VK_FORMAT_R32_SFLOAT,
            VkFormat::VK_FORMAT_R32G32_UINT,
            VkFormat::VK_FORMAT_R32G32_SINT,
            VkFormat::VK_FORMAT_R32G32_SFLOAT,
            VkFormat::VK_FORMAT_R32G32B32_UINT,
            VkFormat::VK_FORMAT_R32G32B32_SINT,
            VkFormat::VK_FORMAT_R32G32B32_SFLOAT,
            VkFormat::VK_FORMAT_R32G32B32A32_UINT,
            VkFormat::VK_FORMAT_R32G32B32A32_SINT,
            VkFormat::VK_FORMAT_R32G32B32A32_SFLOAT,
            VkFormat::VK_FORMAT_R64_UINT,
            VkFormat::VK_FORMAT_R64_SINT,
            VkFormat::VK_FORMAT_R64_SFLOAT,
            VkFormat::VK_FORMAT_R64G64_UINT,
            VkFormat::VK_FORMAT_R64G64_SINT,
            VkFormat::VK_FORMAT_R64G64_SFLOAT,
            VkFormat::VK_FORMAT_R64G64B64_UINT,
            VkFormat::VK_FORMAT_R64G64B64_SINT,
            VkFormat::VK_FORMAT_R64G64B64_SFLOAT,
            VkFormat::VK_FORMAT_R64G64B64A64_UINT,
            VkFormat::VK_FORMAT_R64G64B64A64_SINT,
            VkFormat::VK_FORMAT_R64G64B64A64_SFLOAT,
            VkFormat::VK_FORMAT_B10G11R11_UFLOAT_PACK32,
            VkFormat::VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
            VkFormat::VK_FORMAT_D16_UNORM,
            VkFormat::VK_FORMAT_X8_D24_UNORM_PACK32,
            VkFormat::VK_FORMAT_D32_SFLOAT,
            VkFormat::VK_FORMAT_S8_UINT,
            VkFormat::VK_FORMAT_D16_UNORM_S8_UINT,
            VkFormat::VK_FORMAT_D24_UNORM_S8_UINT,
            VkFormat::VK_FORMAT_D32_SFLOAT_S8_UINT,
            VkFormat::VK_FORMAT_BC1_RGB_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC1_RGB_SRGB_BLOCK,
            VkFormat::VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
            VkFormat::VK_FORMAT_BC2_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC2_SRGB_BLOCK,
            VkFormat::VK_FORMAT_BC3_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC3_SRGB_BLOCK,
            VkFormat::VK_FORMAT_BC4_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC4_SNORM_BLOCK,
            VkFormat::VK_FORMAT_BC5_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC5_SNORM_BLOCK,
            VkFormat::VK_FORMAT_BC6H_UFLOAT_BLOCK,
            VkFormat::VK_FORMAT_BC6H_SFLOAT_BLOCK,
            VkFormat::VK_FORMAT_BC7_UNORM_BLOCK,
            VkFormat::VK_FORMAT_BC7_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
            VkFormat::VK_FORMAT_EAC_R11_UNORM_BLOCK,
            VkFormat::VK_FORMAT_EAC_R11_SNORM_BLOCK,
            VkFormat::VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
            VkFormat::VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
            VkFormat::VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
            VkFormat::VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
            VkFormat::VK_FORMAT_G8B8G8R8_422_UNORM,
            VkFormat::VK_FORMAT_B8G8R8G8_422_UNORM,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
            VkFormat::VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
            VkFormat::VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
            VkFormat::VK_FORMAT_R10X6_UNORM_PACK16,
            VkFormat::VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
            VkFormat::VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
            VkFormat::VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
            VkFormat::VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
            VkFormat::VK_FORMAT_R12X4_UNORM_PACK16,
            VkFormat::VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
            VkFormat::VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
            VkFormat::VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
            VkFormat::VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
            VkFormat::VK_FORMAT_G16B16G16R16_422_UNORM,
            VkFormat::VK_FORMAT_B16G16R16G16_422_UNORM,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
            VkFormat::VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
            VkFormat::VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
            VkFormat::VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
            VkFormat::VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
            VkFormat::VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT,
            VkFormat::VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT,
            VkFormat::VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT,
            VkFormat::VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
            VkFormat::VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
            VkFormat::VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
            VkFormat::VK_FORMAT_R10X6_UNORM_PACK16_KHR,
            VkFormat::VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
            VkFormat::VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_R12X4_UNORM_PACK16_KHR,
            VkFormat::VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
            VkFormat::VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
            VkFormat::VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
            VkFormat::VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
            VkFormat::VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
            VkFormat::VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
            VkFormat::VK_FORMAT_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FORMAT_UNDEFINED",
            "VK_FORMAT_R4G4_UNORM_PACK8",
            "VK_FORMAT_R4G4B4A4_UNORM_PACK16",
            "VK_FORMAT_B4G4R4A4_UNORM_PACK16",
            "VK_FORMAT_R5G6B5_UNORM_PACK16",
            "VK_FORMAT_B5G6R5_UNORM_PACK16",
            "VK_FORMAT_R5G5B5A1_UNORM_PACK16",
            "VK_FORMAT_B5G5R5A1_UNORM_PACK16",
            "VK_FORMAT_A1R5G5B5_UNORM_PACK16",
            "VK_FORMAT_R8_UNORM",
            "VK_FORMAT_R8_SNORM",
            "VK_FORMAT_R8_USCALED",
            "VK_FORMAT_R8_SSCALED",
            "VK_FORMAT_R8_UINT",
            "VK_FORMAT_R8_SINT",
            "VK_FORMAT_R8_SRGB",
            "VK_FORMAT_R8G8_UNORM",
            "VK_FORMAT_R8G8_SNORM",
            "VK_FORMAT_R8G8_USCALED",
            "VK_FORMAT_R8G8_SSCALED",
            "VK_FORMAT_R8G8_UINT",
            "VK_FORMAT_R8G8_SINT",
            "VK_FORMAT_R8G8_SRGB",
            "VK_FORMAT_R8G8B8_UNORM",
            "VK_FORMAT_R8G8B8_SNORM",
            "VK_FORMAT_R8G8B8_USCALED",
            "VK_FORMAT_R8G8B8_SSCALED",
            "VK_FORMAT_R8G8B8_UINT",
            "VK_FORMAT_R8G8B8_SINT",
            "VK_FORMAT_R8G8B8_SRGB",
            "VK_FORMAT_B8G8R8_UNORM",
            "VK_FORMAT_B8G8R8_SNORM",
            "VK_FORMAT_B8G8R8_USCALED",
            "VK_FORMAT_B8G8R8_SSCALED",
            "VK_FORMAT_B8G8R8_UINT",
            "VK_FORMAT_B8G8R8_SINT",
            "VK_FORMAT_B8G8R8_SRGB",
            "VK_FORMAT_R8G8B8A8_UNORM",
            "VK_FORMAT_R8G8B8A8_SNORM",
            "VK_FORMAT_R8G8B8A8_USCALED",
            "VK_FORMAT_R8G8B8A8_SSCALED",
            "VK_FORMAT_R8G8B8A8_UINT",
            "VK_FORMAT_R8G8B8A8_SINT",
            "VK_FORMAT_R8G8B8A8_SRGB",
            "VK_FORMAT_B8G8R8A8_UNORM",
            "VK_FORMAT_B8G8R8A8_SNORM",
            "VK_FORMAT_B8G8R8A8_USCALED",
            "VK_FORMAT_B8G8R8A8_SSCALED",
            "VK_FORMAT_B8G8R8A8_UINT",
            "VK_FORMAT_B8G8R8A8_SINT",
            "VK_FORMAT_B8G8R8A8_SRGB",
            "VK_FORMAT_A8B8G8R8_UNORM_PACK32",
            "VK_FORMAT_A8B8G8R8_SNORM_PACK32",
            "VK_FORMAT_A8B8G8R8_USCALED_PACK32",
            "VK_FORMAT_A8B8G8R8_SSCALED_PACK32",
            "VK_FORMAT_A8B8G8R8_UINT_PACK32",
            "VK_FORMAT_A8B8G8R8_SINT_PACK32",
            "VK_FORMAT_A8B8G8R8_SRGB_PACK32",
            "VK_FORMAT_A2R10G10B10_UNORM_PACK32",
            "VK_FORMAT_A2R10G10B10_SNORM_PACK32",
            "VK_FORMAT_A2R10G10B10_USCALED_PACK32",
            "VK_FORMAT_A2R10G10B10_SSCALED_PACK32",
            "VK_FORMAT_A2R10G10B10_UINT_PACK32",
            "VK_FORMAT_A2R10G10B10_SINT_PACK32",
            "VK_FORMAT_A2B10G10R10_UNORM_PACK32",
            "VK_FORMAT_A2B10G10R10_SNORM_PACK32",
            "VK_FORMAT_A2B10G10R10_USCALED_PACK32",
            "VK_FORMAT_A2B10G10R10_SSCALED_PACK32",
            "VK_FORMAT_A2B10G10R10_UINT_PACK32",
            "VK_FORMAT_A2B10G10R10_SINT_PACK32",
            "VK_FORMAT_R16_UNORM",
            "VK_FORMAT_R16_SNORM",
            "VK_FORMAT_R16_USCALED",
            "VK_FORMAT_R16_SSCALED",
            "VK_FORMAT_R16_UINT",
            "VK_FORMAT_R16_SINT",
            "VK_FORMAT_R16_SFLOAT",
            "VK_FORMAT_R16G16_UNORM",
            "VK_FORMAT_R16G16_SNORM",
            "VK_FORMAT_R16G16_USCALED",
            "VK_FORMAT_R16G16_SSCALED",
            "VK_FORMAT_R16G16_UINT",
            "VK_FORMAT_R16G16_SINT",
            "VK_FORMAT_R16G16_SFLOAT",
            "VK_FORMAT_R16G16B16_UNORM",
            "VK_FORMAT_R16G16B16_SNORM",
            "VK_FORMAT_R16G16B16_USCALED",
            "VK_FORMAT_R16G16B16_SSCALED",
            "VK_FORMAT_R16G16B16_UINT",
            "VK_FORMAT_R16G16B16_SINT",
            "VK_FORMAT_R16G16B16_SFLOAT",
            "VK_FORMAT_R16G16B16A16_UNORM",
            "VK_FORMAT_R16G16B16A16_SNORM",
            "VK_FORMAT_R16G16B16A16_USCALED",
            "VK_FORMAT_R16G16B16A16_SSCALED",
            "VK_FORMAT_R16G16B16A16_UINT",
            "VK_FORMAT_R16G16B16A16_SINT",
            "VK_FORMAT_R16G16B16A16_SFLOAT",
            "VK_FORMAT_R32_UINT",
            "VK_FORMAT_R32_SINT",
            "VK_FORMAT_R32_SFLOAT",
            "VK_FORMAT_R32G32_UINT",
            "VK_FORMAT_R32G32_SINT",
            "VK_FORMAT_R32G32_SFLOAT",
            "VK_FORMAT_R32G32B32_UINT",
            "VK_FORMAT_R32G32B32_SINT",
            "VK_FORMAT_R32G32B32_SFLOAT",
            "VK_FORMAT_R32G32B32A32_UINT",
            "VK_FORMAT_R32G32B32A32_SINT",
            "VK_FORMAT_R32G32B32A32_SFLOAT",
            "VK_FORMAT_R64_UINT",
            "VK_FORMAT_R64_SINT",
            "VK_FORMAT_R64_SFLOAT",
            "VK_FORMAT_R64G64_UINT",
            "VK_FORMAT_R64G64_SINT",
            "VK_FORMAT_R64G64_SFLOAT",
            "VK_FORMAT_R64G64B64_UINT",
            "VK_FORMAT_R64G64B64_SINT",
            "VK_FORMAT_R64G64B64_SFLOAT",
            "VK_FORMAT_R64G64B64A64_UINT",
            "VK_FORMAT_R64G64B64A64_SINT",
            "VK_FORMAT_R64G64B64A64_SFLOAT",
            "VK_FORMAT_B10G11R11_UFLOAT_PACK32",
            "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32",
            "VK_FORMAT_D16_UNORM",
            "VK_FORMAT_X8_D24_UNORM_PACK32",
            "VK_FORMAT_D32_SFLOAT",
            "VK_FORMAT_S8_UINT",
            "VK_FORMAT_D16_UNORM_S8_UINT",
            "VK_FORMAT_D24_UNORM_S8_UINT",
            "VK_FORMAT_D32_SFLOAT_S8_UINT",
            "VK_FORMAT_BC1_RGB_UNORM_BLOCK",
            "VK_FORMAT_BC1_RGB_SRGB_BLOCK",
            "VK_FORMAT_BC1_RGBA_UNORM_BLOCK",
            "VK_FORMAT_BC1_RGBA_SRGB_BLOCK",
            "VK_FORMAT_BC2_UNORM_BLOCK",
            "VK_FORMAT_BC2_SRGB_BLOCK",
            "VK_FORMAT_BC3_UNORM_BLOCK",
            "VK_FORMAT_BC3_SRGB_BLOCK",
            "VK_FORMAT_BC4_UNORM_BLOCK",
            "VK_FORMAT_BC4_SNORM_BLOCK",
            "VK_FORMAT_BC5_UNORM_BLOCK",
            "VK_FORMAT_BC5_SNORM_BLOCK",
            "VK_FORMAT_BC6H_UFLOAT_BLOCK",
            "VK_FORMAT_BC6H_SFLOAT_BLOCK",
            "VK_FORMAT_BC7_UNORM_BLOCK",
            "VK_FORMAT_BC7_SRGB_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK",
            "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK",
            "VK_FORMAT_EAC_R11_UNORM_BLOCK",
            "VK_FORMAT_EAC_R11_SNORM_BLOCK",
            "VK_FORMAT_EAC_R11G11_UNORM_BLOCK",
            "VK_FORMAT_EAC_R11G11_SNORM_BLOCK",
            "VK_FORMAT_ASTC_4x4_UNORM_BLOCK",
            "VK_FORMAT_ASTC_4x4_SRGB_BLOCK",
            "VK_FORMAT_ASTC_5x4_UNORM_BLOCK",
            "VK_FORMAT_ASTC_5x4_SRGB_BLOCK",
            "VK_FORMAT_ASTC_5x5_UNORM_BLOCK",
            "VK_FORMAT_ASTC_5x5_SRGB_BLOCK",
            "VK_FORMAT_ASTC_6x5_UNORM_BLOCK",
            "VK_FORMAT_ASTC_6x5_SRGB_BLOCK",
            "VK_FORMAT_ASTC_6x6_UNORM_BLOCK",
            "VK_FORMAT_ASTC_6x6_SRGB_BLOCK",
            "VK_FORMAT_ASTC_8x5_UNORM_BLOCK",
            "VK_FORMAT_ASTC_8x5_SRGB_BLOCK",
            "VK_FORMAT_ASTC_8x6_UNORM_BLOCK",
            "VK_FORMAT_ASTC_8x6_SRGB_BLOCK",
            "VK_FORMAT_ASTC_8x8_UNORM_BLOCK",
            "VK_FORMAT_ASTC_8x8_SRGB_BLOCK",
            "VK_FORMAT_ASTC_10x5_UNORM_BLOCK",
            "VK_FORMAT_ASTC_10x5_SRGB_BLOCK",
            "VK_FORMAT_ASTC_10x6_UNORM_BLOCK",
            "VK_FORMAT_ASTC_10x6_SRGB_BLOCK",
            "VK_FORMAT_ASTC_10x8_UNORM_BLOCK",
            "VK_FORMAT_ASTC_10x8_SRGB_BLOCK",
            "VK_FORMAT_ASTC_10x10_UNORM_BLOCK",
            "VK_FORMAT_ASTC_10x10_SRGB_BLOCK",
            "VK_FORMAT_ASTC_12x10_UNORM_BLOCK",
            "VK_FORMAT_ASTC_12x10_SRGB_BLOCK",
            "VK_FORMAT_ASTC_12x12_UNORM_BLOCK",
            "VK_FORMAT_ASTC_12x12_SRGB_BLOCK",
            "VK_FORMAT_G8B8G8R8_422_UNORM",
            "VK_FORMAT_B8G8R8G8_422_UNORM",
            "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM",
            "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM",
            "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM",
            "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM",
            "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM",
            "VK_FORMAT_R10X6_UNORM_PACK16",
            "VK_FORMAT_R10X6G10X6_UNORM_2PACK16",
            "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16",
            "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16",
            "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
            "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
            "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
            "VK_FORMAT_R12X4_UNORM_PACK16",
            "VK_FORMAT_R12X4G12X4_UNORM_2PACK16",
            "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16",
            "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16",
            "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
            "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
            "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
            "VK_FORMAT_G16B16G16R16_422_UNORM",
            "VK_FORMAT_B16G16R16G16_422_UNORM",
            "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM",
            "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM",
            "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM",
            "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM",
            "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM",
            "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG",
            "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG",
            "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG",
            "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG",
            "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG",
            "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG",
            "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG",
            "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG",
            "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT",
            "VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT",
            "VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT",
            "VK_FORMAT_G8B8G8R8_422_UNORM_KHR",
            "VK_FORMAT_B8G8R8G8_422_UNORM_KHR",
            "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR",
            "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR",
            "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR",
            "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR",
            "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR",
            "VK_FORMAT_R10X6_UNORM_PACK16_KHR",
            "VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR",
            "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR",
            "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR",
            "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR",
            "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR",
            "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR",
            "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR",
            "VK_FORMAT_R12X4_UNORM_PACK16_KHR",
            "VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR",
            "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR",
            "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR",
            "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR",
            "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR",
            "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR",
            "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR",
            "VK_FORMAT_G16B16G16R16_422_UNORM_KHR",
            "VK_FORMAT_B16G16R16G16_422_UNORM_KHR",
            "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR",
            "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR",
            "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR",
            "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR",
            "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR",
            "VK_FORMAT_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 278; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFormat > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFormat");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageTiling > : cast_enum < VkImageTiling > {};
};

class EnumerationVkImageTiling : public das::Enumeration {
public:
    EnumerationVkImageTiling() : das::Enumeration("VkImageTiling") {
        external = true;
        cppName = "VkImageTiling";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageTiling >::type >::type;
        VkImageTiling enumArray[] = {
            VkImageTiling::VK_IMAGE_TILING_OPTIMAL,
            VkImageTiling::VK_IMAGE_TILING_LINEAR,
            VkImageTiling::VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
            VkImageTiling::VK_IMAGE_TILING_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_TILING_OPTIMAL",
            "VK_IMAGE_TILING_LINEAR",
            "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT",
            "VK_IMAGE_TILING_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageTiling > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageTiling");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageType > : cast_enum < VkImageType > {};
};

class EnumerationVkImageType : public das::Enumeration {
public:
    EnumerationVkImageType() : das::Enumeration("VkImageType") {
        external = true;
        cppName = "VkImageType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageType >::type >::type;
        VkImageType enumArray[] = {
            VkImageType::VK_IMAGE_TYPE_1D,
            VkImageType::VK_IMAGE_TYPE_2D,
            VkImageType::VK_IMAGE_TYPE_3D,
            VkImageType::VK_IMAGE_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_TYPE_1D",
            "VK_IMAGE_TYPE_2D",
            "VK_IMAGE_TYPE_3D",
            "VK_IMAGE_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageType");
        }
    };
}
namespace das
{
    template <> struct cast < VkPhysicalDeviceType > : cast_enum < VkPhysicalDeviceType > {};
};

class EnumerationVkPhysicalDeviceType : public das::Enumeration {
public:
    EnumerationVkPhysicalDeviceType() : das::Enumeration("VkPhysicalDeviceType") {
        external = true;
        cppName = "VkPhysicalDeviceType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPhysicalDeviceType >::type >::type;
        VkPhysicalDeviceType enumArray[] = {
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_OTHER,
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_CPU,
            VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PHYSICAL_DEVICE_TYPE_OTHER",
            "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU",
            "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU",
            "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU",
            "VK_PHYSICAL_DEVICE_TYPE_CPU",
            "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPhysicalDeviceType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPhysicalDeviceType");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueryType > : cast_enum < VkQueryType > {};
};

class EnumerationVkQueryType : public das::Enumeration {
public:
    EnumerationVkQueryType() : das::Enumeration("VkQueryType") {
        external = true;
        cppName = "VkQueryType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueryType >::type >::type;
        VkQueryType enumArray[] = {
            VkQueryType::VK_QUERY_TYPE_OCCLUSION,
            VkQueryType::VK_QUERY_TYPE_PIPELINE_STATISTICS,
            VkQueryType::VK_QUERY_TYPE_TIMESTAMP,
            VkQueryType::VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
            VkQueryType::VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR,
            VkQueryType::VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR,
            VkQueryType::VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR,
            VkQueryType::VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV,
            VkQueryType::VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
            VkQueryType::VK_QUERY_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_QUERY_TYPE_OCCLUSION",
            "VK_QUERY_TYPE_PIPELINE_STATISTICS",
            "VK_QUERY_TYPE_TIMESTAMP",
            "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT",
            "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR",
            "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR",
            "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR",
            "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV",
            "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL",
            "VK_QUERY_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 10; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueryType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueryType");
        }
    };
}
namespace das
{
    template <> struct cast < VkSharingMode > : cast_enum < VkSharingMode > {};
};

class EnumerationVkSharingMode : public das::Enumeration {
public:
    EnumerationVkSharingMode() : das::Enumeration("VkSharingMode") {
        external = true;
        cppName = "VkSharingMode";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSharingMode >::type >::type;
        VkSharingMode enumArray[] = {
            VkSharingMode::VK_SHARING_MODE_EXCLUSIVE,
            VkSharingMode::VK_SHARING_MODE_CONCURRENT,
            VkSharingMode::VK_SHARING_MODE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SHARING_MODE_EXCLUSIVE",
            "VK_SHARING_MODE_CONCURRENT",
            "VK_SHARING_MODE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSharingMode > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSharingMode");
        }
    };
}
namespace das
{
    template <> struct cast < VkComponentSwizzle > : cast_enum < VkComponentSwizzle > {};
};

class EnumerationVkComponentSwizzle : public das::Enumeration {
public:
    EnumerationVkComponentSwizzle() : das::Enumeration("VkComponentSwizzle") {
        external = true;
        cppName = "VkComponentSwizzle";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkComponentSwizzle >::type >::type;
        VkComponentSwizzle enumArray[] = {
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_ZERO,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_ONE,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_R,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_G,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_B,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A,
            VkComponentSwizzle::VK_COMPONENT_SWIZZLE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMPONENT_SWIZZLE_IDENTITY",
            "VK_COMPONENT_SWIZZLE_ZERO",
            "VK_COMPONENT_SWIZZLE_ONE",
            "VK_COMPONENT_SWIZZLE_R",
            "VK_COMPONENT_SWIZZLE_G",
            "VK_COMPONENT_SWIZZLE_B",
            "VK_COMPONENT_SWIZZLE_A",
            "VK_COMPONENT_SWIZZLE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkComponentSwizzle > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkComponentSwizzle");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageViewType > : cast_enum < VkImageViewType > {};
};

class EnumerationVkImageViewType : public das::Enumeration {
public:
    EnumerationVkImageViewType() : das::Enumeration("VkImageViewType") {
        external = true;
        cppName = "VkImageViewType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageViewType >::type >::type;
        VkImageViewType enumArray[] = {
            VkImageViewType::VK_IMAGE_VIEW_TYPE_1D,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_2D,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_3D,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_1D_ARRAY,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_2D_ARRAY,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
            VkImageViewType::VK_IMAGE_VIEW_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_VIEW_TYPE_1D",
            "VK_IMAGE_VIEW_TYPE_2D",
            "VK_IMAGE_VIEW_TYPE_3D",
            "VK_IMAGE_VIEW_TYPE_CUBE",
            "VK_IMAGE_VIEW_TYPE_1D_ARRAY",
            "VK_IMAGE_VIEW_TYPE_2D_ARRAY",
            "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY",
            "VK_IMAGE_VIEW_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageViewType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageViewType");
        }
    };
}
namespace das
{
    template <> struct cast < VkBlendFactor > : cast_enum < VkBlendFactor > {};
};

class EnumerationVkBlendFactor : public das::Enumeration {
public:
    EnumerationVkBlendFactor() : das::Enumeration("VkBlendFactor") {
        external = true;
        cppName = "VkBlendFactor";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBlendFactor >::type >::type;
        VkBlendFactor enumArray[] = {
            VkBlendFactor::VK_BLEND_FACTOR_ZERO,
            VkBlendFactor::VK_BLEND_FACTOR_ONE,
            VkBlendFactor::VK_BLEND_FACTOR_SRC_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_DST_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_SRC_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_DST_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_CONSTANT_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_CONSTANT_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
            VkBlendFactor::VK_BLEND_FACTOR_SRC1_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
            VkBlendFactor::VK_BLEND_FACTOR_SRC1_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
            VkBlendFactor::VK_BLEND_FACTOR_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_BLEND_FACTOR_ZERO",
            "VK_BLEND_FACTOR_ONE",
            "VK_BLEND_FACTOR_SRC_COLOR",
            "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR",
            "VK_BLEND_FACTOR_DST_COLOR",
            "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR",
            "VK_BLEND_FACTOR_SRC_ALPHA",
            "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA",
            "VK_BLEND_FACTOR_DST_ALPHA",
            "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA",
            "VK_BLEND_FACTOR_CONSTANT_COLOR",
            "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR",
            "VK_BLEND_FACTOR_CONSTANT_ALPHA",
            "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA",
            "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE",
            "VK_BLEND_FACTOR_SRC1_COLOR",
            "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR",
            "VK_BLEND_FACTOR_SRC1_ALPHA",
            "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA",
            "VK_BLEND_FACTOR_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 20; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBlendFactor > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBlendFactor");
        }
    };
}
namespace das
{
    template <> struct cast < VkBlendOp > : cast_enum < VkBlendOp > {};
};

class EnumerationVkBlendOp : public das::Enumeration {
public:
    EnumerationVkBlendOp() : das::Enumeration("VkBlendOp") {
        external = true;
        cppName = "VkBlendOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBlendOp >::type >::type;
        VkBlendOp enumArray[] = {
            VkBlendOp::VK_BLEND_OP_ADD,
            VkBlendOp::VK_BLEND_OP_SUBTRACT,
            VkBlendOp::VK_BLEND_OP_REVERSE_SUBTRACT,
            VkBlendOp::VK_BLEND_OP_MIN,
            VkBlendOp::VK_BLEND_OP_MAX,
            VkBlendOp::VK_BLEND_OP_ZERO_EXT,
            VkBlendOp::VK_BLEND_OP_SRC_EXT,
            VkBlendOp::VK_BLEND_OP_DST_EXT,
            VkBlendOp::VK_BLEND_OP_SRC_OVER_EXT,
            VkBlendOp::VK_BLEND_OP_DST_OVER_EXT,
            VkBlendOp::VK_BLEND_OP_SRC_IN_EXT,
            VkBlendOp::VK_BLEND_OP_DST_IN_EXT,
            VkBlendOp::VK_BLEND_OP_SRC_OUT_EXT,
            VkBlendOp::VK_BLEND_OP_DST_OUT_EXT,
            VkBlendOp::VK_BLEND_OP_SRC_ATOP_EXT,
            VkBlendOp::VK_BLEND_OP_DST_ATOP_EXT,
            VkBlendOp::VK_BLEND_OP_XOR_EXT,
            VkBlendOp::VK_BLEND_OP_MULTIPLY_EXT,
            VkBlendOp::VK_BLEND_OP_SCREEN_EXT,
            VkBlendOp::VK_BLEND_OP_OVERLAY_EXT,
            VkBlendOp::VK_BLEND_OP_DARKEN_EXT,
            VkBlendOp::VK_BLEND_OP_LIGHTEN_EXT,
            VkBlendOp::VK_BLEND_OP_COLORDODGE_EXT,
            VkBlendOp::VK_BLEND_OP_COLORBURN_EXT,
            VkBlendOp::VK_BLEND_OP_HARDLIGHT_EXT,
            VkBlendOp::VK_BLEND_OP_SOFTLIGHT_EXT,
            VkBlendOp::VK_BLEND_OP_DIFFERENCE_EXT,
            VkBlendOp::VK_BLEND_OP_EXCLUSION_EXT,
            VkBlendOp::VK_BLEND_OP_INVERT_EXT,
            VkBlendOp::VK_BLEND_OP_INVERT_RGB_EXT,
            VkBlendOp::VK_BLEND_OP_LINEARDODGE_EXT,
            VkBlendOp::VK_BLEND_OP_LINEARBURN_EXT,
            VkBlendOp::VK_BLEND_OP_VIVIDLIGHT_EXT,
            VkBlendOp::VK_BLEND_OP_LINEARLIGHT_EXT,
            VkBlendOp::VK_BLEND_OP_PINLIGHT_EXT,
            VkBlendOp::VK_BLEND_OP_HARDMIX_EXT,
            VkBlendOp::VK_BLEND_OP_HSL_HUE_EXT,
            VkBlendOp::VK_BLEND_OP_HSL_SATURATION_EXT,
            VkBlendOp::VK_BLEND_OP_HSL_COLOR_EXT,
            VkBlendOp::VK_BLEND_OP_HSL_LUMINOSITY_EXT,
            VkBlendOp::VK_BLEND_OP_PLUS_EXT,
            VkBlendOp::VK_BLEND_OP_PLUS_CLAMPED_EXT,
            VkBlendOp::VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
            VkBlendOp::VK_BLEND_OP_PLUS_DARKER_EXT,
            VkBlendOp::VK_BLEND_OP_MINUS_EXT,
            VkBlendOp::VK_BLEND_OP_MINUS_CLAMPED_EXT,
            VkBlendOp::VK_BLEND_OP_CONTRAST_EXT,
            VkBlendOp::VK_BLEND_OP_INVERT_OVG_EXT,
            VkBlendOp::VK_BLEND_OP_RED_EXT,
            VkBlendOp::VK_BLEND_OP_GREEN_EXT,
            VkBlendOp::VK_BLEND_OP_BLUE_EXT,
            VkBlendOp::VK_BLEND_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_BLEND_OP_ADD",
            "VK_BLEND_OP_SUBTRACT",
            "VK_BLEND_OP_REVERSE_SUBTRACT",
            "VK_BLEND_OP_MIN",
            "VK_BLEND_OP_MAX",
            "VK_BLEND_OP_ZERO_EXT",
            "VK_BLEND_OP_SRC_EXT",
            "VK_BLEND_OP_DST_EXT",
            "VK_BLEND_OP_SRC_OVER_EXT",
            "VK_BLEND_OP_DST_OVER_EXT",
            "VK_BLEND_OP_SRC_IN_EXT",
            "VK_BLEND_OP_DST_IN_EXT",
            "VK_BLEND_OP_SRC_OUT_EXT",
            "VK_BLEND_OP_DST_OUT_EXT",
            "VK_BLEND_OP_SRC_ATOP_EXT",
            "VK_BLEND_OP_DST_ATOP_EXT",
            "VK_BLEND_OP_XOR_EXT",
            "VK_BLEND_OP_MULTIPLY_EXT",
            "VK_BLEND_OP_SCREEN_EXT",
            "VK_BLEND_OP_OVERLAY_EXT",
            "VK_BLEND_OP_DARKEN_EXT",
            "VK_BLEND_OP_LIGHTEN_EXT",
            "VK_BLEND_OP_COLORDODGE_EXT",
            "VK_BLEND_OP_COLORBURN_EXT",
            "VK_BLEND_OP_HARDLIGHT_EXT",
            "VK_BLEND_OP_SOFTLIGHT_EXT",
            "VK_BLEND_OP_DIFFERENCE_EXT",
            "VK_BLEND_OP_EXCLUSION_EXT",
            "VK_BLEND_OP_INVERT_EXT",
            "VK_BLEND_OP_INVERT_RGB_EXT",
            "VK_BLEND_OP_LINEARDODGE_EXT",
            "VK_BLEND_OP_LINEARBURN_EXT",
            "VK_BLEND_OP_VIVIDLIGHT_EXT",
            "VK_BLEND_OP_LINEARLIGHT_EXT",
            "VK_BLEND_OP_PINLIGHT_EXT",
            "VK_BLEND_OP_HARDMIX_EXT",
            "VK_BLEND_OP_HSL_HUE_EXT",
            "VK_BLEND_OP_HSL_SATURATION_EXT",
            "VK_BLEND_OP_HSL_COLOR_EXT",
            "VK_BLEND_OP_HSL_LUMINOSITY_EXT",
            "VK_BLEND_OP_PLUS_EXT",
            "VK_BLEND_OP_PLUS_CLAMPED_EXT",
            "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT",
            "VK_BLEND_OP_PLUS_DARKER_EXT",
            "VK_BLEND_OP_MINUS_EXT",
            "VK_BLEND_OP_MINUS_CLAMPED_EXT",
            "VK_BLEND_OP_CONTRAST_EXT",
            "VK_BLEND_OP_INVERT_OVG_EXT",
            "VK_BLEND_OP_RED_EXT",
            "VK_BLEND_OP_GREEN_EXT",
            "VK_BLEND_OP_BLUE_EXT",
            "VK_BLEND_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 52; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBlendOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBlendOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkCompareOp > : cast_enum < VkCompareOp > {};
};

class EnumerationVkCompareOp : public das::Enumeration {
public:
    EnumerationVkCompareOp() : das::Enumeration("VkCompareOp") {
        external = true;
        cppName = "VkCompareOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCompareOp >::type >::type;
        VkCompareOp enumArray[] = {
            VkCompareOp::VK_COMPARE_OP_NEVER,
            VkCompareOp::VK_COMPARE_OP_LESS,
            VkCompareOp::VK_COMPARE_OP_EQUAL,
            VkCompareOp::VK_COMPARE_OP_LESS_OR_EQUAL,
            VkCompareOp::VK_COMPARE_OP_GREATER,
            VkCompareOp::VK_COMPARE_OP_NOT_EQUAL,
            VkCompareOp::VK_COMPARE_OP_GREATER_OR_EQUAL,
            VkCompareOp::VK_COMPARE_OP_ALWAYS,
            VkCompareOp::VK_COMPARE_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMPARE_OP_NEVER",
            "VK_COMPARE_OP_LESS",
            "VK_COMPARE_OP_EQUAL",
            "VK_COMPARE_OP_LESS_OR_EQUAL",
            "VK_COMPARE_OP_GREATER",
            "VK_COMPARE_OP_NOT_EQUAL",
            "VK_COMPARE_OP_GREATER_OR_EQUAL",
            "VK_COMPARE_OP_ALWAYS",
            "VK_COMPARE_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCompareOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCompareOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkDynamicState > : cast_enum < VkDynamicState > {};
};

class EnumerationVkDynamicState : public das::Enumeration {
public:
    EnumerationVkDynamicState() : das::Enumeration("VkDynamicState") {
        external = true;
        cppName = "VkDynamicState";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDynamicState >::type >::type;
        VkDynamicState enumArray[] = {
            VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT,
            VkDynamicState::VK_DYNAMIC_STATE_SCISSOR,
            VkDynamicState::VK_DYNAMIC_STATE_LINE_WIDTH,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BIAS,
            VkDynamicState::VK_DYNAMIC_STATE_BLEND_CONSTANTS,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BOUNDS,
            VkDynamicState::VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
            VkDynamicState::VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
            VkDynamicState::VK_DYNAMIC_STATE_STENCIL_REFERENCE,
            VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
            VkDynamicState::VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR,
            VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
            VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
            VkDynamicState::VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
            VkDynamicState::VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
            VkDynamicState::VK_DYNAMIC_STATE_LINE_STIPPLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_CULL_MODE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_FRONT_FACE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_STENCIL_OP_EXT,
            VkDynamicState::VK_DYNAMIC_STATE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DYNAMIC_STATE_VIEWPORT",
            "VK_DYNAMIC_STATE_SCISSOR",
            "VK_DYNAMIC_STATE_LINE_WIDTH",
            "VK_DYNAMIC_STATE_DEPTH_BIAS",
            "VK_DYNAMIC_STATE_BLEND_CONSTANTS",
            "VK_DYNAMIC_STATE_DEPTH_BOUNDS",
            "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK",
            "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK",
            "VK_DYNAMIC_STATE_STENCIL_REFERENCE",
            "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV",
            "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT",
            "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT",
            "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR",
            "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV",
            "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV",
            "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV",
            "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR",
            "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT",
            "VK_DYNAMIC_STATE_CULL_MODE_EXT",
            "VK_DYNAMIC_STATE_FRONT_FACE_EXT",
            "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT",
            "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT",
            "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT",
            "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT",
            "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT",
            "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT",
            "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT",
            "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT",
            "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT",
            "VK_DYNAMIC_STATE_STENCIL_OP_EXT",
            "VK_DYNAMIC_STATE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 31; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDynamicState > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDynamicState");
        }
    };
}
namespace das
{
    template <> struct cast < VkFrontFace > : cast_enum < VkFrontFace > {};
};

class EnumerationVkFrontFace : public das::Enumeration {
public:
    EnumerationVkFrontFace() : das::Enumeration("VkFrontFace") {
        external = true;
        cppName = "VkFrontFace";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFrontFace >::type >::type;
        VkFrontFace enumArray[] = {
            VkFrontFace::VK_FRONT_FACE_COUNTER_CLOCKWISE,
            VkFrontFace::VK_FRONT_FACE_CLOCKWISE,
            VkFrontFace::VK_FRONT_FACE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FRONT_FACE_COUNTER_CLOCKWISE",
            "VK_FRONT_FACE_CLOCKWISE",
            "VK_FRONT_FACE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFrontFace > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFrontFace");
        }
    };
}
namespace das
{
    template <> struct cast < VkVertexInputRate > : cast_enum < VkVertexInputRate > {};
};

class EnumerationVkVertexInputRate : public das::Enumeration {
public:
    EnumerationVkVertexInputRate() : das::Enumeration("VkVertexInputRate") {
        external = true;
        cppName = "VkVertexInputRate";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkVertexInputRate >::type >::type;
        VkVertexInputRate enumArray[] = {
            VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX,
            VkVertexInputRate::VK_VERTEX_INPUT_RATE_INSTANCE,
            VkVertexInputRate::VK_VERTEX_INPUT_RATE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_VERTEX_INPUT_RATE_VERTEX",
            "VK_VERTEX_INPUT_RATE_INSTANCE",
            "VK_VERTEX_INPUT_RATE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkVertexInputRate > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkVertexInputRate");
        }
    };
}
namespace das
{
    template <> struct cast < VkPrimitiveTopology > : cast_enum < VkPrimitiveTopology > {};
};

class EnumerationVkPrimitiveTopology : public das::Enumeration {
public:
    EnumerationVkPrimitiveTopology() : das::Enumeration("VkPrimitiveTopology") {
        external = true;
        cppName = "VkPrimitiveTopology";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPrimitiveTopology >::type >::type;
        VkPrimitiveTopology enumArray[] = {
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
            VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PRIMITIVE_TOPOLOGY_POINT_LIST",
            "VK_PRIMITIVE_TOPOLOGY_LINE_LIST",
            "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP",
            "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST",
            "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP",
            "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN",
            "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY",
            "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY",
            "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
            "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
            "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST",
            "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPrimitiveTopology > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPrimitiveTopology");
        }
    };
}
namespace das
{
    template <> struct cast < VkPolygonMode > : cast_enum < VkPolygonMode > {};
};

class EnumerationVkPolygonMode : public das::Enumeration {
public:
    EnumerationVkPolygonMode() : das::Enumeration("VkPolygonMode") {
        external = true;
        cppName = "VkPolygonMode";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPolygonMode >::type >::type;
        VkPolygonMode enumArray[] = {
            VkPolygonMode::VK_POLYGON_MODE_FILL,
            VkPolygonMode::VK_POLYGON_MODE_LINE,
            VkPolygonMode::VK_POLYGON_MODE_POINT,
            VkPolygonMode::VK_POLYGON_MODE_FILL_RECTANGLE_NV,
            VkPolygonMode::VK_POLYGON_MODE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_POLYGON_MODE_FILL",
            "VK_POLYGON_MODE_LINE",
            "VK_POLYGON_MODE_POINT",
            "VK_POLYGON_MODE_FILL_RECTANGLE_NV",
            "VK_POLYGON_MODE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPolygonMode > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPolygonMode");
        }
    };
}
namespace das
{
    template <> struct cast < VkStencilOp > : cast_enum < VkStencilOp > {};
};

class EnumerationVkStencilOp : public das::Enumeration {
public:
    EnumerationVkStencilOp() : das::Enumeration("VkStencilOp") {
        external = true;
        cppName = "VkStencilOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkStencilOp >::type >::type;
        VkStencilOp enumArray[] = {
            VkStencilOp::VK_STENCIL_OP_KEEP,
            VkStencilOp::VK_STENCIL_OP_ZERO,
            VkStencilOp::VK_STENCIL_OP_REPLACE,
            VkStencilOp::VK_STENCIL_OP_INCREMENT_AND_CLAMP,
            VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_CLAMP,
            VkStencilOp::VK_STENCIL_OP_INVERT,
            VkStencilOp::VK_STENCIL_OP_INCREMENT_AND_WRAP,
            VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_WRAP,
            VkStencilOp::VK_STENCIL_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_STENCIL_OP_KEEP",
            "VK_STENCIL_OP_ZERO",
            "VK_STENCIL_OP_REPLACE",
            "VK_STENCIL_OP_INCREMENT_AND_CLAMP",
            "VK_STENCIL_OP_DECREMENT_AND_CLAMP",
            "VK_STENCIL_OP_INVERT",
            "VK_STENCIL_OP_INCREMENT_AND_WRAP",
            "VK_STENCIL_OP_DECREMENT_AND_WRAP",
            "VK_STENCIL_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkStencilOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkStencilOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkLogicOp > : cast_enum < VkLogicOp > {};
};

class EnumerationVkLogicOp : public das::Enumeration {
public:
    EnumerationVkLogicOp() : das::Enumeration("VkLogicOp") {
        external = true;
        cppName = "VkLogicOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkLogicOp >::type >::type;
        VkLogicOp enumArray[] = {
            VkLogicOp::VK_LOGIC_OP_CLEAR,
            VkLogicOp::VK_LOGIC_OP_AND,
            VkLogicOp::VK_LOGIC_OP_AND_REVERSE,
            VkLogicOp::VK_LOGIC_OP_COPY,
            VkLogicOp::VK_LOGIC_OP_AND_INVERTED,
            VkLogicOp::VK_LOGIC_OP_NO_OP,
            VkLogicOp::VK_LOGIC_OP_XOR,
            VkLogicOp::VK_LOGIC_OP_OR,
            VkLogicOp::VK_LOGIC_OP_NOR,
            VkLogicOp::VK_LOGIC_OP_EQUIVALENT,
            VkLogicOp::VK_LOGIC_OP_INVERT,
            VkLogicOp::VK_LOGIC_OP_OR_REVERSE,
            VkLogicOp::VK_LOGIC_OP_COPY_INVERTED,
            VkLogicOp::VK_LOGIC_OP_OR_INVERTED,
            VkLogicOp::VK_LOGIC_OP_NAND,
            VkLogicOp::VK_LOGIC_OP_SET,
            VkLogicOp::VK_LOGIC_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_LOGIC_OP_CLEAR",
            "VK_LOGIC_OP_AND",
            "VK_LOGIC_OP_AND_REVERSE",
            "VK_LOGIC_OP_COPY",
            "VK_LOGIC_OP_AND_INVERTED",
            "VK_LOGIC_OP_NO_OP",
            "VK_LOGIC_OP_XOR",
            "VK_LOGIC_OP_OR",
            "VK_LOGIC_OP_NOR",
            "VK_LOGIC_OP_EQUIVALENT",
            "VK_LOGIC_OP_INVERT",
            "VK_LOGIC_OP_OR_REVERSE",
            "VK_LOGIC_OP_COPY_INVERTED",
            "VK_LOGIC_OP_OR_INVERTED",
            "VK_LOGIC_OP_NAND",
            "VK_LOGIC_OP_SET",
            "VK_LOGIC_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 17; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkLogicOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkLogicOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkBorderColor > : cast_enum < VkBorderColor > {};
};

class EnumerationVkBorderColor : public das::Enumeration {
public:
    EnumerationVkBorderColor() : das::Enumeration("VkBorderColor") {
        external = true;
        cppName = "VkBorderColor";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBorderColor >::type >::type;
        VkBorderColor enumArray[] = {
            VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
            VkBorderColor::VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
            VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
            VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_BLACK,
            VkBorderColor::VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
            VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE,
            VkBorderColor::VK_BORDER_COLOR_FLOAT_CUSTOM_EXT,
            VkBorderColor::VK_BORDER_COLOR_INT_CUSTOM_EXT,
            VkBorderColor::VK_BORDER_COLOR_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK",
            "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK",
            "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK",
            "VK_BORDER_COLOR_INT_OPAQUE_BLACK",
            "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE",
            "VK_BORDER_COLOR_INT_OPAQUE_WHITE",
            "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT",
            "VK_BORDER_COLOR_INT_CUSTOM_EXT",
            "VK_BORDER_COLOR_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBorderColor > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBorderColor");
        }
    };
}
namespace das
{
    template <> struct cast < VkFilter > : cast_enum < VkFilter > {};
};

class EnumerationVkFilter : public das::Enumeration {
public:
    EnumerationVkFilter() : das::Enumeration("VkFilter") {
        external = true;
        cppName = "VkFilter";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFilter >::type >::type;
        VkFilter enumArray[] = {
            VkFilter::VK_FILTER_NEAREST,
            VkFilter::VK_FILTER_LINEAR,
            VkFilter::VK_FILTER_CUBIC_IMG,
            VkFilter::VK_FILTER_CUBIC_EXT,
            VkFilter::VK_FILTER_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FILTER_NEAREST",
            "VK_FILTER_LINEAR",
            "VK_FILTER_CUBIC_IMG",
            "VK_FILTER_CUBIC_EXT",
            "VK_FILTER_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFilter > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFilter");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerAddressMode > : cast_enum < VkSamplerAddressMode > {};
};

class EnumerationVkSamplerAddressMode : public das::Enumeration {
public:
    EnumerationVkSamplerAddressMode() : das::Enumeration("VkSamplerAddressMode") {
        external = true;
        cppName = "VkSamplerAddressMode";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerAddressMode >::type >::type;
        VkSamplerAddressMode enumArray[] = {
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR,
            VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_ADDRESS_MODE_REPEAT",
            "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT",
            "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE",
            "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
            "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE",
            "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR",
            "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerAddressMode > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerAddressMode");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerMipmapMode > : cast_enum < VkSamplerMipmapMode > {};
};

class EnumerationVkSamplerMipmapMode : public das::Enumeration {
public:
    EnumerationVkSamplerMipmapMode() : das::Enumeration("VkSamplerMipmapMode") {
        external = true;
        cppName = "VkSamplerMipmapMode";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerMipmapMode >::type >::type;
        VkSamplerMipmapMode enumArray[] = {
            VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST,
            VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR,
            VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_MIPMAP_MODE_NEAREST",
            "VK_SAMPLER_MIPMAP_MODE_LINEAR",
            "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerMipmapMode > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerMipmapMode");
        }
    };
}
namespace das
{
    template <> struct cast < VkDescriptorType > : cast_enum < VkDescriptorType > {};
};

class EnumerationVkDescriptorType : public das::Enumeration {
public:
    EnumerationVkDescriptorType() : das::Enumeration("VkDescriptorType") {
        external = true;
        cppName = "VkDescriptorType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDescriptorType >::type >::type;
        VkDescriptorType enumArray[] = {
            VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
            VkDescriptorType::VK_DESCRIPTOR_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DESCRIPTOR_TYPE_SAMPLER",
            "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER",
            "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE",
            "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE",
            "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER",
            "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER",
            "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER",
            "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER",
            "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC",
            "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC",
            "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT",
            "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT",
            "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR",
            "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV",
            "VK_DESCRIPTOR_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 15; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDescriptorType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDescriptorType");
        }
    };
}
namespace das
{
    template <> struct cast < VkAttachmentLoadOp > : cast_enum < VkAttachmentLoadOp > {};
};

class EnumerationVkAttachmentLoadOp : public das::Enumeration {
public:
    EnumerationVkAttachmentLoadOp() : das::Enumeration("VkAttachmentLoadOp") {
        external = true;
        cppName = "VkAttachmentLoadOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAttachmentLoadOp >::type >::type;
        VkAttachmentLoadOp enumArray[] = {
            VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_LOAD,
            VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_CLEAR,
            VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE,
            VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_ATTACHMENT_LOAD_OP_LOAD",
            "VK_ATTACHMENT_LOAD_OP_CLEAR",
            "VK_ATTACHMENT_LOAD_OP_DONT_CARE",
            "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAttachmentLoadOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAttachmentLoadOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkAttachmentStoreOp > : cast_enum < VkAttachmentStoreOp > {};
};

class EnumerationVkAttachmentStoreOp : public das::Enumeration {
public:
    EnumerationVkAttachmentStoreOp() : das::Enumeration("VkAttachmentStoreOp") {
        external = true;
        cppName = "VkAttachmentStoreOp";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAttachmentStoreOp >::type >::type;
        VkAttachmentStoreOp enumArray[] = {
            VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE,
            VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE,
            VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_NONE_QCOM,
            VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_ATTACHMENT_STORE_OP_STORE",
            "VK_ATTACHMENT_STORE_OP_DONT_CARE",
            "VK_ATTACHMENT_STORE_OP_NONE_QCOM",
            "VK_ATTACHMENT_STORE_OP_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAttachmentStoreOp > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAttachmentStoreOp");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineBindPoint > : cast_enum < VkPipelineBindPoint > {};
};

class EnumerationVkPipelineBindPoint : public das::Enumeration {
public:
    EnumerationVkPipelineBindPoint() : das::Enumeration("VkPipelineBindPoint") {
        external = true;
        cppName = "VkPipelineBindPoint";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineBindPoint >::type >::type;
        VkPipelineBindPoint enumArray[] = {
            VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS,
            VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE,
            VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
            VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
            VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_BIND_POINT_GRAPHICS",
            "VK_PIPELINE_BIND_POINT_COMPUTE",
            "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR",
            "VK_PIPELINE_BIND_POINT_RAY_TRACING_NV",
            "VK_PIPELINE_BIND_POINT_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineBindPoint > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineBindPoint");
        }
    };
}
namespace das
{
    template <> struct cast < VkCommandBufferLevel > : cast_enum < VkCommandBufferLevel > {};
};

class EnumerationVkCommandBufferLevel : public das::Enumeration {
public:
    EnumerationVkCommandBufferLevel() : das::Enumeration("VkCommandBufferLevel") {
        external = true;
        cppName = "VkCommandBufferLevel";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCommandBufferLevel >::type >::type;
        VkCommandBufferLevel enumArray[] = {
            VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY,
            VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_SECONDARY,
            VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMMAND_BUFFER_LEVEL_PRIMARY",
            "VK_COMMAND_BUFFER_LEVEL_SECONDARY",
            "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCommandBufferLevel > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCommandBufferLevel");
        }
    };
}
namespace das
{
    template <> struct cast < VkIndexType > : cast_enum < VkIndexType > {};
};

class EnumerationVkIndexType : public das::Enumeration {
public:
    EnumerationVkIndexType() : das::Enumeration("VkIndexType") {
        external = true;
        cppName = "VkIndexType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkIndexType >::type >::type;
        VkIndexType enumArray[] = {
            VkIndexType::VK_INDEX_TYPE_UINT16,
            VkIndexType::VK_INDEX_TYPE_UINT32,
            VkIndexType::VK_INDEX_TYPE_NONE_KHR,
            VkIndexType::VK_INDEX_TYPE_UINT8_EXT,
            VkIndexType::VK_INDEX_TYPE_NONE_NV,
            VkIndexType::VK_INDEX_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_INDEX_TYPE_UINT16",
            "VK_INDEX_TYPE_UINT32",
            "VK_INDEX_TYPE_NONE_KHR",
            "VK_INDEX_TYPE_UINT8_EXT",
            "VK_INDEX_TYPE_NONE_NV",
            "VK_INDEX_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkIndexType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkIndexType");
        }
    };
}
namespace das
{
    template <> struct cast < VkSubpassContents > : cast_enum < VkSubpassContents > {};
};

class EnumerationVkSubpassContents : public das::Enumeration {
public:
    EnumerationVkSubpassContents() : das::Enumeration("VkSubpassContents") {
        external = true;
        cppName = "VkSubpassContents";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSubpassContents >::type >::type;
        VkSubpassContents enumArray[] = {
            VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE,
            VkSubpassContents::VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
            VkSubpassContents::VK_SUBPASS_CONTENTS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SUBPASS_CONTENTS_INLINE",
            "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS",
            "VK_SUBPASS_CONTENTS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSubpassContents > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSubpassContents");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccessFlagBits > : cast_enum < VkAccessFlagBits > {};
};

class EnumerationVkAccessFlagBits : public das::Enumeration {
public:
    EnumerationVkAccessFlagBits() : das::Enumeration("VkAccessFlagBits") {
        external = true;
        cppName = "VkAccessFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccessFlagBits >::type >::type;
        VkAccessFlagBits enumArray[] = {
            VkAccessFlagBits::VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_INDEX_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_UNIFORM_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_SHADER_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_SHADER_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_TRANSFER_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_TRANSFER_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_HOST_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_HOST_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_MEMORY_READ_BIT,
            VkAccessFlagBits::VK_ACCESS_MEMORY_WRITE_BIT,
            VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
            VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
            VkAccessFlagBits::VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
            VkAccessFlagBits::VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
            VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,
            VkAccessFlagBits::VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,
            VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV,
            VkAccessFlagBits::VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV,
            VkAccessFlagBits::VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
            VkAccessFlagBits::VK_ACCESS_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_ACCESS_INDIRECT_COMMAND_READ_BIT",
            "VK_ACCESS_INDEX_READ_BIT",
            "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT",
            "VK_ACCESS_UNIFORM_READ_BIT",
            "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT",
            "VK_ACCESS_SHADER_READ_BIT",
            "VK_ACCESS_SHADER_WRITE_BIT",
            "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT",
            "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT",
            "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
            "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
            "VK_ACCESS_TRANSFER_READ_BIT",
            "VK_ACCESS_TRANSFER_WRITE_BIT",
            "VK_ACCESS_HOST_READ_BIT",
            "VK_ACCESS_HOST_WRITE_BIT",
            "VK_ACCESS_MEMORY_READ_BIT",
            "VK_ACCESS_MEMORY_WRITE_BIT",
            "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT",
            "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT",
            "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT",
            "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT",
            "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT",
            "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR",
            "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR",
            "VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV",
            "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT",
            "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV",
            "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV",
            "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV",
            "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV",
            "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR",
            "VK_ACCESS_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 32; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccessFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccessFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageAspectFlagBits > : cast_enum < VkImageAspectFlagBits > {};
};

class EnumerationVkImageAspectFlagBits : public das::Enumeration {
public:
    EnumerationVkImageAspectFlagBits() : das::Enumeration("VkImageAspectFlagBits") {
        external = true;
        cppName = "VkImageAspectFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageAspectFlagBits >::type >::type;
        VkImageAspectFlagBits enumArray[] = {
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_COLOR_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_DEPTH_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_STENCIL_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_METADATA_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
            VkImageAspectFlagBits::VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_ASPECT_COLOR_BIT",
            "VK_IMAGE_ASPECT_DEPTH_BIT",
            "VK_IMAGE_ASPECT_STENCIL_BIT",
            "VK_IMAGE_ASPECT_METADATA_BIT",
            "VK_IMAGE_ASPECT_PLANE_0_BIT",
            "VK_IMAGE_ASPECT_PLANE_1_BIT",
            "VK_IMAGE_ASPECT_PLANE_2_BIT",
            "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT",
            "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT",
            "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT",
            "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT",
            "VK_IMAGE_ASPECT_PLANE_0_BIT_KHR",
            "VK_IMAGE_ASPECT_PLANE_1_BIT_KHR",
            "VK_IMAGE_ASPECT_PLANE_2_BIT_KHR",
            "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 15; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageAspectFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageAspectFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkFormatFeatureFlagBits > : cast_enum < VkFormatFeatureFlagBits > {};
};

class EnumerationVkFormatFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkFormatFeatureFlagBits() : das::Enumeration("VkFormatFeatureFlagBits") {
        external = true;
        cppName = "VkFormatFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFormatFeatureFlagBits >::type >::type;
        VkFormatFeatureFlagBits enumArray[] = {
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_SRC_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_BLIT_DST_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
            VkFormatFeatureFlagBits::VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT",
            "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT",
            "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT",
            "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT",
            "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT",
            "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
            "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT",
            "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT",
            "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT",
            "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT",
            "VK_FORMAT_FEATURE_BLIT_SRC_BIT",
            "VK_FORMAT_FEATURE_BLIT_DST_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
            "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT",
            "VK_FORMAT_FEATURE_TRANSFER_DST_BIT",
            "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
            "VK_FORMAT_FEATURE_DISJOINT_BIT",
            "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG",
            "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR",
            "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT",
            "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
            "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR",
            "VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT",
            "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR",
            "VK_FORMAT_FEATURE_DISJOINT_BIT_KHR",
            "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR",
            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT",
            "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 39; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFormatFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFormatFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageCreateFlagBits > : cast_enum < VkImageCreateFlagBits > {};
};

class EnumerationVkImageCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkImageCreateFlagBits() : das::Enumeration("VkImageCreateFlagBits") {
        external = true;
        cppName = "VkImageCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageCreateFlagBits >::type >::type;
        VkImageCreateFlagBits enumArray[] = {
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_PROTECTED_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_ALIAS_BIT_KHR,
            VkImageCreateFlagBits::VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_CREATE_SPARSE_BINDING_BIT",
            "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT",
            "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT",
            "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT",
            "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT",
            "VK_IMAGE_CREATE_ALIAS_BIT",
            "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT",
            "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT",
            "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT",
            "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT",
            "VK_IMAGE_CREATE_PROTECTED_BIT",
            "VK_IMAGE_CREATE_DISJOINT_BIT",
            "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV",
            "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT",
            "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT",
            "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR",
            "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR",
            "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR",
            "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR",
            "VK_IMAGE_CREATE_DISJOINT_BIT_KHR",
            "VK_IMAGE_CREATE_ALIAS_BIT_KHR",
            "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 22; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSampleCountFlagBits > : cast_enum < VkSampleCountFlagBits > {};
};

class EnumerationVkSampleCountFlagBits : public das::Enumeration {
public:
    EnumerationVkSampleCountFlagBits() : das::Enumeration("VkSampleCountFlagBits") {
        external = true;
        cppName = "VkSampleCountFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSampleCountFlagBits >::type >::type;
        VkSampleCountFlagBits enumArray[] = {
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_2_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_4_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_8_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_16_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_32_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_64_BIT,
            VkSampleCountFlagBits::VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLE_COUNT_1_BIT",
            "VK_SAMPLE_COUNT_2_BIT",
            "VK_SAMPLE_COUNT_4_BIT",
            "VK_SAMPLE_COUNT_8_BIT",
            "VK_SAMPLE_COUNT_16_BIT",
            "VK_SAMPLE_COUNT_32_BIT",
            "VK_SAMPLE_COUNT_64_BIT",
            "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSampleCountFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSampleCountFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageUsageFlagBits > : cast_enum < VkImageUsageFlagBits > {};
};

class EnumerationVkImageUsageFlagBits : public das::Enumeration {
public:
    EnumerationVkImageUsageFlagBits() : das::Enumeration("VkImageUsageFlagBits") {
        external = true;
        cppName = "VkImageUsageFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageUsageFlagBits >::type >::type;
        VkImageUsageFlagBits enumArray[] = {
            VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSFER_DST_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_SAMPLED_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_STORAGE_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
            VkImageUsageFlagBits::VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_USAGE_TRANSFER_SRC_BIT",
            "VK_IMAGE_USAGE_TRANSFER_DST_BIT",
            "VK_IMAGE_USAGE_SAMPLED_BIT",
            "VK_IMAGE_USAGE_STORAGE_BIT",
            "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT",
            "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT",
            "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT",
            "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT",
            "VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV",
            "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT",
            "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
            "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageUsageFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageUsageFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkMemoryHeapFlagBits > : cast_enum < VkMemoryHeapFlagBits > {};
};

class EnumerationVkMemoryHeapFlagBits : public das::Enumeration {
public:
    EnumerationVkMemoryHeapFlagBits() : das::Enumeration("VkMemoryHeapFlagBits") {
        external = true;
        cppName = "VkMemoryHeapFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkMemoryHeapFlagBits >::type >::type;
        VkMemoryHeapFlagBits enumArray[] = {
            VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
            VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
            VkMemoryHeapFlagBits::VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
            VkMemoryHeapFlagBits::VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT",
            "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT",
            "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR",
            "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkMemoryHeapFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkMemoryHeapFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkMemoryPropertyFlagBits > : cast_enum < VkMemoryPropertyFlagBits > {};
};

class EnumerationVkMemoryPropertyFlagBits : public das::Enumeration {
public:
    EnumerationVkMemoryPropertyFlagBits() : das::Enumeration("VkMemoryPropertyFlagBits") {
        external = true;
        cppName = "VkMemoryPropertyFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkMemoryPropertyFlagBits >::type >::type;
        VkMemoryPropertyFlagBits enumArray[] = {
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_PROTECTED_BIT,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
            VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT",
            "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT",
            "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT",
            "VK_MEMORY_PROPERTY_HOST_CACHED_BIT",
            "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT",
            "VK_MEMORY_PROPERTY_PROTECTED_BIT",
            "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD",
            "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD",
            "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkMemoryPropertyFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkMemoryPropertyFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueueFlagBits > : cast_enum < VkQueueFlagBits > {};
};

class EnumerationVkQueueFlagBits : public das::Enumeration {
public:
    EnumerationVkQueueFlagBits() : das::Enumeration("VkQueueFlagBits") {
        external = true;
        cppName = "VkQueueFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueueFlagBits >::type >::type;
        VkQueueFlagBits enumArray[] = {
            VkQueueFlagBits::VK_QUEUE_GRAPHICS_BIT,
            VkQueueFlagBits::VK_QUEUE_COMPUTE_BIT,
            VkQueueFlagBits::VK_QUEUE_TRANSFER_BIT,
            VkQueueFlagBits::VK_QUEUE_SPARSE_BINDING_BIT,
            VkQueueFlagBits::VK_QUEUE_PROTECTED_BIT,
            VkQueueFlagBits::VK_QUEUE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_QUEUE_GRAPHICS_BIT",
            "VK_QUEUE_COMPUTE_BIT",
            "VK_QUEUE_TRANSFER_BIT",
            "VK_QUEUE_SPARSE_BINDING_BIT",
            "VK_QUEUE_PROTECTED_BIT",
            "VK_QUEUE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueueFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueueFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDeviceQueueCreateFlagBits > : cast_enum < VkDeviceQueueCreateFlagBits > {};
};

class EnumerationVkDeviceQueueCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkDeviceQueueCreateFlagBits() : das::Enumeration("VkDeviceQueueCreateFlagBits") {
        external = true;
        cppName = "VkDeviceQueueCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDeviceQueueCreateFlagBits >::type >::type;
        VkDeviceQueueCreateFlagBits enumArray[] = {
            VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
            VkDeviceQueueCreateFlagBits::VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT",
            "VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDeviceQueueCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDeviceQueueCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineStageFlagBits > : cast_enum < VkPipelineStageFlagBits > {};
};

class EnumerationVkPipelineStageFlagBits : public das::Enumeration {
public:
    EnumerationVkPipelineStageFlagBits() : das::Enumeration("VkPipelineStageFlagBits") {
        external = true;
        cppName = "VkPipelineStageFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineStageFlagBits >::type >::type;
        VkPipelineStageFlagBits enumArray[] = {
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFER_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_HOST_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
            VkPipelineStageFlagBits::VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT",
            "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT",
            "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT",
            "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT",
            "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT",
            "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
            "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT",
            "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT",
            "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT",
            "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT",
            "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT",
            "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT",
            "VK_PIPELINE_STAGE_TRANSFER_BIT",
            "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT",
            "VK_PIPELINE_STAGE_HOST_BIT",
            "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT",
            "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT",
            "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT",
            "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT",
            "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR",
            "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR",
            "VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV",
            "VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV",
            "VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV",
            "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT",
            "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV",
            "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV",
            "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV",
            "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR",
            "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 30; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineStageFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineStageFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSparseMemoryBindFlagBits > : cast_enum < VkSparseMemoryBindFlagBits > {};
};

class EnumerationVkSparseMemoryBindFlagBits : public das::Enumeration {
public:
    EnumerationVkSparseMemoryBindFlagBits() : das::Enumeration("VkSparseMemoryBindFlagBits") {
        external = true;
        cppName = "VkSparseMemoryBindFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSparseMemoryBindFlagBits >::type >::type;
        VkSparseMemoryBindFlagBits enumArray[] = {
            VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_METADATA_BIT,
            VkSparseMemoryBindFlagBits::VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SPARSE_MEMORY_BIND_METADATA_BIT",
            "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSparseMemoryBindFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSparseMemoryBindFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSparseImageFormatFlagBits > : cast_enum < VkSparseImageFormatFlagBits > {};
};

class EnumerationVkSparseImageFormatFlagBits : public das::Enumeration {
public:
    EnumerationVkSparseImageFormatFlagBits() : das::Enumeration("VkSparseImageFormatFlagBits") {
        external = true;
        cppName = "VkSparseImageFormatFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSparseImageFormatFlagBits >::type >::type;
        VkSparseImageFormatFlagBits enumArray[] = {
            VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
            VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
            VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
            VkSparseImageFormatFlagBits::VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT",
            "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT",
            "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT",
            "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSparseImageFormatFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSparseImageFormatFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkFenceCreateFlagBits > : cast_enum < VkFenceCreateFlagBits > {};
};

class EnumerationVkFenceCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkFenceCreateFlagBits() : das::Enumeration("VkFenceCreateFlagBits") {
        external = true;
        cppName = "VkFenceCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFenceCreateFlagBits >::type >::type;
        VkFenceCreateFlagBits enumArray[] = {
            VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT,
            VkFenceCreateFlagBits::VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FENCE_CREATE_SIGNALED_BIT",
            "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFenceCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFenceCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueryPipelineStatisticFlagBits > : cast_enum < VkQueryPipelineStatisticFlagBits > {};
};

class EnumerationVkQueryPipelineStatisticFlagBits : public das::Enumeration {
public:
    EnumerationVkQueryPipelineStatisticFlagBits() : das::Enumeration("VkQueryPipelineStatisticFlagBits") {
        external = true;
        cppName = "VkQueryPipelineStatisticFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueryPipelineStatisticFlagBits >::type >::type;
        VkQueryPipelineStatisticFlagBits enumArray[] = {
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
            VkQueryPipelineStatisticFlagBits::VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT",
            "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueryPipelineStatisticFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueryPipelineStatisticFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueryResultFlagBits > : cast_enum < VkQueryResultFlagBits > {};
};

class EnumerationVkQueryResultFlagBits : public das::Enumeration {
public:
    EnumerationVkQueryResultFlagBits() : das::Enumeration("VkQueryResultFlagBits") {
        external = true;
        cppName = "VkQueryResultFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueryResultFlagBits >::type >::type;
        VkQueryResultFlagBits enumArray[] = {
            VkQueryResultFlagBits::VK_QUERY_RESULT_64_BIT,
            VkQueryResultFlagBits::VK_QUERY_RESULT_WAIT_BIT,
            VkQueryResultFlagBits::VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
            VkQueryResultFlagBits::VK_QUERY_RESULT_PARTIAL_BIT,
            VkQueryResultFlagBits::VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_QUERY_RESULT_64_BIT",
            "VK_QUERY_RESULT_WAIT_BIT",
            "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT",
            "VK_QUERY_RESULT_PARTIAL_BIT",
            "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueryResultFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueryResultFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkBufferCreateFlagBits > : cast_enum < VkBufferCreateFlagBits > {};
};

class EnumerationVkBufferCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkBufferCreateFlagBits() : das::Enumeration("VkBufferCreateFlagBits") {
        external = true;
        cppName = "VkBufferCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBufferCreateFlagBits >::type >::type;
        VkBufferCreateFlagBits enumArray[] = {
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_PROTECTED_BIT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
            VkBufferCreateFlagBits::VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_BUFFER_CREATE_SPARSE_BINDING_BIT",
            "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT",
            "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT",
            "VK_BUFFER_CREATE_PROTECTED_BIT",
            "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
            "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT",
            "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR",
            "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBufferCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBufferCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkBufferUsageFlagBits > : cast_enum < VkBufferUsageFlagBits > {};
};

class EnumerationVkBufferUsageFlagBits : public das::Enumeration {
public:
    EnumerationVkBufferUsageFlagBits() : das::Enumeration("VkBufferUsageFlagBits") {
        external = true;
        cppName = "VkBufferUsageFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBufferUsageFlagBits >::type >::type;
        VkBufferUsageFlagBits enumArray[] = {
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_RAY_TRACING_BIT_NV,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
            VkBufferUsageFlagBits::VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_BUFFER_USAGE_TRANSFER_SRC_BIT",
            "VK_BUFFER_USAGE_TRANSFER_DST_BIT",
            "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT",
            "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT",
            "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT",
            "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT",
            "VK_BUFFER_USAGE_INDEX_BUFFER_BIT",
            "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT",
            "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT",
            "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT",
            "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT",
            "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT",
            "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT",
            "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR",
            "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR",
            "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR",
            "VK_BUFFER_USAGE_RAY_TRACING_BIT_NV",
            "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT",
            "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR",
            "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 20; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBufferUsageFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBufferUsageFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkImageViewCreateFlagBits > : cast_enum < VkImageViewCreateFlagBits > {};
};

class EnumerationVkImageViewCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkImageViewCreateFlagBits() : das::Enumeration("VkImageViewCreateFlagBits") {
        external = true;
        cppName = "VkImageViewCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkImageViewCreateFlagBits >::type >::type;
        VkImageViewCreateFlagBits enumArray[] = {
            VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,
            VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT,
            VkImageViewCreateFlagBits::VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT",
            "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT",
            "VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkImageViewCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkImageViewCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderModuleCreateFlagBits > : cast_enum < VkShaderModuleCreateFlagBits > {};
};

class EnumerationVkShaderModuleCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkShaderModuleCreateFlagBits() : das::Enumeration("VkShaderModuleCreateFlagBits") {
        external = true;
        cppName = "VkShaderModuleCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderModuleCreateFlagBits >::type >::type;
        VkShaderModuleCreateFlagBits enumArray[] = {
            VkShaderModuleCreateFlagBits::VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 1; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderModuleCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderModuleCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineCacheCreateFlagBits > : cast_enum < VkPipelineCacheCreateFlagBits > {};
};

class EnumerationVkPipelineCacheCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkPipelineCacheCreateFlagBits() : das::Enumeration("VkPipelineCacheCreateFlagBits") {
        external = true;
        cppName = "VkPipelineCacheCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineCacheCreateFlagBits >::type >::type;
        VkPipelineCacheCreateFlagBits enumArray[] = {
            VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT,
            VkPipelineCacheCreateFlagBits::VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT",
            "VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineCacheCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineCacheCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkColorComponentFlagBits > : cast_enum < VkColorComponentFlagBits > {};
};

class EnumerationVkColorComponentFlagBits : public das::Enumeration {
public:
    EnumerationVkColorComponentFlagBits() : das::Enumeration("VkColorComponentFlagBits") {
        external = true;
        cppName = "VkColorComponentFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkColorComponentFlagBits >::type >::type;
        VkColorComponentFlagBits enumArray[] = {
            VkColorComponentFlagBits::VK_COLOR_COMPONENT_R_BIT,
            VkColorComponentFlagBits::VK_COLOR_COMPONENT_G_BIT,
            VkColorComponentFlagBits::VK_COLOR_COMPONENT_B_BIT,
            VkColorComponentFlagBits::VK_COLOR_COMPONENT_A_BIT,
            VkColorComponentFlagBits::VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COLOR_COMPONENT_R_BIT",
            "VK_COLOR_COMPONENT_G_BIT",
            "VK_COLOR_COMPONENT_B_BIT",
            "VK_COLOR_COMPONENT_A_BIT",
            "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkColorComponentFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkColorComponentFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineCreateFlagBits > : cast_enum < VkPipelineCreateFlagBits > {};
};

class EnumerationVkPipelineCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkPipelineCreateFlagBits() : das::Enumeration("VkPipelineCreateFlagBits") {
        external = true;
        cppName = "VkPipelineCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineCreateFlagBits >::type >::type;
        VkPipelineCreateFlagBits enumArray[] = {
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DERIVATIVE_BIT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_DISPATCH_BASE_KHR,
            VkPipelineCreateFlagBits::VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT",
            "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT",
            "VK_PIPELINE_CREATE_DERIVATIVE_BIT",
            "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
            "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT",
            "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR",
            "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR",
            "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV",
            "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR",
            "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR",
            "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV",
            "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR",
            "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT",
            "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT",
            "VK_PIPELINE_CREATE_DISPATCH_BASE",
            "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR",
            "VK_PIPELINE_CREATE_DISPATCH_BASE_KHR",
            "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 23; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineShaderStageCreateFlagBits > : cast_enum < VkPipelineShaderStageCreateFlagBits > {};
};

class EnumerationVkPipelineShaderStageCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkPipelineShaderStageCreateFlagBits() : das::Enumeration("VkPipelineShaderStageCreateFlagBits") {
        external = true;
        cppName = "VkPipelineShaderStageCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineShaderStageCreateFlagBits >::type >::type;
        VkPipelineShaderStageCreateFlagBits enumArray[] = {
            VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
            VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
            VkPipelineShaderStageCreateFlagBits::VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT",
            "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT",
            "VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineShaderStageCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineShaderStageCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderStageFlagBits > : cast_enum < VkShaderStageFlagBits > {};
};

class EnumerationVkShaderStageFlagBits : public das::Enumeration {
public:
    EnumerationVkShaderStageFlagBits() : das::Enumeration("VkShaderStageFlagBits") {
        external = true;
        cppName = "VkShaderStageFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderStageFlagBits >::type >::type;
        VkShaderStageFlagBits enumArray[] = {
            VkShaderStageFlagBits::VK_SHADER_STAGE_VERTEX_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_GEOMETRY_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_FRAGMENT_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
            VkShaderStageFlagBits::VK_SHADER_STAGE_ALL_GRAPHICS,
            VkShaderStageFlagBits::VK_SHADER_STAGE_ALL,
            VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_KHR,
            VkShaderStageFlagBits::VK_SHADER_STAGE_TASK_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_MESH_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_RAYGEN_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_ANY_HIT_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_MISS_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_INTERSECTION_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_CALLABLE_BIT_NV,
            VkShaderStageFlagBits::VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_STAGE_VERTEX_BIT",
            "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT",
            "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT",
            "VK_SHADER_STAGE_GEOMETRY_BIT",
            "VK_SHADER_STAGE_FRAGMENT_BIT",
            "VK_SHADER_STAGE_COMPUTE_BIT",
            "VK_SHADER_STAGE_ALL_GRAPHICS",
            "VK_SHADER_STAGE_ALL",
            "VK_SHADER_STAGE_RAYGEN_BIT_KHR",
            "VK_SHADER_STAGE_ANY_HIT_BIT_KHR",
            "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR",
            "VK_SHADER_STAGE_MISS_BIT_KHR",
            "VK_SHADER_STAGE_INTERSECTION_BIT_KHR",
            "VK_SHADER_STAGE_CALLABLE_BIT_KHR",
            "VK_SHADER_STAGE_TASK_BIT_NV",
            "VK_SHADER_STAGE_MESH_BIT_NV",
            "VK_SHADER_STAGE_RAYGEN_BIT_NV",
            "VK_SHADER_STAGE_ANY_HIT_BIT_NV",
            "VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV",
            "VK_SHADER_STAGE_MISS_BIT_NV",
            "VK_SHADER_STAGE_INTERSECTION_BIT_NV",
            "VK_SHADER_STAGE_CALLABLE_BIT_NV",
            "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 23; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderStageFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderStageFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkCullModeFlagBits > : cast_enum < VkCullModeFlagBits > {};
};

class EnumerationVkCullModeFlagBits : public das::Enumeration {
public:
    EnumerationVkCullModeFlagBits() : das::Enumeration("VkCullModeFlagBits") {
        external = true;
        cppName = "VkCullModeFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCullModeFlagBits >::type >::type;
        VkCullModeFlagBits enumArray[] = {
            VkCullModeFlagBits::VK_CULL_MODE_NONE,
            VkCullModeFlagBits::VK_CULL_MODE_FRONT_BIT,
            VkCullModeFlagBits::VK_CULL_MODE_BACK_BIT,
            VkCullModeFlagBits::VK_CULL_MODE_FRONT_AND_BACK,
            VkCullModeFlagBits::VK_CULL_MODE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_CULL_MODE_NONE",
            "VK_CULL_MODE_FRONT_BIT",
            "VK_CULL_MODE_BACK_BIT",
            "VK_CULL_MODE_FRONT_AND_BACK",
            "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCullModeFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCullModeFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerCreateFlagBits > : cast_enum < VkSamplerCreateFlagBits > {};
};

class EnumerationVkSamplerCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkSamplerCreateFlagBits() : das::Enumeration("VkSamplerCreateFlagBits") {
        external = true;
        cppName = "VkSamplerCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerCreateFlagBits >::type >::type;
        VkSamplerCreateFlagBits enumArray[] = {
            VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,
            VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
            VkSamplerCreateFlagBits::VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT",
            "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT",
            "VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDescriptorPoolCreateFlagBits > : cast_enum < VkDescriptorPoolCreateFlagBits > {};
};

class EnumerationVkDescriptorPoolCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkDescriptorPoolCreateFlagBits() : das::Enumeration("VkDescriptorPoolCreateFlagBits") {
        external = true;
        cppName = "VkDescriptorPoolCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDescriptorPoolCreateFlagBits >::type >::type;
        VkDescriptorPoolCreateFlagBits enumArray[] = {
            VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
            VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
            VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
            VkDescriptorPoolCreateFlagBits::VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT",
            "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT",
            "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT",
            "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDescriptorPoolCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDescriptorPoolCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDescriptorSetLayoutCreateFlagBits > : cast_enum < VkDescriptorSetLayoutCreateFlagBits > {};
};

class EnumerationVkDescriptorSetLayoutCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkDescriptorSetLayoutCreateFlagBits() : das::Enumeration("VkDescriptorSetLayoutCreateFlagBits") {
        external = true;
        cppName = "VkDescriptorSetLayoutCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDescriptorSetLayoutCreateFlagBits >::type >::type;
        VkDescriptorSetLayoutCreateFlagBits enumArray[] = {
            VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
            VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
            VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
            VkDescriptorSetLayoutCreateFlagBits::VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
            "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR",
            "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT",
            "VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDescriptorSetLayoutCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDescriptorSetLayoutCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkAttachmentDescriptionFlagBits > : cast_enum < VkAttachmentDescriptionFlagBits > {};
};

class EnumerationVkAttachmentDescriptionFlagBits : public das::Enumeration {
public:
    EnumerationVkAttachmentDescriptionFlagBits() : das::Enumeration("VkAttachmentDescriptionFlagBits") {
        external = true;
        cppName = "VkAttachmentDescriptionFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAttachmentDescriptionFlagBits >::type >::type;
        VkAttachmentDescriptionFlagBits enumArray[] = {
            VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
            VkAttachmentDescriptionFlagBits::VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT",
            "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAttachmentDescriptionFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAttachmentDescriptionFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDependencyFlagBits > : cast_enum < VkDependencyFlagBits > {};
};

class EnumerationVkDependencyFlagBits : public das::Enumeration {
public:
    EnumerationVkDependencyFlagBits() : das::Enumeration("VkDependencyFlagBits") {
        external = true;
        cppName = "VkDependencyFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDependencyFlagBits >::type >::type;
        VkDependencyFlagBits enumArray[] = {
            VkDependencyFlagBits::VK_DEPENDENCY_BY_REGION_BIT,
            VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT,
            VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT,
            VkDependencyFlagBits::VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
            VkDependencyFlagBits::VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
            VkDependencyFlagBits::VK_DEPENDENCY_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DEPENDENCY_BY_REGION_BIT",
            "VK_DEPENDENCY_DEVICE_GROUP_BIT",
            "VK_DEPENDENCY_VIEW_LOCAL_BIT",
            "VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR",
            "VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR",
            "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDependencyFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDependencyFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkFramebufferCreateFlagBits > : cast_enum < VkFramebufferCreateFlagBits > {};
};

class EnumerationVkFramebufferCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkFramebufferCreateFlagBits() : das::Enumeration("VkFramebufferCreateFlagBits") {
        external = true;
        cppName = "VkFramebufferCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFramebufferCreateFlagBits >::type >::type;
        VkFramebufferCreateFlagBits enumArray[] = {
            VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
            VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR,
            VkFramebufferCreateFlagBits::VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT",
            "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR",
            "VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFramebufferCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFramebufferCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkRenderPassCreateFlagBits > : cast_enum < VkRenderPassCreateFlagBits > {};
};

class EnumerationVkRenderPassCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkRenderPassCreateFlagBits() : das::Enumeration("VkRenderPassCreateFlagBits") {
        external = true;
        cppName = "VkRenderPassCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkRenderPassCreateFlagBits >::type >::type;
        VkRenderPassCreateFlagBits enumArray[] = {
            VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM,
            VkRenderPassCreateFlagBits::VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM",
            "VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkRenderPassCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkRenderPassCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSubpassDescriptionFlagBits > : cast_enum < VkSubpassDescriptionFlagBits > {};
};

class EnumerationVkSubpassDescriptionFlagBits : public das::Enumeration {
public:
    EnumerationVkSubpassDescriptionFlagBits() : das::Enumeration("VkSubpassDescriptionFlagBits") {
        external = true;
        cppName = "VkSubpassDescriptionFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSubpassDescriptionFlagBits >::type >::type;
        VkSubpassDescriptionFlagBits enumArray[] = {
            VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
            VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
            VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM,
            VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM,
            VkSubpassDescriptionFlagBits::VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX",
            "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX",
            "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM",
            "VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM",
            "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSubpassDescriptionFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSubpassDescriptionFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkCommandPoolCreateFlagBits > : cast_enum < VkCommandPoolCreateFlagBits > {};
};

class EnumerationVkCommandPoolCreateFlagBits : public das::Enumeration {
public:
    EnumerationVkCommandPoolCreateFlagBits() : das::Enumeration("VkCommandPoolCreateFlagBits") {
        external = true;
        cppName = "VkCommandPoolCreateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCommandPoolCreateFlagBits >::type >::type;
        VkCommandPoolCreateFlagBits enumArray[] = {
            VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
            VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
            VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
            VkCommandPoolCreateFlagBits::VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT",
            "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT",
            "VK_COMMAND_POOL_CREATE_PROTECTED_BIT",
            "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCommandPoolCreateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCommandPoolCreateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkCommandPoolResetFlagBits > : cast_enum < VkCommandPoolResetFlagBits > {};
};

class EnumerationVkCommandPoolResetFlagBits : public das::Enumeration {
public:
    EnumerationVkCommandPoolResetFlagBits() : das::Enumeration("VkCommandPoolResetFlagBits") {
        external = true;
        cppName = "VkCommandPoolResetFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCommandPoolResetFlagBits >::type >::type;
        VkCommandPoolResetFlagBits enumArray[] = {
            VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
            VkCommandPoolResetFlagBits::VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT",
            "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCommandPoolResetFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCommandPoolResetFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkCommandBufferUsageFlagBits > : cast_enum < VkCommandBufferUsageFlagBits > {};
};

class EnumerationVkCommandBufferUsageFlagBits : public das::Enumeration {
public:
    EnumerationVkCommandBufferUsageFlagBits() : das::Enumeration("VkCommandBufferUsageFlagBits") {
        external = true;
        cppName = "VkCommandBufferUsageFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCommandBufferUsageFlagBits >::type >::type;
        VkCommandBufferUsageFlagBits enumArray[] = {
            VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
            VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
            VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
            VkCommandBufferUsageFlagBits::VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT",
            "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT",
            "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT",
            "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCommandBufferUsageFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCommandBufferUsageFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueryControlFlagBits > : cast_enum < VkQueryControlFlagBits > {};
};

class EnumerationVkQueryControlFlagBits : public das::Enumeration {
public:
    EnumerationVkQueryControlFlagBits() : das::Enumeration("VkQueryControlFlagBits") {
        external = true;
        cppName = "VkQueryControlFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueryControlFlagBits >::type >::type;
        VkQueryControlFlagBits enumArray[] = {
            VkQueryControlFlagBits::VK_QUERY_CONTROL_PRECISE_BIT,
            VkQueryControlFlagBits::VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_QUERY_CONTROL_PRECISE_BIT",
            "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueryControlFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueryControlFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkCommandBufferResetFlagBits > : cast_enum < VkCommandBufferResetFlagBits > {};
};

class EnumerationVkCommandBufferResetFlagBits : public das::Enumeration {
public:
    EnumerationVkCommandBufferResetFlagBits() : das::Enumeration("VkCommandBufferResetFlagBits") {
        external = true;
        cppName = "VkCommandBufferResetFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCommandBufferResetFlagBits >::type >::type;
        VkCommandBufferResetFlagBits enumArray[] = {
            VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
            VkCommandBufferResetFlagBits::VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT",
            "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCommandBufferResetFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCommandBufferResetFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkStencilFaceFlagBits > : cast_enum < VkStencilFaceFlagBits > {};
};

class EnumerationVkStencilFaceFlagBits : public das::Enumeration {
public:
    EnumerationVkStencilFaceFlagBits() : das::Enumeration("VkStencilFaceFlagBits") {
        external = true;
        cppName = "VkStencilFaceFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkStencilFaceFlagBits >::type >::type;
        VkStencilFaceFlagBits enumArray[] = {
            VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_BIT,
            VkStencilFaceFlagBits::VK_STENCIL_FACE_BACK_BIT,
            VkStencilFaceFlagBits::VK_STENCIL_FACE_FRONT_AND_BACK,
            VkStencilFaceFlagBits::VK_STENCIL_FRONT_AND_BACK,
            VkStencilFaceFlagBits::VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_STENCIL_FACE_FRONT_BIT",
            "VK_STENCIL_FACE_BACK_BIT",
            "VK_STENCIL_FACE_FRONT_AND_BACK",
            "VK_STENCIL_FRONT_AND_BACK",
            "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkStencilFaceFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkStencilFaceFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPointClippingBehavior > : cast_enum < VkPointClippingBehavior > {};
};

class EnumerationVkPointClippingBehavior : public das::Enumeration {
public:
    EnumerationVkPointClippingBehavior() : das::Enumeration("VkPointClippingBehavior") {
        external = true;
        cppName = "VkPointClippingBehavior";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPointClippingBehavior >::type >::type;
        VkPointClippingBehavior enumArray[] = {
            VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
            VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
            VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
            VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
            VkPointClippingBehavior::VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES",
            "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY",
            "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR",
            "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR",
            "VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPointClippingBehavior > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPointClippingBehavior");
        }
    };
}
namespace das
{
    template <> struct cast < VkTessellationDomainOrigin > : cast_enum < VkTessellationDomainOrigin > {};
};

class EnumerationVkTessellationDomainOrigin : public das::Enumeration {
public:
    EnumerationVkTessellationDomainOrigin() : das::Enumeration("VkTessellationDomainOrigin") {
        external = true;
        cppName = "VkTessellationDomainOrigin";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkTessellationDomainOrigin >::type >::type;
        VkTessellationDomainOrigin enumArray[] = {
            VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
            VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
            VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
            VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
            VkTessellationDomainOrigin::VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT",
            "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT",
            "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR",
            "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR",
            "VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkTessellationDomainOrigin > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkTessellationDomainOrigin");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerYcbcrModelConversion > : cast_enum < VkSamplerYcbcrModelConversion > {};
};

class EnumerationVkSamplerYcbcrModelConversion : public das::Enumeration {
public:
    EnumerationVkSamplerYcbcrModelConversion() : das::Enumeration("VkSamplerYcbcrModelConversion") {
        external = true;
        cppName = "VkSamplerYcbcrModelConversion";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerYcbcrModelConversion >::type >::type;
        VkSamplerYcbcrModelConversion enumArray[] = {
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
            VkSamplerYcbcrModelConversion::VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR",
            "VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 11; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerYcbcrModelConversion > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerYcbcrModelConversion");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerYcbcrRange > : cast_enum < VkSamplerYcbcrRange > {};
};

class EnumerationVkSamplerYcbcrRange : public das::Enumeration {
public:
    EnumerationVkSamplerYcbcrRange() : das::Enumeration("VkSamplerYcbcrRange") {
        external = true;
        cppName = "VkSamplerYcbcrRange";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerYcbcrRange >::type >::type;
        VkSamplerYcbcrRange enumArray[] = {
            VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
            VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
            VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
            VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
            VkSamplerYcbcrRange::VK_SAMPLER_YCBCR_RANGE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_YCBCR_RANGE_ITU_FULL",
            "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW",
            "VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR",
            "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR",
            "VK_SAMPLER_YCBCR_RANGE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerYcbcrRange > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerYcbcrRange");
        }
    };
}
namespace das
{
    template <> struct cast < VkChromaLocation > : cast_enum < VkChromaLocation > {};
};

class EnumerationVkChromaLocation : public das::Enumeration {
public:
    EnumerationVkChromaLocation() : das::Enumeration("VkChromaLocation") {
        external = true;
        cppName = "VkChromaLocation";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkChromaLocation >::type >::type;
        VkChromaLocation enumArray[] = {
            VkChromaLocation::VK_CHROMA_LOCATION_COSITED_EVEN,
            VkChromaLocation::VK_CHROMA_LOCATION_MIDPOINT,
            VkChromaLocation::VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
            VkChromaLocation::VK_CHROMA_LOCATION_MIDPOINT_KHR,
            VkChromaLocation::VK_CHROMA_LOCATION_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_CHROMA_LOCATION_COSITED_EVEN",
            "VK_CHROMA_LOCATION_MIDPOINT",
            "VK_CHROMA_LOCATION_COSITED_EVEN_KHR",
            "VK_CHROMA_LOCATION_MIDPOINT_KHR",
            "VK_CHROMA_LOCATION_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkChromaLocation > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkChromaLocation");
        }
    };
}
namespace das
{
    template <> struct cast < VkDescriptorUpdateTemplateType > : cast_enum < VkDescriptorUpdateTemplateType > {};
};

class EnumerationVkDescriptorUpdateTemplateType : public das::Enumeration {
public:
    EnumerationVkDescriptorUpdateTemplateType() : das::Enumeration("VkDescriptorUpdateTemplateType") {
        external = true;
        cppName = "VkDescriptorUpdateTemplateType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDescriptorUpdateTemplateType >::type >::type;
        VkDescriptorUpdateTemplateType enumArray[] = {
            VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
            VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
            VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
            VkDescriptorUpdateTemplateType::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET",
            "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR",
            "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR",
            "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDescriptorUpdateTemplateType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDescriptorUpdateTemplateType");
        }
    };
}
namespace das
{
    template <> struct cast < VkSubgroupFeatureFlagBits > : cast_enum < VkSubgroupFeatureFlagBits > {};
};

class EnumerationVkSubgroupFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkSubgroupFeatureFlagBits() : das::Enumeration("VkSubgroupFeatureFlagBits") {
        external = true;
        cppName = "VkSubgroupFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSubgroupFeatureFlagBits >::type >::type;
        VkSubgroupFeatureFlagBits enumArray[] = {
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BASIC_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_VOTE_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_BALLOT_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_QUAD_BIT,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
            VkSubgroupFeatureFlagBits::VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SUBGROUP_FEATURE_BASIC_BIT",
            "VK_SUBGROUP_FEATURE_VOTE_BIT",
            "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT",
            "VK_SUBGROUP_FEATURE_BALLOT_BIT",
            "VK_SUBGROUP_FEATURE_SHUFFLE_BIT",
            "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT",
            "VK_SUBGROUP_FEATURE_CLUSTERED_BIT",
            "VK_SUBGROUP_FEATURE_QUAD_BIT",
            "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV",
            "VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 10; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSubgroupFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSubgroupFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPeerMemoryFeatureFlagBits > : cast_enum < VkPeerMemoryFeatureFlagBits > {};
};

class EnumerationVkPeerMemoryFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkPeerMemoryFeatureFlagBits() : das::Enumeration("VkPeerMemoryFeatureFlagBits") {
        external = true;
        cppName = "VkPeerMemoryFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPeerMemoryFeatureFlagBits >::type >::type;
        VkPeerMemoryFeatureFlagBits enumArray[] = {
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
            VkPeerMemoryFeatureFlagBits::VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT",
            "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT",
            "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT",
            "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT",
            "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR",
            "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR",
            "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR",
            "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR",
            "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPeerMemoryFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPeerMemoryFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkMemoryAllocateFlagBits > : cast_enum < VkMemoryAllocateFlagBits > {};
};

class EnumerationVkMemoryAllocateFlagBits : public das::Enumeration {
public:
    EnumerationVkMemoryAllocateFlagBits() : das::Enumeration("VkMemoryAllocateFlagBits") {
        external = true;
        cppName = "VkMemoryAllocateFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkMemoryAllocateFlagBits >::type >::type;
        VkMemoryAllocateFlagBits enumArray[] = {
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
            VkMemoryAllocateFlagBits::VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT",
            "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT",
            "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
            "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR",
            "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR",
            "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR",
            "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkMemoryAllocateFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkMemoryAllocateFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalMemoryHandleTypeFlagBits > : cast_enum < VkExternalMemoryHandleTypeFlagBits > {};
};

class EnumerationVkExternalMemoryHandleTypeFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalMemoryHandleTypeFlagBits() : das::Enumeration("VkExternalMemoryHandleTypeFlagBits") {
        external = true;
        cppName = "VkExternalMemoryHandleTypeFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalMemoryHandleTypeFlagBits >::type >::type;
        VkExternalMemoryHandleTypeFlagBits enumArray[] = {
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
            VkExternalMemoryHandleTypeFlagBits::VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 19; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalMemoryHandleTypeFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalMemoryHandleTypeFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalMemoryFeatureFlagBits > : cast_enum < VkExternalMemoryFeatureFlagBits > {};
};

class EnumerationVkExternalMemoryFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalMemoryFeatureFlagBits() : das::Enumeration("VkExternalMemoryFeatureFlagBits") {
        external = true;
        cppName = "VkExternalMemoryFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalMemoryFeatureFlagBits >::type >::type;
        VkExternalMemoryFeatureFlagBits enumArray[] = {
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
            VkExternalMemoryFeatureFlagBits::VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT",
            "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT",
            "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT",
            "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR",
            "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR",
            "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR",
            "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalMemoryFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalMemoryFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalFenceHandleTypeFlagBits > : cast_enum < VkExternalFenceHandleTypeFlagBits > {};
};

class EnumerationVkExternalFenceHandleTypeFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalFenceHandleTypeFlagBits() : das::Enumeration("VkExternalFenceHandleTypeFlagBits") {
        external = true;
        cppName = "VkExternalFenceHandleTypeFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalFenceHandleTypeFlagBits >::type >::type;
        VkExternalFenceHandleTypeFlagBits enumArray[] = {
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
            VkExternalFenceHandleTypeFlagBits::VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR",
            "VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalFenceHandleTypeFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalFenceHandleTypeFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalFenceFeatureFlagBits > : cast_enum < VkExternalFenceFeatureFlagBits > {};
};

class EnumerationVkExternalFenceFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalFenceFeatureFlagBits() : das::Enumeration("VkExternalFenceFeatureFlagBits") {
        external = true;
        cppName = "VkExternalFenceFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalFenceFeatureFlagBits >::type >::type;
        VkExternalFenceFeatureFlagBits enumArray[] = {
            VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
            VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
            VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
            VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
            VkExternalFenceFeatureFlagBits::VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT",
            "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT",
            "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR",
            "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR",
            "VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalFenceFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalFenceFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkFenceImportFlagBits > : cast_enum < VkFenceImportFlagBits > {};
};

class EnumerationVkFenceImportFlagBits : public das::Enumeration {
public:
    EnumerationVkFenceImportFlagBits() : das::Enumeration("VkFenceImportFlagBits") {
        external = true;
        cppName = "VkFenceImportFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFenceImportFlagBits >::type >::type;
        VkFenceImportFlagBits enumArray[] = {
            VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT,
            VkFenceImportFlagBits::VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
            VkFenceImportFlagBits::VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_FENCE_IMPORT_TEMPORARY_BIT",
            "VK_FENCE_IMPORT_TEMPORARY_BIT_KHR",
            "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFenceImportFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFenceImportFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSemaphoreImportFlagBits > : cast_enum < VkSemaphoreImportFlagBits > {};
};

class EnumerationVkSemaphoreImportFlagBits : public das::Enumeration {
public:
    EnumerationVkSemaphoreImportFlagBits() : das::Enumeration("VkSemaphoreImportFlagBits") {
        external = true;
        cppName = "VkSemaphoreImportFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSemaphoreImportFlagBits >::type >::type;
        VkSemaphoreImportFlagBits enumArray[] = {
            VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
            VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
            VkSemaphoreImportFlagBits::VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT",
            "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR",
            "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSemaphoreImportFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSemaphoreImportFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalSemaphoreHandleTypeFlagBits > : cast_enum < VkExternalSemaphoreHandleTypeFlagBits > {};
};

class EnumerationVkExternalSemaphoreHandleTypeFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalSemaphoreHandleTypeFlagBits() : das::Enumeration("VkExternalSemaphoreHandleTypeFlagBits") {
        external = true;
        cppName = "VkExternalSemaphoreHandleTypeFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalSemaphoreHandleTypeFlagBits >::type >::type;
        VkExternalSemaphoreHandleTypeFlagBits enumArray[] = {
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
            VkExternalSemaphoreHandleTypeFlagBits::VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalSemaphoreHandleTypeFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalSemaphoreHandleTypeFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalSemaphoreFeatureFlagBits > : cast_enum < VkExternalSemaphoreFeatureFlagBits > {};
};

class EnumerationVkExternalSemaphoreFeatureFlagBits : public das::Enumeration {
public:
    EnumerationVkExternalSemaphoreFeatureFlagBits() : das::Enumeration("VkExternalSemaphoreFeatureFlagBits") {
        external = true;
        cppName = "VkExternalSemaphoreFeatureFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalSemaphoreFeatureFlagBits >::type >::type;
        VkExternalSemaphoreFeatureFlagBits enumArray[] = {
            VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
            VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
            VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
            VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
            VkExternalSemaphoreFeatureFlagBits::VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT",
            "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT",
            "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR",
            "VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalSemaphoreFeatureFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalSemaphoreFeatureFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDriverId > : cast_enum < VkDriverId > {};
};

class EnumerationVkDriverId : public das::Enumeration {
public:
    EnumerationVkDriverId() : das::Enumeration("VkDriverId") {
        external = true;
        cppName = "VkDriverId";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDriverId >::type >::type;
        VkDriverId enumArray[] = {
            VkDriverId::VK_DRIVER_ID_AMD_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_AMD_OPEN_SOURCE,
            VkDriverId::VK_DRIVER_ID_MESA_RADV,
            VkDriverId::VK_DRIVER_ID_NVIDIA_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
            VkDriverId::VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
            VkDriverId::VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_ARM_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
            VkDriverId::VK_DRIVER_ID_GGP_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_BROADCOM_PROPRIETARY,
            VkDriverId::VK_DRIVER_ID_MESA_LLVMPIPE,
            VkDriverId::VK_DRIVER_ID_MOLTENVK,
            VkDriverId::VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
            VkDriverId::VK_DRIVER_ID_MESA_RADV_KHR,
            VkDriverId::VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
            VkDriverId::VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
            VkDriverId::VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR,
            VkDriverId::VK_DRIVER_ID_GGP_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR,
            VkDriverId::VK_DRIVER_ID_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DRIVER_ID_AMD_PROPRIETARY",
            "VK_DRIVER_ID_AMD_OPEN_SOURCE",
            "VK_DRIVER_ID_MESA_RADV",
            "VK_DRIVER_ID_NVIDIA_PROPRIETARY",
            "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS",
            "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA",
            "VK_DRIVER_ID_IMAGINATION_PROPRIETARY",
            "VK_DRIVER_ID_QUALCOMM_PROPRIETARY",
            "VK_DRIVER_ID_ARM_PROPRIETARY",
            "VK_DRIVER_ID_GOOGLE_SWIFTSHADER",
            "VK_DRIVER_ID_GGP_PROPRIETARY",
            "VK_DRIVER_ID_BROADCOM_PROPRIETARY",
            "VK_DRIVER_ID_MESA_LLVMPIPE",
            "VK_DRIVER_ID_MOLTENVK",
            "VK_DRIVER_ID_AMD_PROPRIETARY_KHR",
            "VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR",
            "VK_DRIVER_ID_MESA_RADV_KHR",
            "VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR",
            "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR",
            "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR",
            "VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR",
            "VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR",
            "VK_DRIVER_ID_ARM_PROPRIETARY_KHR",
            "VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR",
            "VK_DRIVER_ID_GGP_PROPRIETARY_KHR",
            "VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR",
            "VK_DRIVER_ID_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 27; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDriverId > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDriverId");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderFloatControlsIndependence > : cast_enum < VkShaderFloatControlsIndependence > {};
};

class EnumerationVkShaderFloatControlsIndependence : public das::Enumeration {
public:
    EnumerationVkShaderFloatControlsIndependence() : das::Enumeration("VkShaderFloatControlsIndependence") {
        external = true;
        cppName = "VkShaderFloatControlsIndependence";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderFloatControlsIndependence >::type >::type;
        VkShaderFloatControlsIndependence enumArray[] = {
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR,
            VkShaderFloatControlsIndependence::VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR",
            "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderFloatControlsIndependence > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderFloatControlsIndependence");
        }
    };
}
namespace das
{
    template <> struct cast < VkSamplerReductionMode > : cast_enum < VkSamplerReductionMode > {};
};

class EnumerationVkSamplerReductionMode : public das::Enumeration {
public:
    EnumerationVkSamplerReductionMode() : das::Enumeration("VkSamplerReductionMode") {
        external = true;
        cppName = "VkSamplerReductionMode";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSamplerReductionMode >::type >::type;
        VkSamplerReductionMode enumArray[] = {
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MIN,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MAX,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
            VkSamplerReductionMode::VK_SAMPLER_REDUCTION_MODE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE",
            "VK_SAMPLER_REDUCTION_MODE_MIN",
            "VK_SAMPLER_REDUCTION_MODE_MAX",
            "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT",
            "VK_SAMPLER_REDUCTION_MODE_MIN_EXT",
            "VK_SAMPLER_REDUCTION_MODE_MAX_EXT",
            "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSamplerReductionMode > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSamplerReductionMode");
        }
    };
}
namespace das
{
    template <> struct cast < VkSemaphoreType > : cast_enum < VkSemaphoreType > {};
};

class EnumerationVkSemaphoreType : public das::Enumeration {
public:
    EnumerationVkSemaphoreType() : das::Enumeration("VkSemaphoreType") {
        external = true;
        cppName = "VkSemaphoreType";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSemaphoreType >::type >::type;
        VkSemaphoreType enumArray[] = {
            VkSemaphoreType::VK_SEMAPHORE_TYPE_BINARY,
            VkSemaphoreType::VK_SEMAPHORE_TYPE_TIMELINE,
            VkSemaphoreType::VK_SEMAPHORE_TYPE_BINARY_KHR,
            VkSemaphoreType::VK_SEMAPHORE_TYPE_TIMELINE_KHR,
            VkSemaphoreType::VK_SEMAPHORE_TYPE_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SEMAPHORE_TYPE_BINARY",
            "VK_SEMAPHORE_TYPE_TIMELINE",
            "VK_SEMAPHORE_TYPE_BINARY_KHR",
            "VK_SEMAPHORE_TYPE_TIMELINE_KHR",
            "VK_SEMAPHORE_TYPE_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSemaphoreType > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSemaphoreType");
        }
    };
}
namespace das
{
    template <> struct cast < VkResolveModeFlagBits > : cast_enum < VkResolveModeFlagBits > {};
};

class EnumerationVkResolveModeFlagBits : public das::Enumeration {
public:
    EnumerationVkResolveModeFlagBits() : das::Enumeration("VkResolveModeFlagBits") {
        external = true;
        cppName = "VkResolveModeFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkResolveModeFlagBits >::type >::type;
        VkResolveModeFlagBits enumArray[] = {
            VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_NONE_KHR,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_MIN_BIT_KHR,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_MAX_BIT_KHR,
            VkResolveModeFlagBits::VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_RESOLVE_MODE_NONE",
            "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT",
            "VK_RESOLVE_MODE_AVERAGE_BIT",
            "VK_RESOLVE_MODE_MIN_BIT",
            "VK_RESOLVE_MODE_MAX_BIT",
            "VK_RESOLVE_MODE_NONE_KHR",
            "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR",
            "VK_RESOLVE_MODE_AVERAGE_BIT_KHR",
            "VK_RESOLVE_MODE_MIN_BIT_KHR",
            "VK_RESOLVE_MODE_MAX_BIT_KHR",
            "VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 11; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkResolveModeFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkResolveModeFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkDescriptorBindingFlagBits > : cast_enum < VkDescriptorBindingFlagBits > {};
};

class EnumerationVkDescriptorBindingFlagBits : public das::Enumeration {
public:
    EnumerationVkDescriptorBindingFlagBits() : das::Enumeration("VkDescriptorBindingFlagBits") {
        external = true;
        cppName = "VkDescriptorBindingFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDescriptorBindingFlagBits >::type >::type;
        VkDescriptorBindingFlagBits enumArray[] = {
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
            VkDescriptorBindingFlagBits::VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT",
            "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
            "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT",
            "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
            "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT",
            "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT",
            "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT",
            "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT",
            "VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDescriptorBindingFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDescriptorBindingFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkSemaphoreWaitFlagBits > : cast_enum < VkSemaphoreWaitFlagBits > {};
};

class EnumerationVkSemaphoreWaitFlagBits : public das::Enumeration {
public:
    EnumerationVkSemaphoreWaitFlagBits() : das::Enumeration("VkSemaphoreWaitFlagBits") {
        external = true;
        cppName = "VkSemaphoreWaitFlagBits";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSemaphoreWaitFlagBits >::type >::type;
        VkSemaphoreWaitFlagBits enumArray[] = {
            VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT,
            VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
            VkSemaphoreWaitFlagBits::VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM
        };
        static const char *enumArrayName[] = {
            "VK_SEMAPHORE_WAIT_ANY_BIT",
            "VK_SEMAPHORE_WAIT_ANY_BIT_KHR",
            "VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSemaphoreWaitFlagBits > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSemaphoreWaitFlagBits");
        }
    };
}
namespace das
{
    template <> struct cast < VkPresentModeKHR > : cast_enum < VkPresentModeKHR > {};
};

class EnumerationVkPresentModeKHR : public das::Enumeration {
public:
    EnumerationVkPresentModeKHR() : das::Enumeration("VkPresentModeKHR") {
        external = true;
        cppName = "VkPresentModeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPresentModeKHR >::type >::type;
        VkPresentModeKHR enumArray[] = {
            VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_MAILBOX_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_FIFO_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
            VkPresentModeKHR::VK_PRESENT_MODE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PRESENT_MODE_IMMEDIATE_KHR",
            "VK_PRESENT_MODE_MAILBOX_KHR",
            "VK_PRESENT_MODE_FIFO_KHR",
            "VK_PRESENT_MODE_FIFO_RELAXED_KHR",
            "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR",
            "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR",
            "VK_PRESENT_MODE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPresentModeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPresentModeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkColorSpaceKHR > : cast_enum < VkColorSpaceKHR > {};
};

class EnumerationVkColorSpaceKHR : public das::Enumeration {
public:
    EnumerationVkColorSpaceKHR() : das::Enumeration("VkColorSpaceKHR") {
        external = true;
        cppName = "VkColorSpaceKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkColorSpaceKHR >::type >::type;
        VkColorSpaceKHR enumArray[] = {
            VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
            VkColorSpaceKHR::VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_BT709_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_BT2020_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_HDR10_ST2084_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_DOLBYVISION_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_HDR10_HLG_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_PASS_THROUGH_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
            VkColorSpaceKHR::VK_COLORSPACE_SRGB_NONLINEAR_KHR,
            VkColorSpaceKHR::VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
            VkColorSpaceKHR::VK_COLOR_SPACE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR",
            "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT",
            "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT",
            "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT",
            "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT",
            "VK_COLOR_SPACE_BT709_LINEAR_EXT",
            "VK_COLOR_SPACE_BT709_NONLINEAR_EXT",
            "VK_COLOR_SPACE_BT2020_LINEAR_EXT",
            "VK_COLOR_SPACE_HDR10_ST2084_EXT",
            "VK_COLOR_SPACE_DOLBYVISION_EXT",
            "VK_COLOR_SPACE_HDR10_HLG_EXT",
            "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT",
            "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT",
            "VK_COLOR_SPACE_PASS_THROUGH_EXT",
            "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT",
            "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD",
            "VK_COLORSPACE_SRGB_NONLINEAR_KHR",
            "VK_COLOR_SPACE_DCI_P3_LINEAR_EXT",
            "VK_COLOR_SPACE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 19; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkColorSpaceKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkColorSpaceKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkSurfaceTransformFlagBitsKHR > : cast_enum < VkSurfaceTransformFlagBitsKHR > {};
};

class EnumerationVkSurfaceTransformFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkSurfaceTransformFlagBitsKHR() : das::Enumeration("VkSurfaceTransformFlagBitsKHR") {
        external = true;
        cppName = "VkSurfaceTransformFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSurfaceTransformFlagBitsKHR >::type >::type;
        VkSurfaceTransformFlagBitsKHR enumArray[] = {
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
            VkSurfaceTransformFlagBitsKHR::VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR",
            "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR",
            "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR",
            "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR",
            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR",
            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR",
            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR",
            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR",
            "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR",
            "VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 10; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSurfaceTransformFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSurfaceTransformFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkCompositeAlphaFlagBitsKHR > : cast_enum < VkCompositeAlphaFlagBitsKHR > {};
};

class EnumerationVkCompositeAlphaFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkCompositeAlphaFlagBitsKHR() : das::Enumeration("VkCompositeAlphaFlagBitsKHR") {
        external = true;
        cppName = "VkCompositeAlphaFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCompositeAlphaFlagBitsKHR >::type >::type;
        VkCompositeAlphaFlagBitsKHR enumArray[] = {
            VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
            VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
            VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
            VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
            VkCompositeAlphaFlagBitsKHR::VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR",
            "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR",
            "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR",
            "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR",
            "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCompositeAlphaFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCompositeAlphaFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkSwapchainCreateFlagBitsKHR > : cast_enum < VkSwapchainCreateFlagBitsKHR > {};
};

class EnumerationVkSwapchainCreateFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkSwapchainCreateFlagBitsKHR() : das::Enumeration("VkSwapchainCreateFlagBitsKHR") {
        external = true;
        cppName = "VkSwapchainCreateFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSwapchainCreateFlagBitsKHR >::type >::type;
        VkSwapchainCreateFlagBitsKHR enumArray[] = {
            VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
            VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
            VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,
            VkSwapchainCreateFlagBitsKHR::VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR",
            "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR",
            "VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR",
            "VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSwapchainCreateFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSwapchainCreateFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkDeviceGroupPresentModeFlagBitsKHR > : cast_enum < VkDeviceGroupPresentModeFlagBitsKHR > {};
};

class EnumerationVkDeviceGroupPresentModeFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkDeviceGroupPresentModeFlagBitsKHR() : das::Enumeration("VkDeviceGroupPresentModeFlagBitsKHR") {
        external = true;
        cppName = "VkDeviceGroupPresentModeFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDeviceGroupPresentModeFlagBitsKHR >::type >::type;
        VkDeviceGroupPresentModeFlagBitsKHR enumArray[] = {
            VkDeviceGroupPresentModeFlagBitsKHR::VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
            VkDeviceGroupPresentModeFlagBitsKHR::VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
            VkDeviceGroupPresentModeFlagBitsKHR::VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
            VkDeviceGroupPresentModeFlagBitsKHR::VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
            VkDeviceGroupPresentModeFlagBitsKHR::VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR",
            "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR",
            "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR",
            "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR",
            "VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDeviceGroupPresentModeFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDeviceGroupPresentModeFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkDisplayPlaneAlphaFlagBitsKHR > : cast_enum < VkDisplayPlaneAlphaFlagBitsKHR > {};
};

class EnumerationVkDisplayPlaneAlphaFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkDisplayPlaneAlphaFlagBitsKHR() : das::Enumeration("VkDisplayPlaneAlphaFlagBitsKHR") {
        external = true;
        cppName = "VkDisplayPlaneAlphaFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDisplayPlaneAlphaFlagBitsKHR >::type >::type;
        VkDisplayPlaneAlphaFlagBitsKHR enumArray[] = {
            VkDisplayPlaneAlphaFlagBitsKHR::VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
            VkDisplayPlaneAlphaFlagBitsKHR::VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
            VkDisplayPlaneAlphaFlagBitsKHR::VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
            VkDisplayPlaneAlphaFlagBitsKHR::VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
            VkDisplayPlaneAlphaFlagBitsKHR::VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR",
            "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR",
            "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR",
            "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR",
            "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDisplayPlaneAlphaFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDisplayPlaneAlphaFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceCounterUnitKHR > : cast_enum < VkPerformanceCounterUnitKHR > {};
};

class EnumerationVkPerformanceCounterUnitKHR : public das::Enumeration {
public:
    EnumerationVkPerformanceCounterUnitKHR() : das::Enumeration("VkPerformanceCounterUnitKHR") {
        external = true;
        cppName = "VkPerformanceCounterUnitKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceCounterUnitKHR >::type >::type;
        VkPerformanceCounterUnitKHR enumArray[] = {
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
            VkPerformanceCounterUnitKHR::VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR",
            "VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceCounterUnitKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceCounterUnitKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceCounterScopeKHR > : cast_enum < VkPerformanceCounterScopeKHR > {};
};

class EnumerationVkPerformanceCounterScopeKHR : public das::Enumeration {
public:
    EnumerationVkPerformanceCounterScopeKHR() : das::Enumeration("VkPerformanceCounterScopeKHR") {
        external = true;
        cppName = "VkPerformanceCounterScopeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceCounterScopeKHR >::type >::type;
        VkPerformanceCounterScopeKHR enumArray[] = {
            VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
            VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
            VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
            VkPerformanceCounterScopeKHR::VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
            VkPerformanceCounterScopeKHR::VK_QUERY_SCOPE_RENDER_PASS_KHR,
            VkPerformanceCounterScopeKHR::VK_QUERY_SCOPE_COMMAND_KHR,
            VkPerformanceCounterScopeKHR::VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR",
            "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR",
            "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR",
            "VK_QUERY_SCOPE_COMMAND_BUFFER_KHR",
            "VK_QUERY_SCOPE_RENDER_PASS_KHR",
            "VK_QUERY_SCOPE_COMMAND_KHR",
            "VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceCounterScopeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceCounterScopeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceCounterStorageKHR > : cast_enum < VkPerformanceCounterStorageKHR > {};
};

class EnumerationVkPerformanceCounterStorageKHR : public das::Enumeration {
public:
    EnumerationVkPerformanceCounterStorageKHR() : das::Enumeration("VkPerformanceCounterStorageKHR") {
        external = true;
        cppName = "VkPerformanceCounterStorageKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceCounterStorageKHR >::type >::type;
        VkPerformanceCounterStorageKHR enumArray[] = {
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
            VkPerformanceCounterStorageKHR::VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR",
            "VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceCounterStorageKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceCounterStorageKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceCounterDescriptionFlagBitsKHR > : cast_enum < VkPerformanceCounterDescriptionFlagBitsKHR > {};
};

class EnumerationVkPerformanceCounterDescriptionFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkPerformanceCounterDescriptionFlagBitsKHR() : das::Enumeration("VkPerformanceCounterDescriptionFlagBitsKHR") {
        external = true;
        cppName = "VkPerformanceCounterDescriptionFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceCounterDescriptionFlagBitsKHR >::type >::type;
        VkPerformanceCounterDescriptionFlagBitsKHR enumArray[] = {
            VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
            VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
            VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR,
            VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR,
            VkPerformanceCounterDescriptionFlagBitsKHR::VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR",
            "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR",
            "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR",
            "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR",
            "VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceCounterDescriptionFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceCounterDescriptionFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAcquireProfilingLockFlagBitsKHR > : cast_enum < VkAcquireProfilingLockFlagBitsKHR > {};
};

class EnumerationVkAcquireProfilingLockFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkAcquireProfilingLockFlagBitsKHR() : das::Enumeration("VkAcquireProfilingLockFlagBitsKHR") {
        external = true;
        cppName = "VkAcquireProfilingLockFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAcquireProfilingLockFlagBitsKHR >::type >::type;
        VkAcquireProfilingLockFlagBitsKHR enumArray[] = {
            VkAcquireProfilingLockFlagBitsKHR::VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 1; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAcquireProfilingLockFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAcquireProfilingLockFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkFragmentShadingRateCombinerOpKHR > : cast_enum < VkFragmentShadingRateCombinerOpKHR > {};
};

class EnumerationVkFragmentShadingRateCombinerOpKHR : public das::Enumeration {
public:
    EnumerationVkFragmentShadingRateCombinerOpKHR() : das::Enumeration("VkFragmentShadingRateCombinerOpKHR") {
        external = true;
        cppName = "VkFragmentShadingRateCombinerOpKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFragmentShadingRateCombinerOpKHR >::type >::type;
        VkFragmentShadingRateCombinerOpKHR enumArray[] = {
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
            VkFragmentShadingRateCombinerOpKHR::VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR",
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR",
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR",
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR",
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR",
            "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFragmentShadingRateCombinerOpKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFragmentShadingRateCombinerOpKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineExecutableStatisticFormatKHR > : cast_enum < VkPipelineExecutableStatisticFormatKHR > {};
};

class EnumerationVkPipelineExecutableStatisticFormatKHR : public das::Enumeration {
public:
    EnumerationVkPipelineExecutableStatisticFormatKHR() : das::Enumeration("VkPipelineExecutableStatisticFormatKHR") {
        external = true;
        cppName = "VkPipelineExecutableStatisticFormatKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineExecutableStatisticFormatKHR >::type >::type;
        VkPipelineExecutableStatisticFormatKHR enumArray[] = {
            VkPipelineExecutableStatisticFormatKHR::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
            VkPipelineExecutableStatisticFormatKHR::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
            VkPipelineExecutableStatisticFormatKHR::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
            VkPipelineExecutableStatisticFormatKHR::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
            VkPipelineExecutableStatisticFormatKHR::VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR",
            "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR",
            "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR",
            "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR",
            "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineExecutableStatisticFormatKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineExecutableStatisticFormatKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkDebugReportObjectTypeEXT > : cast_enum < VkDebugReportObjectTypeEXT > {};
};

class EnumerationVkDebugReportObjectTypeEXT : public das::Enumeration {
public:
    EnumerationVkDebugReportObjectTypeEXT() : das::Enumeration("VkDebugReportObjectTypeEXT") {
        external = true;
        cppName = "VkDebugReportObjectTypeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDebugReportObjectTypeEXT >::type >::type;
        VkDebugReportObjectTypeEXT enumArray[] = {
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT,
            VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT",
            "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 41; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDebugReportObjectTypeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDebugReportObjectTypeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDebugReportFlagBitsEXT > : cast_enum < VkDebugReportFlagBitsEXT > {};
};

class EnumerationVkDebugReportFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkDebugReportFlagBitsEXT() : das::Enumeration("VkDebugReportFlagBitsEXT") {
        external = true;
        cppName = "VkDebugReportFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDebugReportFlagBitsEXT >::type >::type;
        VkDebugReportFlagBitsEXT enumArray[] = {
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_WARNING_BIT_EXT,
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_ERROR_BIT_EXT,
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_DEBUG_BIT_EXT,
            VkDebugReportFlagBitsEXT::VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEBUG_REPORT_INFORMATION_BIT_EXT",
            "VK_DEBUG_REPORT_WARNING_BIT_EXT",
            "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT",
            "VK_DEBUG_REPORT_ERROR_BIT_EXT",
            "VK_DEBUG_REPORT_DEBUG_BIT_EXT",
            "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDebugReportFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDebugReportFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkRasterizationOrderAMD > : cast_enum < VkRasterizationOrderAMD > {};
};

class EnumerationVkRasterizationOrderAMD : public das::Enumeration {
public:
    EnumerationVkRasterizationOrderAMD() : das::Enumeration("VkRasterizationOrderAMD") {
        external = true;
        cppName = "VkRasterizationOrderAMD";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkRasterizationOrderAMD >::type >::type;
        VkRasterizationOrderAMD enumArray[] = {
            VkRasterizationOrderAMD::VK_RASTERIZATION_ORDER_STRICT_AMD,
            VkRasterizationOrderAMD::VK_RASTERIZATION_ORDER_RELAXED_AMD,
            VkRasterizationOrderAMD::VK_RASTERIZATION_ORDER_MAX_ENUM_AMD
        };
        static const char *enumArrayName[] = {
            "VK_RASTERIZATION_ORDER_STRICT_AMD",
            "VK_RASTERIZATION_ORDER_RELAXED_AMD",
            "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkRasterizationOrderAMD > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkRasterizationOrderAMD");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderInfoTypeAMD > : cast_enum < VkShaderInfoTypeAMD > {};
};

class EnumerationVkShaderInfoTypeAMD : public das::Enumeration {
public:
    EnumerationVkShaderInfoTypeAMD() : das::Enumeration("VkShaderInfoTypeAMD") {
        external = true;
        cppName = "VkShaderInfoTypeAMD";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderInfoTypeAMD >::type >::type;
        VkShaderInfoTypeAMD enumArray[] = {
            VkShaderInfoTypeAMD::VK_SHADER_INFO_TYPE_STATISTICS_AMD,
            VkShaderInfoTypeAMD::VK_SHADER_INFO_TYPE_BINARY_AMD,
            VkShaderInfoTypeAMD::VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
            VkShaderInfoTypeAMD::VK_SHADER_INFO_TYPE_MAX_ENUM_AMD
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_INFO_TYPE_STATISTICS_AMD",
            "VK_SHADER_INFO_TYPE_BINARY_AMD",
            "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD",
            "VK_SHADER_INFO_TYPE_MAX_ENUM_AMD"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderInfoTypeAMD > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderInfoTypeAMD");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalMemoryHandleTypeFlagBitsNV > : cast_enum < VkExternalMemoryHandleTypeFlagBitsNV > {};
};

class EnumerationVkExternalMemoryHandleTypeFlagBitsNV : public das::Enumeration {
public:
    EnumerationVkExternalMemoryHandleTypeFlagBitsNV() : das::Enumeration("VkExternalMemoryHandleTypeFlagBitsNV") {
        external = true;
        cppName = "VkExternalMemoryHandleTypeFlagBitsNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalMemoryHandleTypeFlagBitsNV >::type >::type;
        VkExternalMemoryHandleTypeFlagBitsNV enumArray[] = {
            VkExternalMemoryHandleTypeFlagBitsNV::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
            VkExternalMemoryHandleTypeFlagBitsNV::VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
            VkExternalMemoryHandleTypeFlagBitsNV::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
            VkExternalMemoryHandleTypeFlagBitsNV::VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
            VkExternalMemoryHandleTypeFlagBitsNV::VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV",
            "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalMemoryHandleTypeFlagBitsNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalMemoryHandleTypeFlagBitsNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkExternalMemoryFeatureFlagBitsNV > : cast_enum < VkExternalMemoryFeatureFlagBitsNV > {};
};

class EnumerationVkExternalMemoryFeatureFlagBitsNV : public das::Enumeration {
public:
    EnumerationVkExternalMemoryFeatureFlagBitsNV() : das::Enumeration("VkExternalMemoryFeatureFlagBitsNV") {
        external = true;
        cppName = "VkExternalMemoryFeatureFlagBitsNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkExternalMemoryFeatureFlagBitsNV >::type >::type;
        VkExternalMemoryFeatureFlagBitsNV enumArray[] = {
            VkExternalMemoryFeatureFlagBitsNV::VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
            VkExternalMemoryFeatureFlagBitsNV::VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
            VkExternalMemoryFeatureFlagBitsNV::VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
            VkExternalMemoryFeatureFlagBitsNV::VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV",
            "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV",
            "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV",
            "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkExternalMemoryFeatureFlagBitsNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkExternalMemoryFeatureFlagBitsNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkValidationCheckEXT > : cast_enum < VkValidationCheckEXT > {};
};

class EnumerationVkValidationCheckEXT : public das::Enumeration {
public:
    EnumerationVkValidationCheckEXT() : das::Enumeration("VkValidationCheckEXT") {
        external = true;
        cppName = "VkValidationCheckEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkValidationCheckEXT >::type >::type;
        VkValidationCheckEXT enumArray[] = {
            VkValidationCheckEXT::VK_VALIDATION_CHECK_ALL_EXT,
            VkValidationCheckEXT::VK_VALIDATION_CHECK_SHADERS_EXT,
            VkValidationCheckEXT::VK_VALIDATION_CHECK_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_VALIDATION_CHECK_ALL_EXT",
            "VK_VALIDATION_CHECK_SHADERS_EXT",
            "VK_VALIDATION_CHECK_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkValidationCheckEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkValidationCheckEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkConditionalRenderingFlagBitsEXT > : cast_enum < VkConditionalRenderingFlagBitsEXT > {};
};

class EnumerationVkConditionalRenderingFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkConditionalRenderingFlagBitsEXT() : das::Enumeration("VkConditionalRenderingFlagBitsEXT") {
        external = true;
        cppName = "VkConditionalRenderingFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkConditionalRenderingFlagBitsEXT >::type >::type;
        VkConditionalRenderingFlagBitsEXT enumArray[] = {
            VkConditionalRenderingFlagBitsEXT::VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
            VkConditionalRenderingFlagBitsEXT::VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT",
            "VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkConditionalRenderingFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkConditionalRenderingFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkSurfaceCounterFlagBitsEXT > : cast_enum < VkSurfaceCounterFlagBitsEXT > {};
};

class EnumerationVkSurfaceCounterFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkSurfaceCounterFlagBitsEXT() : das::Enumeration("VkSurfaceCounterFlagBitsEXT") {
        external = true;
        cppName = "VkSurfaceCounterFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkSurfaceCounterFlagBitsEXT >::type >::type;
        VkSurfaceCounterFlagBitsEXT enumArray[] = {
            VkSurfaceCounterFlagBitsEXT::VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
            VkSurfaceCounterFlagBitsEXT::VK_SURFACE_COUNTER_VBLANK_EXT,
            VkSurfaceCounterFlagBitsEXT::VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_SURFACE_COUNTER_VBLANK_BIT_EXT",
            "VK_SURFACE_COUNTER_VBLANK_EXT",
            "VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkSurfaceCounterFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkSurfaceCounterFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDisplayPowerStateEXT > : cast_enum < VkDisplayPowerStateEXT > {};
};

class EnumerationVkDisplayPowerStateEXT : public das::Enumeration {
public:
    EnumerationVkDisplayPowerStateEXT() : das::Enumeration("VkDisplayPowerStateEXT") {
        external = true;
        cppName = "VkDisplayPowerStateEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDisplayPowerStateEXT >::type >::type;
        VkDisplayPowerStateEXT enumArray[] = {
            VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_OFF_EXT,
            VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
            VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_ON_EXT,
            VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DISPLAY_POWER_STATE_OFF_EXT",
            "VK_DISPLAY_POWER_STATE_SUSPEND_EXT",
            "VK_DISPLAY_POWER_STATE_ON_EXT",
            "VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDisplayPowerStateEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDisplayPowerStateEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDeviceEventTypeEXT > : cast_enum < VkDeviceEventTypeEXT > {};
};

class EnumerationVkDeviceEventTypeEXT : public das::Enumeration {
public:
    EnumerationVkDeviceEventTypeEXT() : das::Enumeration("VkDeviceEventTypeEXT") {
        external = true;
        cppName = "VkDeviceEventTypeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDeviceEventTypeEXT >::type >::type;
        VkDeviceEventTypeEXT enumArray[] = {
            VkDeviceEventTypeEXT::VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
            VkDeviceEventTypeEXT::VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT",
            "VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDeviceEventTypeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDeviceEventTypeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDisplayEventTypeEXT > : cast_enum < VkDisplayEventTypeEXT > {};
};

class EnumerationVkDisplayEventTypeEXT : public das::Enumeration {
public:
    EnumerationVkDisplayEventTypeEXT() : das::Enumeration("VkDisplayEventTypeEXT") {
        external = true;
        cppName = "VkDisplayEventTypeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDisplayEventTypeEXT >::type >::type;
        VkDisplayEventTypeEXT enumArray[] = {
            VkDisplayEventTypeEXT::VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
            VkDisplayEventTypeEXT::VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT",
            "VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDisplayEventTypeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDisplayEventTypeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkViewportCoordinateSwizzleNV > : cast_enum < VkViewportCoordinateSwizzleNV > {};
};

class EnumerationVkViewportCoordinateSwizzleNV : public das::Enumeration {
public:
    EnumerationVkViewportCoordinateSwizzleNV() : das::Enumeration("VkViewportCoordinateSwizzleNV") {
        external = true;
        cppName = "VkViewportCoordinateSwizzleNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkViewportCoordinateSwizzleNV >::type >::type;
        VkViewportCoordinateSwizzleNV enumArray[] = {
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
            VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV",
            "VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkViewportCoordinateSwizzleNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkViewportCoordinateSwizzleNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkDiscardRectangleModeEXT > : cast_enum < VkDiscardRectangleModeEXT > {};
};

class EnumerationVkDiscardRectangleModeEXT : public das::Enumeration {
public:
    EnumerationVkDiscardRectangleModeEXT() : das::Enumeration("VkDiscardRectangleModeEXT") {
        external = true;
        cppName = "VkDiscardRectangleModeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDiscardRectangleModeEXT >::type >::type;
        VkDiscardRectangleModeEXT enumArray[] = {
            VkDiscardRectangleModeEXT::VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
            VkDiscardRectangleModeEXT::VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
            VkDiscardRectangleModeEXT::VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT",
            "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT",
            "VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDiscardRectangleModeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDiscardRectangleModeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkConservativeRasterizationModeEXT > : cast_enum < VkConservativeRasterizationModeEXT > {};
};

class EnumerationVkConservativeRasterizationModeEXT : public das::Enumeration {
public:
    EnumerationVkConservativeRasterizationModeEXT() : das::Enumeration("VkConservativeRasterizationModeEXT") {
        external = true;
        cppName = "VkConservativeRasterizationModeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkConservativeRasterizationModeEXT >::type >::type;
        VkConservativeRasterizationModeEXT enumArray[] = {
            VkConservativeRasterizationModeEXT::VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
            VkConservativeRasterizationModeEXT::VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
            VkConservativeRasterizationModeEXT::VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
            VkConservativeRasterizationModeEXT::VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT",
            "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT",
            "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT",
            "VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkConservativeRasterizationModeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkConservativeRasterizationModeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDebugUtilsMessageSeverityFlagBitsEXT > : cast_enum < VkDebugUtilsMessageSeverityFlagBitsEXT > {};
};

class EnumerationVkDebugUtilsMessageSeverityFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkDebugUtilsMessageSeverityFlagBitsEXT() : das::Enumeration("VkDebugUtilsMessageSeverityFlagBitsEXT") {
        external = true;
        cppName = "VkDebugUtilsMessageSeverityFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDebugUtilsMessageSeverityFlagBitsEXT >::type >::type;
        VkDebugUtilsMessageSeverityFlagBitsEXT enumArray[] = {
            VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
            VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
            VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
            VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
            VkDebugUtilsMessageSeverityFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDebugUtilsMessageSeverityFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDebugUtilsMessageSeverityFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDebugUtilsMessageTypeFlagBitsEXT > : cast_enum < VkDebugUtilsMessageTypeFlagBitsEXT > {};
};

class EnumerationVkDebugUtilsMessageTypeFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkDebugUtilsMessageTypeFlagBitsEXT() : das::Enumeration("VkDebugUtilsMessageTypeFlagBitsEXT") {
        external = true;
        cppName = "VkDebugUtilsMessageTypeFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDebugUtilsMessageTypeFlagBitsEXT >::type >::type;
        VkDebugUtilsMessageTypeFlagBitsEXT enumArray[] = {
            VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
            VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
            VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
            VkDebugUtilsMessageTypeFlagBitsEXT::VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT",
            "VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDebugUtilsMessageTypeFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDebugUtilsMessageTypeFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkBlendOverlapEXT > : cast_enum < VkBlendOverlapEXT > {};
};

class EnumerationVkBlendOverlapEXT : public das::Enumeration {
public:
    EnumerationVkBlendOverlapEXT() : das::Enumeration("VkBlendOverlapEXT") {
        external = true;
        cppName = "VkBlendOverlapEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBlendOverlapEXT >::type >::type;
        VkBlendOverlapEXT enumArray[] = {
            VkBlendOverlapEXT::VK_BLEND_OVERLAP_UNCORRELATED_EXT,
            VkBlendOverlapEXT::VK_BLEND_OVERLAP_DISJOINT_EXT,
            VkBlendOverlapEXT::VK_BLEND_OVERLAP_CONJOINT_EXT,
            VkBlendOverlapEXT::VK_BLEND_OVERLAP_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_BLEND_OVERLAP_UNCORRELATED_EXT",
            "VK_BLEND_OVERLAP_DISJOINT_EXT",
            "VK_BLEND_OVERLAP_CONJOINT_EXT",
            "VK_BLEND_OVERLAP_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBlendOverlapEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBlendOverlapEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkCoverageModulationModeNV > : cast_enum < VkCoverageModulationModeNV > {};
};

class EnumerationVkCoverageModulationModeNV : public das::Enumeration {
public:
    EnumerationVkCoverageModulationModeNV() : das::Enumeration("VkCoverageModulationModeNV") {
        external = true;
        cppName = "VkCoverageModulationModeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCoverageModulationModeNV >::type >::type;
        VkCoverageModulationModeNV enumArray[] = {
            VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_NONE_NV,
            VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_RGB_NV,
            VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
            VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_RGBA_NV,
            VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_COVERAGE_MODULATION_MODE_NONE_NV",
            "VK_COVERAGE_MODULATION_MODE_RGB_NV",
            "VK_COVERAGE_MODULATION_MODE_ALPHA_NV",
            "VK_COVERAGE_MODULATION_MODE_RGBA_NV",
            "VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCoverageModulationModeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCoverageModulationModeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkValidationCacheHeaderVersionEXT > : cast_enum < VkValidationCacheHeaderVersionEXT > {};
};

class EnumerationVkValidationCacheHeaderVersionEXT : public das::Enumeration {
public:
    EnumerationVkValidationCacheHeaderVersionEXT() : das::Enumeration("VkValidationCacheHeaderVersionEXT") {
        external = true;
        cppName = "VkValidationCacheHeaderVersionEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkValidationCacheHeaderVersionEXT >::type >::type;
        VkValidationCacheHeaderVersionEXT enumArray[] = {
            VkValidationCacheHeaderVersionEXT::VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
            VkValidationCacheHeaderVersionEXT::VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT",
            "VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkValidationCacheHeaderVersionEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkValidationCacheHeaderVersionEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkShadingRatePaletteEntryNV > : cast_enum < VkShadingRatePaletteEntryNV > {};
};

class EnumerationVkShadingRatePaletteEntryNV : public das::Enumeration {
public:
    EnumerationVkShadingRatePaletteEntryNV() : das::Enumeration("VkShadingRatePaletteEntryNV") {
        external = true;
        cppName = "VkShadingRatePaletteEntryNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShadingRatePaletteEntryNV >::type >::type;
        VkShadingRatePaletteEntryNV enumArray[] = {
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
            VkShadingRatePaletteEntryNV::VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV",
            "VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 13; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShadingRatePaletteEntryNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShadingRatePaletteEntryNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkCoarseSampleOrderTypeNV > : cast_enum < VkCoarseSampleOrderTypeNV > {};
};

class EnumerationVkCoarseSampleOrderTypeNV : public das::Enumeration {
public:
    EnumerationVkCoarseSampleOrderTypeNV() : das::Enumeration("VkCoarseSampleOrderTypeNV") {
        external = true;
        cppName = "VkCoarseSampleOrderTypeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCoarseSampleOrderTypeNV >::type >::type;
        VkCoarseSampleOrderTypeNV enumArray[] = {
            VkCoarseSampleOrderTypeNV::VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
            VkCoarseSampleOrderTypeNV::VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
            VkCoarseSampleOrderTypeNV::VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
            VkCoarseSampleOrderTypeNV::VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
            VkCoarseSampleOrderTypeNV::VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV",
            "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV",
            "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV",
            "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV",
            "VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCoarseSampleOrderTypeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCoarseSampleOrderTypeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkRayTracingShaderGroupTypeKHR > : cast_enum < VkRayTracingShaderGroupTypeKHR > {};
};

class EnumerationVkRayTracingShaderGroupTypeKHR : public das::Enumeration {
public:
    EnumerationVkRayTracingShaderGroupTypeKHR() : das::Enumeration("VkRayTracingShaderGroupTypeKHR") {
        external = true;
        cppName = "VkRayTracingShaderGroupTypeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkRayTracingShaderGroupTypeKHR >::type >::type;
        VkRayTracingShaderGroupTypeKHR enumArray[] = {
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV,
            VkRayTracingShaderGroupTypeKHR::VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV",
            "VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkRayTracingShaderGroupTypeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkRayTracingShaderGroupTypeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkGeometryTypeKHR > : cast_enum < VkGeometryTypeKHR > {};
};

class EnumerationVkGeometryTypeKHR : public das::Enumeration {
public:
    EnumerationVkGeometryTypeKHR() : das::Enumeration("VkGeometryTypeKHR") {
        external = true;
        cppName = "VkGeometryTypeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkGeometryTypeKHR >::type >::type;
        VkGeometryTypeKHR enumArray[] = {
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_TRIANGLES_KHR,
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_AABBS_KHR,
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_INSTANCES_KHR,
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_TRIANGLES_NV,
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_AABBS_NV,
            VkGeometryTypeKHR::VK_GEOMETRY_TYPE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_GEOMETRY_TYPE_TRIANGLES_KHR",
            "VK_GEOMETRY_TYPE_AABBS_KHR",
            "VK_GEOMETRY_TYPE_INSTANCES_KHR",
            "VK_GEOMETRY_TYPE_TRIANGLES_NV",
            "VK_GEOMETRY_TYPE_AABBS_NV",
            "VK_GEOMETRY_TYPE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkGeometryTypeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkGeometryTypeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccelerationStructureTypeKHR > : cast_enum < VkAccelerationStructureTypeKHR > {};
};

class EnumerationVkAccelerationStructureTypeKHR : public das::Enumeration {
public:
    EnumerationVkAccelerationStructureTypeKHR() : das::Enumeration("VkAccelerationStructureTypeKHR") {
        external = true;
        cppName = "VkAccelerationStructureTypeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccelerationStructureTypeKHR >::type >::type;
        VkAccelerationStructureTypeKHR enumArray[] = {
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV,
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV,
            VkAccelerationStructureTypeKHR::VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR",
            "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR",
            "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR",
            "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV",
            "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV",
            "VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccelerationStructureTypeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccelerationStructureTypeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkCopyAccelerationStructureModeKHR > : cast_enum < VkCopyAccelerationStructureModeKHR > {};
};

class EnumerationVkCopyAccelerationStructureModeKHR : public das::Enumeration {
public:
    EnumerationVkCopyAccelerationStructureModeKHR() : das::Enumeration("VkCopyAccelerationStructureModeKHR") {
        external = true;
        cppName = "VkCopyAccelerationStructureModeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCopyAccelerationStructureModeKHR >::type >::type;
        VkCopyAccelerationStructureModeKHR enumArray[] = {
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV,
            VkCopyAccelerationStructureModeKHR::VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV",
            "VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 7; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCopyAccelerationStructureModeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCopyAccelerationStructureModeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccelerationStructureMemoryRequirementsTypeNV > : cast_enum < VkAccelerationStructureMemoryRequirementsTypeNV > {};
};

class EnumerationVkAccelerationStructureMemoryRequirementsTypeNV : public das::Enumeration {
public:
    EnumerationVkAccelerationStructureMemoryRequirementsTypeNV() : das::Enumeration("VkAccelerationStructureMemoryRequirementsTypeNV") {
        external = true;
        cppName = "VkAccelerationStructureMemoryRequirementsTypeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccelerationStructureMemoryRequirementsTypeNV >::type >::type;
        VkAccelerationStructureMemoryRequirementsTypeNV enumArray[] = {
            VkAccelerationStructureMemoryRequirementsTypeNV::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
            VkAccelerationStructureMemoryRequirementsTypeNV::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
            VkAccelerationStructureMemoryRequirementsTypeNV::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
            VkAccelerationStructureMemoryRequirementsTypeNV::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV",
            "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV",
            "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV",
            "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccelerationStructureMemoryRequirementsTypeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccelerationStructureMemoryRequirementsTypeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkGeometryFlagBitsKHR > : cast_enum < VkGeometryFlagBitsKHR > {};
};

class EnumerationVkGeometryFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkGeometryFlagBitsKHR() : das::Enumeration("VkGeometryFlagBitsKHR") {
        external = true;
        cppName = "VkGeometryFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkGeometryFlagBitsKHR >::type >::type;
        VkGeometryFlagBitsKHR enumArray[] = {
            VkGeometryFlagBitsKHR::VK_GEOMETRY_OPAQUE_BIT_KHR,
            VkGeometryFlagBitsKHR::VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
            VkGeometryFlagBitsKHR::VK_GEOMETRY_OPAQUE_BIT_NV,
            VkGeometryFlagBitsKHR::VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
            VkGeometryFlagBitsKHR::VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_GEOMETRY_OPAQUE_BIT_KHR",
            "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR",
            "VK_GEOMETRY_OPAQUE_BIT_NV",
            "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV",
            "VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkGeometryFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkGeometryFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkGeometryInstanceFlagBitsKHR > : cast_enum < VkGeometryInstanceFlagBitsKHR > {};
};

class EnumerationVkGeometryInstanceFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkGeometryInstanceFlagBitsKHR() : das::Enumeration("VkGeometryInstanceFlagBitsKHR") {
        external = true;
        cppName = "VkGeometryInstanceFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkGeometryInstanceFlagBitsKHR >::type >::type;
        VkGeometryInstanceFlagBitsKHR enumArray[] = {
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
            VkGeometryInstanceFlagBitsKHR::VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR",
            "VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR",
            "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR",
            "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR",
            "VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV",
            "VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV",
            "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV",
            "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV",
            "VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkGeometryInstanceFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkGeometryInstanceFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkBuildAccelerationStructureFlagBitsKHR > : cast_enum < VkBuildAccelerationStructureFlagBitsKHR > {};
};

class EnumerationVkBuildAccelerationStructureFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkBuildAccelerationStructureFlagBitsKHR() : das::Enumeration("VkBuildAccelerationStructureFlagBitsKHR") {
        external = true;
        cppName = "VkBuildAccelerationStructureFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBuildAccelerationStructureFlagBitsKHR >::type >::type;
        VkBuildAccelerationStructureFlagBitsKHR enumArray[] = {
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
            VkBuildAccelerationStructureFlagBitsKHR::VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV",
            "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV",
            "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV",
            "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV",
            "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV",
            "VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 11; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBuildAccelerationStructureFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBuildAccelerationStructureFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueueGlobalPriorityEXT > : cast_enum < VkQueueGlobalPriorityEXT > {};
};

class EnumerationVkQueueGlobalPriorityEXT : public das::Enumeration {
public:
    EnumerationVkQueueGlobalPriorityEXT() : das::Enumeration("VkQueueGlobalPriorityEXT") {
        external = true;
        cppName = "VkQueueGlobalPriorityEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueueGlobalPriorityEXT >::type >::type;
        VkQueueGlobalPriorityEXT enumArray[] = {
            VkQueueGlobalPriorityEXT::VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
            VkQueueGlobalPriorityEXT::VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
            VkQueueGlobalPriorityEXT::VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
            VkQueueGlobalPriorityEXT::VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
            VkQueueGlobalPriorityEXT::VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT",
            "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT",
            "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT",
            "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT",
            "VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueueGlobalPriorityEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueueGlobalPriorityEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineCompilerControlFlagBitsAMD > : cast_enum < VkPipelineCompilerControlFlagBitsAMD > {};
};

class EnumerationVkPipelineCompilerControlFlagBitsAMD : public das::Enumeration {
public:
    EnumerationVkPipelineCompilerControlFlagBitsAMD() : das::Enumeration("VkPipelineCompilerControlFlagBitsAMD") {
        external = true;
        cppName = "VkPipelineCompilerControlFlagBitsAMD";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineCompilerControlFlagBitsAMD >::type >::type;
        VkPipelineCompilerControlFlagBitsAMD enumArray[] = {
            VkPipelineCompilerControlFlagBitsAMD::VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD"
        };
        for (uint32_t i = 0; i < 1; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineCompilerControlFlagBitsAMD > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineCompilerControlFlagBitsAMD");
        }
    };
}
namespace das
{
    template <> struct cast < VkTimeDomainEXT > : cast_enum < VkTimeDomainEXT > {};
};

class EnumerationVkTimeDomainEXT : public das::Enumeration {
public:
    EnumerationVkTimeDomainEXT() : das::Enumeration("VkTimeDomainEXT") {
        external = true;
        cppName = "VkTimeDomainEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkTimeDomainEXT >::type >::type;
        VkTimeDomainEXT enumArray[] = {
            VkTimeDomainEXT::VK_TIME_DOMAIN_DEVICE_EXT,
            VkTimeDomainEXT::VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT,
            VkTimeDomainEXT::VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT,
            VkTimeDomainEXT::VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT,
            VkTimeDomainEXT::VK_TIME_DOMAIN_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_TIME_DOMAIN_DEVICE_EXT",
            "VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT",
            "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT",
            "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT",
            "VK_TIME_DOMAIN_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkTimeDomainEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkTimeDomainEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkMemoryOverallocationBehaviorAMD > : cast_enum < VkMemoryOverallocationBehaviorAMD > {};
};

class EnumerationVkMemoryOverallocationBehaviorAMD : public das::Enumeration {
public:
    EnumerationVkMemoryOverallocationBehaviorAMD() : das::Enumeration("VkMemoryOverallocationBehaviorAMD") {
        external = true;
        cppName = "VkMemoryOverallocationBehaviorAMD";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkMemoryOverallocationBehaviorAMD >::type >::type;
        VkMemoryOverallocationBehaviorAMD enumArray[] = {
            VkMemoryOverallocationBehaviorAMD::VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
            VkMemoryOverallocationBehaviorAMD::VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
            VkMemoryOverallocationBehaviorAMD::VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
            VkMemoryOverallocationBehaviorAMD::VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD
        };
        static const char *enumArrayName[] = {
            "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD",
            "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD",
            "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD",
            "VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkMemoryOverallocationBehaviorAMD > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkMemoryOverallocationBehaviorAMD");
        }
    };
}
namespace das
{
    template <> struct cast < VkPipelineCreationFeedbackFlagBitsEXT > : cast_enum < VkPipelineCreationFeedbackFlagBitsEXT > {};
};

class EnumerationVkPipelineCreationFeedbackFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkPipelineCreationFeedbackFlagBitsEXT() : das::Enumeration("VkPipelineCreationFeedbackFlagBitsEXT") {
        external = true;
        cppName = "VkPipelineCreationFeedbackFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPipelineCreationFeedbackFlagBitsEXT >::type >::type;
        VkPipelineCreationFeedbackFlagBitsEXT enumArray[] = {
            VkPipelineCreationFeedbackFlagBitsEXT::VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT,
            VkPipelineCreationFeedbackFlagBitsEXT::VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT,
            VkPipelineCreationFeedbackFlagBitsEXT::VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT,
            VkPipelineCreationFeedbackFlagBitsEXT::VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT",
            "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT",
            "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT",
            "VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPipelineCreationFeedbackFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPipelineCreationFeedbackFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceConfigurationTypeINTEL > : cast_enum < VkPerformanceConfigurationTypeINTEL > {};
};

class EnumerationVkPerformanceConfigurationTypeINTEL : public das::Enumeration {
public:
    EnumerationVkPerformanceConfigurationTypeINTEL() : das::Enumeration("VkPerformanceConfigurationTypeINTEL") {
        external = true;
        cppName = "VkPerformanceConfigurationTypeINTEL";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceConfigurationTypeINTEL >::type >::type;
        VkPerformanceConfigurationTypeINTEL enumArray[] = {
            VkPerformanceConfigurationTypeINTEL::VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
            VkPerformanceConfigurationTypeINTEL::VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL",
            "VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceConfigurationTypeINTEL > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceConfigurationTypeINTEL");
        }
    };
}
namespace das
{
    template <> struct cast < VkQueryPoolSamplingModeINTEL > : cast_enum < VkQueryPoolSamplingModeINTEL > {};
};

class EnumerationVkQueryPoolSamplingModeINTEL : public das::Enumeration {
public:
    EnumerationVkQueryPoolSamplingModeINTEL() : das::Enumeration("VkQueryPoolSamplingModeINTEL") {
        external = true;
        cppName = "VkQueryPoolSamplingModeINTEL";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkQueryPoolSamplingModeINTEL >::type >::type;
        VkQueryPoolSamplingModeINTEL enumArray[] = {
            VkQueryPoolSamplingModeINTEL::VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
            VkQueryPoolSamplingModeINTEL::VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL
        };
        static const char *enumArrayName[] = {
            "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL",
            "VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkQueryPoolSamplingModeINTEL > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkQueryPoolSamplingModeINTEL");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceOverrideTypeINTEL > : cast_enum < VkPerformanceOverrideTypeINTEL > {};
};

class EnumerationVkPerformanceOverrideTypeINTEL : public das::Enumeration {
public:
    EnumerationVkPerformanceOverrideTypeINTEL() : das::Enumeration("VkPerformanceOverrideTypeINTEL") {
        external = true;
        cppName = "VkPerformanceOverrideTypeINTEL";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceOverrideTypeINTEL >::type >::type;
        VkPerformanceOverrideTypeINTEL enumArray[] = {
            VkPerformanceOverrideTypeINTEL::VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
            VkPerformanceOverrideTypeINTEL::VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
            VkPerformanceOverrideTypeINTEL::VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL",
            "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL",
            "VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceOverrideTypeINTEL > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceOverrideTypeINTEL");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceParameterTypeINTEL > : cast_enum < VkPerformanceParameterTypeINTEL > {};
};

class EnumerationVkPerformanceParameterTypeINTEL : public das::Enumeration {
public:
    EnumerationVkPerformanceParameterTypeINTEL() : das::Enumeration("VkPerformanceParameterTypeINTEL") {
        external = true;
        cppName = "VkPerformanceParameterTypeINTEL";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceParameterTypeINTEL >::type >::type;
        VkPerformanceParameterTypeINTEL enumArray[] = {
            VkPerformanceParameterTypeINTEL::VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
            VkPerformanceParameterTypeINTEL::VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
            VkPerformanceParameterTypeINTEL::VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL",
            "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL",
            "VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceParameterTypeINTEL > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceParameterTypeINTEL");
        }
    };
}
namespace das
{
    template <> struct cast < VkPerformanceValueTypeINTEL > : cast_enum < VkPerformanceValueTypeINTEL > {};
};

class EnumerationVkPerformanceValueTypeINTEL : public das::Enumeration {
public:
    EnumerationVkPerformanceValueTypeINTEL() : das::Enumeration("VkPerformanceValueTypeINTEL") {
        external = true;
        cppName = "VkPerformanceValueTypeINTEL";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPerformanceValueTypeINTEL >::type >::type;
        VkPerformanceValueTypeINTEL enumArray[] = {
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
            VkPerformanceValueTypeINTEL::VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL
        };
        static const char *enumArrayName[] = {
            "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL",
            "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL",
            "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL",
            "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL",
            "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL",
            "VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPerformanceValueTypeINTEL > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPerformanceValueTypeINTEL");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderCorePropertiesFlagBitsAMD > : cast_enum < VkShaderCorePropertiesFlagBitsAMD > {};
};

class EnumerationVkShaderCorePropertiesFlagBitsAMD : public das::Enumeration {
public:
    EnumerationVkShaderCorePropertiesFlagBitsAMD() : das::Enumeration("VkShaderCorePropertiesFlagBitsAMD") {
        external = true;
        cppName = "VkShaderCorePropertiesFlagBitsAMD";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderCorePropertiesFlagBitsAMD >::type >::type;
        VkShaderCorePropertiesFlagBitsAMD enumArray[] = {
            VkShaderCorePropertiesFlagBitsAMD::VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD"
        };
        for (uint32_t i = 0; i < 1; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderCorePropertiesFlagBitsAMD > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderCorePropertiesFlagBitsAMD");
        }
    };
}
namespace das
{
    template <> struct cast < VkToolPurposeFlagBitsEXT > : cast_enum < VkToolPurposeFlagBitsEXT > {};
};

class EnumerationVkToolPurposeFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkToolPurposeFlagBitsEXT() : das::Enumeration("VkToolPurposeFlagBitsEXT") {
        external = true;
        cppName = "VkToolPurposeFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkToolPurposeFlagBitsEXT >::type >::type;
        VkToolPurposeFlagBitsEXT enumArray[] = {
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_VALIDATION_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_PROFILING_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_TRACING_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT,
            VkToolPurposeFlagBitsEXT::VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_TOOL_PURPOSE_VALIDATION_BIT_EXT",
            "VK_TOOL_PURPOSE_PROFILING_BIT_EXT",
            "VK_TOOL_PURPOSE_TRACING_BIT_EXT",
            "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT",
            "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT",
            "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT",
            "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT",
            "VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkToolPurposeFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkToolPurposeFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkValidationFeatureEnableEXT > : cast_enum < VkValidationFeatureEnableEXT > {};
};

class EnumerationVkValidationFeatureEnableEXT : public das::Enumeration {
public:
    EnumerationVkValidationFeatureEnableEXT() : das::Enumeration("VkValidationFeatureEnableEXT") {
        external = true;
        cppName = "VkValidationFeatureEnableEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkValidationFeatureEnableEXT >::type >::type;
        VkValidationFeatureEnableEXT enumArray[] = {
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
            VkValidationFeatureEnableEXT::VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT",
            "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT",
            "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT",
            "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT",
            "VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT",
            "VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkValidationFeatureEnableEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkValidationFeatureEnableEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkValidationFeatureDisableEXT > : cast_enum < VkValidationFeatureDisableEXT > {};
};

class EnumerationVkValidationFeatureDisableEXT : public das::Enumeration {
public:
    EnumerationVkValidationFeatureDisableEXT() : das::Enumeration("VkValidationFeatureDisableEXT") {
        external = true;
        cppName = "VkValidationFeatureDisableEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkValidationFeatureDisableEXT >::type >::type;
        VkValidationFeatureDisableEXT enumArray[] = {
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
            VkValidationFeatureDisableEXT::VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT",
            "VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 8; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkValidationFeatureDisableEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkValidationFeatureDisableEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkComponentTypeNV > : cast_enum < VkComponentTypeNV > {};
};

class EnumerationVkComponentTypeNV : public das::Enumeration {
public:
    EnumerationVkComponentTypeNV() : das::Enumeration("VkComponentTypeNV") {
        external = true;
        cppName = "VkComponentTypeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkComponentTypeNV >::type >::type;
        VkComponentTypeNV enumArray[] = {
            VkComponentTypeNV::VK_COMPONENT_TYPE_FLOAT16_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_FLOAT32_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_FLOAT64_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_SINT8_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_SINT16_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_SINT32_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_SINT64_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_UINT8_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_UINT16_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_UINT32_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_UINT64_NV,
            VkComponentTypeNV::VK_COMPONENT_TYPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_COMPONENT_TYPE_FLOAT16_NV",
            "VK_COMPONENT_TYPE_FLOAT32_NV",
            "VK_COMPONENT_TYPE_FLOAT64_NV",
            "VK_COMPONENT_TYPE_SINT8_NV",
            "VK_COMPONENT_TYPE_SINT16_NV",
            "VK_COMPONENT_TYPE_SINT32_NV",
            "VK_COMPONENT_TYPE_SINT64_NV",
            "VK_COMPONENT_TYPE_UINT8_NV",
            "VK_COMPONENT_TYPE_UINT16_NV",
            "VK_COMPONENT_TYPE_UINT32_NV",
            "VK_COMPONENT_TYPE_UINT64_NV",
            "VK_COMPONENT_TYPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 12; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkComponentTypeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkComponentTypeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkScopeNV > : cast_enum < VkScopeNV > {};
};

class EnumerationVkScopeNV : public das::Enumeration {
public:
    EnumerationVkScopeNV() : das::Enumeration("VkScopeNV") {
        external = true;
        cppName = "VkScopeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkScopeNV >::type >::type;
        VkScopeNV enumArray[] = {
            VkScopeNV::VK_SCOPE_DEVICE_NV,
            VkScopeNV::VK_SCOPE_WORKGROUP_NV,
            VkScopeNV::VK_SCOPE_SUBGROUP_NV,
            VkScopeNV::VK_SCOPE_QUEUE_FAMILY_NV,
            VkScopeNV::VK_SCOPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_SCOPE_DEVICE_NV",
            "VK_SCOPE_WORKGROUP_NV",
            "VK_SCOPE_SUBGROUP_NV",
            "VK_SCOPE_QUEUE_FAMILY_NV",
            "VK_SCOPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkScopeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkScopeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkCoverageReductionModeNV > : cast_enum < VkCoverageReductionModeNV > {};
};

class EnumerationVkCoverageReductionModeNV : public das::Enumeration {
public:
    EnumerationVkCoverageReductionModeNV() : das::Enumeration("VkCoverageReductionModeNV") {
        external = true;
        cppName = "VkCoverageReductionModeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkCoverageReductionModeNV >::type >::type;
        VkCoverageReductionModeNV enumArray[] = {
            VkCoverageReductionModeNV::VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
            VkCoverageReductionModeNV::VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
            VkCoverageReductionModeNV::VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_COVERAGE_REDUCTION_MODE_MERGE_NV",
            "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV",
            "VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkCoverageReductionModeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkCoverageReductionModeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkLineRasterizationModeEXT > : cast_enum < VkLineRasterizationModeEXT > {};
};

class EnumerationVkLineRasterizationModeEXT : public das::Enumeration {
public:
    EnumerationVkLineRasterizationModeEXT() : das::Enumeration("VkLineRasterizationModeEXT") {
        external = true;
        cppName = "VkLineRasterizationModeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkLineRasterizationModeEXT >::type >::type;
        VkLineRasterizationModeEXT enumArray[] = {
            VkLineRasterizationModeEXT::VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT,
            VkLineRasterizationModeEXT::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT,
            VkLineRasterizationModeEXT::VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT,
            VkLineRasterizationModeEXT::VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT,
            VkLineRasterizationModeEXT::VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT",
            "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT",
            "VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT",
            "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT",
            "VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkLineRasterizationModeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkLineRasterizationModeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkIndirectCommandsTokenTypeNV > : cast_enum < VkIndirectCommandsTokenTypeNV > {};
};

class EnumerationVkIndirectCommandsTokenTypeNV : public das::Enumeration {
public:
    EnumerationVkIndirectCommandsTokenTypeNV() : das::Enumeration("VkIndirectCommandsTokenTypeNV") {
        external = true;
        cppName = "VkIndirectCommandsTokenTypeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkIndirectCommandsTokenTypeNV >::type >::type;
        VkIndirectCommandsTokenTypeNV enumArray[] = {
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
            VkIndirectCommandsTokenTypeNV::VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV",
            "VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 9; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkIndirectCommandsTokenTypeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkIndirectCommandsTokenTypeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkIndirectStateFlagBitsNV > : cast_enum < VkIndirectStateFlagBitsNV > {};
};

class EnumerationVkIndirectStateFlagBitsNV : public das::Enumeration {
public:
    EnumerationVkIndirectStateFlagBitsNV() : das::Enumeration("VkIndirectStateFlagBitsNV") {
        external = true;
        cppName = "VkIndirectStateFlagBitsNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkIndirectStateFlagBitsNV >::type >::type;
        VkIndirectStateFlagBitsNV enumArray[] = {
            VkIndirectStateFlagBitsNV::VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV,
            VkIndirectStateFlagBitsNV::VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV",
            "VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkIndirectStateFlagBitsNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkIndirectStateFlagBitsNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkIndirectCommandsLayoutUsageFlagBitsNV > : cast_enum < VkIndirectCommandsLayoutUsageFlagBitsNV > {};
};

class EnumerationVkIndirectCommandsLayoutUsageFlagBitsNV : public das::Enumeration {
public:
    EnumerationVkIndirectCommandsLayoutUsageFlagBitsNV() : das::Enumeration("VkIndirectCommandsLayoutUsageFlagBitsNV") {
        external = true;
        cppName = "VkIndirectCommandsLayoutUsageFlagBitsNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkIndirectCommandsLayoutUsageFlagBitsNV >::type >::type;
        VkIndirectCommandsLayoutUsageFlagBitsNV enumArray[] = {
            VkIndirectCommandsLayoutUsageFlagBitsNV::VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV,
            VkIndirectCommandsLayoutUsageFlagBitsNV::VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV,
            VkIndirectCommandsLayoutUsageFlagBitsNV::VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV,
            VkIndirectCommandsLayoutUsageFlagBitsNV::VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV",
            "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV",
            "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV",
            "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkIndirectCommandsLayoutUsageFlagBitsNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkIndirectCommandsLayoutUsageFlagBitsNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkDeviceMemoryReportEventTypeEXT > : cast_enum < VkDeviceMemoryReportEventTypeEXT > {};
};

class EnumerationVkDeviceMemoryReportEventTypeEXT : public das::Enumeration {
public:
    EnumerationVkDeviceMemoryReportEventTypeEXT() : das::Enumeration("VkDeviceMemoryReportEventTypeEXT") {
        external = true;
        cppName = "VkDeviceMemoryReportEventTypeEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDeviceMemoryReportEventTypeEXT >::type >::type;
        VkDeviceMemoryReportEventTypeEXT enumArray[] = {
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
            VkDeviceMemoryReportEventTypeEXT::VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT",
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT",
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT",
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT",
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT",
            "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 6; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDeviceMemoryReportEventTypeEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDeviceMemoryReportEventTypeEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkPrivateDataSlotCreateFlagBitsEXT > : cast_enum < VkPrivateDataSlotCreateFlagBitsEXT > {};
};

class EnumerationVkPrivateDataSlotCreateFlagBitsEXT : public das::Enumeration {
public:
    EnumerationVkPrivateDataSlotCreateFlagBitsEXT() : das::Enumeration("VkPrivateDataSlotCreateFlagBitsEXT") {
        external = true;
        cppName = "VkPrivateDataSlotCreateFlagBitsEXT";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkPrivateDataSlotCreateFlagBitsEXT >::type >::type;
        VkPrivateDataSlotCreateFlagBitsEXT enumArray[] = {
            VkPrivateDataSlotCreateFlagBitsEXT::VK_PRIVATE_DATA_SLOT_CREATE_FLAG_BITS_MAX_ENUM_EXT
        };
        static const char *enumArrayName[] = {
            "VK_PRIVATE_DATA_SLOT_CREATE_FLAG_BITS_MAX_ENUM_EXT"
        };
        for (uint32_t i = 0; i < 1; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkPrivateDataSlotCreateFlagBitsEXT > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkPrivateDataSlotCreateFlagBitsEXT");
        }
    };
}
namespace das
{
    template <> struct cast < VkDeviceDiagnosticsConfigFlagBitsNV > : cast_enum < VkDeviceDiagnosticsConfigFlagBitsNV > {};
};

class EnumerationVkDeviceDiagnosticsConfigFlagBitsNV : public das::Enumeration {
public:
    EnumerationVkDeviceDiagnosticsConfigFlagBitsNV() : das::Enumeration("VkDeviceDiagnosticsConfigFlagBitsNV") {
        external = true;
        cppName = "VkDeviceDiagnosticsConfigFlagBitsNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkDeviceDiagnosticsConfigFlagBitsNV >::type >::type;
        VkDeviceDiagnosticsConfigFlagBitsNV enumArray[] = {
            VkDeviceDiagnosticsConfigFlagBitsNV::VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV,
            VkDeviceDiagnosticsConfigFlagBitsNV::VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV,
            VkDeviceDiagnosticsConfigFlagBitsNV::VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV,
            VkDeviceDiagnosticsConfigFlagBitsNV::VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV",
            "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV",
            "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV",
            "VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkDeviceDiagnosticsConfigFlagBitsNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkDeviceDiagnosticsConfigFlagBitsNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkFragmentShadingRateTypeNV > : cast_enum < VkFragmentShadingRateTypeNV > {};
};

class EnumerationVkFragmentShadingRateTypeNV : public das::Enumeration {
public:
    EnumerationVkFragmentShadingRateTypeNV() : das::Enumeration("VkFragmentShadingRateTypeNV") {
        external = true;
        cppName = "VkFragmentShadingRateTypeNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFragmentShadingRateTypeNV >::type >::type;
        VkFragmentShadingRateTypeNV enumArray[] = {
            VkFragmentShadingRateTypeNV::VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
            VkFragmentShadingRateTypeNV::VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
            VkFragmentShadingRateTypeNV::VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV",
            "VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV",
            "VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFragmentShadingRateTypeNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFragmentShadingRateTypeNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkFragmentShadingRateNV > : cast_enum < VkFragmentShadingRateNV > {};
};

class EnumerationVkFragmentShadingRateNV : public das::Enumeration {
public:
    EnumerationVkFragmentShadingRateNV() : das::Enumeration("VkFragmentShadingRateNV") {
        external = true;
        cppName = "VkFragmentShadingRateNV";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkFragmentShadingRateNV >::type >::type;
        VkFragmentShadingRateNV enumArray[] = {
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
            VkFragmentShadingRateNV::VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV
        };
        static const char *enumArrayName[] = {
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV",
            "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV",
            "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV",
            "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV",
            "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV",
            "VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV",
            "VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV"
        };
        for (uint32_t i = 0; i < 13; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkFragmentShadingRateNV > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkFragmentShadingRateNV");
        }
    };
}
namespace das
{
    template <> struct cast < VkBuildAccelerationStructureModeKHR > : cast_enum < VkBuildAccelerationStructureModeKHR > {};
};

class EnumerationVkBuildAccelerationStructureModeKHR : public das::Enumeration {
public:
    EnumerationVkBuildAccelerationStructureModeKHR() : das::Enumeration("VkBuildAccelerationStructureModeKHR") {
        external = true;
        cppName = "VkBuildAccelerationStructureModeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkBuildAccelerationStructureModeKHR >::type >::type;
        VkBuildAccelerationStructureModeKHR enumArray[] = {
            VkBuildAccelerationStructureModeKHR::VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
            VkBuildAccelerationStructureModeKHR::VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
            VkBuildAccelerationStructureModeKHR::VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR",
            "VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkBuildAccelerationStructureModeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkBuildAccelerationStructureModeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccelerationStructureBuildTypeKHR > : cast_enum < VkAccelerationStructureBuildTypeKHR > {};
};

class EnumerationVkAccelerationStructureBuildTypeKHR : public das::Enumeration {
public:
    EnumerationVkAccelerationStructureBuildTypeKHR() : das::Enumeration("VkAccelerationStructureBuildTypeKHR") {
        external = true;
        cppName = "VkAccelerationStructureBuildTypeKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccelerationStructureBuildTypeKHR >::type >::type;
        VkAccelerationStructureBuildTypeKHR enumArray[] = {
            VkAccelerationStructureBuildTypeKHR::VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
            VkAccelerationStructureBuildTypeKHR::VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
            VkAccelerationStructureBuildTypeKHR::VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
            VkAccelerationStructureBuildTypeKHR::VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR",
            "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR",
            "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR",
            "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 4; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccelerationStructureBuildTypeKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccelerationStructureBuildTypeKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccelerationStructureCompatibilityKHR > : cast_enum < VkAccelerationStructureCompatibilityKHR > {};
};

class EnumerationVkAccelerationStructureCompatibilityKHR : public das::Enumeration {
public:
    EnumerationVkAccelerationStructureCompatibilityKHR() : das::Enumeration("VkAccelerationStructureCompatibilityKHR") {
        external = true;
        cppName = "VkAccelerationStructureCompatibilityKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccelerationStructureCompatibilityKHR >::type >::type;
        VkAccelerationStructureCompatibilityKHR enumArray[] = {
            VkAccelerationStructureCompatibilityKHR::VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
            VkAccelerationStructureCompatibilityKHR::VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
            VkAccelerationStructureCompatibilityKHR::VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR",
            "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR",
            "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 3; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccelerationStructureCompatibilityKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccelerationStructureCompatibilityKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkAccelerationStructureCreateFlagBitsKHR > : cast_enum < VkAccelerationStructureCreateFlagBitsKHR > {};
};

class EnumerationVkAccelerationStructureCreateFlagBitsKHR : public das::Enumeration {
public:
    EnumerationVkAccelerationStructureCreateFlagBitsKHR() : das::Enumeration("VkAccelerationStructureCreateFlagBitsKHR") {
        external = true;
        cppName = "VkAccelerationStructureCreateFlagBitsKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkAccelerationStructureCreateFlagBitsKHR >::type >::type;
        VkAccelerationStructureCreateFlagBitsKHR enumArray[] = {
            VkAccelerationStructureCreateFlagBitsKHR::VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
            VkAccelerationStructureCreateFlagBitsKHR::VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR",
            "VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 2; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkAccelerationStructureCreateFlagBitsKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkAccelerationStructureCreateFlagBitsKHR");
        }
    };
}
namespace das
{
    template <> struct cast < VkShaderGroupShaderKHR > : cast_enum < VkShaderGroupShaderKHR > {};
};

class EnumerationVkShaderGroupShaderKHR : public das::Enumeration {
public:
    EnumerationVkShaderGroupShaderKHR() : das::Enumeration("VkShaderGroupShaderKHR") {
        external = true;
        cppName = "VkShaderGroupShaderKHR";
        baseType = (das::Type) das::ToBasicType< das::underlying_type< VkShaderGroupShaderKHR >::type >::type;
        VkShaderGroupShaderKHR enumArray[] = {
            VkShaderGroupShaderKHR::VK_SHADER_GROUP_SHADER_GENERAL_KHR,
            VkShaderGroupShaderKHR::VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
            VkShaderGroupShaderKHR::VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
            VkShaderGroupShaderKHR::VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
            VkShaderGroupShaderKHR::VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR
        };
        static const char *enumArrayName[] = {
            "VK_SHADER_GROUP_SHADER_GENERAL_KHR",
            "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR",
            "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR",
            "VK_SHADER_GROUP_SHADER_INTERSECTION_KHR",
            "VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR"
        };
        for (uint32_t i = 0; i < 5; ++i)
            addI(enumArrayName[i], int64_t(enumArray[i]), das::LineInfo());
    }
};

namespace das
{
    template <>
    struct typeFactory< VkShaderGroupShaderKHR > {
        static TypeDeclPtr make(const ModuleLibrary & library){
            return library.makeEnumType("VkShaderGroupShaderKHR");
        }
    };
}

//
// opaque structs
//

MAKE_TYPE_FACTORY(VkBuffer, VkBuffer)
MAKE_TYPE_FACTORY(VkImage, VkImage)
MAKE_TYPE_FACTORY(VkInstance, VkInstance)
MAKE_TYPE_FACTORY(VkPhysicalDevice, VkPhysicalDevice)
MAKE_TYPE_FACTORY(VkDevice, VkDevice)
MAKE_TYPE_FACTORY(VkQueue, VkQueue)
MAKE_TYPE_FACTORY(VkSemaphore, VkSemaphore)
MAKE_TYPE_FACTORY(VkCommandBuffer, VkCommandBuffer)
MAKE_TYPE_FACTORY(VkFence, VkFence)
MAKE_TYPE_FACTORY(VkDeviceMemory, VkDeviceMemory)
MAKE_TYPE_FACTORY(VkEvent, VkEvent)
MAKE_TYPE_FACTORY(VkQueryPool, VkQueryPool)
MAKE_TYPE_FACTORY(VkBufferView, VkBufferView)
MAKE_TYPE_FACTORY(VkImageView, VkImageView)
MAKE_TYPE_FACTORY(VkShaderModule, VkShaderModule)
MAKE_TYPE_FACTORY(VkPipelineCache, VkPipelineCache)
MAKE_TYPE_FACTORY(VkPipelineLayout, VkPipelineLayout)
MAKE_TYPE_FACTORY(VkPipeline, VkPipeline)
MAKE_TYPE_FACTORY(VkRenderPass, VkRenderPass)
MAKE_TYPE_FACTORY(VkDescriptorSetLayout, VkDescriptorSetLayout)
MAKE_TYPE_FACTORY(VkSampler, VkSampler)
MAKE_TYPE_FACTORY(VkDescriptorSet, VkDescriptorSet)
MAKE_TYPE_FACTORY(VkDescriptorPool, VkDescriptorPool)
MAKE_TYPE_FACTORY(VkFramebuffer, VkFramebuffer)
MAKE_TYPE_FACTORY(VkCommandPool, VkCommandPool)
MAKE_TYPE_FACTORY(VkSamplerYcbcrConversion, VkSamplerYcbcrConversion)
MAKE_TYPE_FACTORY(VkDescriptorUpdateTemplate, VkDescriptorUpdateTemplate)
MAKE_TYPE_FACTORY(VkSurfaceKHR, VkSurfaceKHR)
MAKE_TYPE_FACTORY(VkSwapchainKHR, VkSwapchainKHR)
MAKE_TYPE_FACTORY(VkDisplayKHR, VkDisplayKHR)
MAKE_TYPE_FACTORY(VkDisplayModeKHR, VkDisplayModeKHR)
MAKE_TYPE_FACTORY(VkDeferredOperationKHR, VkDeferredOperationKHR)
MAKE_TYPE_FACTORY(VkDebugReportCallbackEXT, VkDebugReportCallbackEXT)
MAKE_TYPE_FACTORY(VkDebugUtilsMessengerEXT, VkDebugUtilsMessengerEXT)
MAKE_TYPE_FACTORY(VkValidationCacheEXT, VkValidationCacheEXT)
MAKE_TYPE_FACTORY(VkAccelerationStructureNV, VkAccelerationStructureNV)
MAKE_TYPE_FACTORY(VkPerformanceConfigurationINTEL, VkPerformanceConfigurationINTEL)
MAKE_TYPE_FACTORY(VkIndirectCommandsLayoutNV, VkIndirectCommandsLayoutNV)
MAKE_TYPE_FACTORY(VkPrivateDataSlotEXT, VkPrivateDataSlotEXT)
MAKE_TYPE_FACTORY(VkAccelerationStructureKHR, VkAccelerationStructureKHR)
typedef GLFWmonitor * GLFWmonitor_DasHandle;
MAKE_TYPE_FACTORY(GLFWmonitor_DasHandle, GLFWmonitor_DasHandle)
typedef GLFWwindow * GLFWwindow_DasHandle;
MAKE_TYPE_FACTORY(GLFWwindow_DasHandle, GLFWwindow_DasHandle)
typedef GLFWcursor * GLFWcursor_DasHandle;
MAKE_TYPE_FACTORY(GLFWcursor_DasHandle, GLFWcursor_DasHandle)

//
// structs
//


MAKE_TYPE_FACTORY(VkExtent2D, VkExtent2D);

struct VkExtent2DAnnotation
: public ManagedStructureAnnotation<VkExtent2D,true,true> {
    VkExtent2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExtent3D, VkExtent3D);

struct VkExtent3DAnnotation
: public ManagedStructureAnnotation<VkExtent3D,true,true> {
    VkExtent3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkOffset2D, VkOffset2D);

struct VkOffset2DAnnotation
: public ManagedStructureAnnotation<VkOffset2D,true,true> {
    VkOffset2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkOffset3D, VkOffset3D);

struct VkOffset3DAnnotation
: public ManagedStructureAnnotation<VkOffset3D,true,true> {
    VkOffset3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRect2D, VkRect2D);

struct VkRect2DAnnotation
: public ManagedStructureAnnotation<VkRect2D,true,true> {
    VkRect2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRect2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBaseInStructure, VkBaseInStructure);

struct VkBaseInStructureAnnotation
: public ManagedStructureAnnotation<VkBaseInStructure,true,true> {
    VkBaseInStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseInStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBaseOutStructure, VkBaseOutStructure);

struct VkBaseOutStructureAnnotation
: public ManagedStructureAnnotation<VkBaseOutStructure,true,true> {
    VkBaseOutStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseOutStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferMemoryBarrier, VkBufferMemoryBarrier);

struct VkBufferMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkBufferMemoryBarrier,true,true> {
    VkBufferMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDispatchIndirectCommand, VkDispatchIndirectCommand);

struct VkDispatchIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDispatchIndirectCommand,true,true> {
    VkDispatchIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDispatchIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDrawIndexedIndirectCommand, VkDrawIndexedIndirectCommand);

struct VkDrawIndexedIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndexedIndirectCommand,true,true> {
    VkDrawIndexedIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndexedIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(indexCount)>("indexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstIndex)>("firstIndex");
        addField<DAS_BIND_MANAGED_FIELD(vertexOffset)>("vertexOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDrawIndirectCommand, VkDrawIndirectCommand);

struct VkDrawIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndirectCommand,true,true> {
    VkDrawIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(vertexCount)>("vertexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageSubresourceRange, VkImageSubresourceRange);

struct VkImageSubresourceRangeAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceRange,true,true> {
    VkImageSubresourceRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(baseMipLevel)>("baseMipLevel");
        addField<DAS_BIND_MANAGED_FIELD(levelCount)>("levelCount");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageMemoryBarrier, VkImageMemoryBarrier);

struct VkImageMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkImageMemoryBarrier,true,true> {
    VkImageMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(oldLayout)>("oldLayout");
        addField<DAS_BIND_MANAGED_FIELD(newLayout)>("newLayout");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryBarrier, VkMemoryBarrier);

struct VkMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkMemoryBarrier,true,true> {
    VkMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAllocationCallbacks, VkAllocationCallbacks);

struct VkAllocationCallbacksAnnotation
: public ManagedStructureAnnotation<VkAllocationCallbacks,true,true> {
    VkAllocationCallbacksAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAllocationCallbacks", ml) {
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkApplicationInfo, VkApplicationInfo);

struct VkApplicationInfoAnnotation
: public ManagedStructureAnnotation<VkApplicationInfo,true,true> {
    VkApplicationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkApplicationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationName)>("pApplicationName");
        addField<DAS_BIND_MANAGED_FIELD(applicationVersion)>("applicationVersion");
        addField<DAS_BIND_MANAGED_FIELD(pEngineName)>("pEngineName");
        addField<DAS_BIND_MANAGED_FIELD(engineVersion)>("engineVersion");
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFormatProperties, VkFormatProperties);

struct VkFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkFormatProperties,true,true> {
    VkFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(linearTilingFeatures)>("linearTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(optimalTilingFeatures)>("optimalTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(bufferFeatures)>("bufferFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageFormatProperties, VkImageFormatProperties);

struct VkImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkImageFormatProperties,true,true> {
    VkImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxExtent)>("maxExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxMipLevels)>("maxMipLevels");
        addField<DAS_BIND_MANAGED_FIELD(maxArrayLayers)>("maxArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(sampleCounts)>("sampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxResourceSize)>("maxResourceSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkInstanceCreateInfo, VkInstanceCreateInfo);

struct VkInstanceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkInstanceCreateInfo,true,true> {
    VkInstanceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInstanceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationInfo)>("pApplicationInfo");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryHeap, VkMemoryHeap);

struct VkMemoryHeapAnnotation
: public ManagedStructureAnnotation<VkMemoryHeap,true,true> {
    VkMemoryHeapAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHeap", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryType, VkMemoryType);

struct VkMemoryTypeAnnotation
: public ManagedStructureAnnotation<VkMemoryType,true,true> {
    VkMemoryTypeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryType", ml) {
        addField<DAS_BIND_MANAGED_FIELD(propertyFlags)>("propertyFlags");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFeatures, VkPhysicalDeviceFeatures);

struct VkPhysicalDeviceFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFeatures,true,true> {
    VkPhysicalDeviceFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess)>("robustBufferAccess");
        addField<DAS_BIND_MANAGED_FIELD(fullDrawIndexUint32)>("fullDrawIndexUint32");
        addField<DAS_BIND_MANAGED_FIELD(imageCubeArray)>("imageCubeArray");
        addField<DAS_BIND_MANAGED_FIELD(independentBlend)>("independentBlend");
        addField<DAS_BIND_MANAGED_FIELD(geometryShader)>("geometryShader");
        addField<DAS_BIND_MANAGED_FIELD(tessellationShader)>("tessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(sampleRateShading)>("sampleRateShading");
        addField<DAS_BIND_MANAGED_FIELD(dualSrcBlend)>("dualSrcBlend");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(multiDrawIndirect)>("multiDrawIndirect");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectFirstInstance)>("drawIndirectFirstInstance");
        addField<DAS_BIND_MANAGED_FIELD(depthClamp)>("depthClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(fillModeNonSolid)>("fillModeNonSolid");
        addField<DAS_BIND_MANAGED_FIELD(depthBounds)>("depthBounds");
        addField<DAS_BIND_MANAGED_FIELD(wideLines)>("wideLines");
        addField<DAS_BIND_MANAGED_FIELD(largePoints)>("largePoints");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOne)>("alphaToOne");
        addField<DAS_BIND_MANAGED_FIELD(multiViewport)>("multiViewport");
        addField<DAS_BIND_MANAGED_FIELD(samplerAnisotropy)>("samplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionETC2)>("textureCompressionETC2");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_LDR)>("textureCompressionASTC_LDR");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionBC)>("textureCompressionBC");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryPrecise)>("occlusionQueryPrecise");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatisticsQuery)>("pipelineStatisticsQuery");
        addField<DAS_BIND_MANAGED_FIELD(vertexPipelineStoresAndAtomics)>("vertexPipelineStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(fragmentStoresAndAtomics)>("fragmentStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderTessellationAndGeometryPointSize)>("shaderTessellationAndGeometryPointSize");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageGatherExtended)>("shaderImageGatherExtended");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageExtendedFormats)>("shaderStorageImageExtendedFormats");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageMultisample)>("shaderStorageImageMultisample");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageReadWithoutFormat)>("shaderStorageImageReadWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageWriteWithoutFormat)>("shaderStorageImageWriteWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayDynamicIndexing)>("shaderUniformBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayDynamicIndexing)>("shaderSampledImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayDynamicIndexing)>("shaderStorageBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayDynamicIndexing)>("shaderStorageImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderClipDistance)>("shaderClipDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderCullDistance)>("shaderCullDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat64)>("shaderFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt64)>("shaderInt64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt16)>("shaderInt16");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceResidency)>("shaderResourceResidency");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceMinLod)>("shaderResourceMinLod");
        addField<DAS_BIND_MANAGED_FIELD(sparseBinding)>("sparseBinding");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyBuffer)>("sparseResidencyBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage2D)>("sparseResidencyImage2D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage3D)>("sparseResidencyImage3D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency2Samples)>("sparseResidency2Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency4Samples)>("sparseResidency4Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency8Samples)>("sparseResidency8Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency16Samples)>("sparseResidency16Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyAliased)>("sparseResidencyAliased");
        addField<DAS_BIND_MANAGED_FIELD(variableMultisampleRate)>("variableMultisampleRate");
        addField<DAS_BIND_MANAGED_FIELD(inheritedQueries)>("inheritedQueries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceLimits, VkPhysicalDeviceLimits);

struct VkPhysicalDeviceLimitsAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLimits,true,true> {
    VkPhysicalDeviceLimitsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLimits", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension1D)>("maxImageDimension1D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension2D)>("maxImageDimension2D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension3D)>("maxImageDimension3D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimensionCube)>("maxImageDimensionCube");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelBufferElements)>("maxTexelBufferElements");
        addField<DAS_BIND_MANAGED_FIELD(maxUniformBufferRange)>("maxUniformBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxStorageBufferRange)>("maxStorageBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxPushConstantsSize)>("maxPushConstantsSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationCount)>("maxMemoryAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAllocationCount)>("maxSamplerAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageGranularity)>("bufferImageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(sparseAddressSpaceSize)>("sparseAddressSpaceSize");
        addField<DAS_BIND_MANAGED_FIELD(maxBoundDescriptorSets)>("maxBoundDescriptorSets");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSamplers)>("maxPerStageDescriptorSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUniformBuffers)>("maxPerStageDescriptorUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageBuffers)>("maxPerStageDescriptorStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSampledImages)>("maxPerStageDescriptorSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageImages)>("maxPerStageDescriptorStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInputAttachments)>("maxPerStageDescriptorInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageResources)>("maxPerStageResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSamplers)>("maxDescriptorSetSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffers)>("maxDescriptorSetUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffersDynamic)>("maxDescriptorSetUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffers)>("maxDescriptorSetStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffersDynamic)>("maxDescriptorSetStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSampledImages)>("maxDescriptorSetSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageImages)>("maxDescriptorSetStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInputAttachments)>("maxDescriptorSetInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributes)>("maxVertexInputAttributes");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindings)>("maxVertexInputBindings");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributeOffset)>("maxVertexInputAttributeOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindingStride)>("maxVertexInputBindingStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexOutputComponents)>("maxVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationGenerationLevel)>("maxTessellationGenerationLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationPatchSize)>("maxTessellationPatchSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexInputComponents)>("maxTessellationControlPerVertexInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexOutputComponents)>("maxTessellationControlPerVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerPatchOutputComponents)>("maxTessellationControlPerPatchOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlTotalOutputComponents)>("maxTessellationControlTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationInputComponents)>("maxTessellationEvaluationInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationOutputComponents)>("maxTessellationEvaluationOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryShaderInvocations)>("maxGeometryShaderInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryInputComponents)>("maxGeometryInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputComponents)>("maxGeometryOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputVertices)>("maxGeometryOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryTotalOutputComponents)>("maxGeometryTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentInputComponents)>("maxFragmentInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentOutputAttachments)>("maxFragmentOutputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDualSrcAttachments)>("maxFragmentDualSrcAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentCombinedOutputResources)>("maxFragmentCombinedOutputResources");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeSharedMemorySize)>("maxComputeSharedMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupCount)>("maxComputeWorkGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupInvocations)>("maxComputeWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupSize)>("maxComputeWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subPixelPrecisionBits)>("subPixelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(subTexelPrecisionBits)>("subTexelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(mipmapPrecisionBits)>("mipmapPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndexedIndexValue)>("maxDrawIndexedIndexValue");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndirectCount)>("maxDrawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerLodBias)>("maxSamplerLodBias");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAnisotropy)>("maxSamplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(maxViewports)>("maxViewports");
        addField<DAS_BIND_MANAGED_FIELD(maxViewportDimensions)>("maxViewportDimensions");
        addField<DAS_BIND_MANAGED_FIELD(viewportBoundsRange)>("viewportBoundsRange");
        addField<DAS_BIND_MANAGED_FIELD(viewportSubPixelBits)>("viewportSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(minMemoryMapAlignment)>("minMemoryMapAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelBufferOffsetAlignment)>("minTexelBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minUniformBufferOffsetAlignment)>("minUniformBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minStorageBufferOffsetAlignment)>("minStorageBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelOffset)>("minTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelOffset)>("maxTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(minTexelGatherOffset)>("minTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelGatherOffset)>("maxTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(minInterpolationOffset)>("minInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxInterpolationOffset)>("maxInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(subPixelInterpolationOffsetBits)>("subPixelInterpolationOffsetBits");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferWidth)>("maxFramebufferWidth");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferHeight)>("maxFramebufferHeight");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferLayers)>("maxFramebufferLayers");
        addField<DAS_BIND_MANAGED_FIELD(framebufferColorSampleCounts)>("framebufferColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferDepthSampleCounts)>("framebufferDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferStencilSampleCounts)>("framebufferStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferNoAttachmentsSampleCounts)>("framebufferNoAttachmentsSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxColorAttachments)>("maxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageColorSampleCounts)>("sampledImageColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageIntegerSampleCounts)>("sampledImageIntegerSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageDepthSampleCounts)>("sampledImageDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageStencilSampleCounts)>("sampledImageStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(storageImageSampleCounts)>("storageImageSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleMaskWords)>("maxSampleMaskWords");
        addField<DAS_BIND_MANAGED_FIELD(timestampComputeAndGraphics)>("timestampComputeAndGraphics");
        addField<DAS_BIND_MANAGED_FIELD(timestampPeriod)>("timestampPeriod");
        addField<DAS_BIND_MANAGED_FIELD(maxClipDistances)>("maxClipDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCullDistances)>("maxCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCombinedClipAndCullDistances)>("maxCombinedClipAndCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(discreteQueuePriorities)>("discreteQueuePriorities");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeRange)>("pointSizeRange");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthRange)>("lineWidthRange");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeGranularity)>("pointSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthGranularity)>("lineWidthGranularity");
        addField<DAS_BIND_MANAGED_FIELD(strictLines)>("strictLines");
        addField<DAS_BIND_MANAGED_FIELD(standardSampleLocations)>("standardSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyOffsetAlignment)>("optimalBufferCopyOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyRowPitchAlignment)>("optimalBufferCopyRowPitchAlignment");
        addField<DAS_BIND_MANAGED_FIELD(nonCoherentAtomSize)>("nonCoherentAtomSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMemoryProperties, VkPhysicalDeviceMemoryProperties);

struct VkPhysicalDeviceMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryProperties,true,true> {
    VkPhysicalDeviceMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeCount)>("memoryTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypes)>("memoryTypes");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeapCount)>("memoryHeapCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeaps)>("memoryHeaps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSparseProperties, VkPhysicalDeviceSparseProperties);

struct VkPhysicalDeviceSparsePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseProperties,true,true> {
    VkPhysicalDeviceSparsePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DBlockShape)>("residencyStandard2DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DMultisampleBlockShape)>("residencyStandard2DMultisampleBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard3DBlockShape)>("residencyStandard3DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyAlignedMipSize)>("residencyAlignedMipSize");
        addField<DAS_BIND_MANAGED_FIELD(residencyNonResidentStrict)>("residencyNonResidentStrict");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceProperties, VkPhysicalDeviceProperties);

struct VkPhysicalDevicePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProperties,true,true> {
    VkPhysicalDevicePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
        addField<DAS_BIND_MANAGED_FIELD(driverVersion)>("driverVersion");
        addField<DAS_BIND_MANAGED_FIELD(vendorID)>("vendorID");
        addField<DAS_BIND_MANAGED_FIELD(deviceID)>("deviceID");
        addField<DAS_BIND_MANAGED_FIELD(deviceType)>("deviceType");
        addField<DAS_BIND_MANAGED_FIELD(deviceName)>("deviceName");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCacheUUID)>("pipelineCacheUUID");
        addField<DAS_BIND_MANAGED_FIELD(limits)>("limits");
        addField<DAS_BIND_MANAGED_FIELD(sparseProperties)>("sparseProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueueFamilyProperties, VkQueueFamilyProperties);

struct VkQueueFamilyPropertiesAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyProperties,true,true> {
    VkQueueFamilyPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(queueFlags)>("queueFlags");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(timestampValidBits)>("timestampValidBits");
        addField<DAS_BIND_MANAGED_FIELD(minImageTransferGranularity)>("minImageTransferGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceQueueCreateInfo, VkDeviceQueueCreateInfo);

struct VkDeviceQueueCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueCreateInfo,true,true> {
    VkDeviceQueueCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueuePriorities)>("pQueuePriorities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceCreateInfo, VkDeviceCreateInfo);

struct VkDeviceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceCreateInfo,true,true> {
    VkDeviceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueCreateInfoCount)>("queueCreateInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueCreateInfos)>("pQueueCreateInfos");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledFeatures)>("pEnabledFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExtensionProperties, VkExtensionProperties);

struct VkExtensionPropertiesAnnotation
: public ManagedStructureAnnotation<VkExtensionProperties,true,true> {
    VkExtensionPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtensionProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(extensionName)>("extensionName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkLayerProperties, VkLayerProperties);

struct VkLayerPropertiesAnnotation
: public ManagedStructureAnnotation<VkLayerProperties,true,true> {
    VkLayerPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkLayerProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(layerName)>("layerName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
        addField<DAS_BIND_MANAGED_FIELD(implementationVersion)>("implementationVersion");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubmitInfo, VkSubmitInfo);

struct VkSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkSubmitInfo,true,true> {
    VkSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pWaitDstStageMask)>("pWaitDstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
        addField<DAS_BIND_MANAGED_FIELD(pCommandBuffers)>("pCommandBuffers");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMappedMemoryRange, VkMappedMemoryRange);

struct VkMappedMemoryRangeAnnotation
: public ManagedStructureAnnotation<VkMappedMemoryRange,true,true> {
    VkMappedMemoryRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMappedMemoryRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryAllocateInfo, VkMemoryAllocateInfo);

struct VkMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateInfo,true,true> {
    VkMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allocationSize)>("allocationSize");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeIndex)>("memoryTypeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryRequirements, VkMemoryRequirements);

struct VkMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryRequirements,true,true> {
    VkMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(alignment)>("alignment");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseMemoryBind, VkSparseMemoryBind);

struct VkSparseMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseMemoryBind,true,true> {
    VkSparseMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(resourceOffset)>("resourceOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseBufferMemoryBindInfo, VkSparseBufferMemoryBindInfo);

struct VkSparseBufferMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseBufferMemoryBindInfo,true,true> {
    VkSparseBufferMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseBufferMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageOpaqueMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo);

struct VkSparseImageOpaqueMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageOpaqueMemoryBindInfo,true,true> {
    VkSparseImageOpaqueMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageOpaqueMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageSubresource, VkImageSubresource);

struct VkImageSubresourceAnnotation
: public ManagedStructureAnnotation<VkImageSubresource,true,true> {
    VkImageSubresourceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresource", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayer)>("arrayLayer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageMemoryBind, VkSparseImageMemoryBind);

struct VkSparseImageMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBind,true,true> {
    VkSparseImageMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subresource)>("subresource");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageMemoryBindInfo, VkSparseImageMemoryBindInfo);

struct VkSparseImageMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBindInfo,true,true> {
    VkSparseImageMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindSparseInfo, VkBindSparseInfo);

struct VkBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkBindSparseInfo,true,true> {
    VkBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(bufferBindCount)>("bufferBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBufferBinds)>("pBufferBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageOpaqueBindCount)>("imageOpaqueBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageOpaqueBinds)>("pImageOpaqueBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageBindCount)>("imageBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageBinds)>("pImageBinds");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageFormatProperties, VkSparseImageFormatProperties);

struct VkSparseImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties,true,true> {
    VkSparseImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(imageGranularity)>("imageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageMemoryRequirements, VkSparseImageMemoryRequirements);

struct VkSparseImageMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements,true,true> {
    VkSparseImageMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailFirstLod)>("imageMipTailFirstLod");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailSize)>("imageMipTailSize");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailOffset)>("imageMipTailOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailStride)>("imageMipTailStride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFenceCreateInfo, VkFenceCreateInfo);

struct VkFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFenceCreateInfo,true,true> {
    VkFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSemaphoreCreateInfo, VkSemaphoreCreateInfo);

struct VkSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreCreateInfo,true,true> {
    VkSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkEventCreateInfo, VkEventCreateInfo);

struct VkEventCreateInfoAnnotation
: public ManagedStructureAnnotation<VkEventCreateInfo,true,true> {
    VkEventCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkEventCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueryPoolCreateInfo, VkQueryPoolCreateInfo);

struct VkQueryPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkQueryPoolCreateInfo,true,true> {
    VkQueryPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queryType)>("queryType");
        addField<DAS_BIND_MANAGED_FIELD(queryCount)>("queryCount");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferCreateInfo, VkBufferCreateInfo);

struct VkBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferCreateInfo,true,true> {
    VkBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferViewCreateInfo, VkBufferViewCreateInfo);

struct VkBufferViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferViewCreateInfo,true,true> {
    VkBufferViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageCreateInfo, VkImageCreateInfo);

struct VkImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageCreateInfo,true,true> {
    VkImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(imageType)>("imageType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(mipLevels)>("mipLevels");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayers)>("arrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubresourceLayout, VkSubresourceLayout);

struct VkSubresourceLayoutAnnotation
: public ManagedStructureAnnotation<VkSubresourceLayout,true,true> {
    VkSubresourceLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubresourceLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(rowPitch)>("rowPitch");
        addField<DAS_BIND_MANAGED_FIELD(arrayPitch)>("arrayPitch");
        addField<DAS_BIND_MANAGED_FIELD(depthPitch)>("depthPitch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkComponentMapping, VkComponentMapping);

struct VkComponentMappingAnnotation
: public ManagedStructureAnnotation<VkComponentMapping,true,true> {
    VkComponentMappingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComponentMapping", ml) {
        addField<DAS_BIND_MANAGED_FIELD(r)>("r");
        addField<DAS_BIND_MANAGED_FIELD(g)>("g");
        addField<DAS_BIND_MANAGED_FIELD(b)>("b");
        addField<DAS_BIND_MANAGED_FIELD(a)>("a");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageViewCreateInfo, VkImageViewCreateInfo);

struct VkImageViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewCreateInfo,true,true> {
    VkImageViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(viewType)>("viewType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkShaderModuleCreateInfo, VkShaderModuleCreateInfo);

struct VkShaderModuleCreateInfoAnnotation
: public ManagedStructureAnnotation<VkShaderModuleCreateInfo,true,true> {
    VkShaderModuleCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(codeSize)>("codeSize");
        addField<DAS_BIND_MANAGED_FIELD(pCode)>("pCode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCacheCreateInfo, VkPipelineCacheCreateInfo);

struct VkPipelineCacheCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineCacheCreateInfo,true,true> {
    VkPipelineCacheCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCacheCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSpecializationMapEntry, VkSpecializationMapEntry);

struct VkSpecializationMapEntryAnnotation
: public ManagedStructureAnnotation<VkSpecializationMapEntry,true,true> {
    VkSpecializationMapEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationMapEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(constantID)>("constantID");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSpecializationInfo, VkSpecializationInfo);

struct VkSpecializationInfoAnnotation
: public ManagedStructureAnnotation<VkSpecializationInfo,true,true> {
    VkSpecializationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(mapEntryCount)>("mapEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pMapEntries)>("pMapEntries");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineShaderStageCreateInfo, VkPipelineShaderStageCreateInfo);

struct VkPipelineShaderStageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageCreateInfo,true,true> {
    VkPipelineShaderStageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(module)>("module_");
        addField<DAS_BIND_MANAGED_FIELD(pName)>("pName");
        addField<DAS_BIND_MANAGED_FIELD(pSpecializationInfo)>("pSpecializationInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkComputePipelineCreateInfo, VkComputePipelineCreateInfo);

struct VkComputePipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkComputePipelineCreateInfo,true,true> {
    VkComputePipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComputePipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkVertexInputBindingDescription, VkVertexInputBindingDescription);

struct VkVertexInputBindingDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDescription,true,true> {
    VkVertexInputBindingDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(inputRate)>("inputRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkVertexInputAttributeDescription, VkVertexInputAttributeDescription);

struct VkVertexInputAttributeDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputAttributeDescription,true,true> {
    VkVertexInputAttributeDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputAttributeDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(location)>("location");
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineVertexInputStateCreateInfo, VkPipelineVertexInputStateCreateInfo);

struct VkPipelineVertexInputStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputStateCreateInfo,true,true> {
    VkPipelineVertexInputStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDescriptionCount)>("vertexBindingDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDescriptions)>("pVertexBindingDescriptions");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeDescriptionCount)>("vertexAttributeDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexAttributeDescriptions)>("pVertexAttributeDescriptions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineInputAssemblyStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo);

struct VkPipelineInputAssemblyStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineInputAssemblyStateCreateInfo,true,true> {
    VkPipelineInputAssemblyStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInputAssemblyStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(topology)>("topology");
        addField<DAS_BIND_MANAGED_FIELD(primitiveRestartEnable)>("primitiveRestartEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineTessellationStateCreateInfo, VkPipelineTessellationStateCreateInfo);

struct VkPipelineTessellationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationStateCreateInfo,true,true> {
    VkPipelineTessellationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(patchControlPoints)>("patchControlPoints");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkViewport, VkViewport);

struct VkViewportAnnotation
: public ManagedStructureAnnotation<VkViewport,true,true> {
    VkViewportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(minDepth)>("minDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxDepth)>("maxDepth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportStateCreateInfo, VkPipelineViewportStateCreateInfo);

struct VkPipelineViewportStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportStateCreateInfo,true,true> {
    VkPipelineViewportStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewports)>("pViewports");
        addField<DAS_BIND_MANAGED_FIELD(scissorCount)>("scissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pScissors)>("pScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationStateCreateInfo, VkPipelineRasterizationStateCreateInfo);

struct VkPipelineRasterizationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateCreateInfo,true,true> {
    VkPipelineRasterizationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClampEnable)>("depthClampEnable");
        addField<DAS_BIND_MANAGED_FIELD(rasterizerDiscardEnable)>("rasterizerDiscardEnable");
        addField<DAS_BIND_MANAGED_FIELD(polygonMode)>("polygonMode");
        addField<DAS_BIND_MANAGED_FIELD(cullMode)>("cullMode");
        addField<DAS_BIND_MANAGED_FIELD(frontFace)>("frontFace");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasEnable)>("depthBiasEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasConstantFactor)>("depthBiasConstantFactor");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasSlopeFactor)>("depthBiasSlopeFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineWidth)>("lineWidth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineMultisampleStateCreateInfo, VkPipelineMultisampleStateCreateInfo);

struct VkPipelineMultisampleStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineMultisampleStateCreateInfo,true,true> {
    VkPipelineMultisampleStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineMultisampleStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(sampleShadingEnable)>("sampleShadingEnable");
        addField<DAS_BIND_MANAGED_FIELD(minSampleShading)>("minSampleShading");
        addField<DAS_BIND_MANAGED_FIELD(pSampleMask)>("pSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(alphaToCoverageEnable)>("alphaToCoverageEnable");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOneEnable)>("alphaToOneEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkStencilOpState, VkStencilOpState);

struct VkStencilOpStateAnnotation
: public ManagedStructureAnnotation<VkStencilOpState,true,true> {
    VkStencilOpStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStencilOpState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(failOp)>("failOp");
        addField<DAS_BIND_MANAGED_FIELD(passOp)>("passOp");
        addField<DAS_BIND_MANAGED_FIELD(depthFailOp)>("depthFailOp");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(compareMask)>("compareMask");
        addField<DAS_BIND_MANAGED_FIELD(writeMask)>("writeMask");
        addField<DAS_BIND_MANAGED_FIELD(reference)>("reference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineDepthStencilStateCreateInfo, VkPipelineDepthStencilStateCreateInfo);

struct VkPipelineDepthStencilStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDepthStencilStateCreateInfo,true,true> {
    VkPipelineDepthStencilStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDepthStencilStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthTestEnable)>("depthTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthWriteEnable)>("depthWriteEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthCompareOp)>("depthCompareOp");
        addField<DAS_BIND_MANAGED_FIELD(depthBoundsTestEnable)>("depthBoundsTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(stencilTestEnable)>("stencilTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(front)>("front");
        addField<DAS_BIND_MANAGED_FIELD(back)>("back");
        addField<DAS_BIND_MANAGED_FIELD(minDepthBounds)>("minDepthBounds");
        addField<DAS_BIND_MANAGED_FIELD(maxDepthBounds)>("maxDepthBounds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineColorBlendAttachmentState, VkPipelineColorBlendAttachmentState);

struct VkPipelineColorBlendAttachmentStateAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAttachmentState,true,true> {
    VkPipelineColorBlendAttachmentStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAttachmentState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(blendEnable)>("blendEnable");
        addField<DAS_BIND_MANAGED_FIELD(srcColorBlendFactor)>("srcColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstColorBlendFactor)>("dstColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(colorBlendOp)>("colorBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(srcAlphaBlendFactor)>("srcAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstAlphaBlendFactor)>("dstAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(alphaBlendOp)>("alphaBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(colorWriteMask)>("colorWriteMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineColorBlendStateCreateInfo, VkPipelineColorBlendStateCreateInfo);

struct VkPipelineColorBlendStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendStateCreateInfo,true,true> {
    VkPipelineColorBlendStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(logicOpEnable)>("logicOpEnable");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(blendConstants)>("blendConstants");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineDynamicStateCreateInfo, VkPipelineDynamicStateCreateInfo);

struct VkPipelineDynamicStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDynamicStateCreateInfo,true,true> {
    VkPipelineDynamicStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDynamicStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(dynamicStateCount)>("dynamicStateCount");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicStates)>("pDynamicStates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGraphicsPipelineCreateInfo, VkGraphicsPipelineCreateInfo);

struct VkGraphicsPipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineCreateInfo,true,true> {
    VkGraphicsPipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pInputAssemblyState)>("pInputAssemblyState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
        addField<DAS_BIND_MANAGED_FIELD(pViewportState)>("pViewportState");
        addField<DAS_BIND_MANAGED_FIELD(pRasterizationState)>("pRasterizationState");
        addField<DAS_BIND_MANAGED_FIELD(pMultisampleState)>("pMultisampleState");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilState)>("pDepthStencilState");
        addField<DAS_BIND_MANAGED_FIELD(pColorBlendState)>("pColorBlendState");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPushConstantRange, VkPushConstantRange);

struct VkPushConstantRangeAnnotation
: public ManagedStructureAnnotation<VkPushConstantRange,true,true> {
    VkPushConstantRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPushConstantRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineLayoutCreateInfo, VkPipelineLayoutCreateInfo);

struct VkPipelineLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineLayoutCreateInfo,true,true> {
    VkPipelineLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(setLayoutCount)>("setLayoutCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
        addField<DAS_BIND_MANAGED_FIELD(pushConstantRangeCount)>("pushConstantRangeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPushConstantRanges)>("pPushConstantRanges");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerCreateInfo, VkSamplerCreateInfo);

struct VkSamplerCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerCreateInfo,true,true> {
    VkSamplerCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(magFilter)>("magFilter");
        addField<DAS_BIND_MANAGED_FIELD(minFilter)>("minFilter");
        addField<DAS_BIND_MANAGED_FIELD(mipmapMode)>("mipmapMode");
        addField<DAS_BIND_MANAGED_FIELD(addressModeU)>("addressModeU");
        addField<DAS_BIND_MANAGED_FIELD(addressModeV)>("addressModeV");
        addField<DAS_BIND_MANAGED_FIELD(addressModeW)>("addressModeW");
        addField<DAS_BIND_MANAGED_FIELD(mipLodBias)>("mipLodBias");
        addField<DAS_BIND_MANAGED_FIELD(anisotropyEnable)>("anisotropyEnable");
        addField<DAS_BIND_MANAGED_FIELD(maxAnisotropy)>("maxAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(compareEnable)>("compareEnable");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(minLod)>("minLod");
        addField<DAS_BIND_MANAGED_FIELD(maxLod)>("maxLod");
        addField<DAS_BIND_MANAGED_FIELD(borderColor)>("borderColor");
        addField<DAS_BIND_MANAGED_FIELD(unnormalizedCoordinates)>("unnormalizedCoordinates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyDescriptorSet, VkCopyDescriptorSet);

struct VkCopyDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkCopyDescriptorSet,true,true> {
    VkCopyDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSet)>("srcSet");
        addField<DAS_BIND_MANAGED_FIELD(srcBinding)>("srcBinding");
        addField<DAS_BIND_MANAGED_FIELD(srcArrayElement)>("srcArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorBufferInfo, VkDescriptorBufferInfo);

struct VkDescriptorBufferInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorBufferInfo,true,true> {
    VkDescriptorBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorImageInfo, VkDescriptorImageInfo);

struct VkDescriptorImageInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorImageInfo,true,true> {
    VkDescriptorImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(imageLayout)>("imageLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorPoolSize, VkDescriptorPoolSize);

struct VkDescriptorPoolSizeAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolSize,true,true> {
    VkDescriptorPoolSizeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolSize", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorPoolCreateInfo, VkDescriptorPoolCreateInfo);

struct VkDescriptorPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolCreateInfo,true,true> {
    VkDescriptorPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(maxSets)>("maxSets");
        addField<DAS_BIND_MANAGED_FIELD(poolSizeCount)>("poolSizeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPoolSizes)>("pPoolSizes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetAllocateInfo, VkDescriptorSetAllocateInfo);

struct VkDescriptorSetAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetAllocateInfo,true,true> {
    VkDescriptorSetAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorPool)>("descriptorPool");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetLayoutBinding, VkDescriptorSetLayoutBinding);

struct VkDescriptorSetLayoutBindingAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBinding,true,true> {
    VkDescriptorSetLayoutBindingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBinding", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pImmutableSamplers)>("pImmutableSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutCreateInfo);

struct VkDescriptorSetLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutCreateInfo,true,true> {
    VkDescriptorSetLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindings)>("pBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkWriteDescriptorSet, VkWriteDescriptorSet);

struct VkWriteDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSet,true,true> {
    VkWriteDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(pImageInfo)>("pImageInfo");
        addField<DAS_BIND_MANAGED_FIELD(pBufferInfo)>("pBufferInfo");
        addField<DAS_BIND_MANAGED_FIELD(pTexelBufferView)>("pTexelBufferView");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentDescription, VkAttachmentDescription);

struct VkAttachmentDescriptionAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescription,true,true> {
    VkAttachmentDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentReference, VkAttachmentReference);

struct VkAttachmentReferenceAnnotation
: public ManagedStructureAnnotation<VkAttachmentReference,true,true> {
    VkAttachmentReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFramebufferCreateInfo, VkFramebufferCreateInfo);

struct VkFramebufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferCreateInfo,true,true> {
    VkFramebufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layers)>("layers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassDescription, VkSubpassDescription);

struct VkSubpassDescriptionAnnotation
: public ManagedStructureAnnotation<VkSubpassDescription,true,true> {
    VkSubpassDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassDependency, VkSubpassDependency);

struct VkSubpassDependencyAnnotation
: public ManagedStructureAnnotation<VkSubpassDependency,true,true> {
    VkSubpassDependencyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassCreateInfo, VkRenderPassCreateInfo);

struct VkRenderPassCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo,true,true> {
    VkRenderPassCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandPoolCreateInfo, VkCommandPoolCreateInfo);

struct VkCommandPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandPoolCreateInfo,true,true> {
    VkCommandPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandBufferAllocateInfo, VkCommandBufferAllocateInfo);

struct VkCommandBufferAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferAllocateInfo,true,true> {
    VkCommandBufferAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(commandPool)>("commandPool");
        addField<DAS_BIND_MANAGED_FIELD(level)>("level");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandBufferInheritanceInfo, VkCommandBufferInheritanceInfo);

struct VkCommandBufferInheritanceInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceInfo,true,true> {
    VkCommandBufferInheritanceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryEnable)>("occlusionQueryEnable");
        addField<DAS_BIND_MANAGED_FIELD(queryFlags)>("queryFlags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandBufferBeginInfo, VkCommandBufferBeginInfo);

struct VkCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferBeginInfo,true,true> {
    VkCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pInheritanceInfo)>("pInheritanceInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferCopy, VkBufferCopy);

struct VkBufferCopyAnnotation
: public ManagedStructureAnnotation<VkBufferCopy,true,true> {
    VkBufferCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageSubresourceLayers, VkImageSubresourceLayers);

struct VkImageSubresourceLayersAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceLayers,true,true> {
    VkImageSubresourceLayersAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceLayers", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferImageCopy, VkBufferImageCopy);

struct VkBufferImageCopyAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy,true,true> {
    VkBufferImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkClearColorValue, VkClearColorValue);

struct VkClearColorValueAnnotation
: public ManagedStructureAnnotation<VkClearColorValue,true,true> {
    VkClearColorValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearColorValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkClearDepthStencilValue, VkClearDepthStencilValue);

struct VkClearDepthStencilValueAnnotation
: public ManagedStructureAnnotation<VkClearDepthStencilValue,true,true> {
    VkClearDepthStencilValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearDepthStencilValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
        addField<DAS_BIND_MANAGED_FIELD(stencil)>("stencil");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkClearValue, VkClearValue);

struct VkClearValueAnnotation
: public ManagedStructureAnnotation<VkClearValue,true,true> {
    VkClearValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
        addField<DAS_BIND_MANAGED_FIELD(depthStencil)>("depthStencil");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkClearAttachment, VkClearAttachment);

struct VkClearAttachmentAnnotation
: public ManagedStructureAnnotation<VkClearAttachment,true,true> {
    VkClearAttachmentAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearAttachment", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachment)>("colorAttachment");
        addField<DAS_BIND_MANAGED_FIELD(clearValue)>("clearValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkClearRect, VkClearRect);

struct VkClearRectAnnotation
: public ManagedStructureAnnotation<VkClearRect,true,true> {
    VkClearRectAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearRect", ml) {
        addField<DAS_BIND_MANAGED_FIELD(rect)>("rect");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageBlit, VkImageBlit);

struct VkImageBlitAnnotation
: public ManagedStructureAnnotation<VkImageBlit,true,true> {
    VkImageBlitAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageBlit", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffsets)>("srcOffsets");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffsets)>("dstOffsets");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageCopy, VkImageCopy);

struct VkImageCopyAnnotation
: public ManagedStructureAnnotation<VkImageCopy,true,true> {
    VkImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageResolve, VkImageResolve);

struct VkImageResolveAnnotation
: public ManagedStructureAnnotation<VkImageResolve,true,true> {
    VkImageResolveAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageResolve", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassBeginInfo, VkRenderPassBeginInfo);

struct VkRenderPassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassBeginInfo,true,true> {
    VkRenderPassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(renderArea)>("renderArea");
        addField<DAS_BIND_MANAGED_FIELD(clearValueCount)>("clearValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pClearValues)>("pClearValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupProperties);

struct VkPhysicalDeviceSubgroupPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupProperties,true,true> {
    VkPhysicalDeviceSubgroupPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(supportedStages)>("supportedStages");
        addField<DAS_BIND_MANAGED_FIELD(supportedOperations)>("supportedOperations");
        addField<DAS_BIND_MANAGED_FIELD(quadOperationsInAllStages)>("quadOperationsInAllStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindBufferMemoryInfo, VkBindBufferMemoryInfo);

struct VkBindBufferMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindBufferMemoryInfo,true,true> {
    VkBindBufferMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindBufferMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindImageMemoryInfo, VkBindImageMemoryInfo);

struct VkBindImageMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindImageMemoryInfo,true,true> {
    VkBindImageMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice16BitStorageFeatures);

struct VkPhysicalDevice16BitStorageFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice16BitStorageFeatures,true,true> {
    VkPhysicalDevice16BitStorageFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice16BitStorageFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer16BitAccess)>("storageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer16BitAccess)>("uniformAndStorageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant16)>("storagePushConstant16");
        addField<DAS_BIND_MANAGED_FIELD(storageInputOutput16)>("storageInputOutput16");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryDedicatedRequirements, VkMemoryDedicatedRequirements);

struct VkMemoryDedicatedRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryDedicatedRequirements,true,true> {
    VkMemoryDedicatedRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryDedicatedRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(prefersDedicatedAllocation)>("prefersDedicatedAllocation");
        addField<DAS_BIND_MANAGED_FIELD(requiresDedicatedAllocation)>("requiresDedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryDedicatedAllocateInfo, VkMemoryDedicatedAllocateInfo);

struct VkMemoryDedicatedAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryDedicatedAllocateInfo,true,true> {
    VkMemoryDedicatedAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryDedicatedAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryAllocateFlagsInfo, VkMemoryAllocateFlagsInfo);

struct VkMemoryAllocateFlagsInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateFlagsInfo,true,true> {
    VkMemoryAllocateFlagsInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateFlagsInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupRenderPassBeginInfo, VkDeviceGroupRenderPassBeginInfo);

struct VkDeviceGroupRenderPassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupRenderPassBeginInfo,true,true> {
    VkDeviceGroupRenderPassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupRenderPassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceRenderAreaCount)>("deviceRenderAreaCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceRenderAreas)>("pDeviceRenderAreas");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupCommandBufferBeginInfo, VkDeviceGroupCommandBufferBeginInfo);

struct VkDeviceGroupCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupCommandBufferBeginInfo,true,true> {
    VkDeviceGroupCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupSubmitInfo, VkDeviceGroupSubmitInfo);

struct VkDeviceGroupSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupSubmitInfo,true,true> {
    VkDeviceGroupSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreDeviceIndices)>("pWaitSemaphoreDeviceIndices");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
        addField<DAS_BIND_MANAGED_FIELD(pCommandBufferDeviceMasks)>("pCommandBufferDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreDeviceIndices)>("pSignalSemaphoreDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupBindSparseInfo, VkDeviceGroupBindSparseInfo);

struct VkDeviceGroupBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupBindSparseInfo,true,true> {
    VkDeviceGroupBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(resourceDeviceIndex)>("resourceDeviceIndex");
        addField<DAS_BIND_MANAGED_FIELD(memoryDeviceIndex)>("memoryDeviceIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindBufferMemoryDeviceGroupInfo, VkBindBufferMemoryDeviceGroupInfo);

struct VkBindBufferMemoryDeviceGroupInfoAnnotation
: public ManagedStructureAnnotation<VkBindBufferMemoryDeviceGroupInfo,true,true> {
    VkBindBufferMemoryDeviceGroupInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindBufferMemoryDeviceGroupInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindImageMemoryDeviceGroupInfo, VkBindImageMemoryDeviceGroupInfo);

struct VkBindImageMemoryDeviceGroupInfoAnnotation
: public ManagedStructureAnnotation<VkBindImageMemoryDeviceGroupInfo,true,true> {
    VkBindImageMemoryDeviceGroupInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemoryDeviceGroupInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
        addField<DAS_BIND_MANAGED_FIELD(splitInstanceBindRegionCount)>("splitInstanceBindRegionCount");
        addField<DAS_BIND_MANAGED_FIELD(pSplitInstanceBindRegions)>("pSplitInstanceBindRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceGroupProperties, VkPhysicalDeviceGroupProperties);

struct VkPhysicalDeviceGroupPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceGroupProperties,true,true> {
    VkPhysicalDeviceGroupPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceGroupProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(physicalDeviceCount)>("physicalDeviceCount");
        addField<DAS_BIND_MANAGED_FIELD(physicalDevices)>("physicalDevices");
        addField<DAS_BIND_MANAGED_FIELD(subsetAllocation)>("subsetAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupDeviceCreateInfo, VkDeviceGroupDeviceCreateInfo);

struct VkDeviceGroupDeviceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupDeviceCreateInfo,true,true> {
    VkDeviceGroupDeviceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupDeviceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(physicalDeviceCount)>("physicalDeviceCount");
        addField<DAS_BIND_MANAGED_FIELD(pPhysicalDevices)>("pPhysicalDevices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferMemoryRequirementsInfo2, VkBufferMemoryRequirementsInfo2);

struct VkBufferMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkBufferMemoryRequirementsInfo2,true,true> {
    VkBufferMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageMemoryRequirementsInfo2, VkImageMemoryRequirementsInfo2);

struct VkImageMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkImageMemoryRequirementsInfo2,true,true> {
    VkImageMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageSparseMemoryRequirementsInfo2, VkImageSparseMemoryRequirementsInfo2);

struct VkImageSparseMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkImageSparseMemoryRequirementsInfo2,true,true> {
    VkImageSparseMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSparseMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryRequirements2, VkMemoryRequirements2);

struct VkMemoryRequirements2Annotation
: public ManagedStructureAnnotation<VkMemoryRequirements2,true,true> {
    VkMemoryRequirements2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryRequirements)>("memoryRequirements");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageMemoryRequirements2, VkSparseImageMemoryRequirements2);

struct VkSparseImageMemoryRequirements2Annotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements2,true,true> {
    VkSparseImageMemoryRequirements2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryRequirements)>("memoryRequirements");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFeatures2, VkPhysicalDeviceFeatures2);

struct VkPhysicalDeviceFeatures2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFeatures2,true,true> {
    VkPhysicalDeviceFeatures2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFeatures2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(features)>("features");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceProperties2, VkPhysicalDeviceProperties2);

struct VkPhysicalDeviceProperties2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProperties2,true,true> {
    VkPhysicalDeviceProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(properties)>("properties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFormatProperties2, VkFormatProperties2);

struct VkFormatProperties2Annotation
: public ManagedStructureAnnotation<VkFormatProperties2,true,true> {
    VkFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageFormatProperties2, VkImageFormatProperties2);

struct VkImageFormatProperties2Annotation
: public ManagedStructureAnnotation<VkImageFormatProperties2,true,true> {
    VkImageFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceImageFormatInfo2);

struct VkPhysicalDeviceImageFormatInfo2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageFormatInfo2,true,true> {
    VkPhysicalDeviceImageFormatInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageFormatInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueueFamilyProperties2, VkQueueFamilyProperties2);

struct VkQueueFamilyProperties2Annotation
: public ManagedStructureAnnotation<VkQueueFamilyProperties2,true,true> {
    VkQueueFamilyProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyProperties)>("queueFamilyProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMemoryProperties2, VkPhysicalDeviceMemoryProperties2);

struct VkPhysicalDeviceMemoryProperties2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryProperties2,true,true> {
    VkPhysicalDeviceMemoryProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryProperties)>("memoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSparseImageFormatProperties2, VkSparseImageFormatProperties2);

struct VkSparseImageFormatProperties2Annotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties2,true,true> {
    VkSparseImageFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(properties)>("properties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSparseImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2);

struct VkPhysicalDeviceSparseImageFormatInfo2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseImageFormatInfo2,true,true> {
    VkPhysicalDeviceSparseImageFormatInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseImageFormatInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePointClippingProperties);

struct VkPhysicalDevicePointClippingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePointClippingProperties,true,true> {
    VkPhysicalDevicePointClippingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePointClippingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkInputAttachmentAspectReference, VkInputAttachmentAspectReference);

struct VkInputAttachmentAspectReferenceAnnotation
: public ManagedStructureAnnotation<VkInputAttachmentAspectReference,true,true> {
    VkInputAttachmentAspectReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInputAttachmentAspectReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentIndex)>("inputAttachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassInputAttachmentAspectCreateInfo, VkRenderPassInputAttachmentAspectCreateInfo);

struct VkRenderPassInputAttachmentAspectCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassInputAttachmentAspectCreateInfo,true,true> {
    VkRenderPassInputAttachmentAspectCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassInputAttachmentAspectCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(aspectReferenceCount)>("aspectReferenceCount");
        addField<DAS_BIND_MANAGED_FIELD(pAspectReferences)>("pAspectReferences");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageViewUsageCreateInfo, VkImageViewUsageCreateInfo);

struct VkImageViewUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewUsageCreateInfo,true,true> {
    VkImageViewUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineTessellationDomainOriginStateCreateInfo, VkPipelineTessellationDomainOriginStateCreateInfo);

struct VkPipelineTessellationDomainOriginStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationDomainOriginStateCreateInfo,true,true> {
    VkPipelineTessellationDomainOriginStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationDomainOriginStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(domainOrigin)>("domainOrigin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassMultiviewCreateInfo, VkRenderPassMultiviewCreateInfo);

struct VkRenderPassMultiviewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassMultiviewCreateInfo,true,true> {
    VkRenderPassMultiviewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassMultiviewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewMasks)>("pViewMasks");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewOffsets)>("pViewOffsets");
        addField<DAS_BIND_MANAGED_FIELD(correlationMaskCount)>("correlationMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelationMasks)>("pCorrelationMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewFeatures);

struct VkPhysicalDeviceMultiviewFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewFeatures,true,true> {
    VkPhysicalDeviceMultiviewFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceMultiviewProperties);

struct VkPhysicalDeviceMultiviewPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewProperties,true,true> {
    VkPhysicalDeviceMultiviewPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVariablePointersFeatures);

struct VkPhysicalDeviceVariablePointersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVariablePointersFeatures,true,true> {
    VkPhysicalDeviceVariablePointersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVariablePointersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProtectedMemoryFeatures);

struct VkPhysicalDeviceProtectedMemoryFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryFeatures,true,true> {
    VkPhysicalDeviceProtectedMemoryFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProtectedMemoryProperties);

struct VkPhysicalDeviceProtectedMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryProperties,true,true> {
    VkPhysicalDeviceProtectedMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceQueueInfo2, VkDeviceQueueInfo2);

struct VkDeviceQueueInfo2Annotation
: public ManagedStructureAnnotation<VkDeviceQueueInfo2,true,true> {
    VkDeviceQueueInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueIndex)>("queueIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkProtectedSubmitInfo, VkProtectedSubmitInfo);

struct VkProtectedSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkProtectedSubmitInfo,true,true> {
    VkProtectedSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkProtectedSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedSubmit)>("protectedSubmit");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerYcbcrConversionCreateInfo, VkSamplerYcbcrConversionCreateInfo);

struct VkSamplerYcbcrConversionCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionCreateInfo,true,true> {
    VkSamplerYcbcrConversionCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrModel)>("ycbcrModel");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrRange)>("ycbcrRange");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(xChromaOffset)>("xChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(yChromaOffset)>("yChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(chromaFilter)>("chromaFilter");
        addField<DAS_BIND_MANAGED_FIELD(forceExplicitReconstruction)>("forceExplicitReconstruction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerYcbcrConversionInfo, VkSamplerYcbcrConversionInfo);

struct VkSamplerYcbcrConversionInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionInfo,true,true> {
    VkSamplerYcbcrConversionInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conversion)>("conversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindImagePlaneMemoryInfo, VkBindImagePlaneMemoryInfo);

struct VkBindImagePlaneMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindImagePlaneMemoryInfo,true,true> {
    VkBindImagePlaneMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImagePlaneMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImagePlaneMemoryRequirementsInfo, VkImagePlaneMemoryRequirementsInfo);

struct VkImagePlaneMemoryRequirementsInfoAnnotation
: public ManagedStructureAnnotation<VkImagePlaneMemoryRequirementsInfo,true,true> {
    VkImagePlaneMemoryRequirementsInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImagePlaneMemoryRequirementsInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures);

struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerYcbcrConversionFeatures,true,true> {
    VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerYcbcrConversionFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerYcbcrConversionImageFormatProperties, VkSamplerYcbcrConversionImageFormatProperties);

struct VkSamplerYcbcrConversionImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionImageFormatProperties,true,true> {
    VkSamplerYcbcrConversionImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(combinedImageSamplerDescriptorCount)>("combinedImageSamplerDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorUpdateTemplateEntry, VkDescriptorUpdateTemplateEntry);

struct VkDescriptorUpdateTemplateEntryAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateEntry,true,true> {
    VkDescriptorUpdateTemplateEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorUpdateTemplateCreateInfo, VkDescriptorUpdateTemplateCreateInfo);

struct VkDescriptorUpdateTemplateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateCreateInfo,true,true> {
    VkDescriptorUpdateTemplateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(descriptorUpdateEntryCount)>("descriptorUpdateEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorUpdateEntries)>("pDescriptorUpdateEntries");
        addField<DAS_BIND_MANAGED_FIELD(templateType)>("templateType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetLayout)>("descriptorSetLayout");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipelineLayout)>("pipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(set)>("set");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalMemoryProperties, VkExternalMemoryProperties);

struct VkExternalMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryProperties,true,true> {
    VkExternalMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceExternalImageFormatInfo);

struct VkPhysicalDeviceExternalImageFormatInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalImageFormatInfo,true,true> {
    VkPhysicalDeviceExternalImageFormatInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalImageFormatInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalImageFormatProperties, VkExternalImageFormatProperties);

struct VkExternalImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatProperties,true,true> {
    VkExternalImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExternalBufferInfo, VkPhysicalDeviceExternalBufferInfo);

struct VkPhysicalDeviceExternalBufferInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalBufferInfo,true,true> {
    VkPhysicalDeviceExternalBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalBufferProperties, VkExternalBufferProperties);

struct VkExternalBufferPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalBufferProperties,true,true> {
    VkExternalBufferPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalBufferProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceIDProperties, VkPhysicalDeviceIDProperties);

struct VkPhysicalDeviceIDPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIDProperties,true,true> {
    VkPhysicalDeviceIDPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIDProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfo);

struct VkExternalMemoryImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfo,true,true> {
    VkExternalMemoryImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalMemoryBufferCreateInfo, VkExternalMemoryBufferCreateInfo);

struct VkExternalMemoryBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryBufferCreateInfo,true,true> {
    VkExternalMemoryBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfo);

struct VkExportMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfo,true,true> {
    VkExportMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExternalFenceInfo, VkPhysicalDeviceExternalFenceInfo);

struct VkPhysicalDeviceExternalFenceInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalFenceInfo,true,true> {
    VkPhysicalDeviceExternalFenceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalFenceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalFenceProperties, VkExternalFenceProperties);

struct VkExternalFencePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalFenceProperties,true,true> {
    VkExternalFencePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalFenceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalFenceFeatures)>("externalFenceFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExportFenceCreateInfo, VkExportFenceCreateInfo);

struct VkExportFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportFenceCreateInfo,true,true> {
    VkExportFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExportSemaphoreCreateInfo, VkExportSemaphoreCreateInfo);

struct VkExportSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportSemaphoreCreateInfo,true,true> {
    VkExportSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExternalSemaphoreInfo, VkPhysicalDeviceExternalSemaphoreInfo);

struct VkPhysicalDeviceExternalSemaphoreInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalSemaphoreInfo,true,true> {
    VkPhysicalDeviceExternalSemaphoreInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalSemaphoreInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalSemaphoreProperties, VkExternalSemaphoreProperties);

struct VkExternalSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalSemaphoreProperties,true,true> {
    VkExternalSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalSemaphoreFeatures)>("externalSemaphoreFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance3Properties);

struct VkPhysicalDeviceMaintenance3PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMaintenance3Properties,true,true> {
    VkPhysicalDeviceMaintenance3PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMaintenance3Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetLayoutSupport, VkDescriptorSetLayoutSupport);

struct VkDescriptorSetLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutSupport,true,true> {
    VkDescriptorSetLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supported)>("supported");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderDrawParametersFeatures);

struct VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDrawParametersFeatures,true,true> {
    VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDrawParametersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan11Features);

struct VkPhysicalDeviceVulkan11FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Features,true,true> {
    VkPhysicalDeviceVulkan11FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer16BitAccess)>("storageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer16BitAccess)>("uniformAndStorageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant16)>("storagePushConstant16");
        addField<DAS_BIND_MANAGED_FIELD(storageInputOutput16)>("storageInputOutput16");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan11Properties);

struct VkPhysicalDeviceVulkan11PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Properties,true,true> {
    VkPhysicalDeviceVulkan11PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedStages)>("subgroupSupportedStages");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedOperations)>("subgroupSupportedOperations");
        addField<DAS_BIND_MANAGED_FIELD(subgroupQuadOperationsInAllStages)>("subgroupQuadOperationsInAllStages");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan12Features);

struct VkPhysicalDeviceVulkan12FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Features,true,true> {
    VkPhysicalDeviceVulkan12FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerMirrorClampToEdge)>("samplerMirrorClampToEdge");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectCount)>("drawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
        addField<DAS_BIND_MANAGED_FIELD(descriptorIndexing)>("descriptorIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
        addField<DAS_BIND_MANAGED_FIELD(samplerFilterMinmax)>("samplerFilterMinmax");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputViewportIndex)>("shaderOutputViewportIndex");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputLayer)>("shaderOutputLayer");
        addField<DAS_BIND_MANAGED_FIELD(subgroupBroadcastDynamicId)>("subgroupBroadcastDynamicId");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkConformanceVersion, VkConformanceVersion);

struct VkConformanceVersionAnnotation
: public ManagedStructureAnnotation<VkConformanceVersion,true,true> {
    VkConformanceVersionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConformanceVersion", ml) {
        addField<DAS_BIND_MANAGED_FIELD(major)>("major");
        addField<DAS_BIND_MANAGED_FIELD(minor)>("minor");
        addField<DAS_BIND_MANAGED_FIELD(subminor)>("subminor");
        addField<DAS_BIND_MANAGED_FIELD(patch)>("patch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan12Properties);

struct VkPhysicalDeviceVulkan12PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Properties,true,true> {
    VkPhysicalDeviceVulkan12PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
        addField<DAS_BIND_MANAGED_FIELD(framebufferIntegerColorSampleCounts)>("framebufferIntegerColorSampleCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageFormatListCreateInfo, VkImageFormatListCreateInfo);

struct VkImageFormatListCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageFormatListCreateInfo,true,true> {
    VkImageFormatListCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatListCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentDescription2, VkAttachmentDescription2);

struct VkAttachmentDescription2Annotation
: public ManagedStructureAnnotation<VkAttachmentDescription2,true,true> {
    VkAttachmentDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentReference2, VkAttachmentReference2);

struct VkAttachmentReference2Annotation
: public ManagedStructureAnnotation<VkAttachmentReference2,true,true> {
    VkAttachmentReference2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassDescription2, VkSubpassDescription2);

struct VkSubpassDescription2Annotation
: public ManagedStructureAnnotation<VkSubpassDescription2,true,true> {
    VkSubpassDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(viewMask)>("viewMask");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassDependency2, VkSubpassDependency2);

struct VkSubpassDependency2Annotation
: public ManagedStructureAnnotation<VkSubpassDependency2,true,true> {
    VkSubpassDependency2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
        addField<DAS_BIND_MANAGED_FIELD(viewOffset)>("viewOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassCreateInfo2, VkRenderPassCreateInfo2);

struct VkRenderPassCreateInfo2Annotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo2,true,true> {
    VkRenderPassCreateInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
        addField<DAS_BIND_MANAGED_FIELD(correlatedViewMaskCount)>("correlatedViewMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelatedViewMasks)>("pCorrelatedViewMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassBeginInfo, VkSubpassBeginInfo);

struct VkSubpassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassBeginInfo,true,true> {
    VkSubpassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(contents)>("contents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassEndInfo, VkSubpassEndInfo);

struct VkSubpassEndInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassEndInfo,true,true> {
    VkSubpassEndInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassEndInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevice8BitStorageFeatures, VkPhysicalDevice8BitStorageFeatures);

struct VkPhysicalDevice8BitStorageFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice8BitStorageFeatures,true,true> {
    VkPhysicalDevice8BitStorageFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice8BitStorageFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDriverProperties);

struct VkPhysicalDeviceDriverPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDriverProperties,true,true> {
    VkPhysicalDeviceDriverPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDriverProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderAtomicInt64Features);

struct VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicInt64Features,true,true> {
    VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicInt64Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderFloat16Int8Features);

struct VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderFloat16Int8Features,true,true> {
    VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderFloat16Int8Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFloatControlsProperties);

struct VkPhysicalDeviceFloatControlsPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFloatControlsProperties,true,true> {
    VkPhysicalDeviceFloatControlsPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFloatControlsProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetLayoutBindingFlagsCreateInfo, VkDescriptorSetLayoutBindingFlagsCreateInfo);

struct VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBindingFlagsCreateInfo,true,true> {
    VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBindingFlagsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindingFlags)>("pBindingFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorIndexingFeatures);

struct VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingFeatures,true,true> {
    VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDescriptorIndexingProperties);

struct VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingProperties,true,true> {
    VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountAllocateInfo, VkDescriptorSetVariableDescriptorCountAllocateInfo);

struct VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountAllocateInfo,true,true> {
    VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorCounts)>("pDescriptorCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountLayoutSupport, VkDescriptorSetVariableDescriptorCountLayoutSupport);

struct VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountLayoutSupport,true,true> {
    VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVariableDescriptorCount)>("maxVariableDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassDescriptionDepthStencilResolve, VkSubpassDescriptionDepthStencilResolve);

struct VkSubpassDescriptionDepthStencilResolveAnnotation
: public ManagedStructureAnnotation<VkSubpassDescriptionDepthStencilResolve,true,true> {
    VkSubpassDescriptionDepthStencilResolveAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescriptionDepthStencilResolve", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthResolveMode)>("depthResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(stencilResolveMode)>("stencilResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilResolveAttachment)>("pDepthStencilResolveAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDepthStencilResolveProperties);

struct VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthStencilResolveProperties,true,true> {
    VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthStencilResolveProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures);

struct VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceScalarBlockLayoutFeatures,true,true> {
    VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceScalarBlockLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageStencilUsageCreateInfo, VkImageStencilUsageCreateInfo);

struct VkImageStencilUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageStencilUsageCreateInfo,true,true> {
    VkImageStencilUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageStencilUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilUsage)>("stencilUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerReductionModeCreateInfo, VkSamplerReductionModeCreateInfo);

struct VkSamplerReductionModeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerReductionModeCreateInfo,true,true> {
    VkSamplerReductionModeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerReductionModeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(reductionMode)>("reductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceSamplerFilterMinmaxProperties);

struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerFilterMinmaxProperties,true,true> {
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerFilterMinmaxProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceVulkanMemoryModelFeatures);

struct VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkanMemoryModelFeatures,true,true> {
    VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkanMemoryModelFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceImagelessFramebufferFeatures);

struct VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImagelessFramebufferFeatures,true,true> {
    VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImagelessFramebufferFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFramebufferAttachmentImageInfo, VkFramebufferAttachmentImageInfo);

struct VkFramebufferAttachmentImageInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentImageInfo,true,true> {
    VkFramebufferAttachmentImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFramebufferAttachmentsCreateInfo, VkFramebufferAttachmentsCreateInfo);

struct VkFramebufferAttachmentsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentsCreateInfo,true,true> {
    VkFramebufferAttachmentsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentImageInfoCount)>("attachmentImageInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentImageInfos)>("pAttachmentImageInfos");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassAttachmentBeginInfo, VkRenderPassAttachmentBeginInfo);

struct VkRenderPassAttachmentBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassAttachmentBeginInfo,true,true> {
    VkRenderPassAttachmentBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassAttachmentBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);

struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceUniformBufferStandardLayoutFeatures,true,true> {
    VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceUniformBufferStandardLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,true,true> {
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,true,true> {
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentReferenceStencilLayout, VkAttachmentReferenceStencilLayout);

struct VkAttachmentReferenceStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentReferenceStencilLayout,true,true> {
    VkAttachmentReferenceStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReferenceStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilLayout)>("stencilLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentDescriptionStencilLayout, VkAttachmentDescriptionStencilLayout);

struct VkAttachmentDescriptionStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescriptionStencilLayout,true,true> {
    VkAttachmentDescriptionStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescriptionStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilInitialLayout)>("stencilInitialLayout");
        addField<DAS_BIND_MANAGED_FIELD(stencilFinalLayout)>("stencilFinalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceHostQueryResetFeatures);

struct VkPhysicalDeviceHostQueryResetFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceHostQueryResetFeatures,true,true> {
    VkPhysicalDeviceHostQueryResetFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceHostQueryResetFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures);

struct VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreFeatures,true,true> {
    VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTimelineSemaphoreProperties);

struct VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreProperties,true,true> {
    VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSemaphoreTypeCreateInfo, VkSemaphoreTypeCreateInfo);

struct VkSemaphoreTypeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreTypeCreateInfo,true,true> {
    VkSemaphoreTypeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreTypeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreType)>("semaphoreType");
        addField<DAS_BIND_MANAGED_FIELD(initialValue)>("initialValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkTimelineSemaphoreSubmitInfo, VkTimelineSemaphoreSubmitInfo);

struct VkTimelineSemaphoreSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkTimelineSemaphoreSubmitInfo,true,true> {
    VkTimelineSemaphoreSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTimelineSemaphoreSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreValueCount)>("waitSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreValues)>("pWaitSemaphoreValues");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreValueCount)>("signalSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreValues)>("pSignalSemaphoreValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSemaphoreWaitInfo, VkSemaphoreWaitInfo);

struct VkSemaphoreWaitInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreWaitInfo,true,true> {
    VkSemaphoreWaitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreWaitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreCount)>("semaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSemaphores)>("pSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pValues)>("pValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSemaphoreSignalInfo, VkSemaphoreSignalInfo);

struct VkSemaphoreSignalInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreSignalInfo,true,true> {
    VkSemaphoreSignalInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreSignalInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeatures,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferDeviceAddressInfo, VkBufferDeviceAddressInfo);

struct VkBufferDeviceAddressInfoAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressInfo,true,true> {
    VkBufferDeviceAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferOpaqueCaptureAddressCreateInfo, VkBufferOpaqueCaptureAddressCreateInfo);

struct VkBufferOpaqueCaptureAddressCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferOpaqueCaptureAddressCreateInfo,true,true> {
    VkBufferOpaqueCaptureAddressCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferOpaqueCaptureAddressCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryOpaqueCaptureAddressAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo);

struct VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryOpaqueCaptureAddressAllocateInfo,true,true> {
    VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryOpaqueCaptureAddressAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceMemoryOpaqueCaptureAddressInfo, VkDeviceMemoryOpaqueCaptureAddressInfo);

struct VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOpaqueCaptureAddressInfo,true,true> {
    VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOpaqueCaptureAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesKHR);

struct VkSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilitiesKHR,true,true> {
    VkSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceFormatKHR, VkSurfaceFormatKHR);

struct VkSurfaceFormatKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormatKHR,true,true> {
    VkSurfaceFormatKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormatKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(colorSpace)>("colorSpace");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSwapchainCreateInfoKHR, VkSwapchainCreateInfoKHR);

struct VkSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSwapchainCreateInfoKHR,true,true> {
    VkSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(imageFormat)>("imageFormat");
        addField<DAS_BIND_MANAGED_FIELD(imageColorSpace)>("imageColorSpace");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
        addField<DAS_BIND_MANAGED_FIELD(imageArrayLayers)>("imageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(imageUsage)>("imageUsage");
        addField<DAS_BIND_MANAGED_FIELD(imageSharingMode)>("imageSharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(preTransform)>("preTransform");
        addField<DAS_BIND_MANAGED_FIELD(compositeAlpha)>("compositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(presentMode)>("presentMode");
        addField<DAS_BIND_MANAGED_FIELD(clipped)>("clipped");
        addField<DAS_BIND_MANAGED_FIELD(oldSwapchain)>("oldSwapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPresentInfoKHR, VkPresentInfoKHR);

struct VkPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPresentInfoKHR,true,true> {
    VkPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pSwapchains)>("pSwapchains");
        addField<DAS_BIND_MANAGED_FIELD(pImageIndices)>("pImageIndices");
        addField<DAS_BIND_MANAGED_FIELD(pResults)>("pResults");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageSwapchainCreateInfoKHR, VkImageSwapchainCreateInfoKHR);

struct VkImageSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImageSwapchainCreateInfoKHR,true,true> {
    VkImageSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindImageMemorySwapchainInfoKHR, VkBindImageMemorySwapchainInfoKHR);

struct VkBindImageMemorySwapchainInfoKHRAnnotation
: public ManagedStructureAnnotation<VkBindImageMemorySwapchainInfoKHR,true,true> {
    VkBindImageMemorySwapchainInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemorySwapchainInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(imageIndex)>("imageIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAcquireNextImageInfoKHR, VkAcquireNextImageInfoKHR);

struct VkAcquireNextImageInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireNextImageInfoKHR,true,true> {
    VkAcquireNextImageInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireNextImageInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentCapabilitiesKHR);

struct VkDeviceGroupPresentCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentCapabilitiesKHR,true,true> {
    VkDeviceGroupPresentCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(presentMask)>("presentMask");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupPresentInfoKHR, VkDeviceGroupPresentInfoKHR);

struct VkDeviceGroupPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentInfoKHR,true,true> {
    VkDeviceGroupPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceMasks)>("pDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceGroupSwapchainCreateInfoKHR, VkDeviceGroupSwapchainCreateInfoKHR);

struct VkDeviceGroupSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupSwapchainCreateInfoKHR,true,true> {
    VkDeviceGroupSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayModeParametersKHR, VkDisplayModeParametersKHR);

struct VkDisplayModeParametersKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeParametersKHR,true,true> {
    VkDisplayModeParametersKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeParametersKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(visibleRegion)>("visibleRegion");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayModeCreateInfoKHR, VkDisplayModeCreateInfoKHR);

struct VkDisplayModeCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeCreateInfoKHR,true,true> {
    VkDisplayModeCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(parameters)>("parameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayModePropertiesKHR, VkDisplayModePropertiesKHR);

struct VkDisplayModePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModePropertiesKHR,true,true> {
    VkDisplayModePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(displayMode)>("displayMode");
        addField<DAS_BIND_MANAGED_FIELD(parameters)>("parameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPlaneCapabilitiesKHR, VkDisplayPlaneCapabilitiesKHR);

struct VkDisplayPlaneCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneCapabilitiesKHR,true,true> {
    VkDisplayPlaneCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(supportedAlpha)>("supportedAlpha");
        addField<DAS_BIND_MANAGED_FIELD(minSrcPosition)>("minSrcPosition");
        addField<DAS_BIND_MANAGED_FIELD(maxSrcPosition)>("maxSrcPosition");
        addField<DAS_BIND_MANAGED_FIELD(minSrcExtent)>("minSrcExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxSrcExtent)>("maxSrcExtent");
        addField<DAS_BIND_MANAGED_FIELD(minDstPosition)>("minDstPosition");
        addField<DAS_BIND_MANAGED_FIELD(maxDstPosition)>("maxDstPosition");
        addField<DAS_BIND_MANAGED_FIELD(minDstExtent)>("minDstExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxDstExtent)>("maxDstExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPlanePropertiesKHR, VkDisplayPlanePropertiesKHR);

struct VkDisplayPlanePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlanePropertiesKHR,true,true> {
    VkDisplayPlanePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlanePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(currentDisplay)>("currentDisplay");
        addField<DAS_BIND_MANAGED_FIELD(currentStackIndex)>("currentStackIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPropertiesKHR, VkDisplayPropertiesKHR);

struct VkDisplayPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPropertiesKHR,true,true> {
    VkDisplayPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(display)>("display");
        addField<DAS_BIND_MANAGED_FIELD(displayName)>("displayName");
        addField<DAS_BIND_MANAGED_FIELD(physicalDimensions)>("physicalDimensions");
        addField<DAS_BIND_MANAGED_FIELD(physicalResolution)>("physicalResolution");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(planeReorderPossible)>("planeReorderPossible");
        addField<DAS_BIND_MANAGED_FIELD(persistentContent)>("persistentContent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplaySurfaceCreateInfoKHR, VkDisplaySurfaceCreateInfoKHR);

struct VkDisplaySurfaceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplaySurfaceCreateInfoKHR,true,true> {
    VkDisplaySurfaceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplaySurfaceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(displayMode)>("displayMode");
        addField<DAS_BIND_MANAGED_FIELD(planeIndex)>("planeIndex");
        addField<DAS_BIND_MANAGED_FIELD(planeStackIndex)>("planeStackIndex");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(globalAlpha)>("globalAlpha");
        addField<DAS_BIND_MANAGED_FIELD(alphaMode)>("alphaMode");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPresentInfoKHR, VkDisplayPresentInfoKHR);

struct VkDisplayPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPresentInfoKHR,true,true> {
    VkDisplayPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcRect)>("srcRect");
        addField<DAS_BIND_MANAGED_FIELD(dstRect)>("dstRect");
        addField<DAS_BIND_MANAGED_FIELD(persistent)>("persistent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImportMemoryFdInfoKHR, VkImportMemoryFdInfoKHR);

struct VkImportMemoryFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportMemoryFdInfoKHR,true,true> {
    VkImportMemoryFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportMemoryFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryFdPropertiesKHR, VkMemoryFdPropertiesKHR);

struct VkMemoryFdPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkMemoryFdPropertiesKHR,true,true> {
    VkMemoryFdPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryFdPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryGetFdInfoKHR, VkMemoryGetFdInfoKHR);

struct VkMemoryGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkMemoryGetFdInfoKHR,true,true> {
    VkMemoryGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImportSemaphoreFdInfoKHR, VkImportSemaphoreFdInfoKHR);

struct VkImportSemaphoreFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportSemaphoreFdInfoKHR,true,true> {
    VkImportSemaphoreFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportSemaphoreFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSemaphoreGetFdInfoKHR, VkSemaphoreGetFdInfoKHR);

struct VkSemaphoreGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSemaphoreGetFdInfoKHR,true,true> {
    VkSemaphoreGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDevicePushDescriptorPropertiesKHR);

struct VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePushDescriptorPropertiesKHR,true,true> {
    VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePushDescriptorPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPushDescriptors)>("maxPushDescriptors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRectLayerKHR, VkRectLayerKHR);

struct VkRectLayerKHRAnnotation
: public ManagedStructureAnnotation<VkRectLayerKHR,true,true> {
    VkRectLayerKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRectLayerKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPresentRegionKHR, VkPresentRegionKHR);

struct VkPresentRegionKHRAnnotation
: public ManagedStructureAnnotation<VkPresentRegionKHR,true,true> {
    VkPresentRegionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentRegionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(rectangleCount)>("rectangleCount");
        addField<DAS_BIND_MANAGED_FIELD(pRectangles)>("pRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPresentRegionsKHR, VkPresentRegionsKHR);

struct VkPresentRegionsKHRAnnotation
: public ManagedStructureAnnotation<VkPresentRegionsKHR,true,true> {
    VkPresentRegionsKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentRegionsKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSharedPresentSurfaceCapabilitiesKHR, VkSharedPresentSurfaceCapabilitiesKHR);

struct VkSharedPresentSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSharedPresentSurfaceCapabilitiesKHR,true,true> {
    VkSharedPresentSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSharedPresentSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sharedPresentSupportedUsageFlags)>("sharedPresentSupportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImportFenceFdInfoKHR, VkImportFenceFdInfoKHR);

struct VkImportFenceFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportFenceFdInfoKHR,true,true> {
    VkImportFenceFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportFenceFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFenceGetFdInfoKHR, VkFenceGetFdInfoKHR);

struct VkFenceGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkFenceGetFdInfoKHR,true,true> {
    VkFenceGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePerformanceQueryFeaturesKHR, VkPhysicalDevicePerformanceQueryFeaturesKHR);

struct VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePerformanceQueryFeaturesKHR,true,true> {
    VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePerformanceQueryFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCounterQueryPools)>("performanceCounterQueryPools");
        addField<DAS_BIND_MANAGED_FIELD(performanceCounterMultipleQueryPools)>("performanceCounterMultipleQueryPools");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePerformanceQueryPropertiesKHR);

struct VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePerformanceQueryPropertiesKHR,true,true> {
    VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePerformanceQueryPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allowCommandBufferQueryCopies)>("allowCommandBufferQueryCopies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceCounterKHR, VkPerformanceCounterKHR);

struct VkPerformanceCounterKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterKHR,true,true> {
    VkPerformanceCounterKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(unit)>("unit");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
        addField<DAS_BIND_MANAGED_FIELD(storage)>("storage");
        addField<DAS_BIND_MANAGED_FIELD(uuid)>("uuid");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceCounterDescriptionKHR, VkPerformanceCounterDescriptionKHR);

struct VkPerformanceCounterDescriptionKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterDescriptionKHR,true,true> {
    VkPerformanceCounterDescriptionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterDescriptionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(category)>("category");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueryPoolPerformanceCreateInfoKHR, VkQueryPoolPerformanceCreateInfoKHR);

struct VkQueryPoolPerformanceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceCreateInfoKHR,true,true> {
    VkQueryPoolPerformanceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(counterIndexCount)>("counterIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pCounterIndices)>("pCounterIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceCounterResultKHR, VkPerformanceCounterResultKHR);

struct VkPerformanceCounterResultKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterResultKHR,true,true> {
    VkPerformanceCounterResultKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterResultKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(int64)>("int64_");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
        addField<DAS_BIND_MANAGED_FIELD(uint64)>("uint64_");
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(float64)>("float64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAcquireProfilingLockInfoKHR, VkAcquireProfilingLockInfoKHR);

struct VkAcquireProfilingLockInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireProfilingLockInfoKHR,true,true> {
    VkAcquireProfilingLockInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireProfilingLockInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceQuerySubmitInfoKHR, VkPerformanceQuerySubmitInfoKHR);

struct VkPerformanceQuerySubmitInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceQuerySubmitInfoKHR,true,true> {
    VkPerformanceQuerySubmitInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceQuerySubmitInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(counterPassIndex)>("counterPassIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSurfaceInfo2KHR, VkPhysicalDeviceSurfaceInfo2KHR);

struct VkPhysicalDeviceSurfaceInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSurfaceInfo2KHR,true,true> {
    VkPhysicalDeviceSurfaceInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSurfaceInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceCapabilities2KHR, VkSurfaceCapabilities2KHR);

struct VkSurfaceCapabilities2KHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2KHR,true,true> {
    VkSurfaceCapabilities2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCapabilities)>("surfaceCapabilities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceFormat2KHR, VkSurfaceFormat2KHR);

struct VkSurfaceFormat2KHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormat2KHR,true,true> {
    VkSurfaceFormat2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormat2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceFormat)>("surfaceFormat");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayProperties2KHR, VkDisplayProperties2KHR);

struct VkDisplayProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayProperties2KHR,true,true> {
    VkDisplayProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayProperties)>("displayProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPlaneProperties2KHR, VkDisplayPlaneProperties2KHR);

struct VkDisplayPlaneProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneProperties2KHR,true,true> {
    VkDisplayPlaneProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayPlaneProperties)>("displayPlaneProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayModeProperties2KHR, VkDisplayModeProperties2KHR);

struct VkDisplayModeProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeProperties2KHR,true,true> {
    VkDisplayModeProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayModeProperties)>("displayModeProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPlaneInfo2KHR, VkDisplayPlaneInfo2KHR);

struct VkDisplayPlaneInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneInfo2KHR,true,true> {
    VkDisplayPlaneInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
        addField<DAS_BIND_MANAGED_FIELD(planeIndex)>("planeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPlaneCapabilities2KHR, VkDisplayPlaneCapabilities2KHR);

struct VkDisplayPlaneCapabilities2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneCapabilities2KHR,true,true> {
    VkDisplayPlaneCapabilities2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneCapabilities2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(capabilities)>("capabilities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderClockFeaturesKHR, VkPhysicalDeviceShaderClockFeaturesKHR);

struct VkPhysicalDeviceShaderClockFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderClockFeaturesKHR,true,true> {
    VkPhysicalDeviceShaderClockFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderClockFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupClock)>("shaderSubgroupClock");
        addField<DAS_BIND_MANAGED_FIELD(shaderDeviceClock)>("shaderDeviceClock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);

struct VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR,true,true> {
    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderTerminateInvocation)>("shaderTerminateInvocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFragmentShadingRateAttachmentInfoKHR, VkFragmentShadingRateAttachmentInfoKHR);

struct VkFragmentShadingRateAttachmentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkFragmentShadingRateAttachmentInfoKHR,true,true> {
    VkFragmentShadingRateAttachmentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFragmentShadingRateAttachmentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pFragmentShadingRateAttachment)>("pFragmentShadingRateAttachment");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateAttachmentTexelSize)>("shadingRateAttachmentTexelSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineFragmentShadingRateStateCreateInfoKHR, VkPipelineFragmentShadingRateStateCreateInfoKHR);

struct VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineFragmentShadingRateStateCreateInfoKHR,true,true> {
    VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineFragmentShadingRateStateCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentSize)>("fragmentSize");
        addField<DAS_BIND_MANAGED_FIELD(combinerOps)>("combinerOps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, VkPhysicalDeviceFragmentShadingRateFeaturesKHR);

struct VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateFeaturesKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineFragmentShadingRate)>("pipelineFragmentShadingRate");
        addField<DAS_BIND_MANAGED_FIELD(primitiveFragmentShadingRate)>("primitiveFragmentShadingRate");
        addField<DAS_BIND_MANAGED_FIELD(attachmentFragmentShadingRate)>("attachmentFragmentShadingRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceFragmentShadingRatePropertiesKHR);

struct VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRatePropertiesKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRatePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentShadingRateAttachmentTexelSize)>("minFragmentShadingRateAttachmentTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateAttachmentTexelSize)>("maxFragmentShadingRateAttachmentTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateAttachmentTexelSizeAspectRatio)>("maxFragmentShadingRateAttachmentTexelSizeAspectRatio");
        addField<DAS_BIND_MANAGED_FIELD(primitiveFragmentShadingRateWithMultipleViewports)>("primitiveFragmentShadingRateWithMultipleViewports");
        addField<DAS_BIND_MANAGED_FIELD(layeredShadingRateAttachments)>("layeredShadingRateAttachments");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateNonTrivialCombinerOps)>("fragmentShadingRateNonTrivialCombinerOps");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentSize)>("maxFragmentSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentSizeAspectRatio)>("maxFragmentSizeAspectRatio");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateCoverageSamples)>("maxFragmentShadingRateCoverageSamples");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateRasterizationSamples)>("maxFragmentShadingRateRasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithShaderDepthStencilWrites)>("fragmentShadingRateWithShaderDepthStencilWrites");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithSampleMask)>("fragmentShadingRateWithSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithShaderSampleMask)>("fragmentShadingRateWithShaderSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithConservativeRasterization)>("fragmentShadingRateWithConservativeRasterization");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithFragmentShaderInterlock)>("fragmentShadingRateWithFragmentShaderInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithCustomSampleLocations)>("fragmentShadingRateWithCustomSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateStrictMultiplyCombiner)>("fragmentShadingRateStrictMultiplyCombiner");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateKHR, VkPhysicalDeviceFragmentShadingRateKHR);

struct VkPhysicalDeviceFragmentShadingRateKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRateKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleCounts)>("sampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(fragmentSize)>("fragmentSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceProtectedCapabilitiesKHR, VkSurfaceProtectedCapabilitiesKHR);

struct VkSurfaceProtectedCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceProtectedCapabilitiesKHR,true,true> {
    VkSurfaceProtectedCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceProtectedCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsProtected)>("supportsProtected");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);

struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,true,true> {
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineExecutableInfo)>("pipelineExecutableInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineInfoKHR, VkPipelineInfoKHR);

struct VkPipelineInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineInfoKHR,true,true> {
    VkPipelineInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineExecutablePropertiesKHR, VkPipelineExecutablePropertiesKHR);

struct VkPipelineExecutablePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutablePropertiesKHR,true,true> {
    VkPipelineExecutablePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutablePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stages)>("stages");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineExecutableInfoKHR, VkPipelineExecutableInfoKHR);

struct VkPipelineExecutableInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableInfoKHR,true,true> {
    VkPipelineExecutableInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(executableIndex)>("executableIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineExecutableStatisticValueKHR, VkPipelineExecutableStatisticValueKHR);

struct VkPipelineExecutableStatisticValueKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableStatisticValueKHR,true,true> {
    VkPipelineExecutableStatisticValueKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableStatisticValueKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(b32)>("b32");
        addField<DAS_BIND_MANAGED_FIELD(i64)>("i64");
        addField<DAS_BIND_MANAGED_FIELD(u64)>("u64");
        addField<DAS_BIND_MANAGED_FIELD(f64)>("f64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineExecutableStatisticKHR, VkPipelineExecutableStatisticKHR);

struct VkPipelineExecutableStatisticKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableStatisticKHR,true,true> {
    VkPipelineExecutableStatisticKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableStatisticKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineExecutableInternalRepresentationKHR, VkPipelineExecutableInternalRepresentationKHR);

struct VkPipelineExecutableInternalRepresentationKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableInternalRepresentationKHR,true,true> {
    VkPipelineExecutableInternalRepresentationKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableInternalRepresentationKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(isText)>("isText");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineLibraryCreateInfoKHR, VkPipelineLibraryCreateInfoKHR);

struct VkPipelineLibraryCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineLibraryCreateInfoKHR,true,true> {
    VkPipelineLibraryCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLibraryCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(libraryCount)>("libraryCount");
        addField<DAS_BIND_MANAGED_FIELD(pLibraries)>("pLibraries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferCopy2KHR, VkBufferCopy2KHR);

struct VkBufferCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkBufferCopy2KHR,true,true> {
    VkBufferCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyBufferInfo2KHR, VkCopyBufferInfo2KHR);

struct VkCopyBufferInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyBufferInfo2KHR,true,true> {
    VkCopyBufferInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyBufferInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcBuffer)>("srcBuffer");
        addField<DAS_BIND_MANAGED_FIELD(dstBuffer)>("dstBuffer");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageCopy2KHR, VkImageCopy2KHR);

struct VkImageCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkImageCopy2KHR,true,true> {
    VkImageCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyImageInfo2KHR, VkCopyImageInfo2KHR);

struct VkCopyImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyImageInfo2KHR,true,true> {
    VkCopyImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferImageCopy2KHR, VkBufferImageCopy2KHR);

struct VkBufferImageCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy2KHR,true,true> {
    VkBufferImageCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyBufferToImageInfo2KHR, VkCopyBufferToImageInfo2KHR);

struct VkCopyBufferToImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyBufferToImageInfo2KHR,true,true> {
    VkCopyBufferToImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyBufferToImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcBuffer)>("srcBuffer");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyImageToBufferInfo2KHR, VkCopyImageToBufferInfo2KHR);

struct VkCopyImageToBufferInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyImageToBufferInfo2KHR,true,true> {
    VkCopyImageToBufferInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyImageToBufferInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstBuffer)>("dstBuffer");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageBlit2KHR, VkImageBlit2KHR);

struct VkImageBlit2KHRAnnotation
: public ManagedStructureAnnotation<VkImageBlit2KHR,true,true> {
    VkImageBlit2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageBlit2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffsets)>("srcOffsets");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffsets)>("dstOffsets");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBlitImageInfo2KHR, VkBlitImageInfo2KHR);

struct VkBlitImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkBlitImageInfo2KHR,true,true> {
    VkBlitImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBlitImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
        addField<DAS_BIND_MANAGED_FIELD(filter)>("filter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageResolve2KHR, VkImageResolve2KHR);

struct VkImageResolve2KHRAnnotation
: public ManagedStructureAnnotation<VkImageResolve2KHR,true,true> {
    VkImageResolve2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageResolve2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkResolveImageInfo2KHR, VkResolveImageInfo2KHR);

struct VkResolveImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkResolveImageInfo2KHR,true,true> {
    VkResolveImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkResolveImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugReportCallbackCreateInfoEXT, VkDebugReportCallbackCreateInfoEXT);

struct VkDebugReportCallbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugReportCallbackCreateInfoEXT,true,true> {
    VkDebugReportCallbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugReportCallbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationStateRasterizationOrderAMD, VkPipelineRasterizationStateRasterizationOrderAMD);

struct VkPipelineRasterizationStateRasterizationOrderAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateRasterizationOrderAMD,true,true> {
    VkPipelineRasterizationStateRasterizationOrderAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateRasterizationOrderAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationOrder)>("rasterizationOrder");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugMarkerObjectNameInfoEXT, VkDebugMarkerObjectNameInfoEXT);

struct VkDebugMarkerObjectNameInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerObjectNameInfoEXT,true,true> {
    VkDebugMarkerObjectNameInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerObjectNameInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(object)>("object");
        addField<DAS_BIND_MANAGED_FIELD(pObjectName)>("pObjectName");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugMarkerObjectTagInfoEXT, VkDebugMarkerObjectTagInfoEXT);

struct VkDebugMarkerObjectTagInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerObjectTagInfoEXT,true,true> {
    VkDebugMarkerObjectTagInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerObjectTagInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(object)>("object");
        addField<DAS_BIND_MANAGED_FIELD(tagName)>("tagName");
        addField<DAS_BIND_MANAGED_FIELD(tagSize)>("tagSize");
        addField<DAS_BIND_MANAGED_FIELD(pTag)>("pTag");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugMarkerMarkerInfoEXT, VkDebugMarkerMarkerInfoEXT);

struct VkDebugMarkerMarkerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerMarkerInfoEXT,true,true> {
    VkDebugMarkerMarkerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerMarkerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pMarkerName)>("pMarkerName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDedicatedAllocationImageCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV);

struct VkDedicatedAllocationImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationImageCreateInfoNV,true,true> {
    VkDedicatedAllocationImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationBufferCreateInfoNV);

struct VkDedicatedAllocationBufferCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationBufferCreateInfoNV,true,true> {
    VkDedicatedAllocationBufferCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationBufferCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDedicatedAllocationMemoryAllocateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV);

struct VkDedicatedAllocationMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationMemoryAllocateInfoNV,true,true> {
    VkDedicatedAllocationMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);

struct VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackFeaturesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedback)>("transformFeedback");
        addField<DAS_BIND_MANAGED_FIELD(geometryStreams)>("geometryStreams");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);

struct VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackPropertiesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreams)>("maxTransformFeedbackStreams");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBuffers)>("maxTransformFeedbackBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferSize)>("maxTransformFeedbackBufferSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreamDataSize)>("maxTransformFeedbackStreamDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataSize)>("maxTransformFeedbackBufferDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataStride)>("maxTransformFeedbackBufferDataStride");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackQueries)>("transformFeedbackQueries");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackStreamsLinesTriangles)>("transformFeedbackStreamsLinesTriangles");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackRasterizationStreamSelect)>("transformFeedbackRasterizationStreamSelect");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackDraw)>("transformFeedbackDraw");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationStateStreamCreateInfoEXT, VkPipelineRasterizationStateStreamCreateInfoEXT);

struct VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateStreamCreateInfoEXT,true,true> {
    VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateStreamCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationStream)>("rasterizationStream");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageViewHandleInfoNVX, VkImageViewHandleInfoNVX);

struct VkImageViewHandleInfoNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewHandleInfoNVX,true,true> {
    VkImageViewHandleInfoNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewHandleInfoNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageViewAddressPropertiesNVX, VkImageViewAddressPropertiesNVX);

struct VkImageViewAddressPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewAddressPropertiesNVX,true,true> {
    VkImageViewAddressPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewAddressPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkTextureLODGatherFormatPropertiesAMD, VkTextureLODGatherFormatPropertiesAMD);

struct VkTextureLODGatherFormatPropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkTextureLODGatherFormatPropertiesAMD,true,true> {
    VkTextureLODGatherFormatPropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTextureLODGatherFormatPropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsTextureGatherLODBiasAMD)>("supportsTextureGatherLODBiasAMD");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkShaderResourceUsageAMD, VkShaderResourceUsageAMD);

struct VkShaderResourceUsageAMDAnnotation
: public ManagedStructureAnnotation<VkShaderResourceUsageAMD,true,true> {
    VkShaderResourceUsageAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderResourceUsageAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(numUsedVgprs)>("numUsedVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numUsedSgprs)>("numUsedSgprs");
        addField<DAS_BIND_MANAGED_FIELD(ldsSizePerLocalWorkGroup)>("ldsSizePerLocalWorkGroup");
        addField<DAS_BIND_MANAGED_FIELD(ldsUsageSizeInBytes)>("ldsUsageSizeInBytes");
        addField<DAS_BIND_MANAGED_FIELD(scratchMemUsageInBytes)>("scratchMemUsageInBytes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkShaderStatisticsInfoAMD, VkShaderStatisticsInfoAMD);

struct VkShaderStatisticsInfoAMDAnnotation
: public ManagedStructureAnnotation<VkShaderStatisticsInfoAMD,true,true> {
    VkShaderStatisticsInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderStatisticsInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shaderStageMask)>("shaderStageMask");
        addField<DAS_BIND_MANAGED_FIELD(resourceUsage)>("resourceUsage");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalVgprs)>("numPhysicalVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalSgprs)>("numPhysicalSgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableVgprs)>("numAvailableVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableSgprs)>("numAvailableSgprs");
        addField<DAS_BIND_MANAGED_FIELD(computeWorkGroupSize)>("computeWorkGroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV);

struct VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCornerSampledImageFeaturesNV,true,true> {
    VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCornerSampledImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cornerSampledImage)>("cornerSampledImage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalImageFormatPropertiesNV, VkExternalImageFormatPropertiesNV);

struct VkExternalImageFormatPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatPropertiesNV,true,true> {
    VkExternalImageFormatPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExternalMemoryImageCreateInfoNV, VkExternalMemoryImageCreateInfoNV);

struct VkExternalMemoryImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfoNV,true,true> {
    VkExternalMemoryImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkExportMemoryAllocateInfoNV, VkExportMemoryAllocateInfoNV);

struct VkExportMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfoNV,true,true> {
    VkExportMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkValidationFlagsEXT, VkValidationFlagsEXT);

struct VkValidationFlagsEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFlagsEXT,true,true> {
    VkValidationFlagsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFlagsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationCheckCount)>("disabledValidationCheckCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationChecks)>("pDisabledValidationChecks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,true,true> {
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_HDR)>("textureCompressionASTC_HDR");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageViewASTCDecodeModeEXT, VkImageViewASTCDecodeModeEXT);

struct VkImageViewASTCDecodeModeEXTAnnotation
: public ManagedStructureAnnotation<VkImageViewASTCDecodeModeEXT,true,true> {
    VkImageViewASTCDecodeModeEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewASTCDecodeModeEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeMode)>("decodeMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);

struct VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceASTCDecodeFeaturesEXT,true,true> {
    VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceASTCDecodeFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeModeSharedExponent)>("decodeModeSharedExponent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingBeginInfoEXT);

struct VkConditionalRenderingBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkConditionalRenderingBeginInfoEXT,true,true> {
    VkConditionalRenderingBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConditionalRenderingBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);

struct VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConditionalRenderingFeaturesEXT,true,true> {
    VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConditionalRenderingFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRendering)>("conditionalRendering");
        addField<DAS_BIND_MANAGED_FIELD(inheritedConditionalRendering)>("inheritedConditionalRendering");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceConditionalRenderingInfoEXT);

struct VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceConditionalRenderingInfoEXT,true,true> {
    VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceConditionalRenderingInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRenderingEnable)>("conditionalRenderingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkViewportWScalingNV, VkViewportWScalingNV);

struct VkViewportWScalingNVAnnotation
: public ManagedStructureAnnotation<VkViewportWScalingNV,true,true> {
    VkViewportWScalingNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportWScalingNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(xcoeff)>("xcoeff");
        addField<DAS_BIND_MANAGED_FIELD(ycoeff)>("ycoeff");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportWScalingStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV);

struct VkPipelineViewportWScalingStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportWScalingStateCreateInfoNV,true,true> {
    VkPipelineViewportWScalingStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportWScalingStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewportWScalingEnable)>("viewportWScalingEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportWScalings)>("pViewportWScalings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSurfaceCapabilities2EXT, VkSurfaceCapabilities2EXT);

struct VkSurfaceCapabilities2EXTAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2EXT,true,true> {
    VkSurfaceCapabilities2EXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2EXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
        addField<DAS_BIND_MANAGED_FIELD(supportedSurfaceCounters)>("supportedSurfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayPowerInfoEXT, VkDisplayPowerInfoEXT);

struct VkDisplayPowerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayPowerInfoEXT,true,true> {
    VkDisplayPowerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPowerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(powerState)>("powerState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceEventInfoEXT, VkDeviceEventInfoEXT);

struct VkDeviceEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceEventInfoEXT,true,true> {
    VkDeviceEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceEvent)>("deviceEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayEventInfoEXT, VkDisplayEventInfoEXT);

struct VkDisplayEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayEventInfoEXT,true,true> {
    VkDisplayEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayEvent)>("displayEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSwapchainCounterCreateInfoEXT, VkSwapchainCounterCreateInfoEXT);

struct VkSwapchainCounterCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSwapchainCounterCreateInfoEXT,true,true> {
    VkSwapchainCounterCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCounterCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCounters)>("surfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRefreshCycleDurationGOOGLE, VkRefreshCycleDurationGOOGLE);

struct VkRefreshCycleDurationGOOGLEAnnotation
: public ManagedStructureAnnotation<VkRefreshCycleDurationGOOGLE,true,true> {
    VkRefreshCycleDurationGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRefreshCycleDurationGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(refreshDuration)>("refreshDuration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPastPresentationTimingGOOGLE, VkPastPresentationTimingGOOGLE);

struct VkPastPresentationTimingGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPastPresentationTimingGOOGLE,true,true> {
    VkPastPresentationTimingGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPastPresentationTimingGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(actualPresentTime)>("actualPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(earliestPresentTime)>("earliestPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(presentMargin)>("presentMargin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPresentTimeGOOGLE, VkPresentTimeGOOGLE);

struct VkPresentTimeGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimeGOOGLE,true,true> {
    VkPresentTimeGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimeGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPresentTimesInfoGOOGLE, VkPresentTimesInfoGOOGLE);

struct VkPresentTimesInfoGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimesInfoGOOGLE,true,true> {
    VkPresentTimesInfoGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimesInfoGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pTimes)>("pTimes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);

struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,true,true> {
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(perViewPositionAllComponents)>("perViewPositionAllComponents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkViewportSwizzleNV, VkViewportSwizzleNV);

struct VkViewportSwizzleNVAnnotation
: public ManagedStructureAnnotation<VkViewportSwizzleNV,true,true> {
    VkViewportSwizzleNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportSwizzleNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
        addField<DAS_BIND_MANAGED_FIELD(w)>("w");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportSwizzleStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV);

struct VkPipelineViewportSwizzleStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportSwizzleStateCreateInfoNV,true,true> {
    VkPipelineViewportSwizzleStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportSwizzleStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportSwizzles)>("pViewportSwizzles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT);

struct VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiscardRectanglePropertiesEXT,true,true> {
    VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiscardRectanglePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDiscardRectangles)>("maxDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT);

struct VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineDiscardRectangleStateCreateInfoEXT,true,true> {
    VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDiscardRectangleStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleMode)>("discardRectangleMode");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleCount)>("discardRectangleCount");
        addField<DAS_BIND_MANAGED_FIELD(pDiscardRectangles)>("pDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT);

struct VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConservativeRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConservativeRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOverestimationSize)>("primitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(maxExtraPrimitiveOverestimationSize)>("maxExtraPrimitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSizeGranularity)>("extraPrimitiveOverestimationSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(primitiveUnderestimation)>("primitiveUnderestimation");
        addField<DAS_BIND_MANAGED_FIELD(conservativePointAndLineRasterization)>("conservativePointAndLineRasterization");
        addField<DAS_BIND_MANAGED_FIELD(degenerateTrianglesRasterized)>("degenerateTrianglesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(degenerateLinesRasterized)>("degenerateLinesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(fullyCoveredFragmentShaderInputVariable)>("fullyCoveredFragmentShaderInputVariable");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationPostDepthCoverage)>("conservativeRasterizationPostDepthCoverage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationConservativeStateCreateInfoEXT);

struct VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationConservativeStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationConservativeStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationMode)>("conservativeRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSize)>("extraPrimitiveOverestimationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT);

struct VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthClipEnableFeaturesEXT,true,true> {
    VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthClipEnableFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT);

struct VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationDepthClipStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationDepthClipStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkXYColorEXT, VkXYColorEXT);

struct VkXYColorEXTAnnotation
: public ManagedStructureAnnotation<VkXYColorEXT,true,true> {
    VkXYColorEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkXYColorEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkHdrMetadataEXT, VkHdrMetadataEXT);

struct VkHdrMetadataEXTAnnotation
: public ManagedStructureAnnotation<VkHdrMetadataEXT,true,true> {
    VkHdrMetadataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHdrMetadataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryRed)>("displayPrimaryRed");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryGreen)>("displayPrimaryGreen");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryBlue)>("displayPrimaryBlue");
        addField<DAS_BIND_MANAGED_FIELD(whitePoint)>("whitePoint");
        addField<DAS_BIND_MANAGED_FIELD(maxLuminance)>("maxLuminance");
        addField<DAS_BIND_MANAGED_FIELD(minLuminance)>("minLuminance");
        addField<DAS_BIND_MANAGED_FIELD(maxContentLightLevel)>("maxContentLightLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxFrameAverageLightLevel)>("maxFrameAverageLightLevel");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugUtilsLabelEXT, VkDebugUtilsLabelEXT);

struct VkDebugUtilsLabelEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsLabelEXT,true,true> {
    VkDebugUtilsLabelEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsLabelEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pLabelName)>("pLabelName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectNameInfoEXT);

struct VkDebugUtilsObjectNameInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectNameInfoEXT,true,true> {
    VkDebugUtilsObjectNameInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectNameInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(pObjectName)>("pObjectName");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugUtilsMessengerCallbackDataEXT, VkDebugUtilsMessengerCallbackDataEXT);

struct VkDebugUtilsMessengerCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCallbackDataEXT,true,true> {
    VkDebugUtilsMessengerCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pMessageIdName)>("pMessageIdName");
        addField<DAS_BIND_MANAGED_FIELD(messageIdNumber)>("messageIdNumber");
        addField<DAS_BIND_MANAGED_FIELD(pMessage)>("pMessage");
        addField<DAS_BIND_MANAGED_FIELD(queueLabelCount)>("queueLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueLabels)>("pQueueLabels");
        addField<DAS_BIND_MANAGED_FIELD(cmdBufLabelCount)>("cmdBufLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pCmdBufLabels)>("pCmdBufLabels");
        addField<DAS_BIND_MANAGED_FIELD(objectCount)>("objectCount");
        addField<DAS_BIND_MANAGED_FIELD(pObjects)>("pObjects");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT);

struct VkDebugUtilsMessengerCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCreateInfoEXT,true,true> {
    VkDebugUtilsMessengerCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(messageSeverity)>("messageSeverity");
        addField<DAS_BIND_MANAGED_FIELD(messageType)>("messageType");
        addField<DAS_BIND_MANAGED_FIELD(pfnUserCallback)>("pfnUserCallback");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDebugUtilsObjectTagInfoEXT, VkDebugUtilsObjectTagInfoEXT);

struct VkDebugUtilsObjectTagInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectTagInfoEXT,true,true> {
    VkDebugUtilsObjectTagInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectTagInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(tagName)>("tagName");
        addField<DAS_BIND_MANAGED_FIELD(tagSize)>("tagSize");
        addField<DAS_BIND_MANAGED_FIELD(pTag)>("pTag");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT);

struct VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockFeaturesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(inlineUniformBlock)>("inlineUniformBlock");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingInlineUniformBlockUpdateAfterBind)>("descriptorBindingInlineUniformBlockUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT);

struct VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockPropertiesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockSize)>("maxInlineUniformBlockSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInlineUniformBlocks)>("maxPerStageDescriptorInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)>("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInlineUniformBlocks)>("maxDescriptorSetInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)>("maxDescriptorSetUpdateAfterBindInlineUniformBlocks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkWriteDescriptorSetInlineUniformBlockEXT, VkWriteDescriptorSetInlineUniformBlockEXT);

struct VkWriteDescriptorSetInlineUniformBlockEXTAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetInlineUniformBlockEXT,true,true> {
    VkWriteDescriptorSetInlineUniformBlockEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetInlineUniformBlockEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDescriptorPoolInlineUniformBlockCreateInfoEXT, VkDescriptorPoolInlineUniformBlockCreateInfoEXT);

struct VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolInlineUniformBlockCreateInfoEXT,true,true> {
    VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolInlineUniformBlockCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockBindings)>("maxInlineUniformBlockBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSampleLocationEXT, VkSampleLocationEXT);

struct VkSampleLocationEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationEXT,true,true> {
    VkSampleLocationEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSampleLocationsInfoEXT, VkSampleLocationsInfoEXT);

struct VkSampleLocationsInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationsInfoEXT,true,true> {
    VkSampleLocationsInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationsInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsPerPixel)>("sampleLocationsPerPixel");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationGridSize)>("sampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsCount)>("sampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pSampleLocations)>("pSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAttachmentSampleLocationsEXT, VkAttachmentSampleLocationsEXT);

struct VkAttachmentSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkAttachmentSampleLocationsEXT,true,true> {
    VkAttachmentSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachmentIndex)>("attachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSubpassSampleLocationsEXT, VkSubpassSampleLocationsEXT);

struct VkSubpassSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkSubpassSampleLocationsEXT,true,true> {
    VkSubpassSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpassIndex)>("subpassIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassSampleLocationsBeginInfoEXT);

struct VkRenderPassSampleLocationsBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassSampleLocationsBeginInfoEXT,true,true> {
    VkRenderPassSampleLocationsBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassSampleLocationsBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentInitialSampleLocationsCount)>("attachmentInitialSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentInitialSampleLocations)>("pAttachmentInitialSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(postSubpassSampleLocationsCount)>("postSubpassSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pPostSubpassSampleLocations)>("pPostSubpassSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineSampleLocationsStateCreateInfoEXT, VkPipelineSampleLocationsStateCreateInfoEXT);

struct VkPipelineSampleLocationsStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineSampleLocationsStateCreateInfoEXT,true,true> {
    VkPipelineSampleLocationsStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineSampleLocationsStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsEnable)>("sampleLocationsEnable");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT);

struct VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSampleLocationsPropertiesEXT,true,true> {
    VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSampleLocationsPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSampleCounts)>("sampleLocationSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationCoordinateRange)>("sampleLocationCoordinateRange");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSubPixelBits)>("sampleLocationSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(variableSampleLocations)>("variableSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMultisamplePropertiesEXT, VkMultisamplePropertiesEXT);

struct VkMultisamplePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMultisamplePropertiesEXT,true,true> {
    VkMultisamplePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMultisamplePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCoherentOperations)>("advancedBlendCoherentOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendMaxColorAttachments)>("advancedBlendMaxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendIndependentBlend)>("advancedBlendIndependentBlend");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedSrcColor)>("advancedBlendNonPremultipliedSrcColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedDstColor)>("advancedBlendNonPremultipliedDstColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCorrelatedOverlap)>("advancedBlendCorrelatedOverlap");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendAllOperations)>("advancedBlendAllOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineColorBlendAdvancedStateCreateInfoEXT, VkPipelineColorBlendAdvancedStateCreateInfoEXT);

struct VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAdvancedStateCreateInfoEXT,true,true> {
    VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAdvancedStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcPremultiplied)>("srcPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(dstPremultiplied)>("dstPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(blendOverlap)>("blendOverlap");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCoverageToColorStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV);

struct VkPipelineCoverageToColorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageToColorStateCreateInfoNV,true,true> {
    VkPipelineCoverageToColorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageToColorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorEnable)>("coverageToColorEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorLocation)>("coverageToColorLocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageModulationStateCreateInfoNV);

struct VkPipelineCoverageModulationStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageModulationStateCreateInfoNV,true,true> {
    VkPipelineCoverageModulationStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageModulationStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationMode)>("coverageModulationMode");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableEnable)>("coverageModulationTableEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableCount)>("coverageModulationTableCount");
        addField<DAS_BIND_MANAGED_FIELD(pCoverageModulationTable)>("pCoverageModulationTable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);

struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMCount)>("shaderSMCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderWarpsPerSM)>("shaderWarpsPerSM");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);

struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMBuiltins)>("shaderSMBuiltins");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDrmFormatModifierPropertiesEXT, VkDrmFormatModifierPropertiesEXT);

struct VkDrmFormatModifierPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesEXT,true,true> {
    VkDrmFormatModifierPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierPlaneCount)>("drmFormatModifierPlaneCount");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierTilingFeatures)>("drmFormatModifierTilingFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDrmFormatModifierPropertiesListEXT, VkDrmFormatModifierPropertiesListEXT);

struct VkDrmFormatModifierPropertiesListEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesListEXT,true,true> {
    VkDrmFormatModifierPropertiesListEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesListEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierCount)>("drmFormatModifierCount");
        addField<DAS_BIND_MANAGED_FIELD(pDrmFormatModifierProperties)>("pDrmFormatModifierProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageDrmFormatModifierInfoEXT);

struct VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageDrmFormatModifierInfoEXT,true,true> {
    VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageDrmFormatModifierInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageDrmFormatModifierListCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT);

struct VkImageDrmFormatModifierListCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierListCreateInfoEXT,true,true> {
    VkImageDrmFormatModifierListCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierListCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierCount)>("drmFormatModifierCount");
        addField<DAS_BIND_MANAGED_FIELD(pDrmFormatModifiers)>("pDrmFormatModifiers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT);

struct VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierExplicitCreateInfoEXT,true,true> {
    VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierExplicitCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierPlaneCount)>("drmFormatModifierPlaneCount");
        addField<DAS_BIND_MANAGED_FIELD(pPlaneLayouts)>("pPlaneLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImageDrmFormatModifierPropertiesEXT, VkImageDrmFormatModifierPropertiesEXT);

struct VkImageDrmFormatModifierPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierPropertiesEXT,true,true> {
    VkImageDrmFormatModifierPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkValidationCacheCreateInfoEXT, VkValidationCacheCreateInfoEXT);

struct VkValidationCacheCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkValidationCacheCreateInfoEXT,true,true> {
    VkValidationCacheCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationCacheCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkShaderModuleValidationCacheCreateInfoEXT, VkShaderModuleValidationCacheCreateInfoEXT);

struct VkShaderModuleValidationCacheCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkShaderModuleValidationCacheCreateInfoEXT,true,true> {
    VkShaderModuleValidationCacheCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleValidationCacheCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(validationCache)>("validationCache");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkShadingRatePaletteNV, VkShadingRatePaletteNV);

struct VkShadingRatePaletteNVAnnotation
: public ManagedStructureAnnotation<VkShadingRatePaletteNV,true,true> {
    VkShadingRatePaletteNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShadingRatePaletteNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shadingRatePaletteEntryCount)>("shadingRatePaletteEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pShadingRatePaletteEntries)>("pShadingRatePaletteEntries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV);

struct VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportShadingRateImageStateCreateInfoNV,true,true> {
    VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportShadingRateImageStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateImageEnable)>("shadingRateImageEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pShadingRatePalettes)>("pShadingRatePalettes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV);

struct VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShadingRateImageFeaturesNV,true,true> {
    VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShadingRateImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateImage)>("shadingRateImage");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateCoarseSampleOrder)>("shadingRateCoarseSampleOrder");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceShadingRateImagePropertiesNV);

struct VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShadingRateImagePropertiesNV,true,true> {
    VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShadingRateImagePropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateTexelSize)>("shadingRateTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(shadingRatePaletteSize)>("shadingRatePaletteSize");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateMaxCoarseSamples)>("shadingRateMaxCoarseSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCoarseSampleLocationNV, VkCoarseSampleLocationNV);

struct VkCoarseSampleLocationNVAnnotation
: public ManagedStructureAnnotation<VkCoarseSampleLocationNV,true,true> {
    VkCoarseSampleLocationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCoarseSampleLocationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(pixelX)>("pixelX");
        addField<DAS_BIND_MANAGED_FIELD(pixelY)>("pixelY");
        addField<DAS_BIND_MANAGED_FIELD(sample)>("sample");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCoarseSampleOrderCustomNV, VkCoarseSampleOrderCustomNV);

struct VkCoarseSampleOrderCustomNVAnnotation
: public ManagedStructureAnnotation<VkCoarseSampleOrderCustomNV,true,true> {
    VkCoarseSampleOrderCustomNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCoarseSampleOrderCustomNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shadingRate)>("shadingRate");
        addField<DAS_BIND_MANAGED_FIELD(sampleCount)>("sampleCount");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationCount)>("sampleLocationCount");
        addField<DAS_BIND_MANAGED_FIELD(pSampleLocations)>("pSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);

struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,true,true> {
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleOrderType)>("sampleOrderType");
        addField<DAS_BIND_MANAGED_FIELD(customSampleOrderCount)>("customSampleOrderCount");
        addField<DAS_BIND_MANAGED_FIELD(pCustomSampleOrders)>("pCustomSampleOrders");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRayTracingShaderGroupCreateInfoNV, VkRayTracingShaderGroupCreateInfoNV);

struct VkRayTracingShaderGroupCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkRayTracingShaderGroupCreateInfoNV,true,true> {
    VkRayTracingShaderGroupCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingShaderGroupCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(generalShader)>("generalShader");
        addField<DAS_BIND_MANAGED_FIELD(closestHitShader)>("closestHitShader");
        addField<DAS_BIND_MANAGED_FIELD(anyHitShader)>("anyHitShader");
        addField<DAS_BIND_MANAGED_FIELD(intersectionShader)>("intersectionShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRayTracingPipelineCreateInfoNV, VkRayTracingPipelineCreateInfoNV);

struct VkRayTracingPipelineCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineCreateInfoNV,true,true> {
    VkRayTracingPipelineCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(maxRecursionDepth)>("maxRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeometryTrianglesNV, VkGeometryTrianglesNV);

struct VkGeometryTrianglesNVAnnotation
: public ManagedStructureAnnotation<VkGeometryTrianglesNV,true,true> {
    VkGeometryTrianglesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryTrianglesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexData)>("vertexData");
        addField<DAS_BIND_MANAGED_FIELD(vertexOffset)>("vertexOffset");
        addField<DAS_BIND_MANAGED_FIELD(vertexCount)>("vertexCount");
        addField<DAS_BIND_MANAGED_FIELD(vertexStride)>("vertexStride");
        addField<DAS_BIND_MANAGED_FIELD(vertexFormat)>("vertexFormat");
        addField<DAS_BIND_MANAGED_FIELD(indexData)>("indexData");
        addField<DAS_BIND_MANAGED_FIELD(indexOffset)>("indexOffset");
        addField<DAS_BIND_MANAGED_FIELD(indexCount)>("indexCount");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
        addField<DAS_BIND_MANAGED_FIELD(transformData)>("transformData");
        addField<DAS_BIND_MANAGED_FIELD(transformOffset)>("transformOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeometryAABBNV, VkGeometryAABBNV);

struct VkGeometryAABBNVAnnotation
: public ManagedStructureAnnotation<VkGeometryAABBNV,true,true> {
    VkGeometryAABBNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryAABBNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(aabbData)>("aabbData");
        addField<DAS_BIND_MANAGED_FIELD(numAABBs)>("numAABBs");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeometryDataNV, VkGeometryDataNV);

struct VkGeometryDataNVAnnotation
: public ManagedStructureAnnotation<VkGeometryDataNV,true,true> {
    VkGeometryDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(triangles)>("triangles");
        addField<DAS_BIND_MANAGED_FIELD(aabbs)>("aabbs");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeometryNV, VkGeometryNV);

struct VkGeometryNVAnnotation
: public ManagedStructureAnnotation<VkGeometryNV,true,true> {
    VkGeometryNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(geometryType)>("geometryType");
        addField<DAS_BIND_MANAGED_FIELD(geometry)>("geometry");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureInfoNV, VkAccelerationStructureInfoNV);

struct VkAccelerationStructureInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureInfoNV,true,true> {
    VkAccelerationStructureInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(geometryCount)>("geometryCount");
        addField<DAS_BIND_MANAGED_FIELD(pGeometries)>("pGeometries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureCreateInfoNV, VkAccelerationStructureCreateInfoNV);

struct VkAccelerationStructureCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureCreateInfoNV,true,true> {
    VkAccelerationStructureCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compactedSize)>("compactedSize");
        addField<DAS_BIND_MANAGED_FIELD(info)>("info");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindAccelerationStructureMemoryInfoNV, VkBindAccelerationStructureMemoryInfoNV);

struct VkBindAccelerationStructureMemoryInfoNVAnnotation
: public ManagedStructureAnnotation<VkBindAccelerationStructureMemoryInfoNV,true,true> {
    VkBindAccelerationStructureMemoryInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindAccelerationStructureMemoryInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkWriteDescriptorSetAccelerationStructureNV, VkWriteDescriptorSetAccelerationStructureNV);

struct VkWriteDescriptorSetAccelerationStructureNVAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetAccelerationStructureNV,true,true> {
    VkWriteDescriptorSetAccelerationStructureNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetAccelerationStructureNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCount)>("accelerationStructureCount");
        addField<DAS_BIND_MANAGED_FIELD(pAccelerationStructures)>("pAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureMemoryRequirementsInfoNV, VkAccelerationStructureMemoryRequirementsInfoNV);

struct VkAccelerationStructureMemoryRequirementsInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureMemoryRequirementsInfoNV,true,true> {
    VkAccelerationStructureMemoryRequirementsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureMemoryRequirementsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRayTracingPropertiesNV);

struct VkPhysicalDeviceRayTracingPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPropertiesNV,true,true> {
    VkPhysicalDeviceRayTracingPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleSize)>("shaderGroupHandleSize");
        addField<DAS_BIND_MANAGED_FIELD(maxRecursionDepth)>("maxRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxShaderGroupStride)>("maxShaderGroupStride");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupBaseAlignment)>("shaderGroupBaseAlignment");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryCount)>("maxGeometryCount");
        addField<DAS_BIND_MANAGED_FIELD(maxInstanceCount)>("maxInstanceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTriangleCount)>("maxTriangleCount");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetAccelerationStructures)>("maxDescriptorSetAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkTransformMatrixKHR, VkTransformMatrixKHR);

struct VkTransformMatrixKHRAnnotation
: public ManagedStructureAnnotation<VkTransformMatrixKHR,true,true> {
    VkTransformMatrixKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTransformMatrixKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(matrix)>("matrix");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAabbPositionsKHR, VkAabbPositionsKHR);

struct VkAabbPositionsKHRAnnotation
: public ManagedStructureAnnotation<VkAabbPositionsKHR,true,true> {
    VkAabbPositionsKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAabbPositionsKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minX)>("minX");
        addField<DAS_BIND_MANAGED_FIELD(minY)>("minY");
        addField<DAS_BIND_MANAGED_FIELD(minZ)>("minZ");
        addField<DAS_BIND_MANAGED_FIELD(maxX)>("maxX");
        addField<DAS_BIND_MANAGED_FIELD(maxY)>("maxY");
        addField<DAS_BIND_MANAGED_FIELD(maxZ)>("maxZ");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureInstanceKHR, VkAccelerationStructureInstanceKHR);

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_instanceCustomIndex(const VkAccelerationStructureInstanceKHR &s) { return s.instanceCustomIndex; }
__forceinline void VkAccelerationStructureInstanceKHR_set_instanceCustomIndex(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.instanceCustomIndex = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_mask(const VkAccelerationStructureInstanceKHR &s) { return s.mask; }
__forceinline void VkAccelerationStructureInstanceKHR_set_mask(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.mask = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset(const VkAccelerationStructureInstanceKHR &s) { return s.instanceShaderBindingTableRecordOffset; }
__forceinline void VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.instanceShaderBindingTableRecordOffset = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_flags(const VkAccelerationStructureInstanceKHR &s) { return s.flags; }
__forceinline void VkAccelerationStructureInstanceKHR_set_flags(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.flags = f; }

struct VkAccelerationStructureInstanceKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureInstanceKHR,true,true> {
    VkAccelerationStructureInstanceKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureInstanceKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureReference)>("accelerationStructureReference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);

struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,true,true> {
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(representativeFragmentTest)>("representativeFragmentTest");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineRepresentativeFragmentTestStateCreateInfoNV);

struct VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineRepresentativeFragmentTestStateCreateInfoNV,true,true> {
    VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRepresentativeFragmentTestStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(representativeFragmentTestEnable)>("representativeFragmentTestEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceImageViewImageFormatInfoEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT);

struct VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageViewImageFormatInfoEXT,true,true> {
    VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageViewImageFormatInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageViewType)>("imageViewType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFilterCubicImageViewImageFormatPropertiesEXT, VkFilterCubicImageViewImageFormatPropertiesEXT);

struct VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkFilterCubicImageViewImageFormatPropertiesEXT,true,true> {
    VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFilterCubicImageViewImageFormatPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterCubic)>("filterCubic");
        addField<DAS_BIND_MANAGED_FIELD(filterCubicMinmax)>("filterCubicMinmax");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceQueueGlobalPriorityCreateInfoEXT, VkDeviceQueueGlobalPriorityCreateInfoEXT);

struct VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueGlobalPriorityCreateInfoEXT,true,true> {
    VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueGlobalPriorityCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(globalPriority)>("globalPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkImportMemoryHostPointerInfoEXT, VkImportMemoryHostPointerInfoEXT);

struct VkImportMemoryHostPointerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImportMemoryHostPointerInfoEXT,true,true> {
    VkImportMemoryHostPointerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportMemoryHostPointerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(pHostPointer)>("pHostPointer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryHostPointerPropertiesEXT, VkMemoryHostPointerPropertiesEXT);

struct VkMemoryHostPointerPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryHostPointerPropertiesEXT,true,true> {
    VkMemoryHostPointerPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHostPointerPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalMemoryHostPropertiesEXT,true,true> {
    VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalMemoryHostPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImportedHostPointerAlignment)>("minImportedHostPointerAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCompilerControlCreateInfoAMD, VkPipelineCompilerControlCreateInfoAMD);

struct VkPipelineCompilerControlCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineCompilerControlCreateInfoAMD,true,true> {
    VkPipelineCompilerControlCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCompilerControlCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compilerControlFlags)>("compilerControlFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCalibratedTimestampInfoEXT, VkCalibratedTimestampInfoEXT);

struct VkCalibratedTimestampInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCalibratedTimestampInfoEXT,true,true> {
    VkCalibratedTimestampInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCalibratedTimestampInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timeDomain)>("timeDomain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesAMD);

struct VkPhysicalDeviceShaderCorePropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCorePropertiesAMD,true,true> {
    VkPhysicalDeviceShaderCorePropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCorePropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderEngineCount)>("shaderEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderArraysPerEngineCount)>("shaderArraysPerEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(computeUnitsPerShaderArray)>("computeUnitsPerShaderArray");
        addField<DAS_BIND_MANAGED_FIELD(simdPerComputeUnit)>("simdPerComputeUnit");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontsPerSimd)>("wavefrontsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontSize)>("wavefrontSize");
        addField<DAS_BIND_MANAGED_FIELD(sgprsPerSimd)>("sgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minSgprAllocation)>("minSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxSgprAllocation)>("maxSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(sgprAllocationGranularity)>("sgprAllocationGranularity");
        addField<DAS_BIND_MANAGED_FIELD(vgprsPerSimd)>("vgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minVgprAllocation)>("minVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxVgprAllocation)>("maxVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(vgprAllocationGranularity)>("vgprAllocationGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceMemoryOverallocationCreateInfoAMD, VkDeviceMemoryOverallocationCreateInfoAMD);

struct VkDeviceMemoryOverallocationCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOverallocationCreateInfoAMD,true,true> {
    VkDeviceMemoryOverallocationCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOverallocationCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(overallocationBehavior)>("overallocationBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexAttribDivisor)>("maxVertexAttribDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkVertexInputBindingDivisorDescriptionEXT, VkVertexInputBindingDivisorDescriptionEXT);

struct VkVertexInputBindingDivisorDescriptionEXTAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDivisorDescriptionEXT,true,true> {
    VkVertexInputBindingDivisorDescriptionEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDivisorDescriptionEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(divisor)>("divisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineVertexInputDivisorStateCreateInfoEXT, VkPipelineVertexInputDivisorStateCreateInfoEXT);

struct VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputDivisorStateCreateInfoEXT,true,true> {
    VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputDivisorStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDivisorCount)>("vertexBindingDivisorCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDivisors)>("pVertexBindingDivisors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateDivisor)>("vertexAttributeInstanceRateDivisor");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateZeroDivisor)>("vertexAttributeInstanceRateZeroDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackEXT);

struct VkPipelineCreationFeedbackEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackEXT,true,true> {
    VkPipelineCreationFeedbackEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(duration)>("duration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackCreateInfoEXT);

struct VkPipelineCreationFeedbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackCreateInfoEXT,true,true> {
    VkPipelineCreationFeedbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineCreationFeedback)>("pPipelineCreationFeedback");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStageCreationFeedbackCount)>("pipelineStageCreationFeedbackCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineStageCreationFeedbacks)>("pPipelineStageCreationFeedbacks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,true,true> {
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupQuads)>("computeDerivativeGroupQuads");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupLinear)>("computeDerivativeGroupLinear");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderFeaturesNV);

struct VkPhysicalDeviceMeshShaderFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderFeaturesNV,true,true> {
    VkPhysicalDeviceMeshShaderFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(taskShader)>("taskShader");
        addField<DAS_BIND_MANAGED_FIELD(meshShader)>("meshShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesNV);

struct VkPhysicalDeviceMeshShaderPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderPropertiesNV,true,true> {
    VkPhysicalDeviceMeshShaderPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawMeshTasksCount)>("maxDrawMeshTasksCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupInvocations)>("maxTaskWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupSize)>("maxTaskWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskTotalMemorySize)>("maxTaskTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskOutputCount)>("maxTaskOutputCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupInvocations)>("maxMeshWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupSize)>("maxMeshWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshTotalMemorySize)>("maxMeshTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputVertices)>("maxMeshOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputPrimitives)>("maxMeshOutputPrimitives");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshMultiviewViewCount)>("maxMeshMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerVertexGranularity)>("meshOutputPerVertexGranularity");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerPrimitiveGranularity)>("meshOutputPerPrimitiveGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDrawMeshTasksIndirectCommandNV, VkDrawMeshTasksIndirectCommandNV);

struct VkDrawMeshTasksIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkDrawMeshTasksIndirectCommandNV,true,true> {
    VkDrawMeshTasksIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawMeshTasksIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(taskCount)>("taskCount");
        addField<DAS_BIND_MANAGED_FIELD(firstTask)>("firstTask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderBarycentric)>("fragmentShaderBarycentric");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderImageFootprintFeaturesNV);

struct VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageFootprintFeaturesNV,true,true> {
    VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageFootprintFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFootprint)>("imageFootprint");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV);

struct VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportExclusiveScissorStateCreateInfoNV,true,true> {
    VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportExclusiveScissorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissorCount)>("exclusiveScissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pExclusiveScissors)>("pExclusiveScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExclusiveScissorFeaturesNV);

struct VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExclusiveScissorFeaturesNV,true,true> {
    VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExclusiveScissorFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissor)>("exclusiveScissor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyCheckpointPropertiesNV);

struct VkQueueFamilyCheckpointPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyCheckpointPropertiesNV,true,true> {
    VkQueueFamilyCheckpointPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyCheckpointPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(checkpointExecutionStageMask)>("checkpointExecutionStageMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCheckpointDataNV, VkCheckpointDataNV);

struct VkCheckpointDataNVAnnotation
: public ManagedStructureAnnotation<VkCheckpointDataNV,true,true> {
    VkCheckpointDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCheckpointDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(pCheckpointMarker)>("pCheckpointMarker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,true,true> {
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderIntegerFunctions2)>("shaderIntegerFunctions2");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceValueDataINTEL, VkPerformanceValueDataINTEL);

struct VkPerformanceValueDataINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueDataINTEL,true,true> {
    VkPerformanceValueDataINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueDataINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(value32)>("value32");
        addField<DAS_BIND_MANAGED_FIELD(value64)>("value64");
        addField<DAS_BIND_MANAGED_FIELD(valueFloat)>("valueFloat");
        addField<DAS_BIND_MANAGED_FIELD(valueBool)>("valueBool");
        addField<DAS_BIND_MANAGED_FIELD(valueString)>("valueString");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceValueINTEL, VkPerformanceValueINTEL);

struct VkPerformanceValueINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueINTEL,true,true> {
    VkPerformanceValueINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkInitializePerformanceApiInfoINTEL, VkInitializePerformanceApiInfoINTEL);

struct VkInitializePerformanceApiInfoINTELAnnotation
: public ManagedStructureAnnotation<VkInitializePerformanceApiInfoINTEL,true,true> {
    VkInitializePerformanceApiInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInitializePerformanceApiInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkQueryPoolPerformanceQueryCreateInfoINTEL, VkQueryPoolPerformanceQueryCreateInfoINTEL);

struct VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceQueryCreateInfoINTEL,true,true> {
    VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceQueryCreateInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCountersSampling)>("performanceCountersSampling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceMarkerInfoINTEL, VkPerformanceMarkerInfoINTEL);

struct VkPerformanceMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceMarkerInfoINTEL,true,true> {
    VkPerformanceMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceStreamMarkerInfoINTEL, VkPerformanceStreamMarkerInfoINTEL);

struct VkPerformanceStreamMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceStreamMarkerInfoINTEL,true,true> {
    VkPerformanceStreamMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceStreamMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceOverrideInfoINTEL, VkPerformanceOverrideInfoINTEL);

struct VkPerformanceOverrideInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceOverrideInfoINTEL,true,true> {
    VkPerformanceOverrideInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceOverrideInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(enable)>("enable");
        addField<DAS_BIND_MANAGED_FIELD(parameter)>("parameter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPerformanceConfigurationAcquireInfoINTEL, VkPerformanceConfigurationAcquireInfoINTEL);

struct VkPerformanceConfigurationAcquireInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceConfigurationAcquireInfoINTEL,true,true> {
    VkPerformanceConfigurationAcquireInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceConfigurationAcquireInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);

struct VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePCIBusInfoPropertiesEXT,true,true> {
    VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePCIBusInfoPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pciDomain)>("pciDomain");
        addField<DAS_BIND_MANAGED_FIELD(pciBus)>("pciBus");
        addField<DAS_BIND_MANAGED_FIELD(pciDevice)>("pciDevice");
        addField<DAS_BIND_MANAGED_FIELD(pciFunction)>("pciFunction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayNativeHdrSurfaceCapabilitiesAMD);

struct VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation
: public ManagedStructureAnnotation<VkDisplayNativeHdrSurfaceCapabilitiesAMD,true,true> {
    VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayNativeHdrSurfaceCapabilitiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingSupport)>("localDimmingSupport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainDisplayNativeHdrCreateInfoAMD);

struct VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkSwapchainDisplayNativeHdrCreateInfoAMD,true,true> {
    VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainDisplayNativeHdrCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingEnable)>("localDimmingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMap)>("fragmentDensityMap");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDynamic)>("fragmentDensityMapDynamic");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapNonSubsampledImages)>("fragmentDensityMapNonSubsampledImages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapPropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentDensityTexelSize)>("minFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDensityTexelSize)>("maxFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityInvocations)>("fragmentDensityInvocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT);

struct VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassFragmentDensityMapCreateInfoEXT,true,true> {
    VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassFragmentDensityMapCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapAttachment)>("fragmentDensityMapAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSizeControl)>("subgroupSizeControl");
        addField<DAS_BIND_MANAGED_FIELD(computeFullSubgroups)>("computeFullSubgroups");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minSubgroupSize)>("minSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxSubgroupSize)>("maxSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkgroupSubgroups)>("maxComputeWorkgroupSubgroups");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSizeStages)>("requiredSubgroupSizeStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT,true,true> {
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSize)>("requiredSubgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCoreProperties2AMD);

struct VkPhysicalDeviceShaderCoreProperties2AMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCoreProperties2AMD,true,true> {
    VkPhysicalDeviceShaderCoreProperties2AMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCoreProperties2AMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderCoreFeatures)>("shaderCoreFeatures");
        addField<DAS_BIND_MANAGED_FIELD(activeComputeUnitCount)>("activeComputeUnitCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceCoherentMemoryFeaturesAMD);

struct VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoherentMemoryFeaturesAMD,true,true> {
    VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoherentMemoryFeaturesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceCoherentMemory)>("deviceCoherentMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);

struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,true,true> {
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageInt64Atomics)>("shaderImageInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageInt64Atomics)>("sparseImageInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);

struct VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryBudgetPropertiesEXT,true,true> {
    VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryBudgetPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(heapBudget)>("heapBudget");
        addField<DAS_BIND_MANAGED_FIELD(heapUsage)>("heapUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);

struct VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryPriorityFeaturesEXT,true,true> {
    VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryPriorityFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryPriority)>("memoryPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkMemoryPriorityAllocateInfoEXT, VkMemoryPriorityAllocateInfoEXT);

struct VkMemoryPriorityAllocateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryPriorityAllocateInfoEXT,true,true> {
    VkMemoryPriorityAllocateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryPriorityAllocateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(priority)>("priority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,true,true> {
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocationImageAliasing)>("dedicatedAllocationImageAliasing");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressCreateInfoEXT);

struct VkBufferDeviceAddressCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressCreateInfoEXT,true,true> {
    VkBufferDeviceAddressCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceToolPropertiesEXT, VkPhysicalDeviceToolPropertiesEXT);

struct VkPhysicalDeviceToolPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceToolPropertiesEXT,true,true> {
    VkPhysicalDeviceToolPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceToolPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(version)>("version");
        addField<DAS_BIND_MANAGED_FIELD(purposes)>("purposes");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkValidationFeaturesEXT, VkValidationFeaturesEXT);

struct VkValidationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFeaturesEXT,true,true> {
    VkValidationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(enabledValidationFeatureCount)>("enabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledValidationFeatures)>("pEnabledValidationFeatures");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationFeatureCount)>("disabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationFeatures)>("pDisabledValidationFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCooperativeMatrixPropertiesNV, VkCooperativeMatrixPropertiesNV);

struct VkCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkCooperativeMatrixPropertiesNV,true,true> {
    VkCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(MSize)>("MSize");
        addField<DAS_BIND_MANAGED_FIELD(NSize)>("NSize");
        addField<DAS_BIND_MANAGED_FIELD(KSize)>("KSize");
        addField<DAS_BIND_MANAGED_FIELD(AType)>("AType");
        addField<DAS_BIND_MANAGED_FIELD(BType)>("BType");
        addField<DAS_BIND_MANAGED_FIELD(CType)>("CType");
        addField<DAS_BIND_MANAGED_FIELD(DType)>("DType");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixFeaturesNV);

struct VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixFeaturesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrix)>("cooperativeMatrix");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixRobustBufferAccess)>("cooperativeMatrixRobustBufferAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV);

struct VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixPropertiesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixSupportedStages)>("cooperativeMatrixSupportedStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV);

struct VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoverageReductionModeFeaturesNV,true,true> {
    VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoverageReductionModeFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineCoverageReductionStateCreateInfoNV, VkPipelineCoverageReductionStateCreateInfoNV);

struct VkPipelineCoverageReductionStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageReductionStateCreateInfoNV,true,true> {
    VkPipelineCoverageReductionStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageReductionStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkFramebufferMixedSamplesCombinationNV, VkFramebufferMixedSamplesCombinationNV);

struct VkFramebufferMixedSamplesCombinationNVAnnotation
: public ManagedStructureAnnotation<VkFramebufferMixedSamplesCombinationNV,true,true> {
    VkFramebufferMixedSamplesCombinationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferMixedSamplesCombinationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(depthStencilSamples)>("depthStencilSamples");
        addField<DAS_BIND_MANAGED_FIELD(colorSamples)>("colorSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderSampleInterlock)>("fragmentShaderSampleInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderPixelInterlock)>("fragmentShaderPixelInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderShadingRateInterlock)>("fragmentShaderShadingRateInterlock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,true,true> {
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrImageArrays)>("ycbcrImageArrays");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkHeadlessSurfaceCreateInfoEXT, VkHeadlessSurfaceCreateInfoEXT);

struct VkHeadlessSurfaceCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkHeadlessSurfaceCreateInfoEXT,true,true> {
    VkHeadlessSurfaceCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHeadlessSurfaceCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);

struct VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationFeaturesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rectangularLines)>("rectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(bresenhamLines)>("bresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(smoothLines)>("smoothLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledRectangularLines)>("stippledRectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledBresenhamLines)>("stippledBresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledSmoothLines)>("stippledSmoothLines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);

struct VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineSubPixelPrecisionBits)>("lineSubPixelPrecisionBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineRasterizationLineStateCreateInfoEXT, VkPipelineRasterizationLineStateCreateInfoEXT);

struct VkPipelineRasterizationLineStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationLineStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationLineStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationLineStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineRasterizationMode)>("lineRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(stippledLineEnable)>("stippledLineEnable");
        addField<DAS_BIND_MANAGED_FIELD(lineStippleFactor)>("lineStippleFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineStipplePattern)>("lineStipplePattern");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);

struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32Atomics)>("shaderBufferFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32AtomicAdd)>("shaderBufferFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64Atomics)>("shaderBufferFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64AtomicAdd)>("shaderBufferFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32Atomics)>("shaderSharedFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32AtomicAdd)>("shaderSharedFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64Atomics)>("shaderSharedFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64AtomicAdd)>("shaderSharedFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32Atomics)>("shaderImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32AtomicAdd)>("shaderImageFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32Atomics)>("sparseImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32AtomicAdd)>("sparseImageFloat32AtomicAdd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIndexTypeUint8FeaturesEXT,true,true> {
    VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIndexTypeUint8FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeUint8)>("indexTypeUint8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);

struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,true,true> {
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(extendedDynamicState)>("extendedDynamicState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);

struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDemoteToHelperInvocation)>("shaderDemoteToHelperInvocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGraphicsShaderGroupCount)>("maxGraphicsShaderGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectSequenceCount)>("maxIndirectSequenceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenCount)>("maxIndirectCommandsTokenCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamCount)>("maxIndirectCommandsStreamCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenOffset)>("maxIndirectCommandsTokenOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamStride)>("maxIndirectCommandsStreamStride");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesCountBufferOffsetAlignment)>("minSequencesCountBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesIndexBufferOffsetAlignment)>("minSequencesIndexBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minIndirectCommandsBufferOffsetAlignment)>("minIndirectCommandsBufferOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceGeneratedCommands)>("deviceGeneratedCommands");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGraphicsShaderGroupCreateInfoNV, VkGraphicsShaderGroupCreateInfoNV);

struct VkGraphicsShaderGroupCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsShaderGroupCreateInfoNV,true,true> {
    VkGraphicsShaderGroupCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsShaderGroupCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGraphicsPipelineShaderGroupsCreateInfoNV, VkGraphicsPipelineShaderGroupsCreateInfoNV);

struct VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineShaderGroupsCreateInfoNV,true,true> {
    VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineShaderGroupsCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCount)>("pipelineCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelines)>("pPipelines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindShaderGroupIndirectCommandNV, VkBindShaderGroupIndirectCommandNV);

struct VkBindShaderGroupIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindShaderGroupIndirectCommandNV,true,true> {
    VkBindShaderGroupIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindShaderGroupIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(groupIndex)>("groupIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindIndexBufferIndirectCommandNV, VkBindIndexBufferIndirectCommandNV);

struct VkBindIndexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindIndexBufferIndirectCommandNV,true,true> {
    VkBindIndexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindIndexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkBindVertexBufferIndirectCommandNV, VkBindVertexBufferIndirectCommandNV);

struct VkBindVertexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindVertexBufferIndirectCommandNV,true,true> {
    VkBindVertexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindVertexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSetStateFlagsIndirectCommandNV, VkSetStateFlagsIndirectCommandNV);

struct VkSetStateFlagsIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkSetStateFlagsIndirectCommandNV,true,true> {
    VkSetStateFlagsIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSetStateFlagsIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkIndirectCommandsStreamNV, VkIndirectCommandsStreamNV);

struct VkIndirectCommandsStreamNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsStreamNV,true,true> {
    VkIndirectCommandsStreamNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsStreamNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkIndirectCommandsLayoutTokenNV, VkIndirectCommandsLayoutTokenNV);

struct VkIndirectCommandsLayoutTokenNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutTokenNV,true,true> {
    VkIndirectCommandsLayoutTokenNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutTokenNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(tokenType)>("tokenType");
        addField<DAS_BIND_MANAGED_FIELD(stream)>("stream");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingUnit)>("vertexBindingUnit");
        addField<DAS_BIND_MANAGED_FIELD(vertexDynamicStride)>("vertexDynamicStride");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantPipelineLayout)>("pushconstantPipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantShaderStageFlags)>("pushconstantShaderStageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantOffset)>("pushconstantOffset");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantSize)>("pushconstantSize");
        addField<DAS_BIND_MANAGED_FIELD(indirectStateFlags)>("indirectStateFlags");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeCount)>("indexTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypes)>("pIndexTypes");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypeValues)>("pIndexTypeValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkIndirectCommandsLayoutCreateInfoNV, VkIndirectCommandsLayoutCreateInfoNV);

struct VkIndirectCommandsLayoutCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutCreateInfoNV,true,true> {
    VkIndirectCommandsLayoutCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(tokenCount)>("tokenCount");
        addField<DAS_BIND_MANAGED_FIELD(pTokens)>("pTokens");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreamStrides)>("pStreamStrides");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeneratedCommandsInfoNV, VkGeneratedCommandsInfoNV);

struct VkGeneratedCommandsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsInfoNV,true,true> {
    VkGeneratedCommandsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreams)>("pStreams");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCount)>("sequencesCount");
        addField<DAS_BIND_MANAGED_FIELD(preprocessBuffer)>("preprocessBuffer");
        addField<DAS_BIND_MANAGED_FIELD(preprocessOffset)>("preprocessOffset");
        addField<DAS_BIND_MANAGED_FIELD(preprocessSize)>("preprocessSize");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountBuffer)>("sequencesCountBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountOffset)>("sequencesCountOffset");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexBuffer)>("sequencesIndexBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexOffset)>("sequencesIndexOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkGeneratedCommandsMemoryRequirementsInfoNV, VkGeneratedCommandsMemoryRequirementsInfoNV);

struct VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsMemoryRequirementsInfoNV,true,true> {
    VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsMemoryRequirementsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(maxSequencesCount)>("maxSequencesCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(texelBufferAlignment)>("texelBufferAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetAlignmentBytes)>("storageTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetSingleTexelAlignment)>("storageTexelBufferOffsetSingleTexelAlignment");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetAlignmentBytes)>("uniformTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetSingleTexelAlignment)>("uniformTexelBufferOffsetSingleTexelAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRenderPassTransformBeginInfoQCOM, VkRenderPassTransformBeginInfoQCOM);

struct VkRenderPassTransformBeginInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkRenderPassTransformBeginInfoQCOM,true,true> {
    VkRenderPassTransformBeginInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassTransformBeginInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, VkCommandBufferInheritanceRenderPassTransformInfoQCOM);

struct VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceRenderPassTransformInfoQCOM,true,true> {
    VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceRenderPassTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(renderArea)>("renderArea");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);

struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,true,true> {
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMemoryReport)>("deviceMemoryReport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceMemoryReportCallbackDataEXT, VkDeviceMemoryReportCallbackDataEXT);

struct VkDeviceMemoryReportCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryReportCallbackDataEXT,true,true> {
    VkDeviceMemoryReportCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryReportCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(memoryObjectId)>("memoryObjectId");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDeviceMemoryReportCreateInfoEXT);

struct VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceDeviceMemoryReportCreateInfoEXT,true,true> {
    VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDeviceMemoryReportCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRobustness2FeaturesEXT, VkPhysicalDeviceRobustness2FeaturesEXT);

struct VkPhysicalDeviceRobustness2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2FeaturesEXT,true,true> {
    VkPhysicalDeviceRobustness2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess2)>("robustBufferAccess2");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess2)>("robustImageAccess2");
        addField<DAS_BIND_MANAGED_FIELD(nullDescriptor)>("nullDescriptor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceRobustness2PropertiesEXT);

struct VkPhysicalDeviceRobustness2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2PropertiesEXT,true,true> {
    VkPhysicalDeviceRobustness2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustStorageBufferAccessSizeAlignment)>("robustStorageBufferAccessSizeAlignment");
        addField<DAS_BIND_MANAGED_FIELD(robustUniformBufferAccessSizeAlignment)>("robustUniformBufferAccessSizeAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkSamplerCustomBorderColorCreateInfoEXT, VkSamplerCustomBorderColorCreateInfoEXT);

struct VkSamplerCustomBorderColorCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSamplerCustomBorderColorCreateInfoEXT,true,true> {
    VkSamplerCustomBorderColorCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCustomBorderColorCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColor)>("customBorderColor");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceCustomBorderColorPropertiesEXT);

struct VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorPropertiesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxCustomBorderColorSamplers)>("maxCustomBorderColorSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT);

struct VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorFeaturesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColors)>("customBorderColors");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColorWithoutFormat)>("customBorderColorWithoutFormat");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePrivateDataFeaturesEXT, VkPhysicalDevicePrivateDataFeaturesEXT);

struct VkPhysicalDevicePrivateDataFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePrivateDataFeaturesEXT,true,true> {
    VkPhysicalDevicePrivateDataFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePrivateDataFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateData)>("privateData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDevicePrivateDataCreateInfoEXT, VkDevicePrivateDataCreateInfoEXT);

struct VkDevicePrivateDataCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDevicePrivateDataCreateInfoEXT,true,true> {
    VkDevicePrivateDataCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDevicePrivateDataCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateDataSlotRequestCount)>("privateDataSlotRequestCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPrivateDataSlotCreateInfoEXT, VkPrivateDataSlotCreateInfoEXT);

struct VkPrivateDataSlotCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPrivateDataSlotCreateInfoEXT,true,true> {
    VkPrivateDataSlotCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPrivateDataSlotCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);

struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT,true,true> {
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCreationCacheControl)>("pipelineCreationCacheControl");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDiagnosticsConfigFeaturesNV);

struct VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiagnosticsConfigFeaturesNV,true,true> {
    VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiagnosticsConfigFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(diagnosticsConfig)>("diagnosticsConfig");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceDiagnosticsConfigCreateInfoNV);

struct VkDeviceDiagnosticsConfigCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDeviceDiagnosticsConfigCreateInfoNV,true,true> {
    VkDeviceDiagnosticsConfigCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDiagnosticsConfigCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateEnums)>("fragmentShadingRateEnums");
        addField<DAS_BIND_MANAGED_FIELD(supersampleFragmentShadingRates)>("supersampleFragmentShadingRates");
        addField<DAS_BIND_MANAGED_FIELD(noInvocationFragmentShadingRates)>("noInvocationFragmentShadingRates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateInvocationCount)>("maxFragmentShadingRateInvocationCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateEnumStateCreateInfoNV);

struct VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineFragmentShadingRateEnumStateCreateInfoNV,true,true> {
    VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineFragmentShadingRateEnumStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateType)>("shadingRateType");
        addField<DAS_BIND_MANAGED_FIELD(shadingRate)>("shadingRate");
        addField<DAS_BIND_MANAGED_FIELD(combinerOps)>("combinerOps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDeferred)>("fragmentDensityMapDeferred");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subsampledLoads)>("subsampledLoads");
        addField<DAS_BIND_MANAGED_FIELD(subsampledCoarseReconstructionEarlyAccess)>("subsampledCoarseReconstructionEarlyAccess");
        addField<DAS_BIND_MANAGED_FIELD(maxSubsampledArrayLayers)>("maxSubsampledArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSubsampledSamplers)>("maxDescriptorSetSubsampledSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyCommandTransformInfoQCOM, VkCopyCommandTransformInfoQCOM);

struct VkCopyCommandTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCopyCommandTransformInfoQCOM,true,true> {
    VkCopyCommandTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyCommandTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceImageRobustnessFeaturesEXT, VkPhysicalDeviceImageRobustnessFeaturesEXT);

struct VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageRobustnessFeaturesEXT,true,true> {
    VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageRobustnessFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess)>("robustImageAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice4444FormatsFeaturesEXT);

struct VkPhysicalDevice4444FormatsFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice4444FormatsFeaturesEXT,true,true> {
    VkPhysicalDevice4444FormatsFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice4444FormatsFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(formatA4R4G4B4)>("formatA4R4G4B4");
        addField<DAS_BIND_MANAGED_FIELD(formatA4B4G4R4)>("formatA4B4G4R4");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceOrHostAddressKHR, VkDeviceOrHostAddressKHR);

struct VkDeviceOrHostAddressKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressKHR,true,true> {
    VkDeviceOrHostAddressKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkDeviceOrHostAddressConstKHR, VkDeviceOrHostAddressConstKHR);

struct VkDeviceOrHostAddressConstKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressConstKHR,true,true> {
    VkDeviceOrHostAddressConstKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressConstKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureBuildRangeInfoKHR, VkAccelerationStructureBuildRangeInfoKHR);

struct VkAccelerationStructureBuildRangeInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildRangeInfoKHR,true,true> {
    VkAccelerationStructureBuildRangeInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildRangeInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(primitiveCount)>("primitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOffset)>("primitiveOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(transformOffset)>("transformOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureGeometryTrianglesDataKHR, VkAccelerationStructureGeometryTrianglesDataKHR);

struct VkAccelerationStructureGeometryTrianglesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryTrianglesDataKHR,true,true> {
    VkAccelerationStructureGeometryTrianglesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryTrianglesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexFormat)>("vertexFormat");
        addField<DAS_BIND_MANAGED_FIELD(vertexData)>("vertexData");
        addField<DAS_BIND_MANAGED_FIELD(vertexStride)>("vertexStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertex)>("maxVertex");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
        addField<DAS_BIND_MANAGED_FIELD(indexData)>("indexData");
        addField<DAS_BIND_MANAGED_FIELD(transformData)>("transformData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureGeometryAabbsDataKHR, VkAccelerationStructureGeometryAabbsDataKHR);

struct VkAccelerationStructureGeometryAabbsDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryAabbsDataKHR,true,true> {
    VkAccelerationStructureGeometryAabbsDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryAabbsDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureGeometryInstancesDataKHR, VkAccelerationStructureGeometryInstancesDataKHR);

struct VkAccelerationStructureGeometryInstancesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryInstancesDataKHR,true,true> {
    VkAccelerationStructureGeometryInstancesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryInstancesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(arrayOfPointers)>("arrayOfPointers");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureGeometryDataKHR, VkAccelerationStructureGeometryDataKHR);

struct VkAccelerationStructureGeometryDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryDataKHR,true,true> {
    VkAccelerationStructureGeometryDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(triangles)>("triangles");
        addField<DAS_BIND_MANAGED_FIELD(aabbs)>("aabbs");
        addField<DAS_BIND_MANAGED_FIELD(instances)>("instances");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureGeometryKHR, VkAccelerationStructureGeometryKHR);

struct VkAccelerationStructureGeometryKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryKHR,true,true> {
    VkAccelerationStructureGeometryKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(geometryType)>("geometryType");
        addField<DAS_BIND_MANAGED_FIELD(geometry)>("geometry");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureBuildGeometryInfoKHR, VkAccelerationStructureBuildGeometryInfoKHR);

struct VkAccelerationStructureBuildGeometryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildGeometryInfoKHR,true,true> {
    VkAccelerationStructureBuildGeometryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildGeometryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
        addField<DAS_BIND_MANAGED_FIELD(srcAccelerationStructure)>("srcAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(dstAccelerationStructure)>("dstAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(geometryCount)>("geometryCount");
        addField<DAS_BIND_MANAGED_FIELD(pGeometries)>("pGeometries");
        addField<DAS_BIND_MANAGED_FIELD(ppGeometries)>("ppGeometries");
        addField<DAS_BIND_MANAGED_FIELD(scratchData)>("scratchData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureCreateInfoKHR, VkAccelerationStructureCreateInfoKHR);

struct VkAccelerationStructureCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureCreateInfoKHR,true,true> {
    VkAccelerationStructureCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(createFlags)>("createFlags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureKHR);

struct VkWriteDescriptorSetAccelerationStructureKHRAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetAccelerationStructureKHR,true,true> {
    VkWriteDescriptorSetAccelerationStructureKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetAccelerationStructureKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCount)>("accelerationStructureCount");
        addField<DAS_BIND_MANAGED_FIELD(pAccelerationStructures)>("pAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR);

struct VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructureFeaturesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructureFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCaptureReplay)>("accelerationStructureCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureIndirectBuild)>("accelerationStructureIndirectBuild");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureHostCommands)>("accelerationStructureHostCommands");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingAccelerationStructureUpdateAfterBind)>("descriptorBindingAccelerationStructureUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceAccelerationStructurePropertiesKHR);

struct VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructurePropertiesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructurePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryCount)>("maxGeometryCount");
        addField<DAS_BIND_MANAGED_FIELD(maxInstanceCount)>("maxInstanceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPrimitiveCount)>("maxPrimitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorAccelerationStructures)>("maxPerStageDescriptorAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindAccelerationStructures)>("maxPerStageDescriptorUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetAccelerationStructures)>("maxDescriptorSetAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindAccelerationStructures)>("maxDescriptorSetUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(minAccelerationStructureScratchOffsetAlignment)>("minAccelerationStructureScratchOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureDeviceAddressInfoKHR, VkAccelerationStructureDeviceAddressInfoKHR);

struct VkAccelerationStructureDeviceAddressInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureDeviceAddressInfoKHR,true,true> {
    VkAccelerationStructureDeviceAddressInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureDeviceAddressInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureVersionInfoKHR, VkAccelerationStructureVersionInfoKHR);

struct VkAccelerationStructureVersionInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureVersionInfoKHR,true,true> {
    VkAccelerationStructureVersionInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureVersionInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pVersionData)>("pVersionData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyAccelerationStructureToMemoryInfoKHR, VkCopyAccelerationStructureToMemoryInfoKHR);

struct VkCopyAccelerationStructureToMemoryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureToMemoryInfoKHR,true,true> {
    VkCopyAccelerationStructureToMemoryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureToMemoryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyMemoryToAccelerationStructureInfoKHR, VkCopyMemoryToAccelerationStructureInfoKHR);

struct VkCopyMemoryToAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyMemoryToAccelerationStructureInfoKHR,true,true> {
    VkCopyMemoryToAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyMemoryToAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkCopyAccelerationStructureInfoKHR, VkCopyAccelerationStructureInfoKHR);

struct VkCopyAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureInfoKHR,true,true> {
    VkCopyAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkAccelerationStructureBuildSizesInfoKHR, VkAccelerationStructureBuildSizesInfoKHR);

struct VkAccelerationStructureBuildSizesInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildSizesInfoKHR,true,true> {
    VkAccelerationStructureBuildSizesInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildSizesInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureSize)>("accelerationStructureSize");
        addField<DAS_BIND_MANAGED_FIELD(updateScratchSize)>("updateScratchSize");
        addField<DAS_BIND_MANAGED_FIELD(buildScratchSize)>("buildScratchSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRayTracingShaderGroupCreateInfoKHR, VkRayTracingShaderGroupCreateInfoKHR);

struct VkRayTracingShaderGroupCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingShaderGroupCreateInfoKHR,true,true> {
    VkRayTracingShaderGroupCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingShaderGroupCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(generalShader)>("generalShader");
        addField<DAS_BIND_MANAGED_FIELD(closestHitShader)>("closestHitShader");
        addField<DAS_BIND_MANAGED_FIELD(anyHitShader)>("anyHitShader");
        addField<DAS_BIND_MANAGED_FIELD(intersectionShader)>("intersectionShader");
        addField<DAS_BIND_MANAGED_FIELD(pShaderGroupCaptureReplayHandle)>("pShaderGroupCaptureReplayHandle");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRayTracingPipelineInterfaceCreateInfoKHR, VkRayTracingPipelineInterfaceCreateInfoKHR);

struct VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineInterfaceCreateInfoKHR,true,true> {
    VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineInterfaceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayPayloadSize)>("maxPipelineRayPayloadSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayHitAttributeSize)>("maxPipelineRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkRayTracingPipelineCreateInfoKHR, VkRayTracingPipelineCreateInfoKHR);

struct VkRayTracingPipelineCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineCreateInfoKHR,true,true> {
    VkRayTracingPipelineCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayRecursionDepth)>("maxPipelineRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInfo)>("pLibraryInfo");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInterface)>("pLibraryInterface");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR);

struct VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelineFeaturesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelineFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipeline)>("rayTracingPipeline");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplay)>("rayTracingPipelineShaderGroupHandleCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplayMixed)>("rayTracingPipelineShaderGroupHandleCaptureReplayMixed");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineTraceRaysIndirect)>("rayTracingPipelineTraceRaysIndirect");
        addField<DAS_BIND_MANAGED_FIELD(rayTraversalPrimitiveCulling)>("rayTraversalPrimitiveCulling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR);

struct VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelinePropertiesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelinePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleSize)>("shaderGroupHandleSize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayRecursionDepth)>("maxRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxShaderGroupStride)>("maxShaderGroupStride");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupBaseAlignment)>("shaderGroupBaseAlignment");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleCaptureReplaySize)>("shaderGroupHandleCaptureReplaySize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayDispatchInvocationCount)>("maxRayDispatchInvocationCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleAlignment)>("shaderGroupHandleAlignment");
        addField<DAS_BIND_MANAGED_FIELD(maxRayHitAttributeSize)>("maxRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkStridedDeviceAddressRegionKHR, VkStridedDeviceAddressRegionKHR);

struct VkStridedDeviceAddressRegionKHRAnnotation
: public ManagedStructureAnnotation<VkStridedDeviceAddressRegionKHR,true,true> {
    VkStridedDeviceAddressRegionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStridedDeviceAddressRegionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkTraceRaysIndirectCommandKHR, VkTraceRaysIndirectCommandKHR);

struct VkTraceRaysIndirectCommandKHRAnnotation
: public ManagedStructureAnnotation<VkTraceRaysIndirectCommandKHR,true,true> {
    VkTraceRaysIndirectCommandKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTraceRaysIndirectCommandKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayQueryFeaturesKHR);

struct VkPhysicalDeviceRayQueryFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayQueryFeaturesKHR,true,true> {
    VkPhysicalDeviceRayQueryFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayQueryFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayQuery)>("rayQuery");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(GLFWvidmode, GLFWvidmode);

struct GLFWvidmodeAnnotation
: public ManagedStructureAnnotation<GLFWvidmode,true,true> {
    GLFWvidmodeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWvidmode", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(redBits)>("redBits");
        addField<DAS_BIND_MANAGED_FIELD(greenBits)>("greenBits");
        addField<DAS_BIND_MANAGED_FIELD(blueBits)>("blueBits");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(GLFWgammaramp, GLFWgammaramp);

struct GLFWgammarampAnnotation
: public ManagedStructureAnnotation<GLFWgammaramp,true,true> {
    GLFWgammarampAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgammaramp", ml) {
        addField<DAS_BIND_MANAGED_FIELD(red)>("red");
        addField<DAS_BIND_MANAGED_FIELD(green)>("green");
        addField<DAS_BIND_MANAGED_FIELD(blue)>("blue");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(GLFWimage, GLFWimage);

struct GLFWimageAnnotation
: public ManagedStructureAnnotation<GLFWimage,true,true> {
    GLFWimageAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWimage", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(pixels)>("pixels");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

MAKE_TYPE_FACTORY(GLFWgamepadstate, GLFWgamepadstate);

struct GLFWgamepadstateAnnotation
: public ManagedStructureAnnotation<GLFWgamepadstate,true,true> {
    GLFWgamepadstateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgamepadstate", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buttons)>("buttons");
        addField<DAS_BIND_MANAGED_FIELD(axes)>("axes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

class GeneratedModule_vulkan : public Module {
public:
    GeneratedModule_vulkan() : Module("vulkan") {
    }

protected:
    void addGenerated(ModuleLibrary & lib) {

        //
        // enums
        //

        addEnumeration(make_smart<EnumerationVkResult>());
        addEnumeration(make_smart<EnumerationVkStructureType>());
        addEnumeration(make_smart<EnumerationVkImageLayout>());
        addEnumeration(make_smart<EnumerationVkObjectType>());
        addEnumeration(make_smart<EnumerationVkVendorId>());
        addEnumeration(make_smart<EnumerationVkPipelineCacheHeaderVersion>());
        addEnumeration(make_smart<EnumerationVkSystemAllocationScope>());
        addEnumeration(make_smart<EnumerationVkInternalAllocationType>());
        addEnumeration(make_smart<EnumerationVkFormat>());
        addEnumeration(make_smart<EnumerationVkImageTiling>());
        addEnumeration(make_smart<EnumerationVkImageType>());
        addEnumeration(make_smart<EnumerationVkPhysicalDeviceType>());
        addEnumeration(make_smart<EnumerationVkQueryType>());
        addEnumeration(make_smart<EnumerationVkSharingMode>());
        addEnumeration(make_smart<EnumerationVkComponentSwizzle>());
        addEnumeration(make_smart<EnumerationVkImageViewType>());
        addEnumeration(make_smart<EnumerationVkBlendFactor>());
        addEnumeration(make_smart<EnumerationVkBlendOp>());
        addEnumeration(make_smart<EnumerationVkCompareOp>());
        addEnumeration(make_smart<EnumerationVkDynamicState>());
        addEnumeration(make_smart<EnumerationVkFrontFace>());
        addEnumeration(make_smart<EnumerationVkVertexInputRate>());
        addEnumeration(make_smart<EnumerationVkPrimitiveTopology>());
        addEnumeration(make_smart<EnumerationVkPolygonMode>());
        addEnumeration(make_smart<EnumerationVkStencilOp>());
        addEnumeration(make_smart<EnumerationVkLogicOp>());
        addEnumeration(make_smart<EnumerationVkBorderColor>());
        addEnumeration(make_smart<EnumerationVkFilter>());
        addEnumeration(make_smart<EnumerationVkSamplerAddressMode>());
        addEnumeration(make_smart<EnumerationVkSamplerMipmapMode>());
        addEnumeration(make_smart<EnumerationVkDescriptorType>());
        addEnumeration(make_smart<EnumerationVkAttachmentLoadOp>());
        addEnumeration(make_smart<EnumerationVkAttachmentStoreOp>());
        addEnumeration(make_smart<EnumerationVkPipelineBindPoint>());
        addEnumeration(make_smart<EnumerationVkCommandBufferLevel>());
        addEnumeration(make_smart<EnumerationVkIndexType>());
        addEnumeration(make_smart<EnumerationVkSubpassContents>());
        addEnumeration(make_smart<EnumerationVkAccessFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageAspectFlagBits>());
        addEnumeration(make_smart<EnumerationVkFormatFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkSampleCountFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryHeapFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryPropertyFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueueFlagBits>());
        addEnumeration(make_smart<EnumerationVkDeviceQueueCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineStageFlagBits>());
        addEnumeration(make_smart<EnumerationVkSparseMemoryBindFlagBits>());
        addEnumeration(make_smart<EnumerationVkSparseImageFormatFlagBits>());
        addEnumeration(make_smart<EnumerationVkFenceCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryPipelineStatisticFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryResultFlagBits>());
        addEnumeration(make_smart<EnumerationVkBufferCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkBufferUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageViewCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkShaderModuleCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineCacheCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkColorComponentFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineShaderStageCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkShaderStageFlagBits>());
        addEnumeration(make_smart<EnumerationVkCullModeFlagBits>());
        addEnumeration(make_smart<EnumerationVkSamplerCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorPoolCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorSetLayoutCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkAttachmentDescriptionFlagBits>());
        addEnumeration(make_smart<EnumerationVkDependencyFlagBits>());
        addEnumeration(make_smart<EnumerationVkFramebufferCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkRenderPassCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkSubpassDescriptionFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandPoolCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandPoolResetFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandBufferUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryControlFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandBufferResetFlagBits>());
        addEnumeration(make_smart<EnumerationVkStencilFaceFlagBits>());
        addEnumeration(make_smart<EnumerationVkPointClippingBehavior>());
        addEnumeration(make_smart<EnumerationVkTessellationDomainOrigin>());
        addEnumeration(make_smart<EnumerationVkSamplerYcbcrModelConversion>());
        addEnumeration(make_smart<EnumerationVkSamplerYcbcrRange>());
        addEnumeration(make_smart<EnumerationVkChromaLocation>());
        addEnumeration(make_smart<EnumerationVkDescriptorUpdateTemplateType>());
        addEnumeration(make_smart<EnumerationVkSubgroupFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkPeerMemoryFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryAllocateFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalFenceHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalFenceFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkFenceImportFlagBits>());
        addEnumeration(make_smart<EnumerationVkSemaphoreImportFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalSemaphoreHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalSemaphoreFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkDriverId>());
        addEnumeration(make_smart<EnumerationVkShaderFloatControlsIndependence>());
        addEnumeration(make_smart<EnumerationVkSamplerReductionMode>());
        addEnumeration(make_smart<EnumerationVkSemaphoreType>());
        addEnumeration(make_smart<EnumerationVkResolveModeFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorBindingFlagBits>());
        addEnumeration(make_smart<EnumerationVkSemaphoreWaitFlagBits>());
        addEnumeration(make_smart<EnumerationVkPresentModeKHR>());
        addEnumeration(make_smart<EnumerationVkColorSpaceKHR>());
        addEnumeration(make_smart<EnumerationVkSurfaceTransformFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkCompositeAlphaFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkSwapchainCreateFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkDeviceGroupPresentModeFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkDisplayPlaneAlphaFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterUnitKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterScopeKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterStorageKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterDescriptionFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkAcquireProfilingLockFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateCombinerOpKHR>());
        addEnumeration(make_smart<EnumerationVkPipelineExecutableStatisticFormatKHR>());
        addEnumeration(make_smart<EnumerationVkDebugReportObjectTypeEXT>());
        addEnumeration(make_smart<EnumerationVkDebugReportFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkRasterizationOrderAMD>());
        addEnumeration(make_smart<EnumerationVkShaderInfoTypeAMD>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryHandleTypeFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryFeatureFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkValidationCheckEXT>());
        addEnumeration(make_smart<EnumerationVkConditionalRenderingFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkSurfaceCounterFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDisplayPowerStateEXT>());
        addEnumeration(make_smart<EnumerationVkDeviceEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkDisplayEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkViewportCoordinateSwizzleNV>());
        addEnumeration(make_smart<EnumerationVkDiscardRectangleModeEXT>());
        addEnumeration(make_smart<EnumerationVkConservativeRasterizationModeEXT>());
        addEnumeration(make_smart<EnumerationVkDebugUtilsMessageSeverityFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDebugUtilsMessageTypeFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkBlendOverlapEXT>());
        addEnumeration(make_smart<EnumerationVkCoverageModulationModeNV>());
        addEnumeration(make_smart<EnumerationVkValidationCacheHeaderVersionEXT>());
        addEnumeration(make_smart<EnumerationVkShadingRatePaletteEntryNV>());
        addEnumeration(make_smart<EnumerationVkCoarseSampleOrderTypeNV>());
        addEnumeration(make_smart<EnumerationVkRayTracingShaderGroupTypeKHR>());
        addEnumeration(make_smart<EnumerationVkGeometryTypeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureTypeKHR>());
        addEnumeration(make_smart<EnumerationVkCopyAccelerationStructureModeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureMemoryRequirementsTypeNV>());
        addEnumeration(make_smart<EnumerationVkGeometryFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkGeometryInstanceFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkQueueGlobalPriorityEXT>());
        addEnumeration(make_smart<EnumerationVkPipelineCompilerControlFlagBitsAMD>());
        addEnumeration(make_smart<EnumerationVkTimeDomainEXT>());
        addEnumeration(make_smart<EnumerationVkMemoryOverallocationBehaviorAMD>());
        addEnumeration(make_smart<EnumerationVkPipelineCreationFeedbackFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkPerformanceConfigurationTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkQueryPoolSamplingModeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceOverrideTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceParameterTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceValueTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkShaderCorePropertiesFlagBitsAMD>());
        addEnumeration(make_smart<EnumerationVkToolPurposeFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkValidationFeatureEnableEXT>());
        addEnumeration(make_smart<EnumerationVkValidationFeatureDisableEXT>());
        addEnumeration(make_smart<EnumerationVkComponentTypeNV>());
        addEnumeration(make_smart<EnumerationVkScopeNV>());
        addEnumeration(make_smart<EnumerationVkCoverageReductionModeNV>());
        addEnumeration(make_smart<EnumerationVkLineRasterizationModeEXT>());
        addEnumeration(make_smart<EnumerationVkIndirectCommandsTokenTypeNV>());
        addEnumeration(make_smart<EnumerationVkIndirectStateFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkIndirectCommandsLayoutUsageFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkDeviceMemoryReportEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkPrivateDataSlotCreateFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDeviceDiagnosticsConfigFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateTypeNV>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateNV>());
        addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureModeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureBuildTypeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureCompatibilityKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureCreateFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkShaderGroupShaderKHR>());

        //
        // opaque structs
        //

        addAnnotation(make_smart<VkHandleAnnotation<VkBuffer>>("VkBuffer", "VkBuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkImage>>("VkImage", "VkImage"));
        addAnnotation(make_smart<VkHandleAnnotation<VkInstance>>("VkInstance", "VkInstance"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPhysicalDevice>>("VkPhysicalDevice", "VkPhysicalDevice"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDevice>>("VkDevice", "VkDevice"));
        addAnnotation(make_smart<VkHandleAnnotation<VkQueue>>("VkQueue", "VkQueue"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSemaphore>>("VkSemaphore", "VkSemaphore"));
        addAnnotation(make_smart<VkHandleAnnotation<VkCommandBuffer>>("VkCommandBuffer", "VkCommandBuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkFence>>("VkFence", "VkFence"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDeviceMemory>>("VkDeviceMemory", "VkDeviceMemory"));
        addAnnotation(make_smart<VkHandleAnnotation<VkEvent>>("VkEvent", "VkEvent"));
        addAnnotation(make_smart<VkHandleAnnotation<VkQueryPool>>("VkQueryPool", "VkQueryPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkBufferView>>("VkBufferView", "VkBufferView"));
        addAnnotation(make_smart<VkHandleAnnotation<VkImageView>>("VkImageView", "VkImageView"));
        addAnnotation(make_smart<VkHandleAnnotation<VkShaderModule>>("VkShaderModule", "VkShaderModule"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipelineCache>>("VkPipelineCache", "VkPipelineCache"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipelineLayout>>("VkPipelineLayout", "VkPipelineLayout"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipeline>>("VkPipeline", "VkPipeline"));
        addAnnotation(make_smart<VkHandleAnnotation<VkRenderPass>>("VkRenderPass", "VkRenderPass"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorSetLayout>>("VkDescriptorSetLayout", "VkDescriptorSetLayout"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSampler>>("VkSampler", "VkSampler"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorSet>>("VkDescriptorSet", "VkDescriptorSet"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorPool>>("VkDescriptorPool", "VkDescriptorPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkFramebuffer>>("VkFramebuffer", "VkFramebuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkCommandPool>>("VkCommandPool", "VkCommandPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSamplerYcbcrConversion>>("VkSamplerYcbcrConversion", "VkSamplerYcbcrConversion"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorUpdateTemplate>>("VkDescriptorUpdateTemplate", "VkDescriptorUpdateTemplate"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSurfaceKHR>>("VkSurfaceKHR", "VkSurfaceKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSwapchainKHR>>("VkSwapchainKHR", "VkSwapchainKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDisplayKHR>>("VkDisplayKHR", "VkDisplayKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDisplayModeKHR>>("VkDisplayModeKHR", "VkDisplayModeKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDeferredOperationKHR>>("VkDeferredOperationKHR", "VkDeferredOperationKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDebugReportCallbackEXT>>("VkDebugReportCallbackEXT", "VkDebugReportCallbackEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDebugUtilsMessengerEXT>>("VkDebugUtilsMessengerEXT", "VkDebugUtilsMessengerEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkValidationCacheEXT>>("VkValidationCacheEXT", "VkValidationCacheEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureNV>>("VkAccelerationStructureNV", "VkAccelerationStructureNV"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPerformanceConfigurationINTEL>>("VkPerformanceConfigurationINTEL", "VkPerformanceConfigurationINTEL"));
        addAnnotation(make_smart<VkHandleAnnotation<VkIndirectCommandsLayoutNV>>("VkIndirectCommandsLayoutNV", "VkIndirectCommandsLayoutNV"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPrivateDataSlotEXT>>("VkPrivateDataSlotEXT", "VkPrivateDataSlotEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureKHR>>("VkAccelerationStructureKHR", "VkAccelerationStructureKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWmonitor_DasHandle>>("GLFWmonitor_DasHandle", "GLFWmonitor_DasHandle"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWwindow_DasHandle>>("GLFWwindow_DasHandle", "GLFWwindow_DasHandle"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWcursor_DasHandle>>("GLFWcursor_DasHandle", "GLFWcursor_DasHandle"));

        //
        // structs
        //

        addAnnotation(make_smart<VkExtent2DAnnotation>(lib));
        addAnnotation(make_smart<VkExtent3DAnnotation>(lib));
        addAnnotation(make_smart<VkOffset2DAnnotation>(lib));
        addAnnotation(make_smart<VkOffset3DAnnotation>(lib));
        addAnnotation(make_smart<VkRect2DAnnotation>(lib));
        addAnnotation(make_smart<VkBaseInStructureAnnotation>(lib));
        addAnnotation(make_smart<VkBaseOutStructureAnnotation>(lib));
        addAnnotation(make_smart<VkBufferMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkDispatchIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkDrawIndexedIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkDrawIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceRangeAnnotation>(lib));
        addAnnotation(make_smart<VkImageMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkAllocationCallbacksAnnotation>(lib));
        addAnnotation(make_smart<VkApplicationInfoAnnotation>(lib));
        addAnnotation(make_smart<VkFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkInstanceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryHeapAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryTypeAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLimitsAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSparsePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExtensionPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkLayerPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMappedMemoryRangeAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkSparseMemoryBindAnnotation>(lib));
        addAnnotation(make_smart<VkSparseBufferMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageOpaqueMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryBindAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindSparseInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkFenceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkEventCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferViewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubresourceLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkComponentMappingAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkShaderModuleCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCacheCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSpecializationMapEntryAnnotation>(lib));
        addAnnotation(make_smart<VkSpecializationInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineShaderStageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkComputePipelineCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputBindingDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputAttributeDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineVertexInputStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineInputAssemblyStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineTessellationStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkViewportAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineMultisampleStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkStencilOpStateAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDepthStencilStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendAttachmentStateAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDynamicStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsPipelineCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPushConstantRangeAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineLayoutCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCopyDescriptorSetAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorBufferInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorImageInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolSizeAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutBindingAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentReferenceAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDependencyAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCopyAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceLayersAnnotation>(lib));
        addAnnotation(make_smart<VkBufferImageCopyAnnotation>(lib));
        addAnnotation(make_smart<VkClearColorValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearDepthStencilValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearAttachmentAnnotation>(lib));
        addAnnotation(make_smart<VkClearRectAnnotation>(lib));
        addAnnotation(make_smart<VkImageBlitAnnotation>(lib));
        addAnnotation(make_smart<VkImageCopyAnnotation>(lib));
        addAnnotation(make_smart<VkImageResolveAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkBindBufferMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice16BitStorageFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryDedicatedRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryDedicatedAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryAllocateFlagsInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupRenderPassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupCommandBufferBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupBindSparseInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindBufferMemoryDeviceGroupInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemoryDeviceGroupInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceGroupPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupDeviceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkImageMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkImageSparseMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkMemoryRequirements2Annotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryRequirements2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFeatures2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProperties2Annotation>(lib));
        addAnnotation(make_smart<VkFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkImageFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageFormatInfo2Annotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryProperties2Annotation>(lib));
        addAnnotation(make_smart<VkSparseImageFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSparseImageFormatInfo2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePointClippingPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkInputAttachmentAspectReferenceAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassInputAttachmentAspectCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewUsageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineTessellationDomainOriginStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassMultiviewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVariablePointersFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueInfo2Annotation>(lib));
        addAnnotation(make_smart<VkProtectedSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImagePlaneMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImagePlaneMemoryRequirementsInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorUpdateTemplateEntryAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorUpdateTemplateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalImageFormatInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalBufferInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalBufferPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceIDPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryImageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryBufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExportMemoryAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalFenceInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalFencePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkExportFenceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExportSemaphoreCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalSemaphoreInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalSemaphorePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMaintenance3PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutSupportAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan11FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan11PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan12FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkConformanceVersionAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan12PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkImageFormatListCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescription2Annotation>(lib));
        addAnnotation(make_smart<VkAttachmentReference2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassDescription2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassDependency2Annotation>(lib));
        addAnnotation(make_smart<VkRenderPassCreateInfo2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassEndInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice8BitStorageFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDriverPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFloatControlsPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDescriptionDepthStencilResolveAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkImageStencilUsageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerReductionModeCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferAttachmentImageInfoAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferAttachmentsCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassAttachmentBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentReferenceStencilLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescriptionStencilLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceHostQueryResetFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreTypeCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkTimelineSemaphoreSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreWaitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreSignalInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkBufferDeviceAddressInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferOpaqueCaptureAddressCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceFormatKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemorySwapchainInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAcquireNextImageInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupPresentCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeParametersKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlanePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplaySurfaceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportMemoryFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryFdPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportSemaphoreFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRectLayerKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentRegionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentRegionsKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSharedPresentSurfaceCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportFenceFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkFenceGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterDescriptionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolPerformanceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterResultKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAcquireProfilingLockInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceQuerySubmitInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSurfaceInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilities2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceFormat2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneCapabilities2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderClockFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkFragmentShadingRateAttachmentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceProtectedCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutablePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableStatisticValueKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableStatisticKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableInternalRepresentationKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineLibraryCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyBufferInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkBufferImageCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyBufferToImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyImageToBufferInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageBlit2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkBlitImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageResolve2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkResolveImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDebugReportCallbackCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateRasterizationOrderAMDAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerObjectNameInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerObjectTagInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerMarkerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationImageCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationBufferCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationMemoryAllocateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewHandleInfoNVXAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewAddressPropertiesNVXAnnotation>(lib));
        addAnnotation(make_smart<VkTextureLODGatherFormatPropertiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkShaderResourceUsageAMDAnnotation>(lib));
        addAnnotation(make_smart<VkShaderStatisticsInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkExternalImageFormatPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryImageCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkExportMemoryAllocateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkValidationFlagsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewASTCDecodeModeEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkConditionalRenderingBeginInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkViewportWScalingNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportWScalingStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilities2EXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPowerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceEventInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayEventInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainCounterCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRefreshCycleDurationGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPastPresentationTimingGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPresentTimeGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPresentTimesInfoGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation>(lib));
        addAnnotation(make_smart<VkViewportSwizzleNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportSwizzleStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkXYColorEXTAnnotation>(lib));
        addAnnotation(make_smart<VkHdrMetadataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsLabelEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsObjectNameInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsMessengerCallbackDataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsMessengerCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsObjectTagInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetInlineUniformBlockEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSampleLocationEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSampleLocationsInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentSampleLocationsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassSampleLocationsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassSampleLocationsBeginInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineSampleLocationsStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMultisamplePropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageToColorStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageModulationStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDrmFormatModifierPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDrmFormatModifierPropertiesListEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierListCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkValidationCacheCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkShaderModuleValidationCacheCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkShadingRatePaletteNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkCoarseSampleLocationNVAnnotation>(lib));
        addAnnotation(make_smart<VkCoarseSampleOrderCustomNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingShaderGroupCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryTrianglesNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryAABBNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryDataNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindAccelerationStructureMemoryInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAccelerationStructureNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureMemoryRequirementsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkTransformMatrixKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAabbPositionsKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureInstanceKHRAnnotation>(lib));
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_instanceCustomIndex)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_instanceCustomIndex",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_instanceCustomIndex)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_instanceCustomIndex",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_mask)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_mask",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_mask)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_mask",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_flags)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_flags",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_flags)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_flags",
            SideEffects::modifyArgument, "{field.setter_name}");
        addAnnotation(make_smart<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImportMemoryHostPointerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryHostPointerPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCompilerControlCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkCalibratedTimestampInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderCorePropertiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryOverallocationCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputBindingDivisorDescriptionEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCreationFeedbackEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCreationFeedbackCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMeshShaderFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMeshShaderPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDrawMeshTasksIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyCheckpointPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkCheckpointDataNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceValueDataINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceValueINTELAnnotation>(lib));
        addAnnotation(make_smart<VkInitializePerformanceApiInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceMarkerInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceStreamMarkerInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceOverrideInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceConfigurationAcquireInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderCoreProperties2AMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryPriorityAllocateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkBufferDeviceAddressCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceToolPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkValidationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCooperativeMatrixPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageReductionStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferMixedSamplesCombinationNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkHeadlessSurfaceCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationLineStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsShaderGroupCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindShaderGroupIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindIndexBufferIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindVertexBufferIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkSetStateFlagsIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsStreamNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsLayoutTokenNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsLayoutCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeneratedCommandsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassTransformBeginInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryReportCallbackDataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRobustness2FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRobustness2PropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerCustomBorderColorCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePrivateDataFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDevicePrivateDataCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPrivateDataSlotCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceDiagnosticsConfigCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCopyCommandTransformInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice4444FormatsFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceOrHostAddressKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceOrHostAddressConstKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildRangeInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryTrianglesDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryAabbsDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryInstancesDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildGeometryInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAccelerationStructureKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureDeviceAddressInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureVersionInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyAccelerationStructureToMemoryInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyMemoryToAccelerationStructureInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyAccelerationStructureInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildSizesInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingShaderGroupCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkStridedDeviceAddressRegionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkTraceRaysIndirectCommandKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayQueryFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<GLFWvidmodeAnnotation>(lib));
        addAnnotation(make_smart<GLFWgammarampAnnotation>(lib));
        addAnnotation(make_smart<GLFWimageAnnotation>(lib));
        addAnnotation(make_smart<GLFWgamepadstateAnnotation>(lib));

        //
        // functions
        //

        addExtern<DAS_BIND_FUN(vkCreateInstance)>(*this, lib, "vkCreateInstance",
            SideEffects::worstDefault, "vkCreateInstance");
        addExtern<DAS_BIND_FUN(vkDestroyInstance)>(*this, lib, "vkDestroyInstance",
            SideEffects::worstDefault, "vkDestroyInstance");
        addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDevices)>(*this, lib, "vkEnumeratePhysicalDevices",
            SideEffects::worstDefault, "vkEnumeratePhysicalDevices");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures)>(*this, lib, "vkGetPhysicalDeviceFeatures",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties)>(*this, lib, "vkGetPhysicalDeviceFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties)>(*this, lib, "vkGetPhysicalDeviceProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties");
        addExtern<DAS_BIND_FUN(vkCreateDevice)>(*this, lib, "vkCreateDevice",
            SideEffects::worstDefault, "vkCreateDevice");
        addExtern<DAS_BIND_FUN(vkDestroyDevice)>(*this, lib, "vkDestroyDevice",
            SideEffects::worstDefault, "vkDestroyDevice");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceExtensionProperties)>(*this, lib, "vkEnumerateInstanceExtensionProperties",
            SideEffects::worstDefault, "vkEnumerateInstanceExtensionProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateDeviceExtensionProperties)>(*this, lib, "vkEnumerateDeviceExtensionProperties",
            SideEffects::worstDefault, "vkEnumerateDeviceExtensionProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceLayerProperties)>(*this, lib, "vkEnumerateInstanceLayerProperties",
            SideEffects::worstDefault, "vkEnumerateInstanceLayerProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateDeviceLayerProperties)>(*this, lib, "vkEnumerateDeviceLayerProperties",
            SideEffects::worstDefault, "vkEnumerateDeviceLayerProperties");
        addExtern<DAS_BIND_FUN(vkGetDeviceQueue)>(*this, lib, "vkGetDeviceQueue",
            SideEffects::worstDefault, "vkGetDeviceQueue");
        addExtern<DAS_BIND_FUN(vkQueueSubmit)>(*this, lib, "vkQueueSubmit",
            SideEffects::worstDefault, "vkQueueSubmit");
        addExtern<DAS_BIND_FUN(vkQueueWaitIdle)>(*this, lib, "vkQueueWaitIdle",
            SideEffects::worstDefault, "vkQueueWaitIdle");
        addExtern<DAS_BIND_FUN(vkDeviceWaitIdle)>(*this, lib, "vkDeviceWaitIdle",
            SideEffects::worstDefault, "vkDeviceWaitIdle");
        addExtern<DAS_BIND_FUN(vkAllocateMemory)>(*this, lib, "vkAllocateMemory",
            SideEffects::worstDefault, "vkAllocateMemory");
        addExtern<DAS_BIND_FUN(vkFreeMemory)>(*this, lib, "vkFreeMemory",
            SideEffects::worstDefault, "vkFreeMemory");
        addExtern<DAS_BIND_FUN(vkMapMemory)>(*this, lib, "vkMapMemory",
            SideEffects::worstDefault, "vkMapMemory");
        addExtern<DAS_BIND_FUN(vkUnmapMemory)>(*this, lib, "vkUnmapMemory",
            SideEffects::worstDefault, "vkUnmapMemory");
        addExtern<DAS_BIND_FUN(vkFlushMappedMemoryRanges)>(*this, lib, "vkFlushMappedMemoryRanges",
            SideEffects::worstDefault, "vkFlushMappedMemoryRanges");
        addExtern<DAS_BIND_FUN(vkInvalidateMappedMemoryRanges)>(*this, lib, "vkInvalidateMappedMemoryRanges",
            SideEffects::worstDefault, "vkInvalidateMappedMemoryRanges");
        addExtern<DAS_BIND_FUN(vkGetDeviceMemoryCommitment)>(*this, lib, "vkGetDeviceMemoryCommitment",
            SideEffects::worstDefault, "vkGetDeviceMemoryCommitment");
        addExtern<DAS_BIND_FUN(vkBindBufferMemory)>(*this, lib, "vkBindBufferMemory",
            SideEffects::worstDefault, "vkBindBufferMemory");
        addExtern<DAS_BIND_FUN(vkBindImageMemory)>(*this, lib, "vkBindImageMemory",
            SideEffects::worstDefault, "vkBindImageMemory");
        addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements)>(*this, lib, "vkGetBufferMemoryRequirements",
            SideEffects::worstDefault, "vkGetBufferMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements)>(*this, lib, "vkGetImageMemoryRequirements",
            SideEffects::worstDefault, "vkGetImageMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements)>(*this, lib, "vkGetImageSparseMemoryRequirements",
            SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties");
        addExtern<DAS_BIND_FUN(vkQueueBindSparse)>(*this, lib, "vkQueueBindSparse",
            SideEffects::worstDefault, "vkQueueBindSparse");
        addExtern<DAS_BIND_FUN(vkCreateFence)>(*this, lib, "vkCreateFence",
            SideEffects::worstDefault, "vkCreateFence");
        addExtern<DAS_BIND_FUN(vkDestroyFence)>(*this, lib, "vkDestroyFence",
            SideEffects::worstDefault, "vkDestroyFence");
        addExtern<DAS_BIND_FUN(vkResetFences)>(*this, lib, "vkResetFences",
            SideEffects::worstDefault, "vkResetFences");
        addExtern<DAS_BIND_FUN(vkGetFenceStatus)>(*this, lib, "vkGetFenceStatus",
            SideEffects::worstDefault, "vkGetFenceStatus");
        addExtern<DAS_BIND_FUN(vkWaitForFences)>(*this, lib, "vkWaitForFences",
            SideEffects::worstDefault, "vkWaitForFences");
        addExtern<DAS_BIND_FUN(vkCreateSemaphore)>(*this, lib, "vkCreateSemaphore",
            SideEffects::worstDefault, "vkCreateSemaphore");
        addExtern<DAS_BIND_FUN(vkDestroySemaphore)>(*this, lib, "vkDestroySemaphore",
            SideEffects::worstDefault, "vkDestroySemaphore");
        addExtern<DAS_BIND_FUN(vkCreateEvent)>(*this, lib, "vkCreateEvent",
            SideEffects::worstDefault, "vkCreateEvent");
        addExtern<DAS_BIND_FUN(vkDestroyEvent)>(*this, lib, "vkDestroyEvent",
            SideEffects::worstDefault, "vkDestroyEvent");
        addExtern<DAS_BIND_FUN(vkGetEventStatus)>(*this, lib, "vkGetEventStatus",
            SideEffects::worstDefault, "vkGetEventStatus");
        addExtern<DAS_BIND_FUN(vkSetEvent)>(*this, lib, "vkSetEvent",
            SideEffects::worstDefault, "vkSetEvent");
        addExtern<DAS_BIND_FUN(vkResetEvent)>(*this, lib, "vkResetEvent",
            SideEffects::worstDefault, "vkResetEvent");
        addExtern<DAS_BIND_FUN(vkCreateQueryPool)>(*this, lib, "vkCreateQueryPool",
            SideEffects::worstDefault, "vkCreateQueryPool");
        addExtern<DAS_BIND_FUN(vkDestroyQueryPool)>(*this, lib, "vkDestroyQueryPool",
            SideEffects::worstDefault, "vkDestroyQueryPool");
        addExtern<DAS_BIND_FUN(vkGetQueryPoolResults)>(*this, lib, "vkGetQueryPoolResults",
            SideEffects::worstDefault, "vkGetQueryPoolResults");
        addExtern<DAS_BIND_FUN(vkCreateBuffer)>(*this, lib, "vkCreateBuffer",
            SideEffects::worstDefault, "vkCreateBuffer");
        addExtern<DAS_BIND_FUN(vkDestroyBuffer)>(*this, lib, "vkDestroyBuffer",
            SideEffects::worstDefault, "vkDestroyBuffer");
        addExtern<DAS_BIND_FUN(vkCreateBufferView)>(*this, lib, "vkCreateBufferView",
            SideEffects::worstDefault, "vkCreateBufferView");
        addExtern<DAS_BIND_FUN(vkDestroyBufferView)>(*this, lib, "vkDestroyBufferView",
            SideEffects::worstDefault, "vkDestroyBufferView");
        addExtern<DAS_BIND_FUN(vkCreateImage)>(*this, lib, "vkCreateImage",
            SideEffects::worstDefault, "vkCreateImage");
        addExtern<DAS_BIND_FUN(vkDestroyImage)>(*this, lib, "vkDestroyImage",
            SideEffects::worstDefault, "vkDestroyImage");
        addExtern<DAS_BIND_FUN(vkGetImageSubresourceLayout)>(*this, lib, "vkGetImageSubresourceLayout",
            SideEffects::worstDefault, "vkGetImageSubresourceLayout");
        addExtern<DAS_BIND_FUN(vkCreateImageView)>(*this, lib, "vkCreateImageView",
            SideEffects::worstDefault, "vkCreateImageView");
        addExtern<DAS_BIND_FUN(vkDestroyImageView)>(*this, lib, "vkDestroyImageView",
            SideEffects::worstDefault, "vkDestroyImageView");
        addExtern<DAS_BIND_FUN(vkCreateShaderModule)>(*this, lib, "vkCreateShaderModule",
            SideEffects::worstDefault, "vkCreateShaderModule");
        addExtern<DAS_BIND_FUN(vkDestroyShaderModule)>(*this, lib, "vkDestroyShaderModule",
            SideEffects::worstDefault, "vkDestroyShaderModule");
        addExtern<DAS_BIND_FUN(vkCreatePipelineCache)>(*this, lib, "vkCreatePipelineCache",
            SideEffects::worstDefault, "vkCreatePipelineCache");
        addExtern<DAS_BIND_FUN(vkDestroyPipelineCache)>(*this, lib, "vkDestroyPipelineCache",
            SideEffects::worstDefault, "vkDestroyPipelineCache");
        addExtern<DAS_BIND_FUN(vkGetPipelineCacheData)>(*this, lib, "vkGetPipelineCacheData",
            SideEffects::worstDefault, "vkGetPipelineCacheData");
        addExtern<DAS_BIND_FUN(vkMergePipelineCaches)>(*this, lib, "vkMergePipelineCaches",
            SideEffects::worstDefault, "vkMergePipelineCaches");
        addExtern<DAS_BIND_FUN(vkCreateGraphicsPipelines)>(*this, lib, "vkCreateGraphicsPipelines",
            SideEffects::worstDefault, "vkCreateGraphicsPipelines");
        addExtern<DAS_BIND_FUN(vkCreateComputePipelines)>(*this, lib, "vkCreateComputePipelines",
            SideEffects::worstDefault, "vkCreateComputePipelines");
        addExtern<DAS_BIND_FUN(vkDestroyPipeline)>(*this, lib, "vkDestroyPipeline",
            SideEffects::worstDefault, "vkDestroyPipeline");
        addExtern<DAS_BIND_FUN(vkCreatePipelineLayout)>(*this, lib, "vkCreatePipelineLayout",
            SideEffects::worstDefault, "vkCreatePipelineLayout");
        addExtern<DAS_BIND_FUN(vkDestroyPipelineLayout)>(*this, lib, "vkDestroyPipelineLayout",
            SideEffects::worstDefault, "vkDestroyPipelineLayout");
        addExtern<DAS_BIND_FUN(vkCreateSampler)>(*this, lib, "vkCreateSampler",
            SideEffects::worstDefault, "vkCreateSampler");
        addExtern<DAS_BIND_FUN(vkDestroySampler)>(*this, lib, "vkDestroySampler",
            SideEffects::worstDefault, "vkDestroySampler");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorSetLayout)>(*this, lib, "vkCreateDescriptorSetLayout",
            SideEffects::worstDefault, "vkCreateDescriptorSetLayout");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorSetLayout)>(*this, lib, "vkDestroyDescriptorSetLayout",
            SideEffects::worstDefault, "vkDestroyDescriptorSetLayout");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorPool)>(*this, lib, "vkCreateDescriptorPool",
            SideEffects::worstDefault, "vkCreateDescriptorPool");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorPool)>(*this, lib, "vkDestroyDescriptorPool",
            SideEffects::worstDefault, "vkDestroyDescriptorPool");
        addExtern<DAS_BIND_FUN(vkResetDescriptorPool)>(*this, lib, "vkResetDescriptorPool",
            SideEffects::worstDefault, "vkResetDescriptorPool");
        addExtern<DAS_BIND_FUN(vkAllocateDescriptorSets)>(*this, lib, "vkAllocateDescriptorSets",
            SideEffects::worstDefault, "vkAllocateDescriptorSets");
        addExtern<DAS_BIND_FUN(vkFreeDescriptorSets)>(*this, lib, "vkFreeDescriptorSets",
            SideEffects::worstDefault, "vkFreeDescriptorSets");
        addExtern<DAS_BIND_FUN(vkUpdateDescriptorSets)>(*this, lib, "vkUpdateDescriptorSets",
            SideEffects::worstDefault, "vkUpdateDescriptorSets");
        addExtern<DAS_BIND_FUN(vkCreateFramebuffer)>(*this, lib, "vkCreateFramebuffer",
            SideEffects::worstDefault, "vkCreateFramebuffer");
        addExtern<DAS_BIND_FUN(vkDestroyFramebuffer)>(*this, lib, "vkDestroyFramebuffer",
            SideEffects::worstDefault, "vkDestroyFramebuffer");
        addExtern<DAS_BIND_FUN(vkCreateRenderPass)>(*this, lib, "vkCreateRenderPass",
            SideEffects::worstDefault, "vkCreateRenderPass");
        addExtern<DAS_BIND_FUN(vkDestroyRenderPass)>(*this, lib, "vkDestroyRenderPass",
            SideEffects::worstDefault, "vkDestroyRenderPass");
        addExtern<DAS_BIND_FUN(vkGetRenderAreaGranularity)>(*this, lib, "vkGetRenderAreaGranularity",
            SideEffects::worstDefault, "vkGetRenderAreaGranularity");
        addExtern<DAS_BIND_FUN(vkCreateCommandPool)>(*this, lib, "vkCreateCommandPool",
            SideEffects::worstDefault, "vkCreateCommandPool");
        addExtern<DAS_BIND_FUN(vkDestroyCommandPool)>(*this, lib, "vkDestroyCommandPool",
            SideEffects::worstDefault, "vkDestroyCommandPool");
        addExtern<DAS_BIND_FUN(vkResetCommandPool)>(*this, lib, "vkResetCommandPool",
            SideEffects::worstDefault, "vkResetCommandPool");
        addExtern<DAS_BIND_FUN(vkAllocateCommandBuffers)>(*this, lib, "vkAllocateCommandBuffers",
            SideEffects::worstDefault, "vkAllocateCommandBuffers");
        addExtern<DAS_BIND_FUN(vkFreeCommandBuffers)>(*this, lib, "vkFreeCommandBuffers",
            SideEffects::worstDefault, "vkFreeCommandBuffers");
        addExtern<DAS_BIND_FUN(vkBeginCommandBuffer)>(*this, lib, "vkBeginCommandBuffer",
            SideEffects::worstDefault, "vkBeginCommandBuffer");
        addExtern<DAS_BIND_FUN(vkEndCommandBuffer)>(*this, lib, "vkEndCommandBuffer",
            SideEffects::worstDefault, "vkEndCommandBuffer");
        addExtern<DAS_BIND_FUN(vkResetCommandBuffer)>(*this, lib, "vkResetCommandBuffer",
            SideEffects::worstDefault, "vkResetCommandBuffer");
        addExtern<DAS_BIND_FUN(vkCmdBindPipeline)>(*this, lib, "vkCmdBindPipeline",
            SideEffects::worstDefault, "vkCmdBindPipeline");
        addExtern<DAS_BIND_FUN(vkCmdSetViewport)>(*this, lib, "vkCmdSetViewport",
            SideEffects::worstDefault, "vkCmdSetViewport");
        addExtern<DAS_BIND_FUN(vkCmdSetScissor)>(*this, lib, "vkCmdSetScissor",
            SideEffects::worstDefault, "vkCmdSetScissor");
        addExtern<DAS_BIND_FUN(vkCmdSetLineWidth)>(*this, lib, "vkCmdSetLineWidth",
            SideEffects::worstDefault, "vkCmdSetLineWidth");
        addExtern<DAS_BIND_FUN(vkCmdSetDepthBias)>(*this, lib, "vkCmdSetDepthBias",
            SideEffects::worstDefault, "vkCmdSetDepthBias");
        addExtern<DAS_BIND_FUN(vkCmdSetBlendConstants)>(*this, lib, "vkCmdSetBlendConstants",
            SideEffects::worstDefault, "vkCmdSetBlendConstants");
        addExtern<DAS_BIND_FUN(vkCmdSetDepthBounds)>(*this, lib, "vkCmdSetDepthBounds",
            SideEffects::worstDefault, "vkCmdSetDepthBounds");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilCompareMask)>(*this, lib, "vkCmdSetStencilCompareMask",
            SideEffects::worstDefault, "vkCmdSetStencilCompareMask");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilWriteMask)>(*this, lib, "vkCmdSetStencilWriteMask",
            SideEffects::worstDefault, "vkCmdSetStencilWriteMask");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilReference)>(*this, lib, "vkCmdSetStencilReference",
            SideEffects::worstDefault, "vkCmdSetStencilReference");
        addExtern<DAS_BIND_FUN(vkCmdBindDescriptorSets)>(*this, lib, "vkCmdBindDescriptorSets",
            SideEffects::worstDefault, "vkCmdBindDescriptorSets");
        addExtern<DAS_BIND_FUN(vkCmdBindIndexBuffer)>(*this, lib, "vkCmdBindIndexBuffer",
            SideEffects::worstDefault, "vkCmdBindIndexBuffer");
        addExtern<DAS_BIND_FUN(vkCmdBindVertexBuffers)>(*this, lib, "vkCmdBindVertexBuffers",
            SideEffects::worstDefault, "vkCmdBindVertexBuffers");
        addExtern<DAS_BIND_FUN(vkCmdDraw)>(*this, lib, "vkCmdDraw",
            SideEffects::worstDefault, "vkCmdDraw");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexed)>(*this, lib, "vkCmdDrawIndexed",
            SideEffects::worstDefault, "vkCmdDrawIndexed");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndirect)>(*this, lib, "vkCmdDrawIndirect",
            SideEffects::worstDefault, "vkCmdDrawIndirect");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirect)>(*this, lib, "vkCmdDrawIndexedIndirect",
            SideEffects::worstDefault, "vkCmdDrawIndexedIndirect");
        addExtern<DAS_BIND_FUN(vkCmdDispatch)>(*this, lib, "vkCmdDispatch",
            SideEffects::worstDefault, "vkCmdDispatch");
        addExtern<DAS_BIND_FUN(vkCmdDispatchIndirect)>(*this, lib, "vkCmdDispatchIndirect",
            SideEffects::worstDefault, "vkCmdDispatchIndirect");
        addExtern<DAS_BIND_FUN(vkCmdCopyBuffer)>(*this, lib, "vkCmdCopyBuffer",
            SideEffects::worstDefault, "vkCmdCopyBuffer");
        addExtern<DAS_BIND_FUN(vkCmdCopyImage)>(*this, lib, "vkCmdCopyImage",
            SideEffects::worstDefault, "vkCmdCopyImage");
        addExtern<DAS_BIND_FUN(vkCmdBlitImage)>(*this, lib, "vkCmdBlitImage",
            SideEffects::worstDefault, "vkCmdBlitImage");
        addExtern<DAS_BIND_FUN(vkCmdCopyBufferToImage)>(*this, lib, "vkCmdCopyBufferToImage",
            SideEffects::worstDefault, "vkCmdCopyBufferToImage");
        addExtern<DAS_BIND_FUN(vkCmdCopyImageToBuffer)>(*this, lib, "vkCmdCopyImageToBuffer",
            SideEffects::worstDefault, "vkCmdCopyImageToBuffer");
        addExtern<DAS_BIND_FUN(vkCmdUpdateBuffer)>(*this, lib, "vkCmdUpdateBuffer",
            SideEffects::worstDefault, "vkCmdUpdateBuffer");
        addExtern<DAS_BIND_FUN(vkCmdFillBuffer)>(*this, lib, "vkCmdFillBuffer",
            SideEffects::worstDefault, "vkCmdFillBuffer");
        addExtern<DAS_BIND_FUN(vkCmdClearColorImage)>(*this, lib, "vkCmdClearColorImage",
            SideEffects::worstDefault, "vkCmdClearColorImage");
        addExtern<DAS_BIND_FUN(vkCmdClearDepthStencilImage)>(*this, lib, "vkCmdClearDepthStencilImage",
            SideEffects::worstDefault, "vkCmdClearDepthStencilImage");
        addExtern<DAS_BIND_FUN(vkCmdClearAttachments)>(*this, lib, "vkCmdClearAttachments",
            SideEffects::worstDefault, "vkCmdClearAttachments");
        addExtern<DAS_BIND_FUN(vkCmdResolveImage)>(*this, lib, "vkCmdResolveImage",
            SideEffects::worstDefault, "vkCmdResolveImage");
        addExtern<DAS_BIND_FUN(vkCmdSetEvent)>(*this, lib, "vkCmdSetEvent",
            SideEffects::worstDefault, "vkCmdSetEvent");
        addExtern<DAS_BIND_FUN(vkCmdResetEvent)>(*this, lib, "vkCmdResetEvent",
            SideEffects::worstDefault, "vkCmdResetEvent");
        addExtern<DAS_BIND_FUN(vkCmdWaitEvents)>(*this, lib, "vkCmdWaitEvents",
            SideEffects::worstDefault, "vkCmdWaitEvents");
        addExtern<DAS_BIND_FUN(vkCmdPipelineBarrier)>(*this, lib, "vkCmdPipelineBarrier",
            SideEffects::worstDefault, "vkCmdPipelineBarrier");
        addExtern<DAS_BIND_FUN(vkCmdBeginQuery)>(*this, lib, "vkCmdBeginQuery",
            SideEffects::worstDefault, "vkCmdBeginQuery");
        addExtern<DAS_BIND_FUN(vkCmdEndQuery)>(*this, lib, "vkCmdEndQuery",
            SideEffects::worstDefault, "vkCmdEndQuery");
        addExtern<DAS_BIND_FUN(vkCmdResetQueryPool)>(*this, lib, "vkCmdResetQueryPool",
            SideEffects::worstDefault, "vkCmdResetQueryPool");
        addExtern<DAS_BIND_FUN(vkCmdWriteTimestamp)>(*this, lib, "vkCmdWriteTimestamp",
            SideEffects::worstDefault, "vkCmdWriteTimestamp");
        addExtern<DAS_BIND_FUN(vkCmdCopyQueryPoolResults)>(*this, lib, "vkCmdCopyQueryPoolResults",
            SideEffects::worstDefault, "vkCmdCopyQueryPoolResults");
        addExtern<DAS_BIND_FUN(vkCmdPushConstants)>(*this, lib, "vkCmdPushConstants",
            SideEffects::worstDefault, "vkCmdPushConstants");
        addExtern<DAS_BIND_FUN(vkCmdBeginRenderPass)>(*this, lib, "vkCmdBeginRenderPass",
            SideEffects::worstDefault, "vkCmdBeginRenderPass");
        addExtern<DAS_BIND_FUN(vkCmdNextSubpass)>(*this, lib, "vkCmdNextSubpass",
            SideEffects::worstDefault, "vkCmdNextSubpass");
        addExtern<DAS_BIND_FUN(vkCmdEndRenderPass)>(*this, lib, "vkCmdEndRenderPass",
            SideEffects::worstDefault, "vkCmdEndRenderPass");
        addExtern<DAS_BIND_FUN(vkCmdExecuteCommands)>(*this, lib, "vkCmdExecuteCommands",
            SideEffects::worstDefault, "vkCmdExecuteCommands");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceVersion)>(*this, lib, "vkEnumerateInstanceVersion",
            SideEffects::worstDefault, "vkEnumerateInstanceVersion");
        addExtern<DAS_BIND_FUN(vkBindBufferMemory2)>(*this, lib, "vkBindBufferMemory2",
            SideEffects::worstDefault, "vkBindBufferMemory2");
        addExtern<DAS_BIND_FUN(vkBindImageMemory2)>(*this, lib, "vkBindImageMemory2",
            SideEffects::worstDefault, "vkBindImageMemory2");
        addExtern<DAS_BIND_FUN(vkGetDeviceGroupPeerMemoryFeatures)>(*this, lib, "vkGetDeviceGroupPeerMemoryFeatures",
            SideEffects::worstDefault, "vkGetDeviceGroupPeerMemoryFeatures");
        addExtern<DAS_BIND_FUN(vkCmdSetDeviceMask)>(*this, lib, "vkCmdSetDeviceMask",
            SideEffects::worstDefault, "vkCmdSetDeviceMask");
        addExtern<DAS_BIND_FUN(vkCmdDispatchBase)>(*this, lib, "vkCmdDispatchBase",
            SideEffects::worstDefault, "vkCmdDispatchBase");
        addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDeviceGroups)>(*this, lib, "vkEnumeratePhysicalDeviceGroups",
            SideEffects::worstDefault, "vkEnumeratePhysicalDeviceGroups");
        addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements2)>(*this, lib, "vkGetImageMemoryRequirements2",
            SideEffects::worstDefault, "vkGetImageMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements2)>(*this, lib, "vkGetBufferMemoryRequirements2",
            SideEffects::worstDefault, "vkGetBufferMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements2)>(*this, lib, "vkGetImageSparseMemoryRequirements2",
            SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures2)>(*this, lib, "vkGetPhysicalDeviceFeatures2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties2)>(*this, lib, "vkGetPhysicalDeviceProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties2)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties2)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties2");
        addExtern<DAS_BIND_FUN(vkTrimCommandPool)>(*this, lib, "vkTrimCommandPool",
            SideEffects::worstDefault, "vkTrimCommandPool");
        addExtern<DAS_BIND_FUN(vkGetDeviceQueue2)>(*this, lib, "vkGetDeviceQueue2",
            SideEffects::worstDefault, "vkGetDeviceQueue2");
        addExtern<DAS_BIND_FUN(vkCreateSamplerYcbcrConversion)>(*this, lib, "vkCreateSamplerYcbcrConversion",
            SideEffects::worstDefault, "vkCreateSamplerYcbcrConversion");
        addExtern<DAS_BIND_FUN(vkDestroySamplerYcbcrConversion)>(*this, lib, "vkDestroySamplerYcbcrConversion",
            SideEffects::worstDefault, "vkDestroySamplerYcbcrConversion");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorUpdateTemplate)>(*this, lib, "vkCreateDescriptorUpdateTemplate",
            SideEffects::worstDefault, "vkCreateDescriptorUpdateTemplate");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorUpdateTemplate)>(*this, lib, "vkDestroyDescriptorUpdateTemplate",
            SideEffects::worstDefault, "vkDestroyDescriptorUpdateTemplate");
        addExtern<DAS_BIND_FUN(vkUpdateDescriptorSetWithTemplate)>(*this, lib, "vkUpdateDescriptorSetWithTemplate",
            SideEffects::worstDefault, "vkUpdateDescriptorSetWithTemplate");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalBufferProperties)>(*this, lib, "vkGetPhysicalDeviceExternalBufferProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalBufferProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalFenceProperties)>(*this, lib, "vkGetPhysicalDeviceExternalFenceProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalFenceProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalSemaphoreProperties)>(*this, lib, "vkGetPhysicalDeviceExternalSemaphoreProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalSemaphoreProperties");
        addExtern<DAS_BIND_FUN(vkGetDescriptorSetLayoutSupport)>(*this, lib, "vkGetDescriptorSetLayoutSupport",
            SideEffects::worstDefault, "vkGetDescriptorSetLayoutSupport");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndirectCount)>(*this, lib, "vkCmdDrawIndirectCount",
            SideEffects::worstDefault, "vkCmdDrawIndirectCount");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirectCount)>(*this, lib, "vkCmdDrawIndexedIndirectCount",
            SideEffects::worstDefault, "vkCmdDrawIndexedIndirectCount");
        addExtern<DAS_BIND_FUN(vkCreateRenderPass2)>(*this, lib, "vkCreateRenderPass2",
            SideEffects::worstDefault, "vkCreateRenderPass2");
        addExtern<DAS_BIND_FUN(vkCmdBeginRenderPass2)>(*this, lib, "vkCmdBeginRenderPass2",
            SideEffects::worstDefault, "vkCmdBeginRenderPass2");
        addExtern<DAS_BIND_FUN(vkCmdNextSubpass2)>(*this, lib, "vkCmdNextSubpass2",
            SideEffects::worstDefault, "vkCmdNextSubpass2");
        addExtern<DAS_BIND_FUN(vkCmdEndRenderPass2)>(*this, lib, "vkCmdEndRenderPass2",
            SideEffects::worstDefault, "vkCmdEndRenderPass2");
        addExtern<DAS_BIND_FUN(vkResetQueryPool)>(*this, lib, "vkResetQueryPool",
            SideEffects::worstDefault, "vkResetQueryPool");
        addExtern<DAS_BIND_FUN(vkGetSemaphoreCounterValue)>(*this, lib, "vkGetSemaphoreCounterValue",
            SideEffects::worstDefault, "vkGetSemaphoreCounterValue");
        addExtern<DAS_BIND_FUN(vkWaitSemaphores)>(*this, lib, "vkWaitSemaphores",
            SideEffects::worstDefault, "vkWaitSemaphores");
        addExtern<DAS_BIND_FUN(vkSignalSemaphore)>(*this, lib, "vkSignalSemaphore",
            SideEffects::worstDefault, "vkSignalSemaphore");
        addExtern<DAS_BIND_FUN(vkGetBufferDeviceAddress)>(*this, lib, "vkGetBufferDeviceAddress",
            SideEffects::worstDefault, "vkGetBufferDeviceAddress");
        addExtern<DAS_BIND_FUN(vkGetBufferOpaqueCaptureAddress)>(*this, lib, "vkGetBufferOpaqueCaptureAddress",
            SideEffects::worstDefault, "vkGetBufferOpaqueCaptureAddress");
        addExtern<DAS_BIND_FUN(vkGetDeviceMemoryOpaqueCaptureAddress)>(*this, lib, "vkGetDeviceMemoryOpaqueCaptureAddress",
            SideEffects::worstDefault, "vkGetDeviceMemoryOpaqueCaptureAddress");
        addExtern<DAS_BIND_FUN(vkDestroySurfaceKHR)>(*this, lib, "vkDestroySurfaceKHR",
            SideEffects::worstDefault, "vkDestroySurfaceKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceSupportKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceSupportKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceSupportKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceFormatsKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceFormatsKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceFormatsKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfacePresentModesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfacePresentModesKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfacePresentModesKHR");
        addExtern<DAS_BIND_FUN(vkCreateSwapchainKHR)>(*this, lib, "vkCreateSwapchainKHR",
            SideEffects::worstDefault, "vkCreateSwapchainKHR");
        addExtern<DAS_BIND_FUN(vkDestroySwapchainKHR)>(*this, lib, "vkDestroySwapchainKHR",
            SideEffects::worstDefault, "vkDestroySwapchainKHR");
        addExtern<DAS_BIND_FUN(vkGetSwapchainImagesKHR)>(*this, lib, "vkGetSwapchainImagesKHR",
            SideEffects::worstDefault, "vkGetSwapchainImagesKHR");
        addExtern<DAS_BIND_FUN(vkAcquireNextImageKHR)>(*this, lib, "vkAcquireNextImageKHR",
            SideEffects::worstDefault, "vkAcquireNextImageKHR");
        addExtern<DAS_BIND_FUN(vkQueuePresentKHR)>(*this, lib, "vkQueuePresentKHR",
            SideEffects::worstDefault, "vkQueuePresentKHR");
        addExtern<DAS_BIND_FUN(vkCreateDebugUtilsMessengerEXT)>(*this, lib, "vkCreateDebugUtilsMessengerEXT",
            SideEffects::worstDefault, "vkCreateDebugUtilsMessengerEXT");
        addExtern<DAS_BIND_FUN(vkDestroyDebugUtilsMessengerEXT)>(*this, lib, "vkDestroyDebugUtilsMessengerEXT",
            SideEffects::worstDefault, "vkDestroyDebugUtilsMessengerEXT");
        addExtern<DAS_BIND_FUN(glfwInit)>(*this, lib, "glfwInit",
            SideEffects::worstDefault, "glfwInit");
        addExtern<DAS_BIND_FUN(glfwTerminate)>(*this, lib, "glfwTerminate",
            SideEffects::worstDefault, "glfwTerminate");
        addExtern<DAS_BIND_FUN(glfwInitHint)>(*this, lib, "glfwInitHint",
            SideEffects::worstDefault, "glfwInitHint");
        addExtern<DAS_BIND_FUN(glfwGetVersion)>(*this, lib, "glfwGetVersion",
            SideEffects::worstDefault, "glfwGetVersion");
        addExtern<DAS_BIND_FUN(glfwGetVersionString)>(*this, lib, "glfwGetVersionString",
            SideEffects::worstDefault, "glfwGetVersionString");
        addExtern<DAS_BIND_FUN(glfwGetError)>(*this, lib, "glfwGetError",
            SideEffects::worstDefault, "glfwGetError");
        addExtern<DAS_BIND_FUN(glfwGetMonitors)>(*this, lib, "glfwGetMonitors",
            SideEffects::worstDefault, "glfwGetMonitors");
        addExtern<DAS_BIND_FUN(glfwGetPrimaryMonitor)>(*this, lib, "glfwGetPrimaryMonitor",
            SideEffects::worstDefault, "glfwGetPrimaryMonitor");
        addExtern<DAS_BIND_FUN(glfwGetMonitorPos)>(*this, lib, "glfwGetMonitorPos",
            SideEffects::worstDefault, "glfwGetMonitorPos");
        addExtern<DAS_BIND_FUN(glfwGetMonitorWorkarea)>(*this, lib, "glfwGetMonitorWorkarea",
            SideEffects::worstDefault, "glfwGetMonitorWorkarea");
        addExtern<DAS_BIND_FUN(glfwGetMonitorPhysicalSize)>(*this, lib, "glfwGetMonitorPhysicalSize",
            SideEffects::worstDefault, "glfwGetMonitorPhysicalSize");
        addExtern<DAS_BIND_FUN(glfwGetMonitorContentScale)>(*this, lib, "glfwGetMonitorContentScale",
            SideEffects::worstDefault, "glfwGetMonitorContentScale");
        addExtern<DAS_BIND_FUN(glfwGetMonitorName)>(*this, lib, "glfwGetMonitorName",
            SideEffects::worstDefault, "glfwGetMonitorName");
        addExtern<DAS_BIND_FUN(glfwSetMonitorUserPointer)>(*this, lib, "glfwSetMonitorUserPointer",
            SideEffects::worstDefault, "glfwSetMonitorUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetMonitorUserPointer)>(*this, lib, "glfwGetMonitorUserPointer",
            SideEffects::worstDefault, "glfwGetMonitorUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetVideoModes)>(*this, lib, "glfwGetVideoModes",
            SideEffects::worstDefault, "glfwGetVideoModes");
        addExtern<DAS_BIND_FUN(glfwGetVideoMode)>(*this, lib, "glfwGetVideoMode",
            SideEffects::worstDefault, "glfwGetVideoMode");
        addExtern<DAS_BIND_FUN(glfwSetGamma)>(*this, lib, "glfwSetGamma",
            SideEffects::worstDefault, "glfwSetGamma");
        addExtern<DAS_BIND_FUN(glfwGetGammaRamp)>(*this, lib, "glfwGetGammaRamp",
            SideEffects::worstDefault, "glfwGetGammaRamp");
        addExtern<DAS_BIND_FUN(glfwSetGammaRamp)>(*this, lib, "glfwSetGammaRamp",
            SideEffects::worstDefault, "glfwSetGammaRamp");
        addExtern<DAS_BIND_FUN(glfwDefaultWindowHints)>(*this, lib, "glfwDefaultWindowHints",
            SideEffects::worstDefault, "glfwDefaultWindowHints");
        addExtern<DAS_BIND_FUN(glfwWindowHint)>(*this, lib, "glfwWindowHint",
            SideEffects::worstDefault, "glfwWindowHint");
        addExtern<DAS_BIND_FUN(glfwWindowHintString)>(*this, lib, "glfwWindowHintString",
            SideEffects::worstDefault, "glfwWindowHintString");
        addExtern<DAS_BIND_FUN(glfwWindowShouldClose)>(*this, lib, "glfwWindowShouldClose",
            SideEffects::worstDefault, "glfwWindowShouldClose");
        addExtern<DAS_BIND_FUN(glfwSetWindowShouldClose)>(*this, lib, "glfwSetWindowShouldClose",
            SideEffects::worstDefault, "glfwSetWindowShouldClose");
        addExtern<DAS_BIND_FUN(glfwSetWindowTitle)>(*this, lib, "glfwSetWindowTitle",
            SideEffects::worstDefault, "glfwSetWindowTitle");
        addExtern<DAS_BIND_FUN(glfwSetWindowIcon)>(*this, lib, "glfwSetWindowIcon",
            SideEffects::worstDefault, "glfwSetWindowIcon");
        addExtern<DAS_BIND_FUN(glfwGetWindowPos)>(*this, lib, "glfwGetWindowPos",
            SideEffects::worstDefault, "glfwGetWindowPos");
        addExtern<DAS_BIND_FUN(glfwSetWindowPos)>(*this, lib, "glfwSetWindowPos",
            SideEffects::worstDefault, "glfwSetWindowPos");
        addExtern<DAS_BIND_FUN(glfwGetWindowSize)>(*this, lib, "glfwGetWindowSize",
            SideEffects::worstDefault, "glfwGetWindowSize");
        addExtern<DAS_BIND_FUN(glfwSetWindowSizeLimits)>(*this, lib, "glfwSetWindowSizeLimits",
            SideEffects::worstDefault, "glfwSetWindowSizeLimits");
        addExtern<DAS_BIND_FUN(glfwSetWindowAspectRatio)>(*this, lib, "glfwSetWindowAspectRatio",
            SideEffects::worstDefault, "glfwSetWindowAspectRatio");
        addExtern<DAS_BIND_FUN(glfwSetWindowSize)>(*this, lib, "glfwSetWindowSize",
            SideEffects::worstDefault, "glfwSetWindowSize");
        addExtern<DAS_BIND_FUN(glfwGetFramebufferSize)>(*this, lib, "glfwGetFramebufferSize",
            SideEffects::worstDefault, "glfwGetFramebufferSize");
        addExtern<DAS_BIND_FUN(glfwGetWindowFrameSize)>(*this, lib, "glfwGetWindowFrameSize",
            SideEffects::worstDefault, "glfwGetWindowFrameSize");
        addExtern<DAS_BIND_FUN(glfwGetWindowContentScale)>(*this, lib, "glfwGetWindowContentScale",
            SideEffects::worstDefault, "glfwGetWindowContentScale");
        addExtern<DAS_BIND_FUN(glfwGetWindowOpacity)>(*this, lib, "glfwGetWindowOpacity",
            SideEffects::worstDefault, "glfwGetWindowOpacity");
        addExtern<DAS_BIND_FUN(glfwSetWindowOpacity)>(*this, lib, "glfwSetWindowOpacity",
            SideEffects::worstDefault, "glfwSetWindowOpacity");
        addExtern<DAS_BIND_FUN(glfwIconifyWindow)>(*this, lib, "glfwIconifyWindow",
            SideEffects::worstDefault, "glfwIconifyWindow");
        addExtern<DAS_BIND_FUN(glfwRestoreWindow)>(*this, lib, "glfwRestoreWindow",
            SideEffects::worstDefault, "glfwRestoreWindow");
        addExtern<DAS_BIND_FUN(glfwMaximizeWindow)>(*this, lib, "glfwMaximizeWindow",
            SideEffects::worstDefault, "glfwMaximizeWindow");
        addExtern<DAS_BIND_FUN(glfwShowWindow)>(*this, lib, "glfwShowWindow",
            SideEffects::worstDefault, "glfwShowWindow");
        addExtern<DAS_BIND_FUN(glfwHideWindow)>(*this, lib, "glfwHideWindow",
            SideEffects::worstDefault, "glfwHideWindow");
        addExtern<DAS_BIND_FUN(glfwFocusWindow)>(*this, lib, "glfwFocusWindow",
            SideEffects::worstDefault, "glfwFocusWindow");
        addExtern<DAS_BIND_FUN(glfwRequestWindowAttention)>(*this, lib, "glfwRequestWindowAttention",
            SideEffects::worstDefault, "glfwRequestWindowAttention");
        addExtern<DAS_BIND_FUN(glfwGetWindowMonitor)>(*this, lib, "glfwGetWindowMonitor",
            SideEffects::worstDefault, "glfwGetWindowMonitor");
        addExtern<DAS_BIND_FUN(glfwSetWindowMonitor)>(*this, lib, "glfwSetWindowMonitor",
            SideEffects::worstDefault, "glfwSetWindowMonitor");
        addExtern<DAS_BIND_FUN(glfwGetWindowAttrib)>(*this, lib, "glfwGetWindowAttrib",
            SideEffects::worstDefault, "glfwGetWindowAttrib");
        addExtern<DAS_BIND_FUN(glfwSetWindowAttrib)>(*this, lib, "glfwSetWindowAttrib",
            SideEffects::worstDefault, "glfwSetWindowAttrib");
        addExtern<DAS_BIND_FUN(glfwGetWindowUserPointer)>(*this, lib, "glfwGetWindowUserPointer",
            SideEffects::worstDefault, "glfwGetWindowUserPointer");
        addExtern<DAS_BIND_FUN(glfwPollEvents)>(*this, lib, "glfwPollEvents",
            SideEffects::worstDefault, "glfwPollEvents");
        addExtern<DAS_BIND_FUN(glfwWaitEvents)>(*this, lib, "glfwWaitEvents",
            SideEffects::worstDefault, "glfwWaitEvents");
        addExtern<DAS_BIND_FUN(glfwWaitEventsTimeout)>(*this, lib, "glfwWaitEventsTimeout",
            SideEffects::worstDefault, "glfwWaitEventsTimeout");
        addExtern<DAS_BIND_FUN(glfwPostEmptyEvent)>(*this, lib, "glfwPostEmptyEvent",
            SideEffects::worstDefault, "glfwPostEmptyEvent");
        addExtern<DAS_BIND_FUN(glfwGetInputMode)>(*this, lib, "glfwGetInputMode",
            SideEffects::worstDefault, "glfwGetInputMode");
        addExtern<DAS_BIND_FUN(glfwSetInputMode)>(*this, lib, "glfwSetInputMode",
            SideEffects::worstDefault, "glfwSetInputMode");
        addExtern<DAS_BIND_FUN(glfwRawMouseMotionSupported)>(*this, lib, "glfwRawMouseMotionSupported",
            SideEffects::worstDefault, "glfwRawMouseMotionSupported");
        addExtern<DAS_BIND_FUN(glfwGetKeyName)>(*this, lib, "glfwGetKeyName",
            SideEffects::worstDefault, "glfwGetKeyName");
        addExtern<DAS_BIND_FUN(glfwGetKeyScancode)>(*this, lib, "glfwGetKeyScancode",
            SideEffects::worstDefault, "glfwGetKeyScancode");
        addExtern<DAS_BIND_FUN(glfwGetKey)>(*this, lib, "glfwGetKey",
            SideEffects::worstDefault, "glfwGetKey");
        addExtern<DAS_BIND_FUN(glfwGetMouseButton)>(*this, lib, "glfwGetMouseButton",
            SideEffects::worstDefault, "glfwGetMouseButton");
        addExtern<DAS_BIND_FUN(glfwGetCursorPos)>(*this, lib, "glfwGetCursorPos",
            SideEffects::worstDefault, "glfwGetCursorPos");
        addExtern<DAS_BIND_FUN(glfwSetCursorPos)>(*this, lib, "glfwSetCursorPos",
            SideEffects::worstDefault, "glfwSetCursorPos");
        addExtern<DAS_BIND_FUN(glfwCreateCursor)>(*this, lib, "glfwCreateCursor",
            SideEffects::worstDefault, "glfwCreateCursor");
        addExtern<DAS_BIND_FUN(glfwCreateStandardCursor)>(*this, lib, "glfwCreateStandardCursor",
            SideEffects::worstDefault, "glfwCreateStandardCursor");
        addExtern<DAS_BIND_FUN(glfwDestroyCursor)>(*this, lib, "glfwDestroyCursor",
            SideEffects::worstDefault, "glfwDestroyCursor");
        addExtern<DAS_BIND_FUN(glfwSetCursor)>(*this, lib, "glfwSetCursor",
            SideEffects::worstDefault, "glfwSetCursor");
        addExtern<DAS_BIND_FUN(glfwJoystickPresent)>(*this, lib, "glfwJoystickPresent",
            SideEffects::worstDefault, "glfwJoystickPresent");
        addExtern<DAS_BIND_FUN(glfwGetJoystickAxes)>(*this, lib, "glfwGetJoystickAxes",
            SideEffects::worstDefault, "glfwGetJoystickAxes");
        addExtern<DAS_BIND_FUN(glfwGetJoystickButtons)>(*this, lib, "glfwGetJoystickButtons",
            SideEffects::worstDefault, "glfwGetJoystickButtons");
        addExtern<DAS_BIND_FUN(glfwGetJoystickHats)>(*this, lib, "glfwGetJoystickHats",
            SideEffects::worstDefault, "glfwGetJoystickHats");
        addExtern<DAS_BIND_FUN(glfwGetJoystickName)>(*this, lib, "glfwGetJoystickName",
            SideEffects::worstDefault, "glfwGetJoystickName");
        addExtern<DAS_BIND_FUN(glfwGetJoystickGUID)>(*this, lib, "glfwGetJoystickGUID",
            SideEffects::worstDefault, "glfwGetJoystickGUID");
        addExtern<DAS_BIND_FUN(glfwSetJoystickUserPointer)>(*this, lib, "glfwSetJoystickUserPointer",
            SideEffects::worstDefault, "glfwSetJoystickUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetJoystickUserPointer)>(*this, lib, "glfwGetJoystickUserPointer",
            SideEffects::worstDefault, "glfwGetJoystickUserPointer");
        addExtern<DAS_BIND_FUN(glfwJoystickIsGamepad)>(*this, lib, "glfwJoystickIsGamepad",
            SideEffects::worstDefault, "glfwJoystickIsGamepad");
        addExtern<DAS_BIND_FUN(glfwUpdateGamepadMappings)>(*this, lib, "glfwUpdateGamepadMappings",
            SideEffects::worstDefault, "glfwUpdateGamepadMappings");
        addExtern<DAS_BIND_FUN(glfwGetGamepadName)>(*this, lib, "glfwGetGamepadName",
            SideEffects::worstDefault, "glfwGetGamepadName");
        addExtern<DAS_BIND_FUN(glfwGetGamepadState)>(*this, lib, "glfwGetGamepadState",
            SideEffects::worstDefault, "glfwGetGamepadState");
        addExtern<DAS_BIND_FUN(glfwSetClipboardString)>(*this, lib, "glfwSetClipboardString",
            SideEffects::worstDefault, "glfwSetClipboardString");
        addExtern<DAS_BIND_FUN(glfwGetClipboardString)>(*this, lib, "glfwGetClipboardString",
            SideEffects::worstDefault, "glfwGetClipboardString");
        addExtern<DAS_BIND_FUN(glfwGetTime)>(*this, lib, "glfwGetTime",
            SideEffects::worstDefault, "glfwGetTime");
        addExtern<DAS_BIND_FUN(glfwSetTime)>(*this, lib, "glfwSetTime",
            SideEffects::worstDefault, "glfwSetTime");
        addExtern<DAS_BIND_FUN(glfwGetTimerValue)>(*this, lib, "glfwGetTimerValue",
            SideEffects::worstDefault, "glfwGetTimerValue");
        addExtern<DAS_BIND_FUN(glfwGetTimerFrequency)>(*this, lib, "glfwGetTimerFrequency",
            SideEffects::worstDefault, "glfwGetTimerFrequency");
        addExtern<DAS_BIND_FUN(glfwMakeContextCurrent)>(*this, lib, "glfwMakeContextCurrent",
            SideEffects::worstDefault, "glfwMakeContextCurrent");
        addExtern<DAS_BIND_FUN(glfwGetCurrentContext)>(*this, lib, "glfwGetCurrentContext",
            SideEffects::worstDefault, "glfwGetCurrentContext");
        addExtern<DAS_BIND_FUN(glfwSwapBuffers)>(*this, lib, "glfwSwapBuffers",
            SideEffects::worstDefault, "glfwSwapBuffers");
        addExtern<DAS_BIND_FUN(glfwSwapInterval)>(*this, lib, "glfwSwapInterval",
            SideEffects::worstDefault, "glfwSwapInterval");
        addExtern<DAS_BIND_FUN(glfwExtensionSupported)>(*this, lib, "glfwExtensionSupported",
            SideEffects::worstDefault, "glfwExtensionSupported");
        addExtern<DAS_BIND_FUN(glfwVulkanSupported)>(*this, lib, "glfwVulkanSupported",
            SideEffects::worstDefault, "glfwVulkanSupported");
        addExtern<DAS_BIND_FUN(glfwGetRequiredInstanceExtensions)>(*this, lib, "glfwGetRequiredInstanceExtensions",
            SideEffects::worstDefault, "glfwGetRequiredInstanceExtensions");
        addExtern<DAS_BIND_FUN(glfwGetPhysicalDevicePresentationSupport)>(*this, lib, "glfwGetPhysicalDevicePresentationSupport",
            SideEffects::worstDefault, "glfwGetPhysicalDevicePresentationSupport");
        addExtern<DAS_BIND_FUN(glfwCreateWindowSurface)>(*this, lib, "glfwCreateWindowSurface",
            SideEffects::worstDefault, "glfwCreateWindowSurface");

        //
        // macro constants
        //

        addConstant(*this,"GLFW_VERSION_MAJOR",3);
        addConstant(*this,"GLFW_VERSION_MINOR",3);
        addConstant(*this,"GLFW_VERSION_REVISION",2);
        addConstant(*this,"GLFW_TRUE",1);
        addConstant(*this,"GLFW_FALSE",0);
        addConstant(*this,"GLFW_RELEASE",0);
        addConstant(*this,"GLFW_PRESS",1);
        addConstant(*this,"GLFW_REPEAT",2);
        addConstant(*this,"GLFW_HAT_CENTERED",0);
        addConstant(*this,"GLFW_HAT_UP",1);
        addConstant(*this,"GLFW_HAT_RIGHT",2);
        addConstant(*this,"GLFW_HAT_DOWN",4);
        addConstant(*this,"GLFW_HAT_LEFT",8);
        addConstant(*this,"GLFW_HAT_RIGHT_UP",(GLFW_HAT_RIGHT | GLFW_HAT_UP));
        addConstant(*this,"GLFW_HAT_RIGHT_DOWN",(GLFW_HAT_RIGHT | GLFW_HAT_DOWN));
        addConstant(*this,"GLFW_HAT_LEFT_UP",(GLFW_HAT_LEFT  | GLFW_HAT_UP));
        addConstant(*this,"GLFW_HAT_LEFT_DOWN",(GLFW_HAT_LEFT  | GLFW_HAT_DOWN));
        addConstant(*this,"GLFW_KEY_UNKNOWN",-1);
        addConstant(*this,"GLFW_KEY_SPACE",32);
        addConstant(*this,"GLFW_KEY_APOSTROPHE",39  /* ' */);
        addConstant(*this,"GLFW_KEY_COMMA",44  /* , */);
        addConstant(*this,"GLFW_KEY_MINUS",45  /* - */);
        addConstant(*this,"GLFW_KEY_PERIOD",46  /* . */);
        addConstant(*this,"GLFW_KEY_SLASH",47  /* / */);
        addConstant(*this,"GLFW_KEY_0",48);
        addConstant(*this,"GLFW_KEY_1",49);
        addConstant(*this,"GLFW_KEY_2",50);
        addConstant(*this,"GLFW_KEY_3",51);
        addConstant(*this,"GLFW_KEY_4",52);
        addConstant(*this,"GLFW_KEY_5",53);
        addConstant(*this,"GLFW_KEY_6",54);
        addConstant(*this,"GLFW_KEY_7",55);
        addConstant(*this,"GLFW_KEY_8",56);
        addConstant(*this,"GLFW_KEY_9",57);
        addConstant(*this,"GLFW_KEY_SEMICOLON",59  /* ; */);
        addConstant(*this,"GLFW_KEY_EQUAL",61  /* = */);
        addConstant(*this,"GLFW_KEY_A",65);
        addConstant(*this,"GLFW_KEY_B",66);
        addConstant(*this,"GLFW_KEY_C",67);
        addConstant(*this,"GLFW_KEY_D",68);
        addConstant(*this,"GLFW_KEY_E",69);
        addConstant(*this,"GLFW_KEY_F",70);
        addConstant(*this,"GLFW_KEY_G",71);
        addConstant(*this,"GLFW_KEY_H",72);
        addConstant(*this,"GLFW_KEY_I",73);
        addConstant(*this,"GLFW_KEY_J",74);
        addConstant(*this,"GLFW_KEY_K",75);
        addConstant(*this,"GLFW_KEY_L",76);
        addConstant(*this,"GLFW_KEY_M",77);
        addConstant(*this,"GLFW_KEY_N",78);
        addConstant(*this,"GLFW_KEY_O",79);
        addConstant(*this,"GLFW_KEY_P",80);
        addConstant(*this,"GLFW_KEY_Q",81);
        addConstant(*this,"GLFW_KEY_R",82);
        addConstant(*this,"GLFW_KEY_S",83);
        addConstant(*this,"GLFW_KEY_T",84);
        addConstant(*this,"GLFW_KEY_U",85);
        addConstant(*this,"GLFW_KEY_V",86);
        addConstant(*this,"GLFW_KEY_W",87);
        addConstant(*this,"GLFW_KEY_X",88);
        addConstant(*this,"GLFW_KEY_Y",89);
        addConstant(*this,"GLFW_KEY_Z",90);
        addConstant(*this,"GLFW_KEY_LEFT_BRACKET",91  /* [ */);
        addConstant(*this,"GLFW_KEY_BACKSLASH",92  /* \ */);
        addConstant(*this,"GLFW_KEY_RIGHT_BRACKET",93  /* ] */);
        addConstant(*this,"GLFW_KEY_GRAVE_ACCENT",96  /* ` */);
        addConstant(*this,"GLFW_KEY_WORLD_1",161 /* non-US #1 */);
        addConstant(*this,"GLFW_KEY_WORLD_2",162 /* non-US #2 */);
        addConstant(*this,"GLFW_KEY_ESCAPE",256);
        addConstant(*this,"GLFW_KEY_ENTER",257);
        addConstant(*this,"GLFW_KEY_TAB",258);
        addConstant(*this,"GLFW_KEY_BACKSPACE",259);
        addConstant(*this,"GLFW_KEY_INSERT",260);
        addConstant(*this,"GLFW_KEY_DELETE",261);
        addConstant(*this,"GLFW_KEY_RIGHT",262);
        addConstant(*this,"GLFW_KEY_LEFT",263);
        addConstant(*this,"GLFW_KEY_DOWN",264);
        addConstant(*this,"GLFW_KEY_UP",265);
        addConstant(*this,"GLFW_KEY_PAGE_UP",266);
        addConstant(*this,"GLFW_KEY_PAGE_DOWN",267);
        addConstant(*this,"GLFW_KEY_HOME",268);
        addConstant(*this,"GLFW_KEY_END",269);
        addConstant(*this,"GLFW_KEY_CAPS_LOCK",280);
        addConstant(*this,"GLFW_KEY_SCROLL_LOCK",281);
        addConstant(*this,"GLFW_KEY_NUM_LOCK",282);
        addConstant(*this,"GLFW_KEY_PRINT_SCREEN",283);
        addConstant(*this,"GLFW_KEY_PAUSE",284);
        addConstant(*this,"GLFW_KEY_F1",290);
        addConstant(*this,"GLFW_KEY_F2",291);
        addConstant(*this,"GLFW_KEY_F3",292);
        addConstant(*this,"GLFW_KEY_F4",293);
        addConstant(*this,"GLFW_KEY_F5",294);
        addConstant(*this,"GLFW_KEY_F6",295);
        addConstant(*this,"GLFW_KEY_F7",296);
        addConstant(*this,"GLFW_KEY_F8",297);
        addConstant(*this,"GLFW_KEY_F9",298);
        addConstant(*this,"GLFW_KEY_F10",299);
        addConstant(*this,"GLFW_KEY_F11",300);
        addConstant(*this,"GLFW_KEY_F12",301);
        addConstant(*this,"GLFW_KEY_F13",302);
        addConstant(*this,"GLFW_KEY_F14",303);
        addConstant(*this,"GLFW_KEY_F15",304);
        addConstant(*this,"GLFW_KEY_F16",305);
        addConstant(*this,"GLFW_KEY_F17",306);
        addConstant(*this,"GLFW_KEY_F18",307);
        addConstant(*this,"GLFW_KEY_F19",308);
        addConstant(*this,"GLFW_KEY_F20",309);
        addConstant(*this,"GLFW_KEY_F21",310);
        addConstant(*this,"GLFW_KEY_F22",311);
        addConstant(*this,"GLFW_KEY_F23",312);
        addConstant(*this,"GLFW_KEY_F24",313);
        addConstant(*this,"GLFW_KEY_F25",314);
        addConstant(*this,"GLFW_KEY_KP_0",320);
        addConstant(*this,"GLFW_KEY_KP_1",321);
        addConstant(*this,"GLFW_KEY_KP_2",322);
        addConstant(*this,"GLFW_KEY_KP_3",323);
        addConstant(*this,"GLFW_KEY_KP_4",324);
        addConstant(*this,"GLFW_KEY_KP_5",325);
        addConstant(*this,"GLFW_KEY_KP_6",326);
        addConstant(*this,"GLFW_KEY_KP_7",327);
        addConstant(*this,"GLFW_KEY_KP_8",328);
        addConstant(*this,"GLFW_KEY_KP_9",329);
        addConstant(*this,"GLFW_KEY_KP_DECIMAL",330);
        addConstant(*this,"GLFW_KEY_KP_DIVIDE",331);
        addConstant(*this,"GLFW_KEY_KP_MULTIPLY",332);
        addConstant(*this,"GLFW_KEY_KP_SUBTRACT",333);
        addConstant(*this,"GLFW_KEY_KP_ADD",334);
        addConstant(*this,"GLFW_KEY_KP_ENTER",335);
        addConstant(*this,"GLFW_KEY_KP_EQUAL",336);
        addConstant(*this,"GLFW_KEY_LEFT_SHIFT",340);
        addConstant(*this,"GLFW_KEY_LEFT_CONTROL",341);
        addConstant(*this,"GLFW_KEY_LEFT_ALT",342);
        addConstant(*this,"GLFW_KEY_LEFT_SUPER",343);
        addConstant(*this,"GLFW_KEY_RIGHT_SHIFT",344);
        addConstant(*this,"GLFW_KEY_RIGHT_CONTROL",345);
        addConstant(*this,"GLFW_KEY_RIGHT_ALT",346);
        addConstant(*this,"GLFW_KEY_RIGHT_SUPER",347);
        addConstant(*this,"GLFW_KEY_MENU",348);
        addConstant(*this,"GLFW_KEY_LAST",GLFW_KEY_MENU);
        addConstant(*this,"GLFW_MOD_SHIFT",0x0001);
        addConstant(*this,"GLFW_MOD_CONTROL",0x0002);
        addConstant(*this,"GLFW_MOD_ALT",0x0004);
        addConstant(*this,"GLFW_MOD_SUPER",0x0008);
        addConstant(*this,"GLFW_MOD_CAPS_LOCK",0x0010);
        addConstant(*this,"GLFW_MOD_NUM_LOCK",0x0020);
        addConstant(*this,"GLFW_MOUSE_BUTTON_1",0);
        addConstant(*this,"GLFW_MOUSE_BUTTON_2",1);
        addConstant(*this,"GLFW_MOUSE_BUTTON_3",2);
        addConstant(*this,"GLFW_MOUSE_BUTTON_4",3);
        addConstant(*this,"GLFW_MOUSE_BUTTON_5",4);
        addConstant(*this,"GLFW_MOUSE_BUTTON_6",5);
        addConstant(*this,"GLFW_MOUSE_BUTTON_7",6);
        addConstant(*this,"GLFW_MOUSE_BUTTON_8",7);
        addConstant(*this,"GLFW_MOUSE_BUTTON_LAST",GLFW_MOUSE_BUTTON_8);
        addConstant(*this,"GLFW_MOUSE_BUTTON_LEFT",GLFW_MOUSE_BUTTON_1);
        addConstant(*this,"GLFW_MOUSE_BUTTON_RIGHT",GLFW_MOUSE_BUTTON_2);
        addConstant(*this,"GLFW_MOUSE_BUTTON_MIDDLE",GLFW_MOUSE_BUTTON_3);
        addConstant(*this,"GLFW_JOYSTICK_1",0);
        addConstant(*this,"GLFW_JOYSTICK_2",1);
        addConstant(*this,"GLFW_JOYSTICK_3",2);
        addConstant(*this,"GLFW_JOYSTICK_4",3);
        addConstant(*this,"GLFW_JOYSTICK_5",4);
        addConstant(*this,"GLFW_JOYSTICK_6",5);
        addConstant(*this,"GLFW_JOYSTICK_7",6);
        addConstant(*this,"GLFW_JOYSTICK_8",7);
        addConstant(*this,"GLFW_JOYSTICK_9",8);
        addConstant(*this,"GLFW_JOYSTICK_10",9);
        addConstant(*this,"GLFW_JOYSTICK_11",10);
        addConstant(*this,"GLFW_JOYSTICK_12",11);
        addConstant(*this,"GLFW_JOYSTICK_13",12);
        addConstant(*this,"GLFW_JOYSTICK_14",13);
        addConstant(*this,"GLFW_JOYSTICK_15",14);
        addConstant(*this,"GLFW_JOYSTICK_16",15);
        addConstant(*this,"GLFW_JOYSTICK_LAST",GLFW_JOYSTICK_16);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_A",0);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_B",1);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_X",2);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_Y",3);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LEFT_BUMPER",4);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER",5);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_BACK",6);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_START",7);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_GUIDE",8);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LEFT_THUMB",9);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_RIGHT_THUMB",10);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_UP",11);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_RIGHT",12);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_DOWN",13);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_LEFT",14);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LAST",GLFW_GAMEPAD_BUTTON_DPAD_LEFT);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_CROSS",GLFW_GAMEPAD_BUTTON_A);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_CIRCLE",GLFW_GAMEPAD_BUTTON_B);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_SQUARE",GLFW_GAMEPAD_BUTTON_X);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_TRIANGLE",GLFW_GAMEPAD_BUTTON_Y);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_X",0);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_Y",1);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_X",2);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_Y",3);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_TRIGGER",4);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER",5);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LAST",GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER);
        addConstant(*this,"GLFW_NO_ERROR",0);
        addConstant(*this,"GLFW_NOT_INITIALIZED",0x00010001);
        addConstant(*this,"GLFW_NO_CURRENT_CONTEXT",0x00010002);
        addConstant(*this,"GLFW_INVALID_ENUM",0x00010003);
        addConstant(*this,"GLFW_INVALID_VALUE",0x00010004);
        addConstant(*this,"GLFW_OUT_OF_MEMORY",0x00010005);
        addConstant(*this,"GLFW_API_UNAVAILABLE",0x00010006);
        addConstant(*this,"GLFW_VERSION_UNAVAILABLE",0x00010007);
        addConstant(*this,"GLFW_PLATFORM_ERROR",0x00010008);
        addConstant(*this,"GLFW_FORMAT_UNAVAILABLE",0x00010009);
        addConstant(*this,"GLFW_NO_WINDOW_CONTEXT",0x0001000A);
        addConstant(*this,"GLFW_FOCUSED",0x00020001);
        addConstant(*this,"GLFW_ICONIFIED",0x00020002);
        addConstant(*this,"GLFW_RESIZABLE",0x00020003);
        addConstant(*this,"GLFW_VISIBLE",0x00020004);
        addConstant(*this,"GLFW_DECORATED",0x00020005);
        addConstant(*this,"GLFW_AUTO_ICONIFY",0x00020006);
        addConstant(*this,"GLFW_FLOATING",0x00020007);
        addConstant(*this,"GLFW_MAXIMIZED",0x00020008);
        addConstant(*this,"GLFW_CENTER_CURSOR",0x00020009);
        addConstant(*this,"GLFW_TRANSPARENT_FRAMEBUFFER",0x0002000A);
        addConstant(*this,"GLFW_HOVERED",0x0002000B);
        addConstant(*this,"GLFW_FOCUS_ON_SHOW",0x0002000C);
        addConstant(*this,"GLFW_RED_BITS",0x00021001);
        addConstant(*this,"GLFW_GREEN_BITS",0x00021002);
        addConstant(*this,"GLFW_BLUE_BITS",0x00021003);
        addConstant(*this,"GLFW_ALPHA_BITS",0x00021004);
        addConstant(*this,"GLFW_DEPTH_BITS",0x00021005);
        addConstant(*this,"GLFW_STENCIL_BITS",0x00021006);
        addConstant(*this,"GLFW_ACCUM_RED_BITS",0x00021007);
        addConstant(*this,"GLFW_ACCUM_GREEN_BITS",0x00021008);
        addConstant(*this,"GLFW_ACCUM_BLUE_BITS",0x00021009);
        addConstant(*this,"GLFW_ACCUM_ALPHA_BITS",0x0002100A);
        addConstant(*this,"GLFW_AUX_BUFFERS",0x0002100B);
        addConstant(*this,"GLFW_STEREO",0x0002100C);
        addConstant(*this,"GLFW_SAMPLES",0x0002100D);
        addConstant(*this,"GLFW_SRGB_CAPABLE",0x0002100E);
        addConstant(*this,"GLFW_REFRESH_RATE",0x0002100F);
        addConstant(*this,"GLFW_DOUBLEBUFFER",0x00021010);
        addConstant(*this,"GLFW_CLIENT_API",0x00022001);
        addConstant(*this,"GLFW_CONTEXT_VERSION_MAJOR",0x00022002);
        addConstant(*this,"GLFW_CONTEXT_VERSION_MINOR",0x00022003);
        addConstant(*this,"GLFW_CONTEXT_REVISION",0x00022004);
        addConstant(*this,"GLFW_CONTEXT_ROBUSTNESS",0x00022005);
        addConstant(*this,"GLFW_OPENGL_FORWARD_COMPAT",0x00022006);
        addConstant(*this,"GLFW_OPENGL_DEBUG_CONTEXT",0x00022007);
        addConstant(*this,"GLFW_OPENGL_PROFILE",0x00022008);
        addConstant(*this,"GLFW_CONTEXT_RELEASE_BEHAVIOR",0x00022009);
        addConstant(*this,"GLFW_CONTEXT_NO_ERROR",0x0002200A);
        addConstant(*this,"GLFW_CONTEXT_CREATION_API",0x0002200B);
        addConstant(*this,"GLFW_SCALE_TO_MONITOR",0x0002200C);
        addConstant(*this,"GLFW_COCOA_RETINA_FRAMEBUFFER",0x00023001);
        addConstant(*this,"GLFW_COCOA_FRAME_NAME",0x00023002);
        addConstant(*this,"GLFW_COCOA_GRAPHICS_SWITCHING",0x00023003);
        addConstant(*this,"GLFW_X11_CLASS_NAME",0x00024001);
        addConstant(*this,"GLFW_X11_INSTANCE_NAME",0x00024002);
        addConstant(*this,"GLFW_NO_API",0);
        addConstant(*this,"GLFW_OPENGL_API",0x00030001);
        addConstant(*this,"GLFW_OPENGL_ES_API",0x00030002);
        addConstant(*this,"GLFW_NO_ROBUSTNESS",0);
        addConstant(*this,"GLFW_NO_RESET_NOTIFICATION",0x00031001);
        addConstant(*this,"GLFW_LOSE_CONTEXT_ON_RESET",0x00031002);
        addConstant(*this,"GLFW_OPENGL_ANY_PROFILE",0);
        addConstant(*this,"GLFW_OPENGL_CORE_PROFILE",0x00032001);
        addConstant(*this,"GLFW_OPENGL_COMPAT_PROFILE",0x00032002);
        addConstant(*this,"GLFW_CURSOR",0x00033001);
        addConstant(*this,"GLFW_STICKY_KEYS",0x00033002);
        addConstant(*this,"GLFW_STICKY_MOUSE_BUTTONS",0x00033003);
        addConstant(*this,"GLFW_LOCK_KEY_MODS",0x00033004);
        addConstant(*this,"GLFW_RAW_MOUSE_MOTION",0x00033005);
        addConstant(*this,"GLFW_CURSOR_NORMAL",0x00034001);
        addConstant(*this,"GLFW_CURSOR_HIDDEN",0x00034002);
        addConstant(*this,"GLFW_CURSOR_DISABLED",0x00034003);
        addConstant(*this,"GLFW_ANY_RELEASE_BEHAVIOR",0);
        addConstant(*this,"GLFW_RELEASE_BEHAVIOR_FLUSH",0x00035001);
        addConstant(*this,"GLFW_RELEASE_BEHAVIOR_NONE",0x00035002);
        addConstant(*this,"GLFW_NATIVE_CONTEXT_API",0x00036001);
        addConstant(*this,"GLFW_EGL_CONTEXT_API",0x00036002);
        addConstant(*this,"GLFW_OSMESA_CONTEXT_API",0x00036003);
        addConstant(*this,"GLFW_ARROW_CURSOR",0x00036001);
        addConstant(*this,"GLFW_IBEAM_CURSOR",0x00036002);
        addConstant(*this,"GLFW_CROSSHAIR_CURSOR",0x00036003);
        addConstant(*this,"GLFW_HAND_CURSOR",0x00036004);
        addConstant(*this,"GLFW_HRESIZE_CURSOR",0x00036005);
        addConstant(*this,"GLFW_VRESIZE_CURSOR",0x00036006);
        addConstant(*this,"GLFW_CONNECTED",0x00040001);
        addConstant(*this,"GLFW_DISCONNECTED",0x00040002);
        addConstant(*this,"GLFW_JOYSTICK_HAT_BUTTONS",0x00050001);
        addConstant(*this,"GLFW_COCOA_CHDIR_RESOURCES",0x00051001);
        addConstant(*this,"GLFW_COCOA_MENUBAR",0x00051002);
        addConstant(*this,"GLFW_DONT_CARE",-1);
        addConstant(*this,"VK_VERSION_1_0",1);
        addConstant(*this,"VK_API_VERSION_1_0",VK_MAKE_VERSION(1, 0, 0));
        addConstant(*this,"VK_HEADER_VERSION",162);
        addConstant(*this,"VK_HEADER_VERSION_COMPLETE",VK_MAKE_VERSION(1, 2, VK_HEADER_VERSION));
        addConstant(*this,"VK_NULL_HANDLE",0);
        addConstant(*this,"VK_ATTACHMENT_UNUSED",(~0U));
        addConstant(*this,"VK_FALSE",0);
        addConstant(*this,"VK_LOD_CLAMP_NONE",1000.0f);
        addConstant(*this,"VK_QUEUE_FAMILY_IGNORED",(~0U));
        addConstant(*this,"VK_REMAINING_ARRAY_LAYERS",(~0U));
        addConstant(*this,"VK_REMAINING_MIP_LEVELS",(~0U));
        addConstant(*this,"VK_SUBPASS_EXTERNAL",(~0U));
        addConstant(*this,"VK_TRUE",1);
        addConstant(*this,"VK_WHOLE_SIZE",(~0ULL));
        addConstant(*this,"VK_MAX_MEMORY_TYPES",32);
        addConstant(*this,"VK_MAX_MEMORY_HEAPS",16);
        addConstant(*this,"VK_MAX_PHYSICAL_DEVICE_NAME_SIZE",256);
        addConstant(*this,"VK_UUID_SIZE",16);
        addConstant(*this,"VK_MAX_EXTENSION_NAME_SIZE",256);
        addConstant(*this,"VK_MAX_DESCRIPTION_SIZE",256);
        addConstant(*this,"VK_VERSION_1_1",1);
        addConstant(*this,"VK_API_VERSION_1_1",VK_MAKE_VERSION(1, 1, 0));
        addConstant(*this,"VK_MAX_DEVICE_GROUP_SIZE",32);
        addConstant(*this,"VK_LUID_SIZE",8);
        addConstant(*this,"VK_QUEUE_FAMILY_EXTERNAL",(~0U-1));
        addConstant(*this,"VK_VERSION_1_2",1);
        addConstant(*this,"VK_API_VERSION_1_2",VK_MAKE_VERSION(1, 2, 0));
        addConstant(*this,"VK_MAX_DRIVER_NAME_SIZE",256);
        addConstant(*this,"VK_MAX_DRIVER_INFO_SIZE",256);
        addConstant(*this,"VK_KHR_surface",1);
        addConstant(*this,"VK_KHR_SURFACE_SPEC_VERSION",25);
        addConstant(*this,"VK_KHR_swapchain",1);
        addConstant(*this,"VK_KHR_SWAPCHAIN_SPEC_VERSION",70);
        addConstant(*this,"VK_KHR_display",1);
        addConstant(*this,"VK_KHR_DISPLAY_SPEC_VERSION",23);
        addConstant(*this,"VK_KHR_display_swapchain",1);
        addConstant(*this,"VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION",10);
        addConstant(*this,"VK_KHR_sampler_mirror_clamp_to_edge",1);
        addConstant(*this,"VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_multiview",1);
        addConstant(*this,"VK_KHR_MULTIVIEW_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_physical_device_properties2",1);
        addConstant(*this,"VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_device_group",1);
        addConstant(*this,"VK_KHR_DEVICE_GROUP_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_shader_draw_parameters",1);
        addConstant(*this,"VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance1",1);
        addConstant(*this,"VK_KHR_MAINTENANCE1_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_device_group_creation",1);
        addConstant(*this,"VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION",1);
        addConstant(*this,"VK_MAX_DEVICE_GROUP_SIZE_KHR",VK_MAX_DEVICE_GROUP_SIZE);
        addConstant(*this,"VK_KHR_external_memory_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_LUID_SIZE_KHR",VK_LUID_SIZE);
        addConstant(*this,"VK_KHR_external_memory",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_QUEUE_FAMILY_EXTERNAL_KHR",VK_QUEUE_FAMILY_EXTERNAL);
        addConstant(*this,"VK_KHR_external_memory_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_push_descriptor",1);
        addConstant(*this,"VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_shader_float16_int8",1);
        addConstant(*this,"VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_16bit_storage",1);
        addConstant(*this,"VK_KHR_16BIT_STORAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_incremental_present",1);
        addConstant(*this,"VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_descriptor_update_template",1);
        addConstant(*this,"VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_imageless_framebuffer",1);
        addConstant(*this,"VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_create_renderpass2",1);
        addConstant(*this,"VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shared_presentable_image",1);
        addConstant(*this,"VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_performance_query",1);
        addConstant(*this,"VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance2",1);
        addConstant(*this,"VK_KHR_MAINTENANCE2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_surface_capabilities2",1);
        addConstant(*this,"VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_variable_pointers",1);
        addConstant(*this,"VK_KHR_VARIABLE_POINTERS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_display_properties2",1);
        addConstant(*this,"VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_dedicated_allocation",1);
        addConstant(*this,"VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_storage_buffer_storage_class",1);
        addConstant(*this,"VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_relaxed_block_layout",1);
        addConstant(*this,"VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_memory_requirements2",1);
        addConstant(*this,"VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_image_format_list",1);
        addConstant(*this,"VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_sampler_ycbcr_conversion",1);
        addConstant(*this,"VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION",14);
        addConstant(*this,"VK_KHR_bind_memory2",1);
        addConstant(*this,"VK_KHR_BIND_MEMORY_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance3",1);
        addConstant(*this,"VK_KHR_MAINTENANCE3_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_draw_indirect_count",1);
        addConstant(*this,"VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_subgroup_extended_types",1);
        addConstant(*this,"VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_8bit_storage",1);
        addConstant(*this,"VK_KHR_8BIT_STORAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_atomic_int64",1);
        addConstant(*this,"VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_clock",1);
        addConstant(*this,"VK_KHR_SHADER_CLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_driver_properties",1);
        addConstant(*this,"VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION",1);
        addConstant(*this,"VK_MAX_DRIVER_NAME_SIZE_KHR",VK_MAX_DRIVER_NAME_SIZE);
        addConstant(*this,"VK_MAX_DRIVER_INFO_SIZE_KHR",VK_MAX_DRIVER_INFO_SIZE);
        addConstant(*this,"VK_KHR_shader_float_controls",1);
        addConstant(*this,"VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_depth_stencil_resolve",1);
        addConstant(*this,"VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_swapchain_mutable_format",1);
        addConstant(*this,"VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_timeline_semaphore",1);
        addConstant(*this,"VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_vulkan_memory_model",1);
        addConstant(*this,"VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_shader_terminate_invocation",1);
        addConstant(*this,"VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_fragment_shading_rate",1);
        addConstant(*this,"VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_spirv_1_4",1);
        addConstant(*this,"VK_KHR_SPIRV_1_4_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_surface_protected_capabilities",1);
        addConstant(*this,"VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_separate_depth_stencil_layouts",1);
        addConstant(*this,"VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_uniform_buffer_standard_layout",1);
        addConstant(*this,"VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_buffer_device_address",1);
        addConstant(*this,"VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_deferred_host_operations",1);
        addConstant(*this,"VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_pipeline_executable_properties",1);
        addConstant(*this,"VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_pipeline_library",1);
        addConstant(*this,"VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_non_semantic_info",1);
        addConstant(*this,"VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_copy_commands2",1);
        addConstant(*this,"VK_KHR_COPY_COMMANDS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_debug_report",1);
        addConstant(*this,"VK_EXT_DEBUG_REPORT_SPEC_VERSION",9);
        addConstant(*this,"VK_NV_glsl_shader",1);
        addConstant(*this,"VK_NV_GLSL_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_depth_range_unrestricted",1);
        addConstant(*this,"VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION",1);
        addConstant(*this,"VK_IMG_filter_cubic",1);
        addConstant(*this,"VK_IMG_FILTER_CUBIC_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_rasterization_order",1);
        addConstant(*this,"VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_trinary_minmax",1);
        addConstant(*this,"VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_explicit_vertex_parameter",1);
        addConstant(*this,"VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_debug_marker",1);
        addConstant(*this,"VK_EXT_DEBUG_MARKER_SPEC_VERSION",4);
        addConstant(*this,"VK_AMD_gcn_shader",1);
        addConstant(*this,"VK_AMD_GCN_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_dedicated_allocation",1);
        addConstant(*this,"VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_transform_feedback",1);
        addConstant(*this,"VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION",1);
        addConstant(*this,"VK_NVX_image_view_handle",1);
        addConstant(*this,"VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_draw_indirect_count",1);
        addConstant(*this,"VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_negative_viewport_height",1);
        addConstant(*this,"VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_gpu_shader_half_float",1);
        addConstant(*this,"VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_shader_ballot",1);
        addConstant(*this,"VK_AMD_SHADER_BALLOT_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_texture_gather_bias_lod",1);
        addConstant(*this,"VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_info",1);
        addConstant(*this,"VK_AMD_SHADER_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_image_load_store_lod",1);
        addConstant(*this,"VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_corner_sampled_image",1);
        addConstant(*this,"VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION",2);
        addConstant(*this,"VK_IMG_format_pvrtc",1);
        addConstant(*this,"VK_IMG_FORMAT_PVRTC_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_external_memory_capabilities",1);
        addConstant(*this,"VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_external_memory",1);
        addConstant(*this,"VK_NV_EXTERNAL_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_flags",1);
        addConstant(*this,"VK_EXT_VALIDATION_FLAGS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_shader_subgroup_ballot",1);
        addConstant(*this,"VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_subgroup_vote",1);
        addConstant(*this,"VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_texture_compression_astc_hdr",1);
        addConstant(*this,"VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_astc_decode_mode",1);
        addConstant(*this,"VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_conditional_rendering",1);
        addConstant(*this,"VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_clip_space_w_scaling",1);
        addConstant(*this,"VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_direct_mode_display",1);
        addConstant(*this,"VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_display_surface_counter",1);
        addConstant(*this,"VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_display_control",1);
        addConstant(*this,"VK_EXT_DISPLAY_CONTROL_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_display_timing",1);
        addConstant(*this,"VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_sample_mask_override_coverage",1);
        addConstant(*this,"VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_geometry_shader_passthrough",1);
        addConstant(*this,"VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_viewport_array2",1);
        addConstant(*this,"VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION",1);
        addConstant(*this,"VK_NVX_multiview_per_view_attributes",1);
        addConstant(*this,"VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_viewport_swizzle",1);
        addConstant(*this,"VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_discard_rectangles",1);
        addConstant(*this,"VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_conservative_rasterization",1);
        addConstant(*this,"VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_depth_clip_enable",1);
        addConstant(*this,"VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_swapchain_colorspace",1);
        addConstant(*this,"VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION",4);
        addConstant(*this,"VK_EXT_hdr_metadata",1);
        addConstant(*this,"VK_EXT_HDR_METADATA_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_external_memory_dma_buf",1);
        addConstant(*this,"VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_queue_family_foreign",1);
        addConstant(*this,"VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION",1);
        addConstant(*this,"VK_QUEUE_FAMILY_FOREIGN_EXT",(~0U-2));
        addConstant(*this,"VK_EXT_debug_utils",1);
        addConstant(*this,"VK_EXT_DEBUG_UTILS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_sampler_filter_minmax",1);
        addConstant(*this,"VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_gpu_shader_int16",1);
        addConstant(*this,"VK_AMD_GPU_SHADER_INT16_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_mixed_attachment_samples",1);
        addConstant(*this,"VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_fragment_mask",1);
        addConstant(*this,"VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_inline_uniform_block",1);
        addConstant(*this,"VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_stencil_export",1);
        addConstant(*this,"VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_sample_locations",1);
        addConstant(*this,"VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_blend_operation_advanced",1);
        addConstant(*this,"VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_fragment_coverage_to_color",1);
        addConstant(*this,"VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_framebuffer_mixed_samples",1);
        addConstant(*this,"VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_fill_rectangle",1);
        addConstant(*this,"VK_NV_FILL_RECTANGLE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_sm_builtins",1);
        addConstant(*this,"VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_post_depth_coverage",1);
        addConstant(*this,"VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_image_drm_format_modifier",1);
        addConstant(*this,"VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_cache",1);
        addConstant(*this,"VK_EXT_VALIDATION_CACHE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_descriptor_indexing",1);
        addConstant(*this,"VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_shader_viewport_index_layer",1);
        addConstant(*this,"VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shading_rate_image",1);
        addConstant(*this,"VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION",3);
        addConstant(*this,"VK_NV_ray_tracing",1);
        addConstant(*this,"VK_NV_RAY_TRACING_SPEC_VERSION",3);
        addConstant(*this,"VK_SHADER_UNUSED_KHR",(~0U));
        addConstant(*this,"VK_SHADER_UNUSED_NV",VK_SHADER_UNUSED_KHR);
        addConstant(*this,"VK_NV_representative_fragment_test",1);
        addConstant(*this,"VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_filter_cubic",1);
        addConstant(*this,"VK_EXT_FILTER_CUBIC_SPEC_VERSION",3);
        addConstant(*this,"VK_QCOM_render_pass_shader_resolve",1);
        addConstant(*this,"VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION",4);
        addConstant(*this,"VK_EXT_global_priority",1);
        addConstant(*this,"VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_external_memory_host",1);
        addConstant(*this,"VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_buffer_marker",1);
        addConstant(*this,"VK_AMD_BUFFER_MARKER_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_pipeline_compiler_control",1);
        addConstant(*this,"VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_calibrated_timestamps",1);
        addConstant(*this,"VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_core_properties",1);
        addConstant(*this,"VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_memory_overallocation_behavior",1);
        addConstant(*this,"VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_vertex_attribute_divisor",1);
        addConstant(*this,"VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION",3);
        addConstant(*this,"VK_EXT_pipeline_creation_feedback",1);
        addConstant(*this,"VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_subgroup_partitioned",1);
        addConstant(*this,"VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_compute_shader_derivatives",1);
        addConstant(*this,"VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_mesh_shader",1);
        addConstant(*this,"VK_NV_MESH_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_fragment_shader_barycentric",1);
        addConstant(*this,"VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_image_footprint",1);
        addConstant(*this,"VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_scissor_exclusive",1);
        addConstant(*this,"VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_device_diagnostic_checkpoints",1);
        addConstant(*this,"VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION",2);
        addConstant(*this,"VK_INTEL_shader_integer_functions2",1);
        addConstant(*this,"VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_INTEL_performance_query",1);
        addConstant(*this,"VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_pci_bus_info",1);
        addConstant(*this,"VK_EXT_PCI_BUS_INFO_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_display_native_hdr",1);
        addConstant(*this,"VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_density_map",1);
        addConstant(*this,"VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_scalar_block_layout",1);
        addConstant(*this,"VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_hlsl_functionality1",1);
        addConstant(*this,"VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_decorate_string",1);
        addConstant(*this,"VK_GOOGLE_DECORATE_STRING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_subgroup_size_control",1);
        addConstant(*this,"VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_shader_core_properties2",1);
        addConstant(*this,"VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_device_coherent_memory",1);
        addConstant(*this,"VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_image_atomic_int64",1);
        addConstant(*this,"VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_memory_budget",1);
        addConstant(*this,"VK_EXT_MEMORY_BUDGET_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_memory_priority",1);
        addConstant(*this,"VK_EXT_MEMORY_PRIORITY_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_dedicated_allocation_image_aliasing",1);
        addConstant(*this,"VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_buffer_device_address",1);
        addConstant(*this,"VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_tooling_info",1);
        addConstant(*this,"VK_EXT_TOOLING_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_separate_stencil_usage",1);
        addConstant(*this,"VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_features",1);
        addConstant(*this,"VK_EXT_VALIDATION_FEATURES_SPEC_VERSION",4);
        addConstant(*this,"VK_NV_cooperative_matrix",1);
        addConstant(*this,"VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_coverage_reduction_mode",1);
        addConstant(*this,"VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_shader_interlock",1);
        addConstant(*this,"VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_ycbcr_image_arrays",1);
        addConstant(*this,"VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_headless_surface",1);
        addConstant(*this,"VK_EXT_HEADLESS_SURFACE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_line_rasterization",1);
        addConstant(*this,"VK_EXT_LINE_RASTERIZATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_atomic_float",1);
        addConstant(*this,"VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_host_query_reset",1);
        addConstant(*this,"VK_EXT_HOST_QUERY_RESET_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_index_type_uint8",1);
        addConstant(*this,"VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_extended_dynamic_state",1);
        addConstant(*this,"VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_demote_to_helper_invocation",1);
        addConstant(*this,"VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_device_generated_commands",1);
        addConstant(*this,"VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION",3);
        addConstant(*this,"VK_EXT_texel_buffer_alignment",1);
        addConstant(*this,"VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_render_pass_transform",1);
        addConstant(*this,"VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_device_memory_report",1);
        addConstant(*this,"VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_robustness2",1);
        addConstant(*this,"VK_EXT_ROBUSTNESS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_custom_border_color",1);
        addConstant(*this,"VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION",12);
        addConstant(*this,"VK_GOOGLE_user_type",1);
        addConstant(*this,"VK_GOOGLE_USER_TYPE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_private_data",1);
        addConstant(*this,"VK_EXT_PRIVATE_DATA_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_pipeline_creation_cache_control",1);
        addConstant(*this,"VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION",3);
        addConstant(*this,"VK_NV_device_diagnostics_config",1);
        addConstant(*this,"VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_render_pass_store_ops",1);
        addConstant(*this,"VK_QCOM_render_pass_store_ops_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_fragment_shading_rate_enums",1);
        addConstant(*this,"VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_density_map2",1);
        addConstant(*this,"VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_rotated_copy_commands",1);
        addConstant(*this,"VK_QCOM_rotated_copy_commands_SPEC_VERSION",0);
        addConstant(*this,"VK_EXT_image_robustness",1);
        addConstant(*this,"VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_4444_formats",1);
        addConstant(*this,"VK_EXT_4444_FORMATS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_acceleration_structure",1);
        addConstant(*this,"VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION",11);
        addConstant(*this,"VK_KHR_ray_tracing_pipeline",1);
        addConstant(*this,"VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_ray_query",1);
        addConstant(*this,"VK_KHR_RAY_QUERY_SPEC_VERSION",1);
    }
};
