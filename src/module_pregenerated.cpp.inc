// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBuffer, VkBuffer)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImage, VkImage)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInstance, VkInstance)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice, VkPhysicalDevice)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDevice, VkDevice)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueue, VkQueue)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphore, VkSemaphore)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBuffer, VkCommandBuffer)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFence, VkFence)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemory, VkDeviceMemory)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkEvent, VkEvent)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPool, VkQueryPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferView, VkBufferView)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageView, VkImageView)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModule, VkShaderModule)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCache, VkPipelineCache)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayout, VkPipelineLayout)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipeline, VkPipeline)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPass, VkRenderPass)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayout, VkDescriptorSetLayout)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSampler, VkSampler)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSet, VkDescriptorSet)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPool, VkDescriptorPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebuffer, VkFramebuffer)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPool, VkCommandPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversion, VkSamplerYcbcrConversion)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplate, VkDescriptorUpdateTemplate)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceKHR, VkSurfaceKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainKHR, VkSwapchainKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayKHR, VkDisplayKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeKHR, VkDisplayModeKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeferredOperationKHR, VkDeferredOperationKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugReportCallbackEXT, VkDebugReportCallbackEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerEXT, VkDebugUtilsMessengerEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationCacheEXT, VkValidationCacheEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureNV, VkAccelerationStructureNV)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceConfigurationINTEL, VkPerformanceConfigurationINTEL)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutNV, VkIndirectCommandsLayoutNV)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPrivateDataSlotEXT, VkPrivateDataSlotEXT)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureKHR, VkAccelerationStructureKHR)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWmonitor_DasHandle, GLFWmonitor_DasHandle)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWwindow_DasHandle, GLFWwindow_DasHandle)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWcursor_DasHandle, GLFWcursor_DasHandle)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtent2D, VkExtent2D);

struct VkExtent2DAnnotation
: public ManagedStructureAnnotation<VkExtent2D,true,true> {
    VkExtent2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtent3D, VkExtent3D);

struct VkExtent3DAnnotation
: public ManagedStructureAnnotation<VkExtent3D,true,true> {
    VkExtent3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkOffset2D, VkOffset2D);

struct VkOffset2DAnnotation
: public ManagedStructureAnnotation<VkOffset2D,true,true> {
    VkOffset2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkOffset3D, VkOffset3D);

struct VkOffset3DAnnotation
: public ManagedStructureAnnotation<VkOffset3D,true,true> {
    VkOffset3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRect2D, VkRect2D);

struct VkRect2DAnnotation
: public ManagedStructureAnnotation<VkRect2D,true,true> {
    VkRect2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRect2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBaseInStructure, VkBaseInStructure);

struct VkBaseInStructureAnnotation
: public ManagedStructureAnnotation<VkBaseInStructure,true,true> {
    VkBaseInStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseInStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBaseOutStructure, VkBaseOutStructure);

struct VkBaseOutStructureAnnotation
: public ManagedStructureAnnotation<VkBaseOutStructure,true,true> {
    VkBaseOutStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseOutStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferMemoryBarrier, VkBufferMemoryBarrier);

struct VkBufferMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkBufferMemoryBarrier,true,true> {
    VkBufferMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDispatchIndirectCommand, VkDispatchIndirectCommand);

struct VkDispatchIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDispatchIndirectCommand,true,true> {
    VkDispatchIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDispatchIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawIndexedIndirectCommand, VkDrawIndexedIndirectCommand);

struct VkDrawIndexedIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndexedIndirectCommand,true,true> {
    VkDrawIndexedIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndexedIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(indexCount)>("indexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstIndex)>("firstIndex");
        addField<DAS_BIND_MANAGED_FIELD(vertexOffset)>("vertexOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawIndirectCommand, VkDrawIndirectCommand);

struct VkDrawIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndirectCommand,true,true> {
    VkDrawIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(vertexCount)>("vertexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresourceRange, VkImageSubresourceRange);

struct VkImageSubresourceRangeAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceRange,true,true> {
    VkImageSubresourceRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(baseMipLevel)>("baseMipLevel");
        addField<DAS_BIND_MANAGED_FIELD(levelCount)>("levelCount");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageMemoryBarrier, VkImageMemoryBarrier);

struct VkImageMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkImageMemoryBarrier,true,true> {
    VkImageMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(oldLayout)>("oldLayout");
        addField<DAS_BIND_MANAGED_FIELD(newLayout)>("newLayout");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryBarrier, VkMemoryBarrier);

struct VkMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkMemoryBarrier,true,true> {
    VkMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAllocationCallbacks, VkAllocationCallbacks);

struct VkAllocationCallbacksAnnotation
: public ManagedStructureAnnotation<VkAllocationCallbacks,true,true> {
    VkAllocationCallbacksAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAllocationCallbacks", ml) {
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkApplicationInfo, VkApplicationInfo);

struct VkApplicationInfoAnnotation
: public ManagedStructureAnnotation<VkApplicationInfo,true,true> {
    VkApplicationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkApplicationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationName)>("pApplicationName");
        addField<DAS_BIND_MANAGED_FIELD(applicationVersion)>("applicationVersion");
        addField<DAS_BIND_MANAGED_FIELD(pEngineName)>("pEngineName");
        addField<DAS_BIND_MANAGED_FIELD(engineVersion)>("engineVersion");
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFormatProperties, VkFormatProperties);

struct VkFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkFormatProperties,true,true> {
    VkFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(linearTilingFeatures)>("linearTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(optimalTilingFeatures)>("optimalTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(bufferFeatures)>("bufferFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageFormatProperties, VkImageFormatProperties);

struct VkImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkImageFormatProperties,true,true> {
    VkImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxExtent)>("maxExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxMipLevels)>("maxMipLevels");
        addField<DAS_BIND_MANAGED_FIELD(maxArrayLayers)>("maxArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(sampleCounts)>("sampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxResourceSize)>("maxResourceSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInstanceCreateInfo, VkInstanceCreateInfo);

struct VkInstanceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkInstanceCreateInfo,true,true> {
    VkInstanceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInstanceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationInfo)>("pApplicationInfo");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryHeap, VkMemoryHeap);

struct VkMemoryHeapAnnotation
: public ManagedStructureAnnotation<VkMemoryHeap,true,true> {
    VkMemoryHeapAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHeap", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryType, VkMemoryType);

struct VkMemoryTypeAnnotation
: public ManagedStructureAnnotation<VkMemoryType,true,true> {
    VkMemoryTypeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryType", ml) {
        addField<DAS_BIND_MANAGED_FIELD(propertyFlags)>("propertyFlags");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFeatures, VkPhysicalDeviceFeatures);

struct VkPhysicalDeviceFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFeatures,true,true> {
    VkPhysicalDeviceFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess)>("robustBufferAccess");
        addField<DAS_BIND_MANAGED_FIELD(fullDrawIndexUint32)>("fullDrawIndexUint32");
        addField<DAS_BIND_MANAGED_FIELD(imageCubeArray)>("imageCubeArray");
        addField<DAS_BIND_MANAGED_FIELD(independentBlend)>("independentBlend");
        addField<DAS_BIND_MANAGED_FIELD(geometryShader)>("geometryShader");
        addField<DAS_BIND_MANAGED_FIELD(tessellationShader)>("tessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(sampleRateShading)>("sampleRateShading");
        addField<DAS_BIND_MANAGED_FIELD(dualSrcBlend)>("dualSrcBlend");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(multiDrawIndirect)>("multiDrawIndirect");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectFirstInstance)>("drawIndirectFirstInstance");
        addField<DAS_BIND_MANAGED_FIELD(depthClamp)>("depthClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(fillModeNonSolid)>("fillModeNonSolid");
        addField<DAS_BIND_MANAGED_FIELD(depthBounds)>("depthBounds");
        addField<DAS_BIND_MANAGED_FIELD(wideLines)>("wideLines");
        addField<DAS_BIND_MANAGED_FIELD(largePoints)>("largePoints");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOne)>("alphaToOne");
        addField<DAS_BIND_MANAGED_FIELD(multiViewport)>("multiViewport");
        addField<DAS_BIND_MANAGED_FIELD(samplerAnisotropy)>("samplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionETC2)>("textureCompressionETC2");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_LDR)>("textureCompressionASTC_LDR");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionBC)>("textureCompressionBC");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryPrecise)>("occlusionQueryPrecise");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatisticsQuery)>("pipelineStatisticsQuery");
        addField<DAS_BIND_MANAGED_FIELD(vertexPipelineStoresAndAtomics)>("vertexPipelineStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(fragmentStoresAndAtomics)>("fragmentStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderTessellationAndGeometryPointSize)>("shaderTessellationAndGeometryPointSize");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageGatherExtended)>("shaderImageGatherExtended");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageExtendedFormats)>("shaderStorageImageExtendedFormats");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageMultisample)>("shaderStorageImageMultisample");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageReadWithoutFormat)>("shaderStorageImageReadWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageWriteWithoutFormat)>("shaderStorageImageWriteWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayDynamicIndexing)>("shaderUniformBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayDynamicIndexing)>("shaderSampledImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayDynamicIndexing)>("shaderStorageBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayDynamicIndexing)>("shaderStorageImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderClipDistance)>("shaderClipDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderCullDistance)>("shaderCullDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat64)>("shaderFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt64)>("shaderInt64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt16)>("shaderInt16");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceResidency)>("shaderResourceResidency");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceMinLod)>("shaderResourceMinLod");
        addField<DAS_BIND_MANAGED_FIELD(sparseBinding)>("sparseBinding");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyBuffer)>("sparseResidencyBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage2D)>("sparseResidencyImage2D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage3D)>("sparseResidencyImage3D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency2Samples)>("sparseResidency2Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency4Samples)>("sparseResidency4Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency8Samples)>("sparseResidency8Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency16Samples)>("sparseResidency16Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyAliased)>("sparseResidencyAliased");
        addField<DAS_BIND_MANAGED_FIELD(variableMultisampleRate)>("variableMultisampleRate");
        addField<DAS_BIND_MANAGED_FIELD(inheritedQueries)>("inheritedQueries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLimits, VkPhysicalDeviceLimits);

struct VkPhysicalDeviceLimitsAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLimits,true,true> {
    VkPhysicalDeviceLimitsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLimits", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension1D)>("maxImageDimension1D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension2D)>("maxImageDimension2D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension3D)>("maxImageDimension3D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimensionCube)>("maxImageDimensionCube");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelBufferElements)>("maxTexelBufferElements");
        addField<DAS_BIND_MANAGED_FIELD(maxUniformBufferRange)>("maxUniformBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxStorageBufferRange)>("maxStorageBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxPushConstantsSize)>("maxPushConstantsSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationCount)>("maxMemoryAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAllocationCount)>("maxSamplerAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageGranularity)>("bufferImageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(sparseAddressSpaceSize)>("sparseAddressSpaceSize");
        addField<DAS_BIND_MANAGED_FIELD(maxBoundDescriptorSets)>("maxBoundDescriptorSets");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSamplers)>("maxPerStageDescriptorSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUniformBuffers)>("maxPerStageDescriptorUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageBuffers)>("maxPerStageDescriptorStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSampledImages)>("maxPerStageDescriptorSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageImages)>("maxPerStageDescriptorStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInputAttachments)>("maxPerStageDescriptorInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageResources)>("maxPerStageResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSamplers)>("maxDescriptorSetSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffers)>("maxDescriptorSetUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffersDynamic)>("maxDescriptorSetUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffers)>("maxDescriptorSetStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffersDynamic)>("maxDescriptorSetStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSampledImages)>("maxDescriptorSetSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageImages)>("maxDescriptorSetStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInputAttachments)>("maxDescriptorSetInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributes)>("maxVertexInputAttributes");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindings)>("maxVertexInputBindings");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributeOffset)>("maxVertexInputAttributeOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindingStride)>("maxVertexInputBindingStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexOutputComponents)>("maxVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationGenerationLevel)>("maxTessellationGenerationLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationPatchSize)>("maxTessellationPatchSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexInputComponents)>("maxTessellationControlPerVertexInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexOutputComponents)>("maxTessellationControlPerVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerPatchOutputComponents)>("maxTessellationControlPerPatchOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlTotalOutputComponents)>("maxTessellationControlTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationInputComponents)>("maxTessellationEvaluationInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationOutputComponents)>("maxTessellationEvaluationOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryShaderInvocations)>("maxGeometryShaderInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryInputComponents)>("maxGeometryInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputComponents)>("maxGeometryOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputVertices)>("maxGeometryOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryTotalOutputComponents)>("maxGeometryTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentInputComponents)>("maxFragmentInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentOutputAttachments)>("maxFragmentOutputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDualSrcAttachments)>("maxFragmentDualSrcAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentCombinedOutputResources)>("maxFragmentCombinedOutputResources");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeSharedMemorySize)>("maxComputeSharedMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupCount)>("maxComputeWorkGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupInvocations)>("maxComputeWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupSize)>("maxComputeWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subPixelPrecisionBits)>("subPixelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(subTexelPrecisionBits)>("subTexelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(mipmapPrecisionBits)>("mipmapPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndexedIndexValue)>("maxDrawIndexedIndexValue");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndirectCount)>("maxDrawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerLodBias)>("maxSamplerLodBias");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAnisotropy)>("maxSamplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(maxViewports)>("maxViewports");
        addField<DAS_BIND_MANAGED_FIELD(maxViewportDimensions)>("maxViewportDimensions");
        addField<DAS_BIND_MANAGED_FIELD(viewportBoundsRange)>("viewportBoundsRange");
        addField<DAS_BIND_MANAGED_FIELD(viewportSubPixelBits)>("viewportSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(minMemoryMapAlignment)>("minMemoryMapAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelBufferOffsetAlignment)>("minTexelBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minUniformBufferOffsetAlignment)>("minUniformBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minStorageBufferOffsetAlignment)>("minStorageBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelOffset)>("minTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelOffset)>("maxTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(minTexelGatherOffset)>("minTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelGatherOffset)>("maxTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(minInterpolationOffset)>("minInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxInterpolationOffset)>("maxInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(subPixelInterpolationOffsetBits)>("subPixelInterpolationOffsetBits");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferWidth)>("maxFramebufferWidth");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferHeight)>("maxFramebufferHeight");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferLayers)>("maxFramebufferLayers");
        addField<DAS_BIND_MANAGED_FIELD(framebufferColorSampleCounts)>("framebufferColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferDepthSampleCounts)>("framebufferDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferStencilSampleCounts)>("framebufferStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferNoAttachmentsSampleCounts)>("framebufferNoAttachmentsSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxColorAttachments)>("maxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageColorSampleCounts)>("sampledImageColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageIntegerSampleCounts)>("sampledImageIntegerSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageDepthSampleCounts)>("sampledImageDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageStencilSampleCounts)>("sampledImageStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(storageImageSampleCounts)>("storageImageSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleMaskWords)>("maxSampleMaskWords");
        addField<DAS_BIND_MANAGED_FIELD(timestampComputeAndGraphics)>("timestampComputeAndGraphics");
        addField<DAS_BIND_MANAGED_FIELD(timestampPeriod)>("timestampPeriod");
        addField<DAS_BIND_MANAGED_FIELD(maxClipDistances)>("maxClipDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCullDistances)>("maxCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCombinedClipAndCullDistances)>("maxCombinedClipAndCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(discreteQueuePriorities)>("discreteQueuePriorities");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeRange)>("pointSizeRange");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthRange)>("lineWidthRange");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeGranularity)>("pointSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthGranularity)>("lineWidthGranularity");
        addField<DAS_BIND_MANAGED_FIELD(strictLines)>("strictLines");
        addField<DAS_BIND_MANAGED_FIELD(standardSampleLocations)>("standardSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyOffsetAlignment)>("optimalBufferCopyOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyRowPitchAlignment)>("optimalBufferCopyRowPitchAlignment");
        addField<DAS_BIND_MANAGED_FIELD(nonCoherentAtomSize)>("nonCoherentAtomSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryProperties, VkPhysicalDeviceMemoryProperties);

struct VkPhysicalDeviceMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryProperties,true,true> {
    VkPhysicalDeviceMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeCount)>("memoryTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypes)>("memoryTypes");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeapCount)>("memoryHeapCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeaps)>("memoryHeaps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSparseProperties, VkPhysicalDeviceSparseProperties);

struct VkPhysicalDeviceSparsePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseProperties,true,true> {
    VkPhysicalDeviceSparsePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DBlockShape)>("residencyStandard2DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DMultisampleBlockShape)>("residencyStandard2DMultisampleBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard3DBlockShape)>("residencyStandard3DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyAlignedMipSize)>("residencyAlignedMipSize");
        addField<DAS_BIND_MANAGED_FIELD(residencyNonResidentStrict)>("residencyNonResidentStrict");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProperties, VkPhysicalDeviceProperties);

struct VkPhysicalDevicePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProperties,true,true> {
    VkPhysicalDevicePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
        addField<DAS_BIND_MANAGED_FIELD(driverVersion)>("driverVersion");
        addField<DAS_BIND_MANAGED_FIELD(vendorID)>("vendorID");
        addField<DAS_BIND_MANAGED_FIELD(deviceID)>("deviceID");
        addField<DAS_BIND_MANAGED_FIELD(deviceType)>("deviceType");
        addField<DAS_BIND_MANAGED_FIELD(deviceName)>("deviceName");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCacheUUID)>("pipelineCacheUUID");
        addField<DAS_BIND_MANAGED_FIELD(limits)>("limits");
        addField<DAS_BIND_MANAGED_FIELD(sparseProperties)>("sparseProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyProperties, VkQueueFamilyProperties);

struct VkQueueFamilyPropertiesAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyProperties,true,true> {
    VkQueueFamilyPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(queueFlags)>("queueFlags");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(timestampValidBits)>("timestampValidBits");
        addField<DAS_BIND_MANAGED_FIELD(minImageTransferGranularity)>("minImageTransferGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueCreateInfo, VkDeviceQueueCreateInfo);

struct VkDeviceQueueCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueCreateInfo,true,true> {
    VkDeviceQueueCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueuePriorities)>("pQueuePriorities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceCreateInfo, VkDeviceCreateInfo);

struct VkDeviceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceCreateInfo,true,true> {
    VkDeviceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueCreateInfoCount)>("queueCreateInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueCreateInfos)>("pQueueCreateInfos");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledFeatures)>("pEnabledFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtensionProperties, VkExtensionProperties);

struct VkExtensionPropertiesAnnotation
: public ManagedStructureAnnotation<VkExtensionProperties,true,true> {
    VkExtensionPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtensionProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(extensionName)>("extensionName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkLayerProperties, VkLayerProperties);

struct VkLayerPropertiesAnnotation
: public ManagedStructureAnnotation<VkLayerProperties,true,true> {
    VkLayerPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkLayerProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(layerName)>("layerName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
        addField<DAS_BIND_MANAGED_FIELD(implementationVersion)>("implementationVersion");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubmitInfo, VkSubmitInfo);

struct VkSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkSubmitInfo,true,true> {
    VkSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pWaitDstStageMask)>("pWaitDstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
        addField<DAS_BIND_MANAGED_FIELD(pCommandBuffers)>("pCommandBuffers");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMappedMemoryRange, VkMappedMemoryRange);

struct VkMappedMemoryRangeAnnotation
: public ManagedStructureAnnotation<VkMappedMemoryRange,true,true> {
    VkMappedMemoryRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMappedMemoryRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryAllocateInfo, VkMemoryAllocateInfo);

struct VkMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateInfo,true,true> {
    VkMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allocationSize)>("allocationSize");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeIndex)>("memoryTypeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryRequirements, VkMemoryRequirements);

struct VkMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryRequirements,true,true> {
    VkMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(alignment)>("alignment");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseMemoryBind, VkSparseMemoryBind);

struct VkSparseMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseMemoryBind,true,true> {
    VkSparseMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(resourceOffset)>("resourceOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseBufferMemoryBindInfo, VkSparseBufferMemoryBindInfo);

struct VkSparseBufferMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseBufferMemoryBindInfo,true,true> {
    VkSparseBufferMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseBufferMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageOpaqueMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo);

struct VkSparseImageOpaqueMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageOpaqueMemoryBindInfo,true,true> {
    VkSparseImageOpaqueMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageOpaqueMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresource, VkImageSubresource);

struct VkImageSubresourceAnnotation
: public ManagedStructureAnnotation<VkImageSubresource,true,true> {
    VkImageSubresourceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresource", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayer)>("arrayLayer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBind, VkSparseImageMemoryBind);

struct VkSparseImageMemoryBindAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBind,true,true> {
    VkSparseImageMemoryBindAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBind", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subresource)>("subresource");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryBindInfo, VkSparseImageMemoryBindInfo);

struct VkSparseImageMemoryBindInfoAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryBindInfo,true,true> {
    VkSparseImageMemoryBindInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryBindInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(bindCount)>("bindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBinds)>("pBinds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindSparseInfo, VkBindSparseInfo);

struct VkBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkBindSparseInfo,true,true> {
    VkBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(bufferBindCount)>("bufferBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pBufferBinds)>("pBufferBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageOpaqueBindCount)>("imageOpaqueBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageOpaqueBinds)>("pImageOpaqueBinds");
        addField<DAS_BIND_MANAGED_FIELD(imageBindCount)>("imageBindCount");
        addField<DAS_BIND_MANAGED_FIELD(pImageBinds)>("pImageBinds");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageFormatProperties, VkSparseImageFormatProperties);

struct VkSparseImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties,true,true> {
    VkSparseImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(imageGranularity)>("imageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryRequirements, VkSparseImageMemoryRequirements);

struct VkSparseImageMemoryRequirementsAnnotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements,true,true> {
    VkSparseImageMemoryRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailFirstLod)>("imageMipTailFirstLod");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailSize)>("imageMipTailSize");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailOffset)>("imageMipTailOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageMipTailStride)>("imageMipTailStride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFenceCreateInfo, VkFenceCreateInfo);

struct VkFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFenceCreateInfo,true,true> {
    VkFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreCreateInfo, VkSemaphoreCreateInfo);

struct VkSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreCreateInfo,true,true> {
    VkSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkEventCreateInfo, VkEventCreateInfo);

struct VkEventCreateInfoAnnotation
: public ManagedStructureAnnotation<VkEventCreateInfo,true,true> {
    VkEventCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkEventCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolCreateInfo, VkQueryPoolCreateInfo);

struct VkQueryPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkQueryPoolCreateInfo,true,true> {
    VkQueryPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queryType)>("queryType");
        addField<DAS_BIND_MANAGED_FIELD(queryCount)>("queryCount");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCreateInfo, VkBufferCreateInfo);

struct VkBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferCreateInfo,true,true> {
    VkBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferViewCreateInfo, VkBufferViewCreateInfo);

struct VkBufferViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferViewCreateInfo,true,true> {
    VkBufferViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageCreateInfo, VkImageCreateInfo);

struct VkImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageCreateInfo,true,true> {
    VkImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(imageType)>("imageType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(mipLevels)>("mipLevels");
        addField<DAS_BIND_MANAGED_FIELD(arrayLayers)>("arrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubresourceLayout, VkSubresourceLayout);

struct VkSubresourceLayoutAnnotation
: public ManagedStructureAnnotation<VkSubresourceLayout,true,true> {
    VkSubresourceLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubresourceLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(rowPitch)>("rowPitch");
        addField<DAS_BIND_MANAGED_FIELD(arrayPitch)>("arrayPitch");
        addField<DAS_BIND_MANAGED_FIELD(depthPitch)>("depthPitch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComponentMapping, VkComponentMapping);

struct VkComponentMappingAnnotation
: public ManagedStructureAnnotation<VkComponentMapping,true,true> {
    VkComponentMappingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComponentMapping", ml) {
        addField<DAS_BIND_MANAGED_FIELD(r)>("r");
        addField<DAS_BIND_MANAGED_FIELD(g)>("g");
        addField<DAS_BIND_MANAGED_FIELD(b)>("b");
        addField<DAS_BIND_MANAGED_FIELD(a)>("a");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewCreateInfo, VkImageViewCreateInfo);

struct VkImageViewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewCreateInfo,true,true> {
    VkImageViewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(viewType)>("viewType");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModuleCreateInfo, VkShaderModuleCreateInfo);

struct VkShaderModuleCreateInfoAnnotation
: public ManagedStructureAnnotation<VkShaderModuleCreateInfo,true,true> {
    VkShaderModuleCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(codeSize)>("codeSize");
        addField<DAS_BIND_MANAGED_FIELD(pCode)>("pCode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCacheCreateInfo, VkPipelineCacheCreateInfo);

struct VkPipelineCacheCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineCacheCreateInfo,true,true> {
    VkPipelineCacheCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCacheCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationMapEntry, VkSpecializationMapEntry);

struct VkSpecializationMapEntryAnnotation
: public ManagedStructureAnnotation<VkSpecializationMapEntry,true,true> {
    VkSpecializationMapEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationMapEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(constantID)>("constantID");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSpecializationInfo, VkSpecializationInfo);

struct VkSpecializationInfoAnnotation
: public ManagedStructureAnnotation<VkSpecializationInfo,true,true> {
    VkSpecializationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSpecializationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(mapEntryCount)>("mapEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pMapEntries)>("pMapEntries");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageCreateInfo, VkPipelineShaderStageCreateInfo);

struct VkPipelineShaderStageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageCreateInfo,true,true> {
    VkPipelineShaderStageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(module)>("module_");
        addField<DAS_BIND_MANAGED_FIELD(pName)>("pName");
        addField<DAS_BIND_MANAGED_FIELD(pSpecializationInfo)>("pSpecializationInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkComputePipelineCreateInfo, VkComputePipelineCreateInfo);

struct VkComputePipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkComputePipelineCreateInfo,true,true> {
    VkComputePipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkComputePipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDescription, VkVertexInputBindingDescription);

struct VkVertexInputBindingDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDescription,true,true> {
    VkVertexInputBindingDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(inputRate)>("inputRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputAttributeDescription, VkVertexInputAttributeDescription);

struct VkVertexInputAttributeDescriptionAnnotation
: public ManagedStructureAnnotation<VkVertexInputAttributeDescription,true,true> {
    VkVertexInputAttributeDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputAttributeDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(location)>("location");
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputStateCreateInfo, VkPipelineVertexInputStateCreateInfo);

struct VkPipelineVertexInputStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputStateCreateInfo,true,true> {
    VkPipelineVertexInputStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDescriptionCount)>("vertexBindingDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDescriptions)>("pVertexBindingDescriptions");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeDescriptionCount)>("vertexAttributeDescriptionCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexAttributeDescriptions)>("pVertexAttributeDescriptions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineInputAssemblyStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo);

struct VkPipelineInputAssemblyStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineInputAssemblyStateCreateInfo,true,true> {
    VkPipelineInputAssemblyStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInputAssemblyStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(topology)>("topology");
        addField<DAS_BIND_MANAGED_FIELD(primitiveRestartEnable)>("primitiveRestartEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineTessellationStateCreateInfo, VkPipelineTessellationStateCreateInfo);

struct VkPipelineTessellationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationStateCreateInfo,true,true> {
    VkPipelineTessellationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(patchControlPoints)>("patchControlPoints");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewport, VkViewport);

struct VkViewportAnnotation
: public ManagedStructureAnnotation<VkViewport,true,true> {
    VkViewportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(minDepth)>("minDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxDepth)>("maxDepth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportStateCreateInfo, VkPipelineViewportStateCreateInfo);

struct VkPipelineViewportStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportStateCreateInfo,true,true> {
    VkPipelineViewportStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewports)>("pViewports");
        addField<DAS_BIND_MANAGED_FIELD(scissorCount)>("scissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pScissors)>("pScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateCreateInfo, VkPipelineRasterizationStateCreateInfo);

struct VkPipelineRasterizationStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateCreateInfo,true,true> {
    VkPipelineRasterizationStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClampEnable)>("depthClampEnable");
        addField<DAS_BIND_MANAGED_FIELD(rasterizerDiscardEnable)>("rasterizerDiscardEnable");
        addField<DAS_BIND_MANAGED_FIELD(polygonMode)>("polygonMode");
        addField<DAS_BIND_MANAGED_FIELD(cullMode)>("cullMode");
        addField<DAS_BIND_MANAGED_FIELD(frontFace)>("frontFace");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasEnable)>("depthBiasEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasConstantFactor)>("depthBiasConstantFactor");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasSlopeFactor)>("depthBiasSlopeFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineWidth)>("lineWidth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineMultisampleStateCreateInfo, VkPipelineMultisampleStateCreateInfo);

struct VkPipelineMultisampleStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineMultisampleStateCreateInfo,true,true> {
    VkPipelineMultisampleStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineMultisampleStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(sampleShadingEnable)>("sampleShadingEnable");
        addField<DAS_BIND_MANAGED_FIELD(minSampleShading)>("minSampleShading");
        addField<DAS_BIND_MANAGED_FIELD(pSampleMask)>("pSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(alphaToCoverageEnable)>("alphaToCoverageEnable");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOneEnable)>("alphaToOneEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkStencilOpState, VkStencilOpState);

struct VkStencilOpStateAnnotation
: public ManagedStructureAnnotation<VkStencilOpState,true,true> {
    VkStencilOpStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStencilOpState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(failOp)>("failOp");
        addField<DAS_BIND_MANAGED_FIELD(passOp)>("passOp");
        addField<DAS_BIND_MANAGED_FIELD(depthFailOp)>("depthFailOp");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(compareMask)>("compareMask");
        addField<DAS_BIND_MANAGED_FIELD(writeMask)>("writeMask");
        addField<DAS_BIND_MANAGED_FIELD(reference)>("reference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDepthStencilStateCreateInfo, VkPipelineDepthStencilStateCreateInfo);

struct VkPipelineDepthStencilStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDepthStencilStateCreateInfo,true,true> {
    VkPipelineDepthStencilStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDepthStencilStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthTestEnable)>("depthTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthWriteEnable)>("depthWriteEnable");
        addField<DAS_BIND_MANAGED_FIELD(depthCompareOp)>("depthCompareOp");
        addField<DAS_BIND_MANAGED_FIELD(depthBoundsTestEnable)>("depthBoundsTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(stencilTestEnable)>("stencilTestEnable");
        addField<DAS_BIND_MANAGED_FIELD(front)>("front");
        addField<DAS_BIND_MANAGED_FIELD(back)>("back");
        addField<DAS_BIND_MANAGED_FIELD(minDepthBounds)>("minDepthBounds");
        addField<DAS_BIND_MANAGED_FIELD(maxDepthBounds)>("maxDepthBounds");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendAttachmentState, VkPipelineColorBlendAttachmentState);

struct VkPipelineColorBlendAttachmentStateAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAttachmentState,true,true> {
    VkPipelineColorBlendAttachmentStateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAttachmentState", ml) {
        addField<DAS_BIND_MANAGED_FIELD(blendEnable)>("blendEnable");
        addField<DAS_BIND_MANAGED_FIELD(srcColorBlendFactor)>("srcColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstColorBlendFactor)>("dstColorBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(colorBlendOp)>("colorBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(srcAlphaBlendFactor)>("srcAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(dstAlphaBlendFactor)>("dstAlphaBlendFactor");
        addField<DAS_BIND_MANAGED_FIELD(alphaBlendOp)>("alphaBlendOp");
        addField<DAS_BIND_MANAGED_FIELD(colorWriteMask)>("colorWriteMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendStateCreateInfo, VkPipelineColorBlendStateCreateInfo);

struct VkPipelineColorBlendStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendStateCreateInfo,true,true> {
    VkPipelineColorBlendStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(logicOpEnable)>("logicOpEnable");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(blendConstants)>("blendConstants");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDynamicStateCreateInfo, VkPipelineDynamicStateCreateInfo);

struct VkPipelineDynamicStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineDynamicStateCreateInfo,true,true> {
    VkPipelineDynamicStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDynamicStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(dynamicStateCount)>("dynamicStateCount");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicStates)>("pDynamicStates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsPipelineCreateInfo, VkGraphicsPipelineCreateInfo);

struct VkGraphicsPipelineCreateInfoAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineCreateInfo,true,true> {
    VkGraphicsPipelineCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pInputAssemblyState)>("pInputAssemblyState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
        addField<DAS_BIND_MANAGED_FIELD(pViewportState)>("pViewportState");
        addField<DAS_BIND_MANAGED_FIELD(pRasterizationState)>("pRasterizationState");
        addField<DAS_BIND_MANAGED_FIELD(pMultisampleState)>("pMultisampleState");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilState)>("pDepthStencilState");
        addField<DAS_BIND_MANAGED_FIELD(pColorBlendState)>("pColorBlendState");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPushConstantRange, VkPushConstantRange);

struct VkPushConstantRangeAnnotation
: public ManagedStructureAnnotation<VkPushConstantRange,true,true> {
    VkPushConstantRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPushConstantRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayoutCreateInfo, VkPipelineLayoutCreateInfo);

struct VkPipelineLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineLayoutCreateInfo,true,true> {
    VkPipelineLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(setLayoutCount)>("setLayoutCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
        addField<DAS_BIND_MANAGED_FIELD(pushConstantRangeCount)>("pushConstantRangeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPushConstantRanges)>("pPushConstantRanges");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerCreateInfo, VkSamplerCreateInfo);

struct VkSamplerCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerCreateInfo,true,true> {
    VkSamplerCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(magFilter)>("magFilter");
        addField<DAS_BIND_MANAGED_FIELD(minFilter)>("minFilter");
        addField<DAS_BIND_MANAGED_FIELD(mipmapMode)>("mipmapMode");
        addField<DAS_BIND_MANAGED_FIELD(addressModeU)>("addressModeU");
        addField<DAS_BIND_MANAGED_FIELD(addressModeV)>("addressModeV");
        addField<DAS_BIND_MANAGED_FIELD(addressModeW)>("addressModeW");
        addField<DAS_BIND_MANAGED_FIELD(mipLodBias)>("mipLodBias");
        addField<DAS_BIND_MANAGED_FIELD(anisotropyEnable)>("anisotropyEnable");
        addField<DAS_BIND_MANAGED_FIELD(maxAnisotropy)>("maxAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(compareEnable)>("compareEnable");
        addField<DAS_BIND_MANAGED_FIELD(compareOp)>("compareOp");
        addField<DAS_BIND_MANAGED_FIELD(minLod)>("minLod");
        addField<DAS_BIND_MANAGED_FIELD(maxLod)>("maxLod");
        addField<DAS_BIND_MANAGED_FIELD(borderColor)>("borderColor");
        addField<DAS_BIND_MANAGED_FIELD(unnormalizedCoordinates)>("unnormalizedCoordinates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyDescriptorSet, VkCopyDescriptorSet);

struct VkCopyDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkCopyDescriptorSet,true,true> {
    VkCopyDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSet)>("srcSet");
        addField<DAS_BIND_MANAGED_FIELD(srcBinding)>("srcBinding");
        addField<DAS_BIND_MANAGED_FIELD(srcArrayElement)>("srcArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorBufferInfo, VkDescriptorBufferInfo);

struct VkDescriptorBufferInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorBufferInfo,true,true> {
    VkDescriptorBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(range)>("range_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorImageInfo, VkDescriptorImageInfo);

struct VkDescriptorImageInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorImageInfo,true,true> {
    VkDescriptorImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(imageLayout)>("imageLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolSize, VkDescriptorPoolSize);

struct VkDescriptorPoolSizeAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolSize,true,true> {
    VkDescriptorPoolSizeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolSize", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolCreateInfo, VkDescriptorPoolCreateInfo);

struct VkDescriptorPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolCreateInfo,true,true> {
    VkDescriptorPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(maxSets)>("maxSets");
        addField<DAS_BIND_MANAGED_FIELD(poolSizeCount)>("poolSizeCount");
        addField<DAS_BIND_MANAGED_FIELD(pPoolSizes)>("pPoolSizes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetAllocateInfo, VkDescriptorSetAllocateInfo);

struct VkDescriptorSetAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetAllocateInfo,true,true> {
    VkDescriptorSetAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorPool)>("descriptorPool");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pSetLayouts)>("pSetLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutBinding, VkDescriptorSetLayoutBinding);

struct VkDescriptorSetLayoutBindingAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBinding,true,true> {
    VkDescriptorSetLayoutBindingAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBinding", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(stageFlags)>("stageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pImmutableSamplers)>("pImmutableSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutCreateInfo);

struct VkDescriptorSetLayoutCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutCreateInfo,true,true> {
    VkDescriptorSetLayoutCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindings)>("pBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSet, VkWriteDescriptorSet);

struct VkWriteDescriptorSetAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSet,true,true> {
    VkWriteDescriptorSetAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSet", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dstSet)>("dstSet");
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(pImageInfo)>("pImageInfo");
        addField<DAS_BIND_MANAGED_FIELD(pBufferInfo)>("pBufferInfo");
        addField<DAS_BIND_MANAGED_FIELD(pTexelBufferView)>("pTexelBufferView");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescription, VkAttachmentDescription);

struct VkAttachmentDescriptionAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescription,true,true> {
    VkAttachmentDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReference, VkAttachmentReference);

struct VkAttachmentReferenceAnnotation
: public ManagedStructureAnnotation<VkAttachmentReference,true,true> {
    VkAttachmentReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferCreateInfo, VkFramebufferCreateInfo);

struct VkFramebufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferCreateInfo,true,true> {
    VkFramebufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layers)>("layers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescription, VkSubpassDescription);

struct VkSubpassDescriptionAnnotation
: public ManagedStructureAnnotation<VkSubpassDescription,true,true> {
    VkSubpassDescriptionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDependency, VkSubpassDependency);

struct VkSubpassDependencyAnnotation
: public ManagedStructureAnnotation<VkSubpassDependency,true,true> {
    VkSubpassDependencyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassCreateInfo, VkRenderPassCreateInfo);

struct VkRenderPassCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo,true,true> {
    VkRenderPassCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandPoolCreateInfo, VkCommandPoolCreateInfo);

struct VkCommandPoolCreateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandPoolCreateInfo,true,true> {
    VkCommandPoolCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandPoolCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferAllocateInfo, VkCommandBufferAllocateInfo);

struct VkCommandBufferAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferAllocateInfo,true,true> {
    VkCommandBufferAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(commandPool)>("commandPool");
        addField<DAS_BIND_MANAGED_FIELD(level)>("level");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceInfo, VkCommandBufferInheritanceInfo);

struct VkCommandBufferInheritanceInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceInfo,true,true> {
    VkCommandBufferInheritanceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryEnable)>("occlusionQueryEnable");
        addField<DAS_BIND_MANAGED_FIELD(queryFlags)>("queryFlags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatistics)>("pipelineStatistics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferBeginInfo, VkCommandBufferBeginInfo);

struct VkCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkCommandBufferBeginInfo,true,true> {
    VkCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pInheritanceInfo)>("pInheritanceInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCopy, VkBufferCopy);

struct VkBufferCopyAnnotation
: public ManagedStructureAnnotation<VkBufferCopy,true,true> {
    VkBufferCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresourceLayers, VkImageSubresourceLayers);

struct VkImageSubresourceLayersAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceLayers,true,true> {
    VkImageSubresourceLayersAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceLayers", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(mipLevel)>("mipLevel");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferImageCopy, VkBufferImageCopy);

struct VkBufferImageCopyAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy,true,true> {
    VkBufferImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearColorValue, VkClearColorValue);

struct VkClearColorValueAnnotation
: public ManagedStructureAnnotation<VkClearColorValue,true,true> {
    VkClearColorValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearColorValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearDepthStencilValue, VkClearDepthStencilValue);

struct VkClearDepthStencilValueAnnotation
: public ManagedStructureAnnotation<VkClearDepthStencilValue,true,true> {
    VkClearDepthStencilValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearDepthStencilValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
        addField<DAS_BIND_MANAGED_FIELD(stencil)>("stencil");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearValue, VkClearValue);

struct VkClearValueAnnotation
: public ManagedStructureAnnotation<VkClearValue,true,true> {
    VkClearValueAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearValue", ml) {
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
        addField<DAS_BIND_MANAGED_FIELD(depthStencil)>("depthStencil");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearAttachment, VkClearAttachment);

struct VkClearAttachmentAnnotation
: public ManagedStructureAnnotation<VkClearAttachment,true,true> {
    VkClearAttachmentAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearAttachment", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachment)>("colorAttachment");
        addField<DAS_BIND_MANAGED_FIELD(clearValue)>("clearValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkClearRect, VkClearRect);

struct VkClearRectAnnotation
: public ManagedStructureAnnotation<VkClearRect,true,true> {
    VkClearRectAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkClearRect", ml) {
        addField<DAS_BIND_MANAGED_FIELD(rect)>("rect");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageBlit, VkImageBlit);

struct VkImageBlitAnnotation
: public ManagedStructureAnnotation<VkImageBlit,true,true> {
    VkImageBlitAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageBlit", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffsets)>("srcOffsets");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffsets)>("dstOffsets");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageCopy, VkImageCopy);

struct VkImageCopyAnnotation
: public ManagedStructureAnnotation<VkImageCopy,true,true> {
    VkImageCopyAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCopy", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageResolve, VkImageResolve);

struct VkImageResolveAnnotation
: public ManagedStructureAnnotation<VkImageResolve,true,true> {
    VkImageResolveAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageResolve", ml) {
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassBeginInfo, VkRenderPassBeginInfo);

struct VkRenderPassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassBeginInfo,true,true> {
    VkRenderPassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(renderPass)>("renderPass");
        addField<DAS_BIND_MANAGED_FIELD(framebuffer)>("framebuffer");
        addField<DAS_BIND_MANAGED_FIELD(renderArea)>("renderArea");
        addField<DAS_BIND_MANAGED_FIELD(clearValueCount)>("clearValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pClearValues)>("pClearValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupProperties);

struct VkPhysicalDeviceSubgroupPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupProperties,true,true> {
    VkPhysicalDeviceSubgroupPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(supportedStages)>("supportedStages");
        addField<DAS_BIND_MANAGED_FIELD(supportedOperations)>("supportedOperations");
        addField<DAS_BIND_MANAGED_FIELD(quadOperationsInAllStages)>("quadOperationsInAllStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindBufferMemoryInfo, VkBindBufferMemoryInfo);

struct VkBindBufferMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindBufferMemoryInfo,true,true> {
    VkBindBufferMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindBufferMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImageMemoryInfo, VkBindImageMemoryInfo);

struct VkBindImageMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindImageMemoryInfo,true,true> {
    VkBindImageMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice16BitStorageFeatures);

struct VkPhysicalDevice16BitStorageFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice16BitStorageFeatures,true,true> {
    VkPhysicalDevice16BitStorageFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice16BitStorageFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer16BitAccess)>("storageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer16BitAccess)>("uniformAndStorageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant16)>("storagePushConstant16");
        addField<DAS_BIND_MANAGED_FIELD(storageInputOutput16)>("storageInputOutput16");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryDedicatedRequirements, VkMemoryDedicatedRequirements);

struct VkMemoryDedicatedRequirementsAnnotation
: public ManagedStructureAnnotation<VkMemoryDedicatedRequirements,true,true> {
    VkMemoryDedicatedRequirementsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryDedicatedRequirements", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(prefersDedicatedAllocation)>("prefersDedicatedAllocation");
        addField<DAS_BIND_MANAGED_FIELD(requiresDedicatedAllocation)>("requiresDedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryDedicatedAllocateInfo, VkMemoryDedicatedAllocateInfo);

struct VkMemoryDedicatedAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryDedicatedAllocateInfo,true,true> {
    VkMemoryDedicatedAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryDedicatedAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryAllocateFlagsInfo, VkMemoryAllocateFlagsInfo);

struct VkMemoryAllocateFlagsInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateFlagsInfo,true,true> {
    VkMemoryAllocateFlagsInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateFlagsInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupRenderPassBeginInfo, VkDeviceGroupRenderPassBeginInfo);

struct VkDeviceGroupRenderPassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupRenderPassBeginInfo,true,true> {
    VkDeviceGroupRenderPassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupRenderPassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceRenderAreaCount)>("deviceRenderAreaCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceRenderAreas)>("pDeviceRenderAreas");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupCommandBufferBeginInfo, VkDeviceGroupCommandBufferBeginInfo);

struct VkDeviceGroupCommandBufferBeginInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupCommandBufferBeginInfo,true,true> {
    VkDeviceGroupCommandBufferBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupCommandBufferBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupSubmitInfo, VkDeviceGroupSubmitInfo);

struct VkDeviceGroupSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupSubmitInfo,true,true> {
    VkDeviceGroupSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreDeviceIndices)>("pWaitSemaphoreDeviceIndices");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
        addField<DAS_BIND_MANAGED_FIELD(pCommandBufferDeviceMasks)>("pCommandBufferDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreDeviceIndices)>("pSignalSemaphoreDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupBindSparseInfo, VkDeviceGroupBindSparseInfo);

struct VkDeviceGroupBindSparseInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupBindSparseInfo,true,true> {
    VkDeviceGroupBindSparseInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupBindSparseInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(resourceDeviceIndex)>("resourceDeviceIndex");
        addField<DAS_BIND_MANAGED_FIELD(memoryDeviceIndex)>("memoryDeviceIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindBufferMemoryDeviceGroupInfo, VkBindBufferMemoryDeviceGroupInfo);

struct VkBindBufferMemoryDeviceGroupInfoAnnotation
: public ManagedStructureAnnotation<VkBindBufferMemoryDeviceGroupInfo,true,true> {
    VkBindBufferMemoryDeviceGroupInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindBufferMemoryDeviceGroupInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImageMemoryDeviceGroupInfo, VkBindImageMemoryDeviceGroupInfo);

struct VkBindImageMemoryDeviceGroupInfoAnnotation
: public ManagedStructureAnnotation<VkBindImageMemoryDeviceGroupInfo,true,true> {
    VkBindImageMemoryDeviceGroupInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemoryDeviceGroupInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
        addField<DAS_BIND_MANAGED_FIELD(splitInstanceBindRegionCount)>("splitInstanceBindRegionCount");
        addField<DAS_BIND_MANAGED_FIELD(pSplitInstanceBindRegions)>("pSplitInstanceBindRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceGroupProperties, VkPhysicalDeviceGroupProperties);

struct VkPhysicalDeviceGroupPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceGroupProperties,true,true> {
    VkPhysicalDeviceGroupPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceGroupProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(physicalDeviceCount)>("physicalDeviceCount");
        addField<DAS_BIND_MANAGED_FIELD(physicalDevices)>("physicalDevices");
        addField<DAS_BIND_MANAGED_FIELD(subsetAllocation)>("subsetAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupDeviceCreateInfo, VkDeviceGroupDeviceCreateInfo);

struct VkDeviceGroupDeviceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupDeviceCreateInfo,true,true> {
    VkDeviceGroupDeviceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupDeviceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(physicalDeviceCount)>("physicalDeviceCount");
        addField<DAS_BIND_MANAGED_FIELD(pPhysicalDevices)>("pPhysicalDevices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferMemoryRequirementsInfo2, VkBufferMemoryRequirementsInfo2);

struct VkBufferMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkBufferMemoryRequirementsInfo2,true,true> {
    VkBufferMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageMemoryRequirementsInfo2, VkImageMemoryRequirementsInfo2);

struct VkImageMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkImageMemoryRequirementsInfo2,true,true> {
    VkImageMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSparseMemoryRequirementsInfo2, VkImageSparseMemoryRequirementsInfo2);

struct VkImageSparseMemoryRequirementsInfo2Annotation
: public ManagedStructureAnnotation<VkImageSparseMemoryRequirementsInfo2,true,true> {
    VkImageSparseMemoryRequirementsInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSparseMemoryRequirementsInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryRequirements2, VkMemoryRequirements2);

struct VkMemoryRequirements2Annotation
: public ManagedStructureAnnotation<VkMemoryRequirements2,true,true> {
    VkMemoryRequirements2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryRequirements2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryRequirements)>("memoryRequirements");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageMemoryRequirements2, VkSparseImageMemoryRequirements2);

struct VkSparseImageMemoryRequirements2Annotation
: public ManagedStructureAnnotation<VkSparseImageMemoryRequirements2,true,true> {
    VkSparseImageMemoryRequirements2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageMemoryRequirements2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryRequirements)>("memoryRequirements");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFeatures2, VkPhysicalDeviceFeatures2);

struct VkPhysicalDeviceFeatures2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFeatures2,true,true> {
    VkPhysicalDeviceFeatures2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFeatures2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(features)>("features");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProperties2, VkPhysicalDeviceProperties2);

struct VkPhysicalDeviceProperties2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProperties2,true,true> {
    VkPhysicalDeviceProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(properties)>("properties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFormatProperties2, VkFormatProperties2);

struct VkFormatProperties2Annotation
: public ManagedStructureAnnotation<VkFormatProperties2,true,true> {
    VkFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(formatProperties)>("formatProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageFormatProperties2, VkImageFormatProperties2);

struct VkImageFormatProperties2Annotation
: public ManagedStructureAnnotation<VkImageFormatProperties2,true,true> {
    VkImageFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceImageFormatInfo2);

struct VkPhysicalDeviceImageFormatInfo2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageFormatInfo2,true,true> {
    VkPhysicalDeviceImageFormatInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageFormatInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyProperties2, VkQueueFamilyProperties2);

struct VkQueueFamilyProperties2Annotation
: public ManagedStructureAnnotation<VkQueueFamilyProperties2,true,true> {
    VkQueueFamilyProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyProperties)>("queueFamilyProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryProperties2, VkPhysicalDeviceMemoryProperties2);

struct VkPhysicalDeviceMemoryProperties2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryProperties2,true,true> {
    VkPhysicalDeviceMemoryProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryProperties)>("memoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageFormatProperties2, VkSparseImageFormatProperties2);

struct VkSparseImageFormatProperties2Annotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties2,true,true> {
    VkSparseImageFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(properties)>("properties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSparseImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2);

struct VkPhysicalDeviceSparseImageFormatInfo2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseImageFormatInfo2,true,true> {
    VkPhysicalDeviceSparseImageFormatInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseImageFormatInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePointClippingProperties);

struct VkPhysicalDevicePointClippingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePointClippingProperties,true,true> {
    VkPhysicalDevicePointClippingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePointClippingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInputAttachmentAspectReference, VkInputAttachmentAspectReference);

struct VkInputAttachmentAspectReferenceAnnotation
: public ManagedStructureAnnotation<VkInputAttachmentAspectReference,true,true> {
    VkInputAttachmentAspectReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInputAttachmentAspectReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentIndex)>("inputAttachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassInputAttachmentAspectCreateInfo, VkRenderPassInputAttachmentAspectCreateInfo);

struct VkRenderPassInputAttachmentAspectCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassInputAttachmentAspectCreateInfo,true,true> {
    VkRenderPassInputAttachmentAspectCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassInputAttachmentAspectCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(aspectReferenceCount)>("aspectReferenceCount");
        addField<DAS_BIND_MANAGED_FIELD(pAspectReferences)>("pAspectReferences");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewUsageCreateInfo, VkImageViewUsageCreateInfo);

struct VkImageViewUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewUsageCreateInfo,true,true> {
    VkImageViewUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineTessellationDomainOriginStateCreateInfo, VkPipelineTessellationDomainOriginStateCreateInfo);

struct VkPipelineTessellationDomainOriginStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationDomainOriginStateCreateInfo,true,true> {
    VkPipelineTessellationDomainOriginStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationDomainOriginStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(domainOrigin)>("domainOrigin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassMultiviewCreateInfo, VkRenderPassMultiviewCreateInfo);

struct VkRenderPassMultiviewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassMultiviewCreateInfo,true,true> {
    VkRenderPassMultiviewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassMultiviewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewMasks)>("pViewMasks");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewOffsets)>("pViewOffsets");
        addField<DAS_BIND_MANAGED_FIELD(correlationMaskCount)>("correlationMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelationMasks)>("pCorrelationMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewFeatures);

struct VkPhysicalDeviceMultiviewFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewFeatures,true,true> {
    VkPhysicalDeviceMultiviewFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceMultiviewProperties);

struct VkPhysicalDeviceMultiviewPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewProperties,true,true> {
    VkPhysicalDeviceMultiviewPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVariablePointersFeatures);

struct VkPhysicalDeviceVariablePointersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVariablePointersFeatures,true,true> {
    VkPhysicalDeviceVariablePointersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVariablePointersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProtectedMemoryFeatures);

struct VkPhysicalDeviceProtectedMemoryFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryFeatures,true,true> {
    VkPhysicalDeviceProtectedMemoryFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProtectedMemoryProperties);

struct VkPhysicalDeviceProtectedMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryProperties,true,true> {
    VkPhysicalDeviceProtectedMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueInfo2, VkDeviceQueueInfo2);

struct VkDeviceQueueInfo2Annotation
: public ManagedStructureAnnotation<VkDeviceQueueInfo2,true,true> {
    VkDeviceQueueInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueIndex)>("queueIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkProtectedSubmitInfo, VkProtectedSubmitInfo);

struct VkProtectedSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkProtectedSubmitInfo,true,true> {
    VkProtectedSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkProtectedSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedSubmit)>("protectedSubmit");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionCreateInfo, VkSamplerYcbcrConversionCreateInfo);

struct VkSamplerYcbcrConversionCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionCreateInfo,true,true> {
    VkSamplerYcbcrConversionCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrModel)>("ycbcrModel");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrRange)>("ycbcrRange");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(xChromaOffset)>("xChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(yChromaOffset)>("yChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(chromaFilter)>("chromaFilter");
        addField<DAS_BIND_MANAGED_FIELD(forceExplicitReconstruction)>("forceExplicitReconstruction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionInfo, VkSamplerYcbcrConversionInfo);

struct VkSamplerYcbcrConversionInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionInfo,true,true> {
    VkSamplerYcbcrConversionInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conversion)>("conversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImagePlaneMemoryInfo, VkBindImagePlaneMemoryInfo);

struct VkBindImagePlaneMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindImagePlaneMemoryInfo,true,true> {
    VkBindImagePlaneMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImagePlaneMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImagePlaneMemoryRequirementsInfo, VkImagePlaneMemoryRequirementsInfo);

struct VkImagePlaneMemoryRequirementsInfoAnnotation
: public ManagedStructureAnnotation<VkImagePlaneMemoryRequirementsInfo,true,true> {
    VkImagePlaneMemoryRequirementsInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImagePlaneMemoryRequirementsInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures);

struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerYcbcrConversionFeatures,true,true> {
    VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerYcbcrConversionFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionImageFormatProperties, VkSamplerYcbcrConversionImageFormatProperties);

struct VkSamplerYcbcrConversionImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionImageFormatProperties,true,true> {
    VkSamplerYcbcrConversionImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(combinedImageSamplerDescriptorCount)>("combinedImageSamplerDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplateEntry, VkDescriptorUpdateTemplateEntry);

struct VkDescriptorUpdateTemplateEntryAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateEntry,true,true> {
    VkDescriptorUpdateTemplateEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplateCreateInfo, VkDescriptorUpdateTemplateCreateInfo);

struct VkDescriptorUpdateTemplateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateCreateInfo,true,true> {
    VkDescriptorUpdateTemplateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(descriptorUpdateEntryCount)>("descriptorUpdateEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorUpdateEntries)>("pDescriptorUpdateEntries");
        addField<DAS_BIND_MANAGED_FIELD(templateType)>("templateType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetLayout)>("descriptorSetLayout");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipelineLayout)>("pipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(set)>("set");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryProperties, VkExternalMemoryProperties);

struct VkExternalMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryProperties,true,true> {
    VkExternalMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceExternalImageFormatInfo);

struct VkPhysicalDeviceExternalImageFormatInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalImageFormatInfo,true,true> {
    VkPhysicalDeviceExternalImageFormatInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalImageFormatInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalImageFormatProperties, VkExternalImageFormatProperties);

struct VkExternalImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatProperties,true,true> {
    VkExternalImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalBufferInfo, VkPhysicalDeviceExternalBufferInfo);

struct VkPhysicalDeviceExternalBufferInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalBufferInfo,true,true> {
    VkPhysicalDeviceExternalBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalBufferProperties, VkExternalBufferProperties);

struct VkExternalBufferPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalBufferProperties,true,true> {
    VkExternalBufferPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalBufferProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceIDProperties, VkPhysicalDeviceIDProperties);

struct VkPhysicalDeviceIDPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIDProperties,true,true> {
    VkPhysicalDeviceIDPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIDProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfo);

struct VkExternalMemoryImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfo,true,true> {
    VkExternalMemoryImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryBufferCreateInfo, VkExternalMemoryBufferCreateInfo);

struct VkExternalMemoryBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryBufferCreateInfo,true,true> {
    VkExternalMemoryBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfo);

struct VkExportMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfo,true,true> {
    VkExportMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalFenceInfo, VkPhysicalDeviceExternalFenceInfo);

struct VkPhysicalDeviceExternalFenceInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalFenceInfo,true,true> {
    VkPhysicalDeviceExternalFenceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalFenceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalFenceProperties, VkExternalFenceProperties);

struct VkExternalFencePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalFenceProperties,true,true> {
    VkExternalFencePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalFenceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalFenceFeatures)>("externalFenceFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportFenceCreateInfo, VkExportFenceCreateInfo);

struct VkExportFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportFenceCreateInfo,true,true> {
    VkExportFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportSemaphoreCreateInfo, VkExportSemaphoreCreateInfo);

struct VkExportSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportSemaphoreCreateInfo,true,true> {
    VkExportSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalSemaphoreInfo, VkPhysicalDeviceExternalSemaphoreInfo);

struct VkPhysicalDeviceExternalSemaphoreInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalSemaphoreInfo,true,true> {
    VkPhysicalDeviceExternalSemaphoreInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalSemaphoreInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalSemaphoreProperties, VkExternalSemaphoreProperties);

struct VkExternalSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalSemaphoreProperties,true,true> {
    VkExternalSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalSemaphoreFeatures)>("externalSemaphoreFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance3Properties);

struct VkPhysicalDeviceMaintenance3PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMaintenance3Properties,true,true> {
    VkPhysicalDeviceMaintenance3PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMaintenance3Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutSupport, VkDescriptorSetLayoutSupport);

struct VkDescriptorSetLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutSupport,true,true> {
    VkDescriptorSetLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supported)>("supported");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderDrawParametersFeatures);

struct VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDrawParametersFeatures,true,true> {
    VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDrawParametersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan11Features);

struct VkPhysicalDeviceVulkan11FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Features,true,true> {
    VkPhysicalDeviceVulkan11FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer16BitAccess)>("storageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer16BitAccess)>("uniformAndStorageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant16)>("storagePushConstant16");
        addField<DAS_BIND_MANAGED_FIELD(storageInputOutput16)>("storageInputOutput16");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan11Properties);

struct VkPhysicalDeviceVulkan11PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Properties,true,true> {
    VkPhysicalDeviceVulkan11PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedStages)>("subgroupSupportedStages");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedOperations)>("subgroupSupportedOperations");
        addField<DAS_BIND_MANAGED_FIELD(subgroupQuadOperationsInAllStages)>("subgroupQuadOperationsInAllStages");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan12Features);

struct VkPhysicalDeviceVulkan12FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Features,true,true> {
    VkPhysicalDeviceVulkan12FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerMirrorClampToEdge)>("samplerMirrorClampToEdge");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectCount)>("drawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
        addField<DAS_BIND_MANAGED_FIELD(descriptorIndexing)>("descriptorIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
        addField<DAS_BIND_MANAGED_FIELD(samplerFilterMinmax)>("samplerFilterMinmax");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputViewportIndex)>("shaderOutputViewportIndex");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputLayer)>("shaderOutputLayer");
        addField<DAS_BIND_MANAGED_FIELD(subgroupBroadcastDynamicId)>("subgroupBroadcastDynamicId");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkConformanceVersion, VkConformanceVersion);

struct VkConformanceVersionAnnotation
: public ManagedStructureAnnotation<VkConformanceVersion,true,true> {
    VkConformanceVersionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConformanceVersion", ml) {
        addField<DAS_BIND_MANAGED_FIELD(major)>("major");
        addField<DAS_BIND_MANAGED_FIELD(minor)>("minor");
        addField<DAS_BIND_MANAGED_FIELD(subminor)>("subminor");
        addField<DAS_BIND_MANAGED_FIELD(patch)>("patch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan12Properties);

struct VkPhysicalDeviceVulkan12PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Properties,true,true> {
    VkPhysicalDeviceVulkan12PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
        addField<DAS_BIND_MANAGED_FIELD(framebufferIntegerColorSampleCounts)>("framebufferIntegerColorSampleCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageFormatListCreateInfo, VkImageFormatListCreateInfo);

struct VkImageFormatListCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageFormatListCreateInfo,true,true> {
    VkImageFormatListCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatListCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescription2, VkAttachmentDescription2);

struct VkAttachmentDescription2Annotation
: public ManagedStructureAnnotation<VkAttachmentDescription2,true,true> {
    VkAttachmentDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReference2, VkAttachmentReference2);

struct VkAttachmentReference2Annotation
: public ManagedStructureAnnotation<VkAttachmentReference2,true,true> {
    VkAttachmentReference2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescription2, VkSubpassDescription2);

struct VkSubpassDescription2Annotation
: public ManagedStructureAnnotation<VkSubpassDescription2,true,true> {
    VkSubpassDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(viewMask)>("viewMask");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDependency2, VkSubpassDependency2);

struct VkSubpassDependency2Annotation
: public ManagedStructureAnnotation<VkSubpassDependency2,true,true> {
    VkSubpassDependency2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
        addField<DAS_BIND_MANAGED_FIELD(viewOffset)>("viewOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassCreateInfo2, VkRenderPassCreateInfo2);

struct VkRenderPassCreateInfo2Annotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo2,true,true> {
    VkRenderPassCreateInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
        addField<DAS_BIND_MANAGED_FIELD(correlatedViewMaskCount)>("correlatedViewMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelatedViewMasks)>("pCorrelatedViewMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassBeginInfo, VkSubpassBeginInfo);

struct VkSubpassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassBeginInfo,true,true> {
    VkSubpassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(contents)>("contents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassEndInfo, VkSubpassEndInfo);

struct VkSubpassEndInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassEndInfo,true,true> {
    VkSubpassEndInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassEndInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice8BitStorageFeatures, VkPhysicalDevice8BitStorageFeatures);

struct VkPhysicalDevice8BitStorageFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice8BitStorageFeatures,true,true> {
    VkPhysicalDevice8BitStorageFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice8BitStorageFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDriverProperties);

struct VkPhysicalDeviceDriverPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDriverProperties,true,true> {
    VkPhysicalDeviceDriverPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDriverProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderAtomicInt64Features);

struct VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicInt64Features,true,true> {
    VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicInt64Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderFloat16Int8Features);

struct VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderFloat16Int8Features,true,true> {
    VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderFloat16Int8Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFloatControlsProperties);

struct VkPhysicalDeviceFloatControlsPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFloatControlsProperties,true,true> {
    VkPhysicalDeviceFloatControlsPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFloatControlsProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutBindingFlagsCreateInfo, VkDescriptorSetLayoutBindingFlagsCreateInfo);

struct VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBindingFlagsCreateInfo,true,true> {
    VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBindingFlagsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindingFlags)>("pBindingFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorIndexingFeatures);

struct VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingFeatures,true,true> {
    VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDescriptorIndexingProperties);

struct VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingProperties,true,true> {
    VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountAllocateInfo, VkDescriptorSetVariableDescriptorCountAllocateInfo);

struct VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountAllocateInfo,true,true> {
    VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorCounts)>("pDescriptorCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountLayoutSupport, VkDescriptorSetVariableDescriptorCountLayoutSupport);

struct VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountLayoutSupport,true,true> {
    VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVariableDescriptorCount)>("maxVariableDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescriptionDepthStencilResolve, VkSubpassDescriptionDepthStencilResolve);

struct VkSubpassDescriptionDepthStencilResolveAnnotation
: public ManagedStructureAnnotation<VkSubpassDescriptionDepthStencilResolve,true,true> {
    VkSubpassDescriptionDepthStencilResolveAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescriptionDepthStencilResolve", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthResolveMode)>("depthResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(stencilResolveMode)>("stencilResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilResolveAttachment)>("pDepthStencilResolveAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDepthStencilResolveProperties);

struct VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthStencilResolveProperties,true,true> {
    VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthStencilResolveProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures);

struct VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceScalarBlockLayoutFeatures,true,true> {
    VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceScalarBlockLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageStencilUsageCreateInfo, VkImageStencilUsageCreateInfo);

struct VkImageStencilUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageStencilUsageCreateInfo,true,true> {
    VkImageStencilUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageStencilUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilUsage)>("stencilUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerReductionModeCreateInfo, VkSamplerReductionModeCreateInfo);

struct VkSamplerReductionModeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerReductionModeCreateInfo,true,true> {
    VkSamplerReductionModeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerReductionModeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(reductionMode)>("reductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceSamplerFilterMinmaxProperties);

struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerFilterMinmaxProperties,true,true> {
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerFilterMinmaxProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceVulkanMemoryModelFeatures);

struct VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkanMemoryModelFeatures,true,true> {
    VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkanMemoryModelFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceImagelessFramebufferFeatures);

struct VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImagelessFramebufferFeatures,true,true> {
    VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImagelessFramebufferFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentImageInfo, VkFramebufferAttachmentImageInfo);

struct VkFramebufferAttachmentImageInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentImageInfo,true,true> {
    VkFramebufferAttachmentImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentsCreateInfo, VkFramebufferAttachmentsCreateInfo);

struct VkFramebufferAttachmentsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentsCreateInfo,true,true> {
    VkFramebufferAttachmentsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentImageInfoCount)>("attachmentImageInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentImageInfos)>("pAttachmentImageInfos");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassAttachmentBeginInfo, VkRenderPassAttachmentBeginInfo);

struct VkRenderPassAttachmentBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassAttachmentBeginInfo,true,true> {
    VkRenderPassAttachmentBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassAttachmentBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);

struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceUniformBufferStandardLayoutFeatures,true,true> {
    VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceUniformBufferStandardLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,true,true> {
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,true,true> {
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReferenceStencilLayout, VkAttachmentReferenceStencilLayout);

struct VkAttachmentReferenceStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentReferenceStencilLayout,true,true> {
    VkAttachmentReferenceStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReferenceStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilLayout)>("stencilLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescriptionStencilLayout, VkAttachmentDescriptionStencilLayout);

struct VkAttachmentDescriptionStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescriptionStencilLayout,true,true> {
    VkAttachmentDescriptionStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescriptionStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilInitialLayout)>("stencilInitialLayout");
        addField<DAS_BIND_MANAGED_FIELD(stencilFinalLayout)>("stencilFinalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceHostQueryResetFeatures);

struct VkPhysicalDeviceHostQueryResetFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceHostQueryResetFeatures,true,true> {
    VkPhysicalDeviceHostQueryResetFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceHostQueryResetFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures);

struct VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreFeatures,true,true> {
    VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTimelineSemaphoreProperties);

struct VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreProperties,true,true> {
    VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreTypeCreateInfo, VkSemaphoreTypeCreateInfo);

struct VkSemaphoreTypeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreTypeCreateInfo,true,true> {
    VkSemaphoreTypeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreTypeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreType)>("semaphoreType");
        addField<DAS_BIND_MANAGED_FIELD(initialValue)>("initialValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTimelineSemaphoreSubmitInfo, VkTimelineSemaphoreSubmitInfo);

struct VkTimelineSemaphoreSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkTimelineSemaphoreSubmitInfo,true,true> {
    VkTimelineSemaphoreSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTimelineSemaphoreSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreValueCount)>("waitSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreValues)>("pWaitSemaphoreValues");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreValueCount)>("signalSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreValues)>("pSignalSemaphoreValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreWaitInfo, VkSemaphoreWaitInfo);

struct VkSemaphoreWaitInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreWaitInfo,true,true> {
    VkSemaphoreWaitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreWaitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreCount)>("semaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSemaphores)>("pSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pValues)>("pValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreSignalInfo, VkSemaphoreSignalInfo);

struct VkSemaphoreSignalInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreSignalInfo,true,true> {
    VkSemaphoreSignalInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreSignalInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeatures,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressInfo, VkBufferDeviceAddressInfo);

struct VkBufferDeviceAddressInfoAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressInfo,true,true> {
    VkBufferDeviceAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferOpaqueCaptureAddressCreateInfo, VkBufferOpaqueCaptureAddressCreateInfo);

struct VkBufferOpaqueCaptureAddressCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferOpaqueCaptureAddressCreateInfo,true,true> {
    VkBufferOpaqueCaptureAddressCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferOpaqueCaptureAddressCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryOpaqueCaptureAddressAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo);

struct VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryOpaqueCaptureAddressAllocateInfo,true,true> {
    VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryOpaqueCaptureAddressAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOpaqueCaptureAddressInfo, VkDeviceMemoryOpaqueCaptureAddressInfo);

struct VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOpaqueCaptureAddressInfo,true,true> {
    VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOpaqueCaptureAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesKHR);

struct VkSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilitiesKHR,true,true> {
    VkSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceFormatKHR, VkSurfaceFormatKHR);

struct VkSurfaceFormatKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormatKHR,true,true> {
    VkSurfaceFormatKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormatKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(colorSpace)>("colorSpace");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCreateInfoKHR, VkSwapchainCreateInfoKHR);

struct VkSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSwapchainCreateInfoKHR,true,true> {
    VkSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(imageFormat)>("imageFormat");
        addField<DAS_BIND_MANAGED_FIELD(imageColorSpace)>("imageColorSpace");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
        addField<DAS_BIND_MANAGED_FIELD(imageArrayLayers)>("imageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(imageUsage)>("imageUsage");
        addField<DAS_BIND_MANAGED_FIELD(imageSharingMode)>("imageSharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(preTransform)>("preTransform");
        addField<DAS_BIND_MANAGED_FIELD(compositeAlpha)>("compositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(presentMode)>("presentMode");
        addField<DAS_BIND_MANAGED_FIELD(clipped)>("clipped");
        addField<DAS_BIND_MANAGED_FIELD(oldSwapchain)>("oldSwapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentInfoKHR, VkPresentInfoKHR);

struct VkPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPresentInfoKHR,true,true> {
    VkPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pSwapchains)>("pSwapchains");
        addField<DAS_BIND_MANAGED_FIELD(pImageIndices)>("pImageIndices");
        addField<DAS_BIND_MANAGED_FIELD(pResults)>("pResults");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSwapchainCreateInfoKHR, VkImageSwapchainCreateInfoKHR);

struct VkImageSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImageSwapchainCreateInfoKHR,true,true> {
    VkImageSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImageMemorySwapchainInfoKHR, VkBindImageMemorySwapchainInfoKHR);

struct VkBindImageMemorySwapchainInfoKHRAnnotation
: public ManagedStructureAnnotation<VkBindImageMemorySwapchainInfoKHR,true,true> {
    VkBindImageMemorySwapchainInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemorySwapchainInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(imageIndex)>("imageIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAcquireNextImageInfoKHR, VkAcquireNextImageInfoKHR);

struct VkAcquireNextImageInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireNextImageInfoKHR,true,true> {
    VkAcquireNextImageInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireNextImageInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentCapabilitiesKHR);

struct VkDeviceGroupPresentCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentCapabilitiesKHR,true,true> {
    VkDeviceGroupPresentCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(presentMask)>("presentMask");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentInfoKHR, VkDeviceGroupPresentInfoKHR);

struct VkDeviceGroupPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentInfoKHR,true,true> {
    VkDeviceGroupPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceMasks)>("pDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupSwapchainCreateInfoKHR, VkDeviceGroupSwapchainCreateInfoKHR);

struct VkDeviceGroupSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupSwapchainCreateInfoKHR,true,true> {
    VkDeviceGroupSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeParametersKHR, VkDisplayModeParametersKHR);

struct VkDisplayModeParametersKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeParametersKHR,true,true> {
    VkDisplayModeParametersKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeParametersKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(visibleRegion)>("visibleRegion");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeCreateInfoKHR, VkDisplayModeCreateInfoKHR);

struct VkDisplayModeCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeCreateInfoKHR,true,true> {
    VkDisplayModeCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(parameters)>("parameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModePropertiesKHR, VkDisplayModePropertiesKHR);

struct VkDisplayModePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModePropertiesKHR,true,true> {
    VkDisplayModePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(displayMode)>("displayMode");
        addField<DAS_BIND_MANAGED_FIELD(parameters)>("parameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPlaneCapabilitiesKHR, VkDisplayPlaneCapabilitiesKHR);

struct VkDisplayPlaneCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneCapabilitiesKHR,true,true> {
    VkDisplayPlaneCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(supportedAlpha)>("supportedAlpha");
        addField<DAS_BIND_MANAGED_FIELD(minSrcPosition)>("minSrcPosition");
        addField<DAS_BIND_MANAGED_FIELD(maxSrcPosition)>("maxSrcPosition");
        addField<DAS_BIND_MANAGED_FIELD(minSrcExtent)>("minSrcExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxSrcExtent)>("maxSrcExtent");
        addField<DAS_BIND_MANAGED_FIELD(minDstPosition)>("minDstPosition");
        addField<DAS_BIND_MANAGED_FIELD(maxDstPosition)>("maxDstPosition");
        addField<DAS_BIND_MANAGED_FIELD(minDstExtent)>("minDstExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxDstExtent)>("maxDstExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPlanePropertiesKHR, VkDisplayPlanePropertiesKHR);

struct VkDisplayPlanePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlanePropertiesKHR,true,true> {
    VkDisplayPlanePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlanePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(currentDisplay)>("currentDisplay");
        addField<DAS_BIND_MANAGED_FIELD(currentStackIndex)>("currentStackIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPropertiesKHR, VkDisplayPropertiesKHR);

struct VkDisplayPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPropertiesKHR,true,true> {
    VkDisplayPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(display)>("display");
        addField<DAS_BIND_MANAGED_FIELD(displayName)>("displayName");
        addField<DAS_BIND_MANAGED_FIELD(physicalDimensions)>("physicalDimensions");
        addField<DAS_BIND_MANAGED_FIELD(physicalResolution)>("physicalResolution");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(planeReorderPossible)>("planeReorderPossible");
        addField<DAS_BIND_MANAGED_FIELD(persistentContent)>("persistentContent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplaySurfaceCreateInfoKHR, VkDisplaySurfaceCreateInfoKHR);

struct VkDisplaySurfaceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplaySurfaceCreateInfoKHR,true,true> {
    VkDisplaySurfaceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplaySurfaceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(displayMode)>("displayMode");
        addField<DAS_BIND_MANAGED_FIELD(planeIndex)>("planeIndex");
        addField<DAS_BIND_MANAGED_FIELD(planeStackIndex)>("planeStackIndex");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(globalAlpha)>("globalAlpha");
        addField<DAS_BIND_MANAGED_FIELD(alphaMode)>("alphaMode");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPresentInfoKHR, VkDisplayPresentInfoKHR);

struct VkDisplayPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPresentInfoKHR,true,true> {
    VkDisplayPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcRect)>("srcRect");
        addField<DAS_BIND_MANAGED_FIELD(dstRect)>("dstRect");
        addField<DAS_BIND_MANAGED_FIELD(persistent)>("persistent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImportMemoryFdInfoKHR, VkImportMemoryFdInfoKHR);

struct VkImportMemoryFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportMemoryFdInfoKHR,true,true> {
    VkImportMemoryFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportMemoryFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryFdPropertiesKHR, VkMemoryFdPropertiesKHR);

struct VkMemoryFdPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkMemoryFdPropertiesKHR,true,true> {
    VkMemoryFdPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryFdPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryGetFdInfoKHR, VkMemoryGetFdInfoKHR);

struct VkMemoryGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkMemoryGetFdInfoKHR,true,true> {
    VkMemoryGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImportSemaphoreFdInfoKHR, VkImportSemaphoreFdInfoKHR);

struct VkImportSemaphoreFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportSemaphoreFdInfoKHR,true,true> {
    VkImportSemaphoreFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportSemaphoreFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreGetFdInfoKHR, VkSemaphoreGetFdInfoKHR);

struct VkSemaphoreGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSemaphoreGetFdInfoKHR,true,true> {
    VkSemaphoreGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDevicePushDescriptorPropertiesKHR);

struct VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePushDescriptorPropertiesKHR,true,true> {
    VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePushDescriptorPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPushDescriptors)>("maxPushDescriptors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRectLayerKHR, VkRectLayerKHR);

struct VkRectLayerKHRAnnotation
: public ManagedStructureAnnotation<VkRectLayerKHR,true,true> {
    VkRectLayerKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRectLayerKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentRegionKHR, VkPresentRegionKHR);

struct VkPresentRegionKHRAnnotation
: public ManagedStructureAnnotation<VkPresentRegionKHR,true,true> {
    VkPresentRegionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentRegionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(rectangleCount)>("rectangleCount");
        addField<DAS_BIND_MANAGED_FIELD(pRectangles)>("pRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentRegionsKHR, VkPresentRegionsKHR);

struct VkPresentRegionsKHRAnnotation
: public ManagedStructureAnnotation<VkPresentRegionsKHR,true,true> {
    VkPresentRegionsKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentRegionsKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSharedPresentSurfaceCapabilitiesKHR, VkSharedPresentSurfaceCapabilitiesKHR);

struct VkSharedPresentSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSharedPresentSurfaceCapabilitiesKHR,true,true> {
    VkSharedPresentSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSharedPresentSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sharedPresentSupportedUsageFlags)>("sharedPresentSupportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImportFenceFdInfoKHR, VkImportFenceFdInfoKHR);

struct VkImportFenceFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImportFenceFdInfoKHR,true,true> {
    VkImportFenceFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportFenceFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(fd)>("fd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFenceGetFdInfoKHR, VkFenceGetFdInfoKHR);

struct VkFenceGetFdInfoKHRAnnotation
: public ManagedStructureAnnotation<VkFenceGetFdInfoKHR,true,true> {
    VkFenceGetFdInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFenceGetFdInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePerformanceQueryFeaturesKHR, VkPhysicalDevicePerformanceQueryFeaturesKHR);

struct VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePerformanceQueryFeaturesKHR,true,true> {
    VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePerformanceQueryFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCounterQueryPools)>("performanceCounterQueryPools");
        addField<DAS_BIND_MANAGED_FIELD(performanceCounterMultipleQueryPools)>("performanceCounterMultipleQueryPools");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePerformanceQueryPropertiesKHR);

struct VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePerformanceQueryPropertiesKHR,true,true> {
    VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePerformanceQueryPropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allowCommandBufferQueryCopies)>("allowCommandBufferQueryCopies");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceCounterKHR, VkPerformanceCounterKHR);

struct VkPerformanceCounterKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterKHR,true,true> {
    VkPerformanceCounterKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(unit)>("unit");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
        addField<DAS_BIND_MANAGED_FIELD(storage)>("storage");
        addField<DAS_BIND_MANAGED_FIELD(uuid)>("uuid");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceCounterDescriptionKHR, VkPerformanceCounterDescriptionKHR);

struct VkPerformanceCounterDescriptionKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterDescriptionKHR,true,true> {
    VkPerformanceCounterDescriptionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterDescriptionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(category)>("category");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolPerformanceCreateInfoKHR, VkQueryPoolPerformanceCreateInfoKHR);

struct VkQueryPoolPerformanceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceCreateInfoKHR,true,true> {
    VkQueryPoolPerformanceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(counterIndexCount)>("counterIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pCounterIndices)>("pCounterIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceCounterResultKHR, VkPerformanceCounterResultKHR);

struct VkPerformanceCounterResultKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceCounterResultKHR,true,true> {
    VkPerformanceCounterResultKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceCounterResultKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(int32)>("int32");
        addField<DAS_BIND_MANAGED_FIELD(int64)>("int64_");
        addField<DAS_BIND_MANAGED_FIELD(uint32)>("uint32");
        addField<DAS_BIND_MANAGED_FIELD(uint64)>("uint64_");
        addField<DAS_BIND_MANAGED_FIELD(float32)>("float32");
        addField<DAS_BIND_MANAGED_FIELD(float64)>("float64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAcquireProfilingLockInfoKHR, VkAcquireProfilingLockInfoKHR);

struct VkAcquireProfilingLockInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireProfilingLockInfoKHR,true,true> {
    VkAcquireProfilingLockInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireProfilingLockInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceQuerySubmitInfoKHR, VkPerformanceQuerySubmitInfoKHR);

struct VkPerformanceQuerySubmitInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPerformanceQuerySubmitInfoKHR,true,true> {
    VkPerformanceQuerySubmitInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceQuerySubmitInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(counterPassIndex)>("counterPassIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSurfaceInfo2KHR, VkPhysicalDeviceSurfaceInfo2KHR);

struct VkPhysicalDeviceSurfaceInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSurfaceInfo2KHR,true,true> {
    VkPhysicalDeviceSurfaceInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSurfaceInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilities2KHR, VkSurfaceCapabilities2KHR);

struct VkSurfaceCapabilities2KHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2KHR,true,true> {
    VkSurfaceCapabilities2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCapabilities)>("surfaceCapabilities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceFormat2KHR, VkSurfaceFormat2KHR);

struct VkSurfaceFormat2KHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormat2KHR,true,true> {
    VkSurfaceFormat2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormat2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceFormat)>("surfaceFormat");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayProperties2KHR, VkDisplayProperties2KHR);

struct VkDisplayProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayProperties2KHR,true,true> {
    VkDisplayProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayProperties)>("displayProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPlaneProperties2KHR, VkDisplayPlaneProperties2KHR);

struct VkDisplayPlaneProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneProperties2KHR,true,true> {
    VkDisplayPlaneProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayPlaneProperties)>("displayPlaneProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeProperties2KHR, VkDisplayModeProperties2KHR);

struct VkDisplayModeProperties2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeProperties2KHR,true,true> {
    VkDisplayModeProperties2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeProperties2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayModeProperties)>("displayModeProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPlaneInfo2KHR, VkDisplayPlaneInfo2KHR);

struct VkDisplayPlaneInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneInfo2KHR,true,true> {
    VkDisplayPlaneInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
        addField<DAS_BIND_MANAGED_FIELD(planeIndex)>("planeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPlaneCapabilities2KHR, VkDisplayPlaneCapabilities2KHR);

struct VkDisplayPlaneCapabilities2KHRAnnotation
: public ManagedStructureAnnotation<VkDisplayPlaneCapabilities2KHR,true,true> {
    VkDisplayPlaneCapabilities2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPlaneCapabilities2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(capabilities)>("capabilities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderClockFeaturesKHR, VkPhysicalDeviceShaderClockFeaturesKHR);

struct VkPhysicalDeviceShaderClockFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderClockFeaturesKHR,true,true> {
    VkPhysicalDeviceShaderClockFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderClockFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupClock)>("shaderSubgroupClock");
        addField<DAS_BIND_MANAGED_FIELD(shaderDeviceClock)>("shaderDeviceClock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);

struct VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR,true,true> {
    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderTerminateInvocation)>("shaderTerminateInvocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFragmentShadingRateAttachmentInfoKHR, VkFragmentShadingRateAttachmentInfoKHR);

struct VkFragmentShadingRateAttachmentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkFragmentShadingRateAttachmentInfoKHR,true,true> {
    VkFragmentShadingRateAttachmentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFragmentShadingRateAttachmentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pFragmentShadingRateAttachment)>("pFragmentShadingRateAttachment");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateAttachmentTexelSize)>("shadingRateAttachmentTexelSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineFragmentShadingRateStateCreateInfoKHR, VkPipelineFragmentShadingRateStateCreateInfoKHR);

struct VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineFragmentShadingRateStateCreateInfoKHR,true,true> {
    VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineFragmentShadingRateStateCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentSize)>("fragmentSize");
        addField<DAS_BIND_MANAGED_FIELD(combinerOps)>("combinerOps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateFeaturesKHR, VkPhysicalDeviceFragmentShadingRateFeaturesKHR);

struct VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateFeaturesKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineFragmentShadingRate)>("pipelineFragmentShadingRate");
        addField<DAS_BIND_MANAGED_FIELD(primitiveFragmentShadingRate)>("primitiveFragmentShadingRate");
        addField<DAS_BIND_MANAGED_FIELD(attachmentFragmentShadingRate)>("attachmentFragmentShadingRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceFragmentShadingRatePropertiesKHR);

struct VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRatePropertiesKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRatePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentShadingRateAttachmentTexelSize)>("minFragmentShadingRateAttachmentTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateAttachmentTexelSize)>("maxFragmentShadingRateAttachmentTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateAttachmentTexelSizeAspectRatio)>("maxFragmentShadingRateAttachmentTexelSizeAspectRatio");
        addField<DAS_BIND_MANAGED_FIELD(primitiveFragmentShadingRateWithMultipleViewports)>("primitiveFragmentShadingRateWithMultipleViewports");
        addField<DAS_BIND_MANAGED_FIELD(layeredShadingRateAttachments)>("layeredShadingRateAttachments");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateNonTrivialCombinerOps)>("fragmentShadingRateNonTrivialCombinerOps");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentSize)>("maxFragmentSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentSizeAspectRatio)>("maxFragmentSizeAspectRatio");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateCoverageSamples)>("maxFragmentShadingRateCoverageSamples");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateRasterizationSamples)>("maxFragmentShadingRateRasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithShaderDepthStencilWrites)>("fragmentShadingRateWithShaderDepthStencilWrites");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithSampleMask)>("fragmentShadingRateWithSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithShaderSampleMask)>("fragmentShadingRateWithShaderSampleMask");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithConservativeRasterization)>("fragmentShadingRateWithConservativeRasterization");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithFragmentShaderInterlock)>("fragmentShadingRateWithFragmentShaderInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateWithCustomSampleLocations)>("fragmentShadingRateWithCustomSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateStrictMultiplyCombiner)>("fragmentShadingRateStrictMultiplyCombiner");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateKHR, VkPhysicalDeviceFragmentShadingRateKHR);

struct VkPhysicalDeviceFragmentShadingRateKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateKHR,true,true> {
    VkPhysicalDeviceFragmentShadingRateKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleCounts)>("sampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(fragmentSize)>("fragmentSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceProtectedCapabilitiesKHR, VkSurfaceProtectedCapabilitiesKHR);

struct VkSurfaceProtectedCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceProtectedCapabilitiesKHR,true,true> {
    VkSurfaceProtectedCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceProtectedCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsProtected)>("supportsProtected");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);

struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,true,true> {
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineExecutableInfo)>("pipelineExecutableInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineInfoKHR, VkPipelineInfoKHR);

struct VkPipelineInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineInfoKHR,true,true> {
    VkPipelineInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineExecutablePropertiesKHR, VkPipelineExecutablePropertiesKHR);

struct VkPipelineExecutablePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutablePropertiesKHR,true,true> {
    VkPipelineExecutablePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutablePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stages)>("stages");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineExecutableInfoKHR, VkPipelineExecutableInfoKHR);

struct VkPipelineExecutableInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableInfoKHR,true,true> {
    VkPipelineExecutableInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(executableIndex)>("executableIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineExecutableStatisticValueKHR, VkPipelineExecutableStatisticValueKHR);

struct VkPipelineExecutableStatisticValueKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableStatisticValueKHR,true,true> {
    VkPipelineExecutableStatisticValueKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableStatisticValueKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(b32)>("b32");
        addField<DAS_BIND_MANAGED_FIELD(i64)>("i64");
        addField<DAS_BIND_MANAGED_FIELD(u64)>("u64");
        addField<DAS_BIND_MANAGED_FIELD(f64)>("f64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineExecutableStatisticKHR, VkPipelineExecutableStatisticKHR);

struct VkPipelineExecutableStatisticKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableStatisticKHR,true,true> {
    VkPipelineExecutableStatisticKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableStatisticKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineExecutableInternalRepresentationKHR, VkPipelineExecutableInternalRepresentationKHR);

struct VkPipelineExecutableInternalRepresentationKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineExecutableInternalRepresentationKHR,true,true> {
    VkPipelineExecutableInternalRepresentationKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineExecutableInternalRepresentationKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(isText)>("isText");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLibraryCreateInfoKHR, VkPipelineLibraryCreateInfoKHR);

struct VkPipelineLibraryCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPipelineLibraryCreateInfoKHR,true,true> {
    VkPipelineLibraryCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineLibraryCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(libraryCount)>("libraryCount");
        addField<DAS_BIND_MANAGED_FIELD(pLibraries)>("pLibraries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferCopy2KHR, VkBufferCopy2KHR);

struct VkBufferCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkBufferCopy2KHR,true,true> {
    VkBufferCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyBufferInfo2KHR, VkCopyBufferInfo2KHR);

struct VkCopyBufferInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyBufferInfo2KHR,true,true> {
    VkCopyBufferInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyBufferInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcBuffer)>("srcBuffer");
        addField<DAS_BIND_MANAGED_FIELD(dstBuffer)>("dstBuffer");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageCopy2KHR, VkImageCopy2KHR);

struct VkImageCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkImageCopy2KHR,true,true> {
    VkImageCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyImageInfo2KHR, VkCopyImageInfo2KHR);

struct VkCopyImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyImageInfo2KHR,true,true> {
    VkCopyImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferImageCopy2KHR, VkBufferImageCopy2KHR);

struct VkBufferImageCopy2KHRAnnotation
: public ManagedStructureAnnotation<VkBufferImageCopy2KHR,true,true> {
    VkBufferImageCopy2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferImageCopy2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferOffset)>("bufferOffset");
        addField<DAS_BIND_MANAGED_FIELD(bufferRowLength)>("bufferRowLength");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageHeight)>("bufferImageHeight");
        addField<DAS_BIND_MANAGED_FIELD(imageSubresource)>("imageSubresource");
        addField<DAS_BIND_MANAGED_FIELD(imageOffset)>("imageOffset");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyBufferToImageInfo2KHR, VkCopyBufferToImageInfo2KHR);

struct VkCopyBufferToImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyBufferToImageInfo2KHR,true,true> {
    VkCopyBufferToImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyBufferToImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcBuffer)>("srcBuffer");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyImageToBufferInfo2KHR, VkCopyImageToBufferInfo2KHR);

struct VkCopyImageToBufferInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkCopyImageToBufferInfo2KHR,true,true> {
    VkCopyImageToBufferInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyImageToBufferInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstBuffer)>("dstBuffer");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageBlit2KHR, VkImageBlit2KHR);

struct VkImageBlit2KHRAnnotation
: public ManagedStructureAnnotation<VkImageBlit2KHR,true,true> {
    VkImageBlit2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageBlit2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffsets)>("srcOffsets");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffsets)>("dstOffsets");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBlitImageInfo2KHR, VkBlitImageInfo2KHR);

struct VkBlitImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkBlitImageInfo2KHR,true,true> {
    VkBlitImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBlitImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
        addField<DAS_BIND_MANAGED_FIELD(filter)>("filter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageResolve2KHR, VkImageResolve2KHR);

struct VkImageResolve2KHRAnnotation
: public ManagedStructureAnnotation<VkImageResolve2KHR,true,true> {
    VkImageResolve2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageResolve2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubresource)>("srcSubresource");
        addField<DAS_BIND_MANAGED_FIELD(srcOffset)>("srcOffset");
        addField<DAS_BIND_MANAGED_FIELD(dstSubresource)>("dstSubresource");
        addField<DAS_BIND_MANAGED_FIELD(dstOffset)>("dstOffset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkResolveImageInfo2KHR, VkResolveImageInfo2KHR);

struct VkResolveImageInfo2KHRAnnotation
: public ManagedStructureAnnotation<VkResolveImageInfo2KHR,true,true> {
    VkResolveImageInfo2KHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkResolveImageInfo2KHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcImage)>("srcImage");
        addField<DAS_BIND_MANAGED_FIELD(srcImageLayout)>("srcImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(dstImage)>("dstImage");
        addField<DAS_BIND_MANAGED_FIELD(dstImageLayout)>("dstImageLayout");
        addField<DAS_BIND_MANAGED_FIELD(regionCount)>("regionCount");
        addField<DAS_BIND_MANAGED_FIELD(pRegions)>("pRegions");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugReportCallbackCreateInfoEXT, VkDebugReportCallbackCreateInfoEXT);

struct VkDebugReportCallbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugReportCallbackCreateInfoEXT,true,true> {
    VkDebugReportCallbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugReportCallbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateRasterizationOrderAMD, VkPipelineRasterizationStateRasterizationOrderAMD);

struct VkPipelineRasterizationStateRasterizationOrderAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateRasterizationOrderAMD,true,true> {
    VkPipelineRasterizationStateRasterizationOrderAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateRasterizationOrderAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationOrder)>("rasterizationOrder");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugMarkerObjectNameInfoEXT, VkDebugMarkerObjectNameInfoEXT);

struct VkDebugMarkerObjectNameInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerObjectNameInfoEXT,true,true> {
    VkDebugMarkerObjectNameInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerObjectNameInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(object)>("object");
        addField<DAS_BIND_MANAGED_FIELD(pObjectName)>("pObjectName");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugMarkerObjectTagInfoEXT, VkDebugMarkerObjectTagInfoEXT);

struct VkDebugMarkerObjectTagInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerObjectTagInfoEXT,true,true> {
    VkDebugMarkerObjectTagInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerObjectTagInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(object)>("object");
        addField<DAS_BIND_MANAGED_FIELD(tagName)>("tagName");
        addField<DAS_BIND_MANAGED_FIELD(tagSize)>("tagSize");
        addField<DAS_BIND_MANAGED_FIELD(pTag)>("pTag");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugMarkerMarkerInfoEXT, VkDebugMarkerMarkerInfoEXT);

struct VkDebugMarkerMarkerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugMarkerMarkerInfoEXT,true,true> {
    VkDebugMarkerMarkerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugMarkerMarkerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pMarkerName)>("pMarkerName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationImageCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV);

struct VkDedicatedAllocationImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationImageCreateInfoNV,true,true> {
    VkDedicatedAllocationImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationBufferCreateInfoNV);

struct VkDedicatedAllocationBufferCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationBufferCreateInfoNV,true,true> {
    VkDedicatedAllocationBufferCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationBufferCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocation)>("dedicatedAllocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDedicatedAllocationMemoryAllocateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV);

struct VkDedicatedAllocationMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDedicatedAllocationMemoryAllocateInfoNV,true,true> {
    VkDedicatedAllocationMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDedicatedAllocationMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackFeaturesEXT);

struct VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackFeaturesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedback)>("transformFeedback");
        addField<DAS_BIND_MANAGED_FIELD(geometryStreams)>("geometryStreams");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT);

struct VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTransformFeedbackPropertiesEXT,true,true> {
    VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTransformFeedbackPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreams)>("maxTransformFeedbackStreams");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBuffers)>("maxTransformFeedbackBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferSize)>("maxTransformFeedbackBufferSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackStreamDataSize)>("maxTransformFeedbackStreamDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataSize)>("maxTransformFeedbackBufferDataSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTransformFeedbackBufferDataStride)>("maxTransformFeedbackBufferDataStride");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackQueries)>("transformFeedbackQueries");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackStreamsLinesTriangles)>("transformFeedbackStreamsLinesTriangles");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackRasterizationStreamSelect)>("transformFeedbackRasterizationStreamSelect");
        addField<DAS_BIND_MANAGED_FIELD(transformFeedbackDraw)>("transformFeedbackDraw");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationStateStreamCreateInfoEXT, VkPipelineRasterizationStateStreamCreateInfoEXT);

struct VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationStateStreamCreateInfoEXT,true,true> {
    VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationStateStreamCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationStream)>("rasterizationStream");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewHandleInfoNVX, VkImageViewHandleInfoNVX);

struct VkImageViewHandleInfoNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewHandleInfoNVX,true,true> {
    VkImageViewHandleInfoNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewHandleInfoNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageView)>("imageView");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(sampler)>("sampler");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewAddressPropertiesNVX, VkImageViewAddressPropertiesNVX);

struct VkImageViewAddressPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkImageViewAddressPropertiesNVX,true,true> {
    VkImageViewAddressPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewAddressPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTextureLODGatherFormatPropertiesAMD, VkTextureLODGatherFormatPropertiesAMD);

struct VkTextureLODGatherFormatPropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkTextureLODGatherFormatPropertiesAMD,true,true> {
    VkTextureLODGatherFormatPropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTextureLODGatherFormatPropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportsTextureGatherLODBiasAMD)>("supportsTextureGatherLODBiasAMD");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderResourceUsageAMD, VkShaderResourceUsageAMD);

struct VkShaderResourceUsageAMDAnnotation
: public ManagedStructureAnnotation<VkShaderResourceUsageAMD,true,true> {
    VkShaderResourceUsageAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderResourceUsageAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(numUsedVgprs)>("numUsedVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numUsedSgprs)>("numUsedSgprs");
        addField<DAS_BIND_MANAGED_FIELD(ldsSizePerLocalWorkGroup)>("ldsSizePerLocalWorkGroup");
        addField<DAS_BIND_MANAGED_FIELD(ldsUsageSizeInBytes)>("ldsUsageSizeInBytes");
        addField<DAS_BIND_MANAGED_FIELD(scratchMemUsageInBytes)>("scratchMemUsageInBytes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderStatisticsInfoAMD, VkShaderStatisticsInfoAMD);

struct VkShaderStatisticsInfoAMDAnnotation
: public ManagedStructureAnnotation<VkShaderStatisticsInfoAMD,true,true> {
    VkShaderStatisticsInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderStatisticsInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shaderStageMask)>("shaderStageMask");
        addField<DAS_BIND_MANAGED_FIELD(resourceUsage)>("resourceUsage");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalVgprs)>("numPhysicalVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numPhysicalSgprs)>("numPhysicalSgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableVgprs)>("numAvailableVgprs");
        addField<DAS_BIND_MANAGED_FIELD(numAvailableSgprs)>("numAvailableSgprs");
        addField<DAS_BIND_MANAGED_FIELD(computeWorkGroupSize)>("computeWorkGroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV);

struct VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCornerSampledImageFeaturesNV,true,true> {
    VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCornerSampledImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cornerSampledImage)>("cornerSampledImage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalImageFormatPropertiesNV, VkExternalImageFormatPropertiesNV);

struct VkExternalImageFormatPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatPropertiesNV,true,true> {
    VkExternalImageFormatPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(imageFormatProperties)>("imageFormatProperties");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryImageCreateInfoNV, VkExternalMemoryImageCreateInfoNV);

struct VkExternalMemoryImageCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfoNV,true,true> {
    VkExternalMemoryImageCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportMemoryAllocateInfoNV, VkExportMemoryAllocateInfoNV);

struct VkExportMemoryAllocateInfoNVAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfoNV,true,true> {
    VkExportMemoryAllocateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFlagsEXT, VkValidationFlagsEXT);

struct VkValidationFlagsEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFlagsEXT,true,true> {
    VkValidationFlagsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFlagsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationCheckCount)>("disabledValidationCheckCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationChecks)>("pDisabledValidationChecks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);

struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,true,true> {
    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_HDR)>("textureCompressionASTC_HDR");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewASTCDecodeModeEXT, VkImageViewASTCDecodeModeEXT);

struct VkImageViewASTCDecodeModeEXTAnnotation
: public ManagedStructureAnnotation<VkImageViewASTCDecodeModeEXT,true,true> {
    VkImageViewASTCDecodeModeEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewASTCDecodeModeEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeMode)>("decodeMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceASTCDecodeFeaturesEXT);

struct VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceASTCDecodeFeaturesEXT,true,true> {
    VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceASTCDecodeFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(decodeModeSharedExponent)>("decodeModeSharedExponent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingBeginInfoEXT);

struct VkConditionalRenderingBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkConditionalRenderingBeginInfoEXT,true,true> {
    VkConditionalRenderingBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConditionalRenderingBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT);

struct VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConditionalRenderingFeaturesEXT,true,true> {
    VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConditionalRenderingFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRendering)>("conditionalRendering");
        addField<DAS_BIND_MANAGED_FIELD(inheritedConditionalRendering)>("inheritedConditionalRendering");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceConditionalRenderingInfoEXT);

struct VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceConditionalRenderingInfoEXT,true,true> {
    VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceConditionalRenderingInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conditionalRenderingEnable)>("conditionalRenderingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewportWScalingNV, VkViewportWScalingNV);

struct VkViewportWScalingNVAnnotation
: public ManagedStructureAnnotation<VkViewportWScalingNV,true,true> {
    VkViewportWScalingNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportWScalingNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(xcoeff)>("xcoeff");
        addField<DAS_BIND_MANAGED_FIELD(ycoeff)>("ycoeff");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportWScalingStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV);

struct VkPipelineViewportWScalingStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportWScalingStateCreateInfoNV,true,true> {
    VkPipelineViewportWScalingStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportWScalingStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewportWScalingEnable)>("viewportWScalingEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportWScalings)>("pViewportWScalings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilities2EXT, VkSurfaceCapabilities2EXT);

struct VkSurfaceCapabilities2EXTAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilities2EXT,true,true> {
    VkSurfaceCapabilities2EXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilities2EXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
        addField<DAS_BIND_MANAGED_FIELD(supportedSurfaceCounters)>("supportedSurfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayPowerInfoEXT, VkDisplayPowerInfoEXT);

struct VkDisplayPowerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayPowerInfoEXT,true,true> {
    VkDisplayPowerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayPowerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(powerState)>("powerState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceEventInfoEXT, VkDeviceEventInfoEXT);

struct VkDeviceEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceEventInfoEXT,true,true> {
    VkDeviceEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceEvent)>("deviceEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayEventInfoEXT, VkDisplayEventInfoEXT);

struct VkDisplayEventInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDisplayEventInfoEXT,true,true> {
    VkDisplayEventInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayEventInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayEvent)>("displayEvent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCounterCreateInfoEXT, VkSwapchainCounterCreateInfoEXT);

struct VkSwapchainCounterCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSwapchainCounterCreateInfoEXT,true,true> {
    VkSwapchainCounterCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCounterCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(surfaceCounters)>("surfaceCounters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRefreshCycleDurationGOOGLE, VkRefreshCycleDurationGOOGLE);

struct VkRefreshCycleDurationGOOGLEAnnotation
: public ManagedStructureAnnotation<VkRefreshCycleDurationGOOGLE,true,true> {
    VkRefreshCycleDurationGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRefreshCycleDurationGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(refreshDuration)>("refreshDuration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPastPresentationTimingGOOGLE, VkPastPresentationTimingGOOGLE);

struct VkPastPresentationTimingGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPastPresentationTimingGOOGLE,true,true> {
    VkPastPresentationTimingGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPastPresentationTimingGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(actualPresentTime)>("actualPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(earliestPresentTime)>("earliestPresentTime");
        addField<DAS_BIND_MANAGED_FIELD(presentMargin)>("presentMargin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimeGOOGLE, VkPresentTimeGOOGLE);

struct VkPresentTimeGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimeGOOGLE,true,true> {
    VkPresentTimeGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimeGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(presentID)>("presentID");
        addField<DAS_BIND_MANAGED_FIELD(desiredPresentTime)>("desiredPresentTime");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentTimesInfoGOOGLE, VkPresentTimesInfoGOOGLE);

struct VkPresentTimesInfoGOOGLEAnnotation
: public ManagedStructureAnnotation<VkPresentTimesInfoGOOGLE,true,true> {
    VkPresentTimesInfoGOOGLEAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentTimesInfoGOOGLE", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pTimes)>("pTimes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);

struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,true,true> {
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(perViewPositionAllComponents)>("perViewPositionAllComponents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkViewportSwizzleNV, VkViewportSwizzleNV);

struct VkViewportSwizzleNVAnnotation
: public ManagedStructureAnnotation<VkViewportSwizzleNV,true,true> {
    VkViewportSwizzleNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkViewportSwizzleNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
        addField<DAS_BIND_MANAGED_FIELD(w)>("w");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportSwizzleStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV);

struct VkPipelineViewportSwizzleStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportSwizzleStateCreateInfoNV,true,true> {
    VkPipelineViewportSwizzleStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportSwizzleStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewportSwizzles)>("pViewportSwizzles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT);

struct VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiscardRectanglePropertiesEXT,true,true> {
    VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiscardRectanglePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDiscardRectangles)>("maxDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT);

struct VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineDiscardRectangleStateCreateInfoEXT,true,true> {
    VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineDiscardRectangleStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleMode)>("discardRectangleMode");
        addField<DAS_BIND_MANAGED_FIELD(discardRectangleCount)>("discardRectangleCount");
        addField<DAS_BIND_MANAGED_FIELD(pDiscardRectangles)>("pDiscardRectangles");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT);

struct VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceConservativeRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceConservativeRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOverestimationSize)>("primitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(maxExtraPrimitiveOverestimationSize)>("maxExtraPrimitiveOverestimationSize");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSizeGranularity)>("extraPrimitiveOverestimationSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(primitiveUnderestimation)>("primitiveUnderestimation");
        addField<DAS_BIND_MANAGED_FIELD(conservativePointAndLineRasterization)>("conservativePointAndLineRasterization");
        addField<DAS_BIND_MANAGED_FIELD(degenerateTrianglesRasterized)>("degenerateTrianglesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(degenerateLinesRasterized)>("degenerateLinesRasterized");
        addField<DAS_BIND_MANAGED_FIELD(fullyCoveredFragmentShaderInputVariable)>("fullyCoveredFragmentShaderInputVariable");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationPostDepthCoverage)>("conservativeRasterizationPostDepthCoverage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationConservativeStateCreateInfoEXT);

struct VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationConservativeStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationConservativeStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(conservativeRasterizationMode)>("conservativeRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(extraPrimitiveOverestimationSize)>("extraPrimitiveOverestimationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT);

struct VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthClipEnableFeaturesEXT,true,true> {
    VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthClipEnableFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT);

struct VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationDepthClipStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationDepthClipStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(depthClipEnable)>("depthClipEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkXYColorEXT, VkXYColorEXT);

struct VkXYColorEXTAnnotation
: public ManagedStructureAnnotation<VkXYColorEXT,true,true> {
    VkXYColorEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkXYColorEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkHdrMetadataEXT, VkHdrMetadataEXT);

struct VkHdrMetadataEXTAnnotation
: public ManagedStructureAnnotation<VkHdrMetadataEXT,true,true> {
    VkHdrMetadataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHdrMetadataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryRed)>("displayPrimaryRed");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryGreen)>("displayPrimaryGreen");
        addField<DAS_BIND_MANAGED_FIELD(displayPrimaryBlue)>("displayPrimaryBlue");
        addField<DAS_BIND_MANAGED_FIELD(whitePoint)>("whitePoint");
        addField<DAS_BIND_MANAGED_FIELD(maxLuminance)>("maxLuminance");
        addField<DAS_BIND_MANAGED_FIELD(minLuminance)>("minLuminance");
        addField<DAS_BIND_MANAGED_FIELD(maxContentLightLevel)>("maxContentLightLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxFrameAverageLightLevel)>("maxFrameAverageLightLevel");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsLabelEXT, VkDebugUtilsLabelEXT);

struct VkDebugUtilsLabelEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsLabelEXT,true,true> {
    VkDebugUtilsLabelEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsLabelEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pLabelName)>("pLabelName");
        addField<DAS_BIND_MANAGED_FIELD(color)>("color");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectNameInfoEXT);

struct VkDebugUtilsObjectNameInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectNameInfoEXT,true,true> {
    VkDebugUtilsObjectNameInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectNameInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(pObjectName)>("pObjectName");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerCallbackDataEXT, VkDebugUtilsMessengerCallbackDataEXT);

struct VkDebugUtilsMessengerCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCallbackDataEXT,true,true> {
    VkDebugUtilsMessengerCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pMessageIdName)>("pMessageIdName");
        addField<DAS_BIND_MANAGED_FIELD(messageIdNumber)>("messageIdNumber");
        addField<DAS_BIND_MANAGED_FIELD(pMessage)>("pMessage");
        addField<DAS_BIND_MANAGED_FIELD(queueLabelCount)>("queueLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueLabels)>("pQueueLabels");
        addField<DAS_BIND_MANAGED_FIELD(cmdBufLabelCount)>("cmdBufLabelCount");
        addField<DAS_BIND_MANAGED_FIELD(pCmdBufLabels)>("pCmdBufLabels");
        addField<DAS_BIND_MANAGED_FIELD(objectCount)>("objectCount");
        addField<DAS_BIND_MANAGED_FIELD(pObjects)>("pObjects");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT);

struct VkDebugUtilsMessengerCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsMessengerCreateInfoEXT,true,true> {
    VkDebugUtilsMessengerCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsMessengerCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(messageSeverity)>("messageSeverity");
        addField<DAS_BIND_MANAGED_FIELD(messageType)>("messageType");
        addField<DAS_BIND_MANAGED_FIELD(pfnUserCallback)>("pfnUserCallback");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDebugUtilsObjectTagInfoEXT, VkDebugUtilsObjectTagInfoEXT);

struct VkDebugUtilsObjectTagInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDebugUtilsObjectTagInfoEXT,true,true> {
    VkDebugUtilsObjectTagInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDebugUtilsObjectTagInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(tagName)>("tagName");
        addField<DAS_BIND_MANAGED_FIELD(tagSize)>("tagSize");
        addField<DAS_BIND_MANAGED_FIELD(pTag)>("pTag");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT);

struct VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockFeaturesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(inlineUniformBlock)>("inlineUniformBlock");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingInlineUniformBlockUpdateAfterBind)>("descriptorBindingInlineUniformBlockUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT);

struct VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceInlineUniformBlockPropertiesEXT,true,true> {
    VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceInlineUniformBlockPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockSize)>("maxInlineUniformBlockSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInlineUniformBlocks)>("maxPerStageDescriptorInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)>("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInlineUniformBlocks)>("maxDescriptorSetInlineUniformBlocks");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)>("maxDescriptorSetUpdateAfterBindInlineUniformBlocks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSetInlineUniformBlockEXT, VkWriteDescriptorSetInlineUniformBlockEXT);

struct VkWriteDescriptorSetInlineUniformBlockEXTAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetInlineUniformBlockEXT,true,true> {
    VkWriteDescriptorSetInlineUniformBlockEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetInlineUniformBlockEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dataSize)>("dataSize");
        addField<DAS_BIND_MANAGED_FIELD(pData)>("pData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorPoolInlineUniformBlockCreateInfoEXT, VkDescriptorPoolInlineUniformBlockCreateInfoEXT);

struct VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDescriptorPoolInlineUniformBlockCreateInfoEXT,true,true> {
    VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorPoolInlineUniformBlockCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxInlineUniformBlockBindings)>("maxInlineUniformBlockBindings");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSampleLocationEXT, VkSampleLocationEXT);

struct VkSampleLocationEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationEXT,true,true> {
    VkSampleLocationEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSampleLocationsInfoEXT, VkSampleLocationsInfoEXT);

struct VkSampleLocationsInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSampleLocationsInfoEXT,true,true> {
    VkSampleLocationsInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSampleLocationsInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsPerPixel)>("sampleLocationsPerPixel");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationGridSize)>("sampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsCount)>("sampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pSampleLocations)>("pSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentSampleLocationsEXT, VkAttachmentSampleLocationsEXT);

struct VkAttachmentSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkAttachmentSampleLocationsEXT,true,true> {
    VkAttachmentSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(attachmentIndex)>("attachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassSampleLocationsEXT, VkSubpassSampleLocationsEXT);

struct VkSubpassSampleLocationsEXTAnnotation
: public ManagedStructureAnnotation<VkSubpassSampleLocationsEXT,true,true> {
    VkSubpassSampleLocationsEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassSampleLocationsEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpassIndex)>("subpassIndex");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassSampleLocationsBeginInfoEXT);

struct VkRenderPassSampleLocationsBeginInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassSampleLocationsBeginInfoEXT,true,true> {
    VkRenderPassSampleLocationsBeginInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassSampleLocationsBeginInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentInitialSampleLocationsCount)>("attachmentInitialSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentInitialSampleLocations)>("pAttachmentInitialSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(postSubpassSampleLocationsCount)>("postSubpassSampleLocationsCount");
        addField<DAS_BIND_MANAGED_FIELD(pPostSubpassSampleLocations)>("pPostSubpassSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineSampleLocationsStateCreateInfoEXT, VkPipelineSampleLocationsStateCreateInfoEXT);

struct VkPipelineSampleLocationsStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineSampleLocationsStateCreateInfoEXT,true,true> {
    VkPipelineSampleLocationsStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineSampleLocationsStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsEnable)>("sampleLocationsEnable");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationsInfo)>("sampleLocationsInfo");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT);

struct VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSampleLocationsPropertiesEXT,true,true> {
    VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSampleLocationsPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSampleCounts)>("sampleLocationSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationCoordinateRange)>("sampleLocationCoordinateRange");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationSubPixelBits)>("sampleLocationSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(variableSampleLocations)>("variableSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMultisamplePropertiesEXT, VkMultisamplePropertiesEXT);

struct VkMultisamplePropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMultisamplePropertiesEXT,true,true> {
    VkMultisamplePropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMultisamplePropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleLocationGridSize)>("maxSampleLocationGridSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCoherentOperations)>("advancedBlendCoherentOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);

struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,true,true> {
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendMaxColorAttachments)>("advancedBlendMaxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendIndependentBlend)>("advancedBlendIndependentBlend");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedSrcColor)>("advancedBlendNonPremultipliedSrcColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendNonPremultipliedDstColor)>("advancedBlendNonPremultipliedDstColor");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendCorrelatedOverlap)>("advancedBlendCorrelatedOverlap");
        addField<DAS_BIND_MANAGED_FIELD(advancedBlendAllOperations)>("advancedBlendAllOperations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineColorBlendAdvancedStateCreateInfoEXT, VkPipelineColorBlendAdvancedStateCreateInfoEXT);

struct VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineColorBlendAdvancedStateCreateInfoEXT,true,true> {
    VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineColorBlendAdvancedStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcPremultiplied)>("srcPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(dstPremultiplied)>("dstPremultiplied");
        addField<DAS_BIND_MANAGED_FIELD(blendOverlap)>("blendOverlap");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageToColorStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV);

struct VkPipelineCoverageToColorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageToColorStateCreateInfoNV,true,true> {
    VkPipelineCoverageToColorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageToColorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorEnable)>("coverageToColorEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageToColorLocation)>("coverageToColorLocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageModulationStateCreateInfoNV);

struct VkPipelineCoverageModulationStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageModulationStateCreateInfoNV,true,true> {
    VkPipelineCoverageModulationStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageModulationStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationMode)>("coverageModulationMode");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableEnable)>("coverageModulationTableEnable");
        addField<DAS_BIND_MANAGED_FIELD(coverageModulationTableCount)>("coverageModulationTableCount");
        addField<DAS_BIND_MANAGED_FIELD(pCoverageModulationTable)>("pCoverageModulationTable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);

struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMCount)>("shaderSMCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderWarpsPerSM)>("shaderWarpsPerSM");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);

struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,true,true> {
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSMBuiltins)>("shaderSMBuiltins");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrmFormatModifierPropertiesEXT, VkDrmFormatModifierPropertiesEXT);

struct VkDrmFormatModifierPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesEXT,true,true> {
    VkDrmFormatModifierPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierPlaneCount)>("drmFormatModifierPlaneCount");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierTilingFeatures)>("drmFormatModifierTilingFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrmFormatModifierPropertiesListEXT, VkDrmFormatModifierPropertiesListEXT);

struct VkDrmFormatModifierPropertiesListEXTAnnotation
: public ManagedStructureAnnotation<VkDrmFormatModifierPropertiesListEXT,true,true> {
    VkDrmFormatModifierPropertiesListEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrmFormatModifierPropertiesListEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierCount)>("drmFormatModifierCount");
        addField<DAS_BIND_MANAGED_FIELD(pDrmFormatModifierProperties)>("pDrmFormatModifierProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageDrmFormatModifierInfoEXT);

struct VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageDrmFormatModifierInfoEXT,true,true> {
    VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageDrmFormatModifierInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(sharingMode)>("sharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageDrmFormatModifierListCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT);

struct VkImageDrmFormatModifierListCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierListCreateInfoEXT,true,true> {
    VkImageDrmFormatModifierListCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierListCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierCount)>("drmFormatModifierCount");
        addField<DAS_BIND_MANAGED_FIELD(pDrmFormatModifiers)>("pDrmFormatModifiers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT);

struct VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierExplicitCreateInfoEXT,true,true> {
    VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierExplicitCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifierPlaneCount)>("drmFormatModifierPlaneCount");
        addField<DAS_BIND_MANAGED_FIELD(pPlaneLayouts)>("pPlaneLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageDrmFormatModifierPropertiesEXT, VkImageDrmFormatModifierPropertiesEXT);

struct VkImageDrmFormatModifierPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkImageDrmFormatModifierPropertiesEXT,true,true> {
    VkImageDrmFormatModifierPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageDrmFormatModifierPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(drmFormatModifier)>("drmFormatModifier");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationCacheCreateInfoEXT, VkValidationCacheCreateInfoEXT);

struct VkValidationCacheCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkValidationCacheCreateInfoEXT,true,true> {
    VkValidationCacheCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationCacheCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(initialDataSize)>("initialDataSize");
        addField<DAS_BIND_MANAGED_FIELD(pInitialData)>("pInitialData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModuleValidationCacheCreateInfoEXT, VkShaderModuleValidationCacheCreateInfoEXT);

struct VkShaderModuleValidationCacheCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkShaderModuleValidationCacheCreateInfoEXT,true,true> {
    VkShaderModuleValidationCacheCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShaderModuleValidationCacheCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(validationCache)>("validationCache");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShadingRatePaletteNV, VkShadingRatePaletteNV);

struct VkShadingRatePaletteNVAnnotation
: public ManagedStructureAnnotation<VkShadingRatePaletteNV,true,true> {
    VkShadingRatePaletteNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkShadingRatePaletteNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shadingRatePaletteEntryCount)>("shadingRatePaletteEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pShadingRatePaletteEntries)>("pShadingRatePaletteEntries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV);

struct VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportShadingRateImageStateCreateInfoNV,true,true> {
    VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportShadingRateImageStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateImageEnable)>("shadingRateImageEnable");
        addField<DAS_BIND_MANAGED_FIELD(viewportCount)>("viewportCount");
        addField<DAS_BIND_MANAGED_FIELD(pShadingRatePalettes)>("pShadingRatePalettes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV);

struct VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShadingRateImageFeaturesNV,true,true> {
    VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShadingRateImageFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateImage)>("shadingRateImage");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateCoarseSampleOrder)>("shadingRateCoarseSampleOrder");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceShadingRateImagePropertiesNV);

struct VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShadingRateImagePropertiesNV,true,true> {
    VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShadingRateImagePropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateTexelSize)>("shadingRateTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(shadingRatePaletteSize)>("shadingRatePaletteSize");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateMaxCoarseSamples)>("shadingRateMaxCoarseSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCoarseSampleLocationNV, VkCoarseSampleLocationNV);

struct VkCoarseSampleLocationNVAnnotation
: public ManagedStructureAnnotation<VkCoarseSampleLocationNV,true,true> {
    VkCoarseSampleLocationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCoarseSampleLocationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(pixelX)>("pixelX");
        addField<DAS_BIND_MANAGED_FIELD(pixelY)>("pixelY");
        addField<DAS_BIND_MANAGED_FIELD(sample)>("sample");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCoarseSampleOrderCustomNV, VkCoarseSampleOrderCustomNV);

struct VkCoarseSampleOrderCustomNVAnnotation
: public ManagedStructureAnnotation<VkCoarseSampleOrderCustomNV,true,true> {
    VkCoarseSampleOrderCustomNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCoarseSampleOrderCustomNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(shadingRate)>("shadingRate");
        addField<DAS_BIND_MANAGED_FIELD(sampleCount)>("sampleCount");
        addField<DAS_BIND_MANAGED_FIELD(sampleLocationCount)>("sampleLocationCount");
        addField<DAS_BIND_MANAGED_FIELD(pSampleLocations)>("pSampleLocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);

struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,true,true> {
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(sampleOrderType)>("sampleOrderType");
        addField<DAS_BIND_MANAGED_FIELD(customSampleOrderCount)>("customSampleOrderCount");
        addField<DAS_BIND_MANAGED_FIELD(pCustomSampleOrders)>("pCustomSampleOrders");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingShaderGroupCreateInfoNV, VkRayTracingShaderGroupCreateInfoNV);

struct VkRayTracingShaderGroupCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkRayTracingShaderGroupCreateInfoNV,true,true> {
    VkRayTracingShaderGroupCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingShaderGroupCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(generalShader)>("generalShader");
        addField<DAS_BIND_MANAGED_FIELD(closestHitShader)>("closestHitShader");
        addField<DAS_BIND_MANAGED_FIELD(anyHitShader)>("anyHitShader");
        addField<DAS_BIND_MANAGED_FIELD(intersectionShader)>("intersectionShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingPipelineCreateInfoNV, VkRayTracingPipelineCreateInfoNV);

struct VkRayTracingPipelineCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineCreateInfoNV,true,true> {
    VkRayTracingPipelineCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(maxRecursionDepth)>("maxRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeometryTrianglesNV, VkGeometryTrianglesNV);

struct VkGeometryTrianglesNVAnnotation
: public ManagedStructureAnnotation<VkGeometryTrianglesNV,true,true> {
    VkGeometryTrianglesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryTrianglesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexData)>("vertexData");
        addField<DAS_BIND_MANAGED_FIELD(vertexOffset)>("vertexOffset");
        addField<DAS_BIND_MANAGED_FIELD(vertexCount)>("vertexCount");
        addField<DAS_BIND_MANAGED_FIELD(vertexStride)>("vertexStride");
        addField<DAS_BIND_MANAGED_FIELD(vertexFormat)>("vertexFormat");
        addField<DAS_BIND_MANAGED_FIELD(indexData)>("indexData");
        addField<DAS_BIND_MANAGED_FIELD(indexOffset)>("indexOffset");
        addField<DAS_BIND_MANAGED_FIELD(indexCount)>("indexCount");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
        addField<DAS_BIND_MANAGED_FIELD(transformData)>("transformData");
        addField<DAS_BIND_MANAGED_FIELD(transformOffset)>("transformOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeometryAABBNV, VkGeometryAABBNV);

struct VkGeometryAABBNVAnnotation
: public ManagedStructureAnnotation<VkGeometryAABBNV,true,true> {
    VkGeometryAABBNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryAABBNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(aabbData)>("aabbData");
        addField<DAS_BIND_MANAGED_FIELD(numAABBs)>("numAABBs");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeometryDataNV, VkGeometryDataNV);

struct VkGeometryDataNVAnnotation
: public ManagedStructureAnnotation<VkGeometryDataNV,true,true> {
    VkGeometryDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(triangles)>("triangles");
        addField<DAS_BIND_MANAGED_FIELD(aabbs)>("aabbs");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeometryNV, VkGeometryNV);

struct VkGeometryNVAnnotation
: public ManagedStructureAnnotation<VkGeometryNV,true,true> {
    VkGeometryNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeometryNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(geometryType)>("geometryType");
        addField<DAS_BIND_MANAGED_FIELD(geometry)>("geometry");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureInfoNV, VkAccelerationStructureInfoNV);

struct VkAccelerationStructureInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureInfoNV,true,true> {
    VkAccelerationStructureInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(geometryCount)>("geometryCount");
        addField<DAS_BIND_MANAGED_FIELD(pGeometries)>("pGeometries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureCreateInfoNV, VkAccelerationStructureCreateInfoNV);

struct VkAccelerationStructureCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureCreateInfoNV,true,true> {
    VkAccelerationStructureCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compactedSize)>("compactedSize");
        addField<DAS_BIND_MANAGED_FIELD(info)>("info");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindAccelerationStructureMemoryInfoNV, VkBindAccelerationStructureMemoryInfoNV);

struct VkBindAccelerationStructureMemoryInfoNVAnnotation
: public ManagedStructureAnnotation<VkBindAccelerationStructureMemoryInfoNV,true,true> {
    VkBindAccelerationStructureMemoryInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindAccelerationStructureMemoryInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(memoryOffset)>("memoryOffset");
        addField<DAS_BIND_MANAGED_FIELD(deviceIndexCount)>("deviceIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceIndices)>("pDeviceIndices");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSetAccelerationStructureNV, VkWriteDescriptorSetAccelerationStructureNV);

struct VkWriteDescriptorSetAccelerationStructureNVAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetAccelerationStructureNV,true,true> {
    VkWriteDescriptorSetAccelerationStructureNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetAccelerationStructureNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCount)>("accelerationStructureCount");
        addField<DAS_BIND_MANAGED_FIELD(pAccelerationStructures)>("pAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureMemoryRequirementsInfoNV, VkAccelerationStructureMemoryRequirementsInfoNV);

struct VkAccelerationStructureMemoryRequirementsInfoNVAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureMemoryRequirementsInfoNV,true,true> {
    VkAccelerationStructureMemoryRequirementsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureMemoryRequirementsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRayTracingPropertiesNV);

struct VkPhysicalDeviceRayTracingPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPropertiesNV,true,true> {
    VkPhysicalDeviceRayTracingPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleSize)>("shaderGroupHandleSize");
        addField<DAS_BIND_MANAGED_FIELD(maxRecursionDepth)>("maxRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxShaderGroupStride)>("maxShaderGroupStride");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupBaseAlignment)>("shaderGroupBaseAlignment");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryCount)>("maxGeometryCount");
        addField<DAS_BIND_MANAGED_FIELD(maxInstanceCount)>("maxInstanceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTriangleCount)>("maxTriangleCount");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetAccelerationStructures)>("maxDescriptorSetAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTransformMatrixKHR, VkTransformMatrixKHR);

struct VkTransformMatrixKHRAnnotation
: public ManagedStructureAnnotation<VkTransformMatrixKHR,true,true> {
    VkTransformMatrixKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTransformMatrixKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(matrix)>("matrix");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAabbPositionsKHR, VkAabbPositionsKHR);

struct VkAabbPositionsKHRAnnotation
: public ManagedStructureAnnotation<VkAabbPositionsKHR,true,true> {
    VkAabbPositionsKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAabbPositionsKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minX)>("minX");
        addField<DAS_BIND_MANAGED_FIELD(minY)>("minY");
        addField<DAS_BIND_MANAGED_FIELD(minZ)>("minZ");
        addField<DAS_BIND_MANAGED_FIELD(maxX)>("maxX");
        addField<DAS_BIND_MANAGED_FIELD(maxY)>("maxY");
        addField<DAS_BIND_MANAGED_FIELD(maxZ)>("maxZ");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureInstanceKHR, VkAccelerationStructureInstanceKHR);

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_instanceCustomIndex(const VkAccelerationStructureInstanceKHR &s) { return s.instanceCustomIndex; }
__forceinline void VkAccelerationStructureInstanceKHR_set_instanceCustomIndex(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.instanceCustomIndex = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_mask(const VkAccelerationStructureInstanceKHR &s) { return s.mask; }
__forceinline void VkAccelerationStructureInstanceKHR_set_mask(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.mask = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset(const VkAccelerationStructureInstanceKHR &s) { return s.instanceShaderBindingTableRecordOffset; }
__forceinline void VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.instanceShaderBindingTableRecordOffset = f; }

__forceinline unsigned int VkAccelerationStructureInstanceKHR_get_flags(const VkAccelerationStructureInstanceKHR &s) { return s.flags; }
__forceinline void VkAccelerationStructureInstanceKHR_set_flags(VkAccelerationStructureInstanceKHR &s, unsigned int f) { s.flags = f; }

struct VkAccelerationStructureInstanceKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureInstanceKHR,true,true> {
    VkAccelerationStructureInstanceKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureInstanceKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureReference)>("accelerationStructureReference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);

struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,true,true> {
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(representativeFragmentTest)>("representativeFragmentTest");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineRepresentativeFragmentTestStateCreateInfoNV);

struct VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineRepresentativeFragmentTestStateCreateInfoNV,true,true> {
    VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRepresentativeFragmentTestStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(representativeFragmentTestEnable)>("representativeFragmentTestEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImageViewImageFormatInfoEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT);

struct VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageViewImageFormatInfoEXT,true,true> {
    VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageViewImageFormatInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageViewType)>("imageViewType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFilterCubicImageViewImageFormatPropertiesEXT, VkFilterCubicImageViewImageFormatPropertiesEXT);

struct VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkFilterCubicImageViewImageFormatPropertiesEXT,true,true> {
    VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFilterCubicImageViewImageFormatPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterCubic)>("filterCubic");
        addField<DAS_BIND_MANAGED_FIELD(filterCubicMinmax)>("filterCubicMinmax");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueGlobalPriorityCreateInfoEXT, VkDeviceQueueGlobalPriorityCreateInfoEXT);

struct VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueGlobalPriorityCreateInfoEXT,true,true> {
    VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueGlobalPriorityCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(globalPriority)>("globalPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImportMemoryHostPointerInfoEXT, VkImportMemoryHostPointerInfoEXT);

struct VkImportMemoryHostPointerInfoEXTAnnotation
: public ManagedStructureAnnotation<VkImportMemoryHostPointerInfoEXT,true,true> {
    VkImportMemoryHostPointerInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImportMemoryHostPointerInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
        addField<DAS_BIND_MANAGED_FIELD(pHostPointer)>("pHostPointer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryHostPointerPropertiesEXT, VkMemoryHostPointerPropertiesEXT);

struct VkMemoryHostPointerPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryHostPointerPropertiesEXT,true,true> {
    VkMemoryHostPointerPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHostPointerPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeBits)>("memoryTypeBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT);

struct VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalMemoryHostPropertiesEXT,true,true> {
    VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalMemoryHostPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minImportedHostPointerAlignment)>("minImportedHostPointerAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCompilerControlCreateInfoAMD, VkPipelineCompilerControlCreateInfoAMD);

struct VkPipelineCompilerControlCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkPipelineCompilerControlCreateInfoAMD,true,true> {
    VkPipelineCompilerControlCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCompilerControlCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(compilerControlFlags)>("compilerControlFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCalibratedTimestampInfoEXT, VkCalibratedTimestampInfoEXT);

struct VkCalibratedTimestampInfoEXTAnnotation
: public ManagedStructureAnnotation<VkCalibratedTimestampInfoEXT,true,true> {
    VkCalibratedTimestampInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCalibratedTimestampInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timeDomain)>("timeDomain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesAMD);

struct VkPhysicalDeviceShaderCorePropertiesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCorePropertiesAMD,true,true> {
    VkPhysicalDeviceShaderCorePropertiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCorePropertiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderEngineCount)>("shaderEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderArraysPerEngineCount)>("shaderArraysPerEngineCount");
        addField<DAS_BIND_MANAGED_FIELD(computeUnitsPerShaderArray)>("computeUnitsPerShaderArray");
        addField<DAS_BIND_MANAGED_FIELD(simdPerComputeUnit)>("simdPerComputeUnit");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontsPerSimd)>("wavefrontsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(wavefrontSize)>("wavefrontSize");
        addField<DAS_BIND_MANAGED_FIELD(sgprsPerSimd)>("sgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minSgprAllocation)>("minSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxSgprAllocation)>("maxSgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(sgprAllocationGranularity)>("sgprAllocationGranularity");
        addField<DAS_BIND_MANAGED_FIELD(vgprsPerSimd)>("vgprsPerSimd");
        addField<DAS_BIND_MANAGED_FIELD(minVgprAllocation)>("minVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(maxVgprAllocation)>("maxVgprAllocation");
        addField<DAS_BIND_MANAGED_FIELD(vgprAllocationGranularity)>("vgprAllocationGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOverallocationCreateInfoAMD, VkDeviceMemoryOverallocationCreateInfoAMD);

struct VkDeviceMemoryOverallocationCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOverallocationCreateInfoAMD,true,true> {
    VkDeviceMemoryOverallocationCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOverallocationCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(overallocationBehavior)>("overallocationBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexAttribDivisor)>("maxVertexAttribDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkVertexInputBindingDivisorDescriptionEXT, VkVertexInputBindingDivisorDescriptionEXT);

struct VkVertexInputBindingDivisorDescriptionEXTAnnotation
: public ManagedStructureAnnotation<VkVertexInputBindingDivisorDescriptionEXT,true,true> {
    VkVertexInputBindingDivisorDescriptionEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkVertexInputBindingDivisorDescriptionEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(binding)>("binding");
        addField<DAS_BIND_MANAGED_FIELD(divisor)>("divisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineVertexInputDivisorStateCreateInfoEXT, VkPipelineVertexInputDivisorStateCreateInfoEXT);

struct VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineVertexInputDivisorStateCreateInfoEXT,true,true> {
    VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineVertexInputDivisorStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingDivisorCount)>("vertexBindingDivisorCount");
        addField<DAS_BIND_MANAGED_FIELD(pVertexBindingDivisors)>("pVertexBindingDivisors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);

struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,true,true> {
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateDivisor)>("vertexAttributeInstanceRateDivisor");
        addField<DAS_BIND_MANAGED_FIELD(vertexAttributeInstanceRateZeroDivisor)>("vertexAttributeInstanceRateZeroDivisor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackEXT);

struct VkPipelineCreationFeedbackEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackEXT,true,true> {
    VkPipelineCreationFeedbackEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(duration)>("duration");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackCreateInfoEXT);

struct VkPipelineCreationFeedbackCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineCreationFeedbackCreateInfoEXT,true,true> {
    VkPipelineCreationFeedbackCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCreationFeedbackCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineCreationFeedback)>("pPipelineCreationFeedback");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStageCreationFeedbackCount)>("pipelineStageCreationFeedbackCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelineStageCreationFeedbacks)>("pPipelineStageCreationFeedbacks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);

struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,true,true> {
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupQuads)>("computeDerivativeGroupQuads");
        addField<DAS_BIND_MANAGED_FIELD(computeDerivativeGroupLinear)>("computeDerivativeGroupLinear");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderFeaturesNV);

struct VkPhysicalDeviceMeshShaderFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderFeaturesNV,true,true> {
    VkPhysicalDeviceMeshShaderFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(taskShader)>("taskShader");
        addField<DAS_BIND_MANAGED_FIELD(meshShader)>("meshShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesNV);

struct VkPhysicalDeviceMeshShaderPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMeshShaderPropertiesNV,true,true> {
    VkPhysicalDeviceMeshShaderPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMeshShaderPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawMeshTasksCount)>("maxDrawMeshTasksCount");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupInvocations)>("maxTaskWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskWorkGroupSize)>("maxTaskWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskTotalMemorySize)>("maxTaskTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxTaskOutputCount)>("maxTaskOutputCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupInvocations)>("maxMeshWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshWorkGroupSize)>("maxMeshWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshTotalMemorySize)>("maxMeshTotalMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputVertices)>("maxMeshOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshOutputPrimitives)>("maxMeshOutputPrimitives");
        addField<DAS_BIND_MANAGED_FIELD(maxMeshMultiviewViewCount)>("maxMeshMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerVertexGranularity)>("meshOutputPerVertexGranularity");
        addField<DAS_BIND_MANAGED_FIELD(meshOutputPerPrimitiveGranularity)>("meshOutputPerPrimitiveGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawMeshTasksIndirectCommandNV, VkDrawMeshTasksIndirectCommandNV);

struct VkDrawMeshTasksIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkDrawMeshTasksIndirectCommandNV,true,true> {
    VkDrawMeshTasksIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawMeshTasksIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(taskCount)>("taskCount");
        addField<DAS_BIND_MANAGED_FIELD(firstTask)>("firstTask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);

struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderBarycentric)>("fragmentShaderBarycentric");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderImageFootprintFeaturesNV);

struct VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageFootprintFeaturesNV,true,true> {
    VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageFootprintFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imageFootprint)>("imageFootprint");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV);

struct VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineViewportExclusiveScissorStateCreateInfoNV,true,true> {
    VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineViewportExclusiveScissorStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissorCount)>("exclusiveScissorCount");
        addField<DAS_BIND_MANAGED_FIELD(pExclusiveScissors)>("pExclusiveScissors");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExclusiveScissorFeaturesNV);

struct VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExclusiveScissorFeaturesNV,true,true> {
    VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExclusiveScissorFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exclusiveScissor)>("exclusiveScissor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyCheckpointPropertiesNV);

struct VkQueueFamilyCheckpointPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyCheckpointPropertiesNV,true,true> {
    VkQueueFamilyCheckpointPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyCheckpointPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(checkpointExecutionStageMask)>("checkpointExecutionStageMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCheckpointDataNV, VkCheckpointDataNV);

struct VkCheckpointDataNVAnnotation
: public ManagedStructureAnnotation<VkCheckpointDataNV,true,true> {
    VkCheckpointDataNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCheckpointDataNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stage)>("stage");
        addField<DAS_BIND_MANAGED_FIELD(pCheckpointMarker)>("pCheckpointMarker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);

struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,true,true> {
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderIntegerFunctions2)>("shaderIntegerFunctions2");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueDataINTEL, VkPerformanceValueDataINTEL);

struct VkPerformanceValueDataINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueDataINTEL,true,true> {
    VkPerformanceValueDataINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueDataINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(value32)>("value32");
        addField<DAS_BIND_MANAGED_FIELD(value64)>("value64");
        addField<DAS_BIND_MANAGED_FIELD(valueFloat)>("valueFloat");
        addField<DAS_BIND_MANAGED_FIELD(valueBool)>("valueBool");
        addField<DAS_BIND_MANAGED_FIELD(valueString)>("valueString");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceValueINTEL, VkPerformanceValueINTEL);

struct VkPerformanceValueINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceValueINTEL,true,true> {
    VkPerformanceValueINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceValueINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInitializePerformanceApiInfoINTEL, VkInitializePerformanceApiInfoINTEL);

struct VkInitializePerformanceApiInfoINTELAnnotation
: public ManagedStructureAnnotation<VkInitializePerformanceApiInfoINTEL,true,true> {
    VkInitializePerformanceApiInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInitializePerformanceApiInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPoolPerformanceQueryCreateInfoINTEL, VkQueryPoolPerformanceQueryCreateInfoINTEL);

struct VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation
: public ManagedStructureAnnotation<VkQueryPoolPerformanceQueryCreateInfoINTEL,true,true> {
    VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueryPoolPerformanceQueryCreateInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(performanceCountersSampling)>("performanceCountersSampling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceMarkerInfoINTEL, VkPerformanceMarkerInfoINTEL);

struct VkPerformanceMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceMarkerInfoINTEL,true,true> {
    VkPerformanceMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceStreamMarkerInfoINTEL, VkPerformanceStreamMarkerInfoINTEL);

struct VkPerformanceStreamMarkerInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceStreamMarkerInfoINTEL,true,true> {
    VkPerformanceStreamMarkerInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceStreamMarkerInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(marker)>("marker");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceOverrideInfoINTEL, VkPerformanceOverrideInfoINTEL);

struct VkPerformanceOverrideInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceOverrideInfoINTEL,true,true> {
    VkPerformanceOverrideInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceOverrideInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(enable)>("enable");
        addField<DAS_BIND_MANAGED_FIELD(parameter)>("parameter");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPerformanceConfigurationAcquireInfoINTEL, VkPerformanceConfigurationAcquireInfoINTEL);

struct VkPerformanceConfigurationAcquireInfoINTELAnnotation
: public ManagedStructureAnnotation<VkPerformanceConfigurationAcquireInfoINTEL,true,true> {
    VkPerformanceConfigurationAcquireInfoINTELAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPerformanceConfigurationAcquireInfoINTEL", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePCIBusInfoPropertiesEXT);

struct VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePCIBusInfoPropertiesEXT,true,true> {
    VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePCIBusInfoPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pciDomain)>("pciDomain");
        addField<DAS_BIND_MANAGED_FIELD(pciBus)>("pciBus");
        addField<DAS_BIND_MANAGED_FIELD(pciDevice)>("pciDevice");
        addField<DAS_BIND_MANAGED_FIELD(pciFunction)>("pciFunction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayNativeHdrSurfaceCapabilitiesAMD);

struct VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation
: public ManagedStructureAnnotation<VkDisplayNativeHdrSurfaceCapabilitiesAMD,true,true> {
    VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayNativeHdrSurfaceCapabilitiesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingSupport)>("localDimmingSupport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainDisplayNativeHdrCreateInfoAMD);

struct VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation
: public ManagedStructureAnnotation<VkSwapchainDisplayNativeHdrCreateInfoAMD,true,true> {
    VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainDisplayNativeHdrCreateInfoAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(localDimmingEnable)>("localDimmingEnable");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMap)>("fragmentDensityMap");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDynamic)>("fragmentDensityMapDynamic");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapNonSubsampledImages)>("fragmentDensityMapNonSubsampledImages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMapPropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMapPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minFragmentDensityTexelSize)>("minFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDensityTexelSize)>("maxFragmentDensityTexelSize");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityInvocations)>("fragmentDensityInvocations");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT);

struct VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkRenderPassFragmentDensityMapCreateInfoEXT,true,true> {
    VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassFragmentDensityMapCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapAttachment)>("fragmentDensityMapAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);

struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSizeControl)>("subgroupSizeControl");
        addField<DAS_BIND_MANAGED_FIELD(computeFullSubgroups)>("computeFullSubgroups");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);

struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,true,true> {
    VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(minSubgroupSize)>("minSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxSubgroupSize)>("maxSubgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkgroupSubgroups)>("maxComputeWorkgroupSubgroups");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSizeStages)>("requiredSubgroupSizeStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);

struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT,true,true> {
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(requiredSubgroupSize)>("requiredSubgroupSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCoreProperties2AMD);

struct VkPhysicalDeviceShaderCoreProperties2AMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderCoreProperties2AMD,true,true> {
    VkPhysicalDeviceShaderCoreProperties2AMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderCoreProperties2AMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderCoreFeatures)>("shaderCoreFeatures");
        addField<DAS_BIND_MANAGED_FIELD(activeComputeUnitCount)>("activeComputeUnitCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceCoherentMemoryFeaturesAMD);

struct VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoherentMemoryFeaturesAMD,true,true> {
    VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoherentMemoryFeaturesAMD", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceCoherentMemory)>("deviceCoherentMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);

struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,true,true> {
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageInt64Atomics)>("shaderImageInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageInt64Atomics)>("sparseImageInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceMemoryBudgetPropertiesEXT);

struct VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryBudgetPropertiesEXT,true,true> {
    VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryBudgetPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(heapBudget)>("heapBudget");
        addField<DAS_BIND_MANAGED_FIELD(heapUsage)>("heapUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT);

struct VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryPriorityFeaturesEXT,true,true> {
    VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryPriorityFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memoryPriority)>("memoryPriority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryPriorityAllocateInfoEXT, VkMemoryPriorityAllocateInfoEXT);

struct VkMemoryPriorityAllocateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkMemoryPriorityAllocateInfoEXT,true,true> {
    VkMemoryPriorityAllocateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryPriorityAllocateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(priority)>("priority");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);

struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,true,true> {
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(dedicatedAllocationImageAliasing)>("dedicatedAllocationImageAliasing");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressCreateInfoEXT);

struct VkBufferDeviceAddressCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressCreateInfoEXT,true,true> {
    VkBufferDeviceAddressCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceToolPropertiesEXT, VkPhysicalDeviceToolPropertiesEXT);

struct VkPhysicalDeviceToolPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceToolPropertiesEXT,true,true> {
    VkPhysicalDeviceToolPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceToolPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(name)>("name");
        addField<DAS_BIND_MANAGED_FIELD(version)>("version");
        addField<DAS_BIND_MANAGED_FIELD(purposes)>("purposes");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
        addField<DAS_BIND_MANAGED_FIELD(layer)>("layer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkValidationFeaturesEXT, VkValidationFeaturesEXT);

struct VkValidationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkValidationFeaturesEXT,true,true> {
    VkValidationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkValidationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(enabledValidationFeatureCount)>("enabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledValidationFeatures)>("pEnabledValidationFeatures");
        addField<DAS_BIND_MANAGED_FIELD(disabledValidationFeatureCount)>("disabledValidationFeatureCount");
        addField<DAS_BIND_MANAGED_FIELD(pDisabledValidationFeatures)>("pDisabledValidationFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCooperativeMatrixPropertiesNV, VkCooperativeMatrixPropertiesNV);

struct VkCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkCooperativeMatrixPropertiesNV,true,true> {
    VkCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(MSize)>("MSize");
        addField<DAS_BIND_MANAGED_FIELD(NSize)>("NSize");
        addField<DAS_BIND_MANAGED_FIELD(KSize)>("KSize");
        addField<DAS_BIND_MANAGED_FIELD(AType)>("AType");
        addField<DAS_BIND_MANAGED_FIELD(BType)>("BType");
        addField<DAS_BIND_MANAGED_FIELD(CType)>("CType");
        addField<DAS_BIND_MANAGED_FIELD(DType)>("DType");
        addField<DAS_BIND_MANAGED_FIELD(scope)>("scope");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixFeaturesNV);

struct VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixFeaturesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrix)>("cooperativeMatrix");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixRobustBufferAccess)>("cooperativeMatrixRobustBufferAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV);

struct VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCooperativeMatrixPropertiesNV,true,true> {
    VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCooperativeMatrixPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(cooperativeMatrixSupportedStages)>("cooperativeMatrixSupportedStages");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV);

struct VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCoverageReductionModeFeaturesNV,true,true> {
    VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCoverageReductionModeFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCoverageReductionStateCreateInfoNV, VkPipelineCoverageReductionStateCreateInfoNV);

struct VkPipelineCoverageReductionStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineCoverageReductionStateCreateInfoNV,true,true> {
    VkPipelineCoverageReductionStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineCoverageReductionStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferMixedSamplesCombinationNV, VkFramebufferMixedSamplesCombinationNV);

struct VkFramebufferMixedSamplesCombinationNVAnnotation
: public ManagedStructureAnnotation<VkFramebufferMixedSamplesCombinationNV,true,true> {
    VkFramebufferMixedSamplesCombinationNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferMixedSamplesCombinationNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(coverageReductionMode)>("coverageReductionMode");
        addField<DAS_BIND_MANAGED_FIELD(rasterizationSamples)>("rasterizationSamples");
        addField<DAS_BIND_MANAGED_FIELD(depthStencilSamples)>("depthStencilSamples");
        addField<DAS_BIND_MANAGED_FIELD(colorSamples)>("colorSamples");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);

struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderSampleInterlock)>("fragmentShaderSampleInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderPixelInterlock)>("fragmentShaderPixelInterlock");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShaderShadingRateInterlock)>("fragmentShaderShadingRateInterlock");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);

struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,true,true> {
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrImageArrays)>("ycbcrImageArrays");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkHeadlessSurfaceCreateInfoEXT, VkHeadlessSurfaceCreateInfoEXT);

struct VkHeadlessSurfaceCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkHeadlessSurfaceCreateInfoEXT,true,true> {
    VkHeadlessSurfaceCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkHeadlessSurfaceCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT);

struct VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationFeaturesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rectangularLines)>("rectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(bresenhamLines)>("bresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(smoothLines)>("smoothLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledRectangularLines)>("stippledRectangularLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledBresenhamLines)>("stippledBresenhamLines");
        addField<DAS_BIND_MANAGED_FIELD(stippledSmoothLines)>("stippledSmoothLines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceLineRasterizationPropertiesEXT);

struct VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLineRasterizationPropertiesEXT,true,true> {
    VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLineRasterizationPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineSubPixelPrecisionBits)>("lineSubPixelPrecisionBits");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineRasterizationLineStateCreateInfoEXT, VkPipelineRasterizationLineStateCreateInfoEXT);

struct VkPipelineRasterizationLineStateCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPipelineRasterizationLineStateCreateInfoEXT,true,true> {
    VkPipelineRasterizationLineStateCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineRasterizationLineStateCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(lineRasterizationMode)>("lineRasterizationMode");
        addField<DAS_BIND_MANAGED_FIELD(stippledLineEnable)>("stippledLineEnable");
        addField<DAS_BIND_MANAGED_FIELD(lineStippleFactor)>("lineStippleFactor");
        addField<DAS_BIND_MANAGED_FIELD(lineStipplePattern)>("lineStipplePattern");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);

struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32Atomics)>("shaderBufferFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat32AtomicAdd)>("shaderBufferFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64Atomics)>("shaderBufferFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferFloat64AtomicAdd)>("shaderBufferFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32Atomics)>("shaderSharedFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat32AtomicAdd)>("shaderSharedFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64Atomics)>("shaderSharedFloat64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedFloat64AtomicAdd)>("shaderSharedFloat64AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32Atomics)>("shaderImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageFloat32AtomicAdd)>("shaderImageFloat32AtomicAdd");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32Atomics)>("sparseImageFloat32Atomics");
        addField<DAS_BIND_MANAGED_FIELD(sparseImageFloat32AtomicAdd)>("sparseImageFloat32AtomicAdd");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceIndexTypeUint8FeaturesEXT);

struct VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIndexTypeUint8FeaturesEXT,true,true> {
    VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIndexTypeUint8FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeUint8)>("indexTypeUint8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);

struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,true,true> {
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(extendedDynamicState)>("extendedDynamicState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);

struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,true,true> {
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDemoteToHelperInvocation)>("shaderDemoteToHelperInvocation");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGraphicsShaderGroupCount)>("maxGraphicsShaderGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectSequenceCount)>("maxIndirectSequenceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenCount)>("maxIndirectCommandsTokenCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamCount)>("maxIndirectCommandsStreamCount");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsTokenOffset)>("maxIndirectCommandsTokenOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxIndirectCommandsStreamStride)>("maxIndirectCommandsStreamStride");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesCountBufferOffsetAlignment)>("minSequencesCountBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minSequencesIndexBufferOffsetAlignment)>("minSequencesIndexBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minIndirectCommandsBufferOffsetAlignment)>("minIndirectCommandsBufferOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);

struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,true,true> {
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceGeneratedCommands)>("deviceGeneratedCommands");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsShaderGroupCreateInfoNV, VkGraphicsShaderGroupCreateInfoNV);

struct VkGraphicsShaderGroupCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsShaderGroupCreateInfoNV,true,true> {
    VkGraphicsShaderGroupCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsShaderGroupCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(pVertexInputState)>("pVertexInputState");
        addField<DAS_BIND_MANAGED_FIELD(pTessellationState)>("pTessellationState");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGraphicsPipelineShaderGroupsCreateInfoNV, VkGraphicsPipelineShaderGroupsCreateInfoNV);

struct VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkGraphicsPipelineShaderGroupsCreateInfoNV,true,true> {
    VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGraphicsPipelineShaderGroupsCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCount)>("pipelineCount");
        addField<DAS_BIND_MANAGED_FIELD(pPipelines)>("pPipelines");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindShaderGroupIndirectCommandNV, VkBindShaderGroupIndirectCommandNV);

struct VkBindShaderGroupIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindShaderGroupIndirectCommandNV,true,true> {
    VkBindShaderGroupIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindShaderGroupIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(groupIndex)>("groupIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindIndexBufferIndirectCommandNV, VkBindIndexBufferIndirectCommandNV);

struct VkBindIndexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindIndexBufferIndirectCommandNV,true,true> {
    VkBindIndexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindIndexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindVertexBufferIndirectCommandNV, VkBindVertexBufferIndirectCommandNV);

struct VkBindVertexBufferIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkBindVertexBufferIndirectCommandNV,true,true> {
    VkBindVertexBufferIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindVertexBufferIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(bufferAddress)>("bufferAddress");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSetStateFlagsIndirectCommandNV, VkSetStateFlagsIndirectCommandNV);

struct VkSetStateFlagsIndirectCommandNVAnnotation
: public ManagedStructureAnnotation<VkSetStateFlagsIndirectCommandNV,true,true> {
    VkSetStateFlagsIndirectCommandNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSetStateFlagsIndirectCommandNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsStreamNV, VkIndirectCommandsStreamNV);

struct VkIndirectCommandsStreamNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsStreamNV,true,true> {
    VkIndirectCommandsStreamNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsStreamNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutTokenNV, VkIndirectCommandsLayoutTokenNV);

struct VkIndirectCommandsLayoutTokenNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutTokenNV,true,true> {
    VkIndirectCommandsLayoutTokenNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutTokenNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(tokenType)>("tokenType");
        addField<DAS_BIND_MANAGED_FIELD(stream)>("stream");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(vertexBindingUnit)>("vertexBindingUnit");
        addField<DAS_BIND_MANAGED_FIELD(vertexDynamicStride)>("vertexDynamicStride");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantPipelineLayout)>("pushconstantPipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantShaderStageFlags)>("pushconstantShaderStageFlags");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantOffset)>("pushconstantOffset");
        addField<DAS_BIND_MANAGED_FIELD(pushconstantSize)>("pushconstantSize");
        addField<DAS_BIND_MANAGED_FIELD(indirectStateFlags)>("indirectStateFlags");
        addField<DAS_BIND_MANAGED_FIELD(indexTypeCount)>("indexTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypes)>("pIndexTypes");
        addField<DAS_BIND_MANAGED_FIELD(pIndexTypeValues)>("pIndexTypeValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkIndirectCommandsLayoutCreateInfoNV, VkIndirectCommandsLayoutCreateInfoNV);

struct VkIndirectCommandsLayoutCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkIndirectCommandsLayoutCreateInfoNV,true,true> {
    VkIndirectCommandsLayoutCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkIndirectCommandsLayoutCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(tokenCount)>("tokenCount");
        addField<DAS_BIND_MANAGED_FIELD(pTokens)>("pTokens");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreamStrides)>("pStreamStrides");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeneratedCommandsInfoNV, VkGeneratedCommandsInfoNV);

struct VkGeneratedCommandsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsInfoNV,true,true> {
    VkGeneratedCommandsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(streamCount)>("streamCount");
        addField<DAS_BIND_MANAGED_FIELD(pStreams)>("pStreams");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCount)>("sequencesCount");
        addField<DAS_BIND_MANAGED_FIELD(preprocessBuffer)>("preprocessBuffer");
        addField<DAS_BIND_MANAGED_FIELD(preprocessOffset)>("preprocessOffset");
        addField<DAS_BIND_MANAGED_FIELD(preprocessSize)>("preprocessSize");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountBuffer)>("sequencesCountBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesCountOffset)>("sequencesCountOffset");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexBuffer)>("sequencesIndexBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sequencesIndexOffset)>("sequencesIndexOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkGeneratedCommandsMemoryRequirementsInfoNV, VkGeneratedCommandsMemoryRequirementsInfoNV);

struct VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation
: public ManagedStructureAnnotation<VkGeneratedCommandsMemoryRequirementsInfoNV,true,true> {
    VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkGeneratedCommandsMemoryRequirementsInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipeline)>("pipeline");
        addField<DAS_BIND_MANAGED_FIELD(indirectCommandsLayout)>("indirectCommandsLayout");
        addField<DAS_BIND_MANAGED_FIELD(maxSequencesCount)>("maxSequencesCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(texelBufferAlignment)>("texelBufferAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);

struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,true,true> {
    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetAlignmentBytes)>("storageTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(storageTexelBufferOffsetSingleTexelAlignment)>("storageTexelBufferOffsetSingleTexelAlignment");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetAlignmentBytes)>("uniformTexelBufferOffsetAlignmentBytes");
        addField<DAS_BIND_MANAGED_FIELD(uniformTexelBufferOffsetSingleTexelAlignment)>("uniformTexelBufferOffsetSingleTexelAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassTransformBeginInfoQCOM, VkRenderPassTransformBeginInfoQCOM);

struct VkRenderPassTransformBeginInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkRenderPassTransformBeginInfoQCOM,true,true> {
    VkRenderPassTransformBeginInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassTransformBeginInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCommandBufferInheritanceRenderPassTransformInfoQCOM, VkCommandBufferInheritanceRenderPassTransformInfoQCOM);

struct VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCommandBufferInheritanceRenderPassTransformInfoQCOM,true,true> {
    VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCommandBufferInheritanceRenderPassTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
        addField<DAS_BIND_MANAGED_FIELD(renderArea)>("renderArea");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);

struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,true,true> {
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceMemoryReport)>("deviceMemoryReport");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryReportCallbackDataEXT, VkDeviceMemoryReportCallbackDataEXT);

struct VkDeviceMemoryReportCallbackDataEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryReportCallbackDataEXT,true,true> {
    VkDeviceMemoryReportCallbackDataEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryReportCallbackDataEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(memoryObjectId)>("memoryObjectId");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(objectType)>("objectType");
        addField<DAS_BIND_MANAGED_FIELD(objectHandle)>("objectHandle");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDeviceMemoryReportCreateInfoEXT);

struct VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDeviceDeviceMemoryReportCreateInfoEXT,true,true> {
    VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDeviceMemoryReportCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRobustness2FeaturesEXT, VkPhysicalDeviceRobustness2FeaturesEXT);

struct VkPhysicalDeviceRobustness2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2FeaturesEXT,true,true> {
    VkPhysicalDeviceRobustness2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess2)>("robustBufferAccess2");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess2)>("robustImageAccess2");
        addField<DAS_BIND_MANAGED_FIELD(nullDescriptor)>("nullDescriptor");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceRobustness2PropertiesEXT);

struct VkPhysicalDeviceRobustness2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRobustness2PropertiesEXT,true,true> {
    VkPhysicalDeviceRobustness2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRobustness2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustStorageBufferAccessSizeAlignment)>("robustStorageBufferAccessSizeAlignment");
        addField<DAS_BIND_MANAGED_FIELD(robustUniformBufferAccessSizeAlignment)>("robustUniformBufferAccessSizeAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerCustomBorderColorCreateInfoEXT, VkSamplerCustomBorderColorCreateInfoEXT);

struct VkSamplerCustomBorderColorCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkSamplerCustomBorderColorCreateInfoEXT,true,true> {
    VkSamplerCustomBorderColorCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerCustomBorderColorCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColor)>("customBorderColor");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceCustomBorderColorPropertiesEXT);

struct VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorPropertiesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorPropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxCustomBorderColorSamplers)>("maxCustomBorderColorSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceCustomBorderColorFeaturesEXT);

struct VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceCustomBorderColorFeaturesEXT,true,true> {
    VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceCustomBorderColorFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColors)>("customBorderColors");
        addField<DAS_BIND_MANAGED_FIELD(customBorderColorWithoutFormat)>("customBorderColorWithoutFormat");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePrivateDataFeaturesEXT, VkPhysicalDevicePrivateDataFeaturesEXT);

struct VkPhysicalDevicePrivateDataFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePrivateDataFeaturesEXT,true,true> {
    VkPhysicalDevicePrivateDataFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePrivateDataFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateData)>("privateData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDevicePrivateDataCreateInfoEXT, VkDevicePrivateDataCreateInfoEXT);

struct VkDevicePrivateDataCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkDevicePrivateDataCreateInfoEXT,true,true> {
    VkDevicePrivateDataCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDevicePrivateDataCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(privateDataSlotRequestCount)>("privateDataSlotRequestCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPrivateDataSlotCreateInfoEXT, VkPrivateDataSlotCreateInfoEXT);

struct VkPrivateDataSlotCreateInfoEXTAnnotation
: public ManagedStructureAnnotation<VkPrivateDataSlotCreateInfoEXT,true,true> {
    VkPrivateDataSlotCreateInfoEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPrivateDataSlotCreateInfoEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);

struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT,true,true> {
    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCreationCacheControl)>("pipelineCreationCacheControl");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDiagnosticsConfigFeaturesNV);

struct VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDiagnosticsConfigFeaturesNV,true,true> {
    VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDiagnosticsConfigFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(diagnosticsConfig)>("diagnosticsConfig");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceDiagnosticsConfigCreateInfoNV);

struct VkDeviceDiagnosticsConfigCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkDeviceDiagnosticsConfigCreateInfoNV,true,true> {
    VkDeviceDiagnosticsConfigCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceDiagnosticsConfigCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentShadingRateEnums)>("fragmentShadingRateEnums");
        addField<DAS_BIND_MANAGED_FIELD(supersampleFragmentShadingRates)>("supersampleFragmentShadingRates");
        addField<DAS_BIND_MANAGED_FIELD(noInvocationFragmentShadingRates)>("noInvocationFragmentShadingRates");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);

struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,true,true> {
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentShadingRateInvocationCount)>("maxFragmentShadingRateInvocationCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateEnumStateCreateInfoNV);

struct VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation
: public ManagedStructureAnnotation<VkPipelineFragmentShadingRateEnumStateCreateInfoNV,true,true> {
    VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineFragmentShadingRateEnumStateCreateInfoNV", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shadingRateType)>("shadingRateType");
        addField<DAS_BIND_MANAGED_FIELD(shadingRate)>("shadingRate");
        addField<DAS_BIND_MANAGED_FIELD(combinerOps)>("combinerOps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);

struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(fragmentDensityMapDeferred)>("fragmentDensityMapDeferred");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);

struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,true,true> {
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subsampledLoads)>("subsampledLoads");
        addField<DAS_BIND_MANAGED_FIELD(subsampledCoarseReconstructionEarlyAccess)>("subsampledCoarseReconstructionEarlyAccess");
        addField<DAS_BIND_MANAGED_FIELD(maxSubsampledArrayLayers)>("maxSubsampledArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSubsampledSamplers)>("maxDescriptorSetSubsampledSamplers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyCommandTransformInfoQCOM, VkCopyCommandTransformInfoQCOM);

struct VkCopyCommandTransformInfoQCOMAnnotation
: public ManagedStructureAnnotation<VkCopyCommandTransformInfoQCOM,true,true> {
    VkCopyCommandTransformInfoQCOMAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyCommandTransformInfoQCOM", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(transform)>("transform");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImageRobustnessFeaturesEXT, VkPhysicalDeviceImageRobustnessFeaturesEXT);

struct VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImageRobustnessFeaturesEXT,true,true> {
    VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImageRobustnessFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(robustImageAccess)>("robustImageAccess");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice4444FormatsFeaturesEXT);

struct VkPhysicalDevice4444FormatsFeaturesEXTAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice4444FormatsFeaturesEXT,true,true> {
    VkPhysicalDevice4444FormatsFeaturesEXTAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice4444FormatsFeaturesEXT", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(formatA4R4G4B4)>("formatA4R4G4B4");
        addField<DAS_BIND_MANAGED_FIELD(formatA4B4G4R4)>("formatA4B4G4R4");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceOrHostAddressKHR, VkDeviceOrHostAddressKHR);

struct VkDeviceOrHostAddressKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressKHR,true,true> {
    VkDeviceOrHostAddressKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceOrHostAddressConstKHR, VkDeviceOrHostAddressConstKHR);

struct VkDeviceOrHostAddressConstKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceOrHostAddressConstKHR,true,true> {
    VkDeviceOrHostAddressConstKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceOrHostAddressConstKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(hostAddress)>("hostAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildRangeInfoKHR, VkAccelerationStructureBuildRangeInfoKHR);

struct VkAccelerationStructureBuildRangeInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildRangeInfoKHR,true,true> {
    VkAccelerationStructureBuildRangeInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildRangeInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(primitiveCount)>("primitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(primitiveOffset)>("primitiveOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(transformOffset)>("transformOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryTrianglesDataKHR, VkAccelerationStructureGeometryTrianglesDataKHR);

struct VkAccelerationStructureGeometryTrianglesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryTrianglesDataKHR,true,true> {
    VkAccelerationStructureGeometryTrianglesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryTrianglesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vertexFormat)>("vertexFormat");
        addField<DAS_BIND_MANAGED_FIELD(vertexData)>("vertexData");
        addField<DAS_BIND_MANAGED_FIELD(vertexStride)>("vertexStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertex)>("maxVertex");
        addField<DAS_BIND_MANAGED_FIELD(indexType)>("indexType");
        addField<DAS_BIND_MANAGED_FIELD(indexData)>("indexData");
        addField<DAS_BIND_MANAGED_FIELD(transformData)>("transformData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryAabbsDataKHR, VkAccelerationStructureGeometryAabbsDataKHR);

struct VkAccelerationStructureGeometryAabbsDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryAabbsDataKHR,true,true> {
    VkAccelerationStructureGeometryAabbsDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryAabbsDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryInstancesDataKHR, VkAccelerationStructureGeometryInstancesDataKHR);

struct VkAccelerationStructureGeometryInstancesDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryInstancesDataKHR,true,true> {
    VkAccelerationStructureGeometryInstancesDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryInstancesDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(arrayOfPointers)>("arrayOfPointers");
        addField<DAS_BIND_MANAGED_FIELD(data)>("data");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryDataKHR, VkAccelerationStructureGeometryDataKHR);

struct VkAccelerationStructureGeometryDataKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryDataKHR,true,true> {
    VkAccelerationStructureGeometryDataKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryDataKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(triangles)>("triangles");
        addField<DAS_BIND_MANAGED_FIELD(aabbs)>("aabbs");
        addField<DAS_BIND_MANAGED_FIELD(instances)>("instances");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureGeometryKHR, VkAccelerationStructureGeometryKHR);

struct VkAccelerationStructureGeometryKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureGeometryKHR,true,true> {
    VkAccelerationStructureGeometryKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureGeometryKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(geometryType)>("geometryType");
        addField<DAS_BIND_MANAGED_FIELD(geometry)>("geometry");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildGeometryInfoKHR, VkAccelerationStructureBuildGeometryInfoKHR);

struct VkAccelerationStructureBuildGeometryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildGeometryInfoKHR,true,true> {
    VkAccelerationStructureBuildGeometryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildGeometryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
        addField<DAS_BIND_MANAGED_FIELD(srcAccelerationStructure)>("srcAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(dstAccelerationStructure)>("dstAccelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(geometryCount)>("geometryCount");
        addField<DAS_BIND_MANAGED_FIELD(pGeometries)>("pGeometries");
        addField<DAS_BIND_MANAGED_FIELD(ppGeometries)>("ppGeometries");
        addField<DAS_BIND_MANAGED_FIELD(scratchData)>("scratchData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureCreateInfoKHR, VkAccelerationStructureCreateInfoKHR);

struct VkAccelerationStructureCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureCreateInfoKHR,true,true> {
    VkAccelerationStructureCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(createFlags)>("createFlags");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureKHR);

struct VkWriteDescriptorSetAccelerationStructureKHRAnnotation
: public ManagedStructureAnnotation<VkWriteDescriptorSetAccelerationStructureKHR,true,true> {
    VkWriteDescriptorSetAccelerationStructureKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkWriteDescriptorSetAccelerationStructureKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCount)>("accelerationStructureCount");
        addField<DAS_BIND_MANAGED_FIELD(pAccelerationStructures)>("pAccelerationStructures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR);

struct VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructureFeaturesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructureFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureCaptureReplay)>("accelerationStructureCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureIndirectBuild)>("accelerationStructureIndirectBuild");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureHostCommands)>("accelerationStructureHostCommands");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingAccelerationStructureUpdateAfterBind)>("descriptorBindingAccelerationStructureUpdateAfterBind");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceAccelerationStructurePropertiesKHR);

struct VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceAccelerationStructurePropertiesKHR,true,true> {
    VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceAccelerationStructurePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryCount)>("maxGeometryCount");
        addField<DAS_BIND_MANAGED_FIELD(maxInstanceCount)>("maxInstanceCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPrimitiveCount)>("maxPrimitiveCount");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorAccelerationStructures)>("maxPerStageDescriptorAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindAccelerationStructures)>("maxPerStageDescriptorUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetAccelerationStructures)>("maxDescriptorSetAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindAccelerationStructures)>("maxDescriptorSetUpdateAfterBindAccelerationStructures");
        addField<DAS_BIND_MANAGED_FIELD(minAccelerationStructureScratchOffsetAlignment)>("minAccelerationStructureScratchOffsetAlignment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureDeviceAddressInfoKHR, VkAccelerationStructureDeviceAddressInfoKHR);

struct VkAccelerationStructureDeviceAddressInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureDeviceAddressInfoKHR,true,true> {
    VkAccelerationStructureDeviceAddressInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureDeviceAddressInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructure)>("accelerationStructure");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureVersionInfoKHR, VkAccelerationStructureVersionInfoKHR);

struct VkAccelerationStructureVersionInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureVersionInfoKHR,true,true> {
    VkAccelerationStructureVersionInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureVersionInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pVersionData)>("pVersionData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyAccelerationStructureToMemoryInfoKHR, VkCopyAccelerationStructureToMemoryInfoKHR);

struct VkCopyAccelerationStructureToMemoryInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureToMemoryInfoKHR,true,true> {
    VkCopyAccelerationStructureToMemoryInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureToMemoryInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyMemoryToAccelerationStructureInfoKHR, VkCopyMemoryToAccelerationStructureInfoKHR);

struct VkCopyMemoryToAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyMemoryToAccelerationStructureInfoKHR,true,true> {
    VkCopyMemoryToAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyMemoryToAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkCopyAccelerationStructureInfoKHR, VkCopyAccelerationStructureInfoKHR);

struct VkCopyAccelerationStructureInfoKHRAnnotation
: public ManagedStructureAnnotation<VkCopyAccelerationStructureInfoKHR,true,true> {
    VkCopyAccelerationStructureInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkCopyAccelerationStructureInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(src)>("src");
        addField<DAS_BIND_MANAGED_FIELD(dst)>("dst");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAccelerationStructureBuildSizesInfoKHR, VkAccelerationStructureBuildSizesInfoKHR);

struct VkAccelerationStructureBuildSizesInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAccelerationStructureBuildSizesInfoKHR,true,true> {
    VkAccelerationStructureBuildSizesInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAccelerationStructureBuildSizesInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(accelerationStructureSize)>("accelerationStructureSize");
        addField<DAS_BIND_MANAGED_FIELD(updateScratchSize)>("updateScratchSize");
        addField<DAS_BIND_MANAGED_FIELD(buildScratchSize)>("buildScratchSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingShaderGroupCreateInfoKHR, VkRayTracingShaderGroupCreateInfoKHR);

struct VkRayTracingShaderGroupCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingShaderGroupCreateInfoKHR,true,true> {
    VkRayTracingShaderGroupCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingShaderGroupCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(generalShader)>("generalShader");
        addField<DAS_BIND_MANAGED_FIELD(closestHitShader)>("closestHitShader");
        addField<DAS_BIND_MANAGED_FIELD(anyHitShader)>("anyHitShader");
        addField<DAS_BIND_MANAGED_FIELD(intersectionShader)>("intersectionShader");
        addField<DAS_BIND_MANAGED_FIELD(pShaderGroupCaptureReplayHandle)>("pShaderGroupCaptureReplayHandle");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingPipelineInterfaceCreateInfoKHR, VkRayTracingPipelineInterfaceCreateInfoKHR);

struct VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineInterfaceCreateInfoKHR,true,true> {
    VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineInterfaceCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayPayloadSize)>("maxPipelineRayPayloadSize");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayHitAttributeSize)>("maxPipelineRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRayTracingPipelineCreateInfoKHR, VkRayTracingPipelineCreateInfoKHR);

struct VkRayTracingPipelineCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkRayTracingPipelineCreateInfoKHR,true,true> {
    VkRayTracingPipelineCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRayTracingPipelineCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(stageCount)>("stageCount");
        addField<DAS_BIND_MANAGED_FIELD(pStages)>("pStages");
        addField<DAS_BIND_MANAGED_FIELD(groupCount)>("groupCount");
        addField<DAS_BIND_MANAGED_FIELD(pGroups)>("pGroups");
        addField<DAS_BIND_MANAGED_FIELD(maxPipelineRayRecursionDepth)>("maxPipelineRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInfo)>("pLibraryInfo");
        addField<DAS_BIND_MANAGED_FIELD(pLibraryInterface)>("pLibraryInterface");
        addField<DAS_BIND_MANAGED_FIELD(pDynamicState)>("pDynamicState");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineHandle)>("basePipelineHandle");
        addField<DAS_BIND_MANAGED_FIELD(basePipelineIndex)>("basePipelineIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRayTracingPipelineFeaturesKHR);

struct VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelineFeaturesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelineFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipeline)>("rayTracingPipeline");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplay)>("rayTracingPipelineShaderGroupHandleCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineShaderGroupHandleCaptureReplayMixed)>("rayTracingPipelineShaderGroupHandleCaptureReplayMixed");
        addField<DAS_BIND_MANAGED_FIELD(rayTracingPipelineTraceRaysIndirect)>("rayTracingPipelineTraceRaysIndirect");
        addField<DAS_BIND_MANAGED_FIELD(rayTraversalPrimitiveCulling)>("rayTraversalPrimitiveCulling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR);

struct VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayTracingPipelinePropertiesKHR,true,true> {
    VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayTracingPipelinePropertiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleSize)>("shaderGroupHandleSize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayRecursionDepth)>("maxRayRecursionDepth");
        addField<DAS_BIND_MANAGED_FIELD(maxShaderGroupStride)>("maxShaderGroupStride");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupBaseAlignment)>("shaderGroupBaseAlignment");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleCaptureReplaySize)>("shaderGroupHandleCaptureReplaySize");
        addField<DAS_BIND_MANAGED_FIELD(maxRayDispatchInvocationCount)>("maxRayDispatchInvocationCount");
        addField<DAS_BIND_MANAGED_FIELD(shaderGroupHandleAlignment)>("shaderGroupHandleAlignment");
        addField<DAS_BIND_MANAGED_FIELD(maxRayHitAttributeSize)>("maxRayHitAttributeSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkStridedDeviceAddressRegionKHR, VkStridedDeviceAddressRegionKHR);

struct VkStridedDeviceAddressRegionKHRAnnotation
: public ManagedStructureAnnotation<VkStridedDeviceAddressRegionKHR,true,true> {
    VkStridedDeviceAddressRegionKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkStridedDeviceAddressRegionKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(deviceAddress)>("deviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTraceRaysIndirectCommandKHR, VkTraceRaysIndirectCommandKHR);

struct VkTraceRaysIndirectCommandKHRAnnotation
: public ManagedStructureAnnotation<VkTraceRaysIndirectCommandKHR,true,true> {
    VkTraceRaysIndirectCommandKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTraceRaysIndirectCommandKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayQueryFeaturesKHR);

struct VkPhysicalDeviceRayQueryFeaturesKHRAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceRayQueryFeaturesKHR,true,true> {
    VkPhysicalDeviceRayQueryFeaturesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceRayQueryFeaturesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(rayQuery)>("rayQuery");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWvidmode, GLFWvidmode);

struct GLFWvidmodeAnnotation
: public ManagedStructureAnnotation<GLFWvidmode,true,true> {
    GLFWvidmodeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWvidmode", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(redBits)>("redBits");
        addField<DAS_BIND_MANAGED_FIELD(greenBits)>("greenBits");
        addField<DAS_BIND_MANAGED_FIELD(blueBits)>("blueBits");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWgammaramp, GLFWgammaramp);

struct GLFWgammarampAnnotation
: public ManagedStructureAnnotation<GLFWgammaramp,true,true> {
    GLFWgammarampAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgammaramp", ml) {
        addField<DAS_BIND_MANAGED_FIELD(red)>("red");
        addField<DAS_BIND_MANAGED_FIELD(green)>("green");
        addField<DAS_BIND_MANAGED_FIELD(blue)>("blue");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWimage, GLFWimage);

struct GLFWimageAnnotation
: public ManagedStructureAnnotation<GLFWimage,true,true> {
    GLFWimageAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWimage", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(pixels)>("pixels");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(GLFWgamepadstate, GLFWgamepadstate);

struct GLFWgamepadstateAnnotation
: public ManagedStructureAnnotation<GLFWgamepadstate,true,true> {
    GLFWgamepadstateAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("GLFWgamepadstate", ml) {
        addField<DAS_BIND_MANAGED_FIELD(buttons)>("buttons");
        addField<DAS_BIND_MANAGED_FIELD(axes)>("axes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

class GeneratedModule_vulkan : public Module {
public:
    GeneratedModule_vulkan() : Module("vulkan") {
    }

protected:
    void addGenerated(ModuleLibrary & lib) {

        //
        // enums
        //

        addEnumeration(make_smart<EnumerationVkResult>());
        addEnumeration(make_smart<EnumerationVkStructureType>());
        addEnumeration(make_smart<EnumerationVkImageLayout>());
        addEnumeration(make_smart<EnumerationVkObjectType>());
        addEnumeration(make_smart<EnumerationVkVendorId>());
        addEnumeration(make_smart<EnumerationVkPipelineCacheHeaderVersion>());
        addEnumeration(make_smart<EnumerationVkSystemAllocationScope>());
        addEnumeration(make_smart<EnumerationVkInternalAllocationType>());
        addEnumeration(make_smart<EnumerationVkFormat>());
        addEnumeration(make_smart<EnumerationVkImageTiling>());
        addEnumeration(make_smart<EnumerationVkImageType>());
        addEnumeration(make_smart<EnumerationVkPhysicalDeviceType>());
        addEnumeration(make_smart<EnumerationVkQueryType>());
        addEnumeration(make_smart<EnumerationVkSharingMode>());
        addEnumeration(make_smart<EnumerationVkComponentSwizzle>());
        addEnumeration(make_smart<EnumerationVkImageViewType>());
        addEnumeration(make_smart<EnumerationVkBlendFactor>());
        addEnumeration(make_smart<EnumerationVkBlendOp>());
        addEnumeration(make_smart<EnumerationVkCompareOp>());
        addEnumeration(make_smart<EnumerationVkDynamicState>());
        addEnumeration(make_smart<EnumerationVkFrontFace>());
        addEnumeration(make_smart<EnumerationVkVertexInputRate>());
        addEnumeration(make_smart<EnumerationVkPrimitiveTopology>());
        addEnumeration(make_smart<EnumerationVkPolygonMode>());
        addEnumeration(make_smart<EnumerationVkStencilOp>());
        addEnumeration(make_smart<EnumerationVkLogicOp>());
        addEnumeration(make_smart<EnumerationVkBorderColor>());
        addEnumeration(make_smart<EnumerationVkFilter>());
        addEnumeration(make_smart<EnumerationVkSamplerAddressMode>());
        addEnumeration(make_smart<EnumerationVkSamplerMipmapMode>());
        addEnumeration(make_smart<EnumerationVkDescriptorType>());
        addEnumeration(make_smart<EnumerationVkAttachmentLoadOp>());
        addEnumeration(make_smart<EnumerationVkAttachmentStoreOp>());
        addEnumeration(make_smart<EnumerationVkPipelineBindPoint>());
        addEnumeration(make_smart<EnumerationVkCommandBufferLevel>());
        addEnumeration(make_smart<EnumerationVkIndexType>());
        addEnumeration(make_smart<EnumerationVkSubpassContents>());
        addEnumeration(make_smart<EnumerationVkAccessFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageAspectFlagBits>());
        addEnumeration(make_smart<EnumerationVkFormatFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkSampleCountFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryHeapFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryPropertyFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueueFlagBits>());
        addEnumeration(make_smart<EnumerationVkDeviceQueueCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineStageFlagBits>());
        addEnumeration(make_smart<EnumerationVkSparseMemoryBindFlagBits>());
        addEnumeration(make_smart<EnumerationVkSparseImageFormatFlagBits>());
        addEnumeration(make_smart<EnumerationVkFenceCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryPipelineStatisticFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryResultFlagBits>());
        addEnumeration(make_smart<EnumerationVkBufferCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkBufferUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkImageViewCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkShaderModuleCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineCacheCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkColorComponentFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkPipelineShaderStageCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkShaderStageFlagBits>());
        addEnumeration(make_smart<EnumerationVkCullModeFlagBits>());
        addEnumeration(make_smart<EnumerationVkSamplerCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorPoolCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorSetLayoutCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkAttachmentDescriptionFlagBits>());
        addEnumeration(make_smart<EnumerationVkDependencyFlagBits>());
        addEnumeration(make_smart<EnumerationVkFramebufferCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkRenderPassCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkSubpassDescriptionFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandPoolCreateFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandPoolResetFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandBufferUsageFlagBits>());
        addEnumeration(make_smart<EnumerationVkQueryControlFlagBits>());
        addEnumeration(make_smart<EnumerationVkCommandBufferResetFlagBits>());
        addEnumeration(make_smart<EnumerationVkStencilFaceFlagBits>());
        addEnumeration(make_smart<EnumerationVkPointClippingBehavior>());
        addEnumeration(make_smart<EnumerationVkTessellationDomainOrigin>());
        addEnumeration(make_smart<EnumerationVkSamplerYcbcrModelConversion>());
        addEnumeration(make_smart<EnumerationVkSamplerYcbcrRange>());
        addEnumeration(make_smart<EnumerationVkChromaLocation>());
        addEnumeration(make_smart<EnumerationVkDescriptorUpdateTemplateType>());
        addEnumeration(make_smart<EnumerationVkSubgroupFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkPeerMemoryFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkMemoryAllocateFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalFenceHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalFenceFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkFenceImportFlagBits>());
        addEnumeration(make_smart<EnumerationVkSemaphoreImportFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalSemaphoreHandleTypeFlagBits>());
        addEnumeration(make_smart<EnumerationVkExternalSemaphoreFeatureFlagBits>());
        addEnumeration(make_smart<EnumerationVkDriverId>());
        addEnumeration(make_smart<EnumerationVkShaderFloatControlsIndependence>());
        addEnumeration(make_smart<EnumerationVkSamplerReductionMode>());
        addEnumeration(make_smart<EnumerationVkSemaphoreType>());
        addEnumeration(make_smart<EnumerationVkResolveModeFlagBits>());
        addEnumeration(make_smart<EnumerationVkDescriptorBindingFlagBits>());
        addEnumeration(make_smart<EnumerationVkSemaphoreWaitFlagBits>());
        addEnumeration(make_smart<EnumerationVkPresentModeKHR>());
        addEnumeration(make_smart<EnumerationVkColorSpaceKHR>());
        addEnumeration(make_smart<EnumerationVkSurfaceTransformFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkCompositeAlphaFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkSwapchainCreateFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkDeviceGroupPresentModeFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkDisplayPlaneAlphaFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterUnitKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterScopeKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterStorageKHR>());
        addEnumeration(make_smart<EnumerationVkPerformanceCounterDescriptionFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkAcquireProfilingLockFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateCombinerOpKHR>());
        addEnumeration(make_smart<EnumerationVkPipelineExecutableStatisticFormatKHR>());
        addEnumeration(make_smart<EnumerationVkDebugReportObjectTypeEXT>());
        addEnumeration(make_smart<EnumerationVkDebugReportFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkRasterizationOrderAMD>());
        addEnumeration(make_smart<EnumerationVkShaderInfoTypeAMD>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryHandleTypeFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkExternalMemoryFeatureFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkValidationCheckEXT>());
        addEnumeration(make_smart<EnumerationVkConditionalRenderingFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkSurfaceCounterFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDisplayPowerStateEXT>());
        addEnumeration(make_smart<EnumerationVkDeviceEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkDisplayEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkViewportCoordinateSwizzleNV>());
        addEnumeration(make_smart<EnumerationVkDiscardRectangleModeEXT>());
        addEnumeration(make_smart<EnumerationVkConservativeRasterizationModeEXT>());
        addEnumeration(make_smart<EnumerationVkDebugUtilsMessageSeverityFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDebugUtilsMessageTypeFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkBlendOverlapEXT>());
        addEnumeration(make_smart<EnumerationVkCoverageModulationModeNV>());
        addEnumeration(make_smart<EnumerationVkValidationCacheHeaderVersionEXT>());
        addEnumeration(make_smart<EnumerationVkShadingRatePaletteEntryNV>());
        addEnumeration(make_smart<EnumerationVkCoarseSampleOrderTypeNV>());
        addEnumeration(make_smart<EnumerationVkRayTracingShaderGroupTypeKHR>());
        addEnumeration(make_smart<EnumerationVkGeometryTypeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureTypeKHR>());
        addEnumeration(make_smart<EnumerationVkCopyAccelerationStructureModeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureMemoryRequirementsTypeNV>());
        addEnumeration(make_smart<EnumerationVkGeometryFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkGeometryInstanceFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkQueueGlobalPriorityEXT>());
        addEnumeration(make_smart<EnumerationVkPipelineCompilerControlFlagBitsAMD>());
        addEnumeration(make_smart<EnumerationVkTimeDomainEXT>());
        addEnumeration(make_smart<EnumerationVkMemoryOverallocationBehaviorAMD>());
        addEnumeration(make_smart<EnumerationVkPipelineCreationFeedbackFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkPerformanceConfigurationTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkQueryPoolSamplingModeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceOverrideTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceParameterTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkPerformanceValueTypeINTEL>());
        addEnumeration(make_smart<EnumerationVkShaderCorePropertiesFlagBitsAMD>());
        addEnumeration(make_smart<EnumerationVkToolPurposeFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkValidationFeatureEnableEXT>());
        addEnumeration(make_smart<EnumerationVkValidationFeatureDisableEXT>());
        addEnumeration(make_smart<EnumerationVkComponentTypeNV>());
        addEnumeration(make_smart<EnumerationVkScopeNV>());
        addEnumeration(make_smart<EnumerationVkCoverageReductionModeNV>());
        addEnumeration(make_smart<EnumerationVkLineRasterizationModeEXT>());
        addEnumeration(make_smart<EnumerationVkIndirectCommandsTokenTypeNV>());
        addEnumeration(make_smart<EnumerationVkIndirectStateFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkIndirectCommandsLayoutUsageFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkDeviceMemoryReportEventTypeEXT>());
        addEnumeration(make_smart<EnumerationVkPrivateDataSlotCreateFlagBitsEXT>());
        addEnumeration(make_smart<EnumerationVkDeviceDiagnosticsConfigFlagBitsNV>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateTypeNV>());
        addEnumeration(make_smart<EnumerationVkFragmentShadingRateNV>());
        addEnumeration(make_smart<EnumerationVkBuildAccelerationStructureModeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureBuildTypeKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureCompatibilityKHR>());
        addEnumeration(make_smart<EnumerationVkAccelerationStructureCreateFlagBitsKHR>());
        addEnumeration(make_smart<EnumerationVkShaderGroupShaderKHR>());

        //
        // opaque structs
        //

        addAnnotation(make_smart<VkHandleAnnotation<VkBuffer>>("VkBuffer", "VkBuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkImage>>("VkImage", "VkImage"));
        addAnnotation(make_smart<VkHandleAnnotation<VkInstance>>("VkInstance", "VkInstance"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPhysicalDevice>>("VkPhysicalDevice", "VkPhysicalDevice"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDevice>>("VkDevice", "VkDevice"));
        addAnnotation(make_smart<VkHandleAnnotation<VkQueue>>("VkQueue", "VkQueue"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSemaphore>>("VkSemaphore", "VkSemaphore"));
        addAnnotation(make_smart<VkHandleAnnotation<VkCommandBuffer>>("VkCommandBuffer", "VkCommandBuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkFence>>("VkFence", "VkFence"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDeviceMemory>>("VkDeviceMemory", "VkDeviceMemory"));
        addAnnotation(make_smart<VkHandleAnnotation<VkEvent>>("VkEvent", "VkEvent"));
        addAnnotation(make_smart<VkHandleAnnotation<VkQueryPool>>("VkQueryPool", "VkQueryPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkBufferView>>("VkBufferView", "VkBufferView"));
        addAnnotation(make_smart<VkHandleAnnotation<VkImageView>>("VkImageView", "VkImageView"));
        addAnnotation(make_smart<VkHandleAnnotation<VkShaderModule>>("VkShaderModule", "VkShaderModule"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipelineCache>>("VkPipelineCache", "VkPipelineCache"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipelineLayout>>("VkPipelineLayout", "VkPipelineLayout"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPipeline>>("VkPipeline", "VkPipeline"));
        addAnnotation(make_smart<VkHandleAnnotation<VkRenderPass>>("VkRenderPass", "VkRenderPass"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorSetLayout>>("VkDescriptorSetLayout", "VkDescriptorSetLayout"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSampler>>("VkSampler", "VkSampler"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorSet>>("VkDescriptorSet", "VkDescriptorSet"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorPool>>("VkDescriptorPool", "VkDescriptorPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkFramebuffer>>("VkFramebuffer", "VkFramebuffer"));
        addAnnotation(make_smart<VkHandleAnnotation<VkCommandPool>>("VkCommandPool", "VkCommandPool"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSamplerYcbcrConversion>>("VkSamplerYcbcrConversion", "VkSamplerYcbcrConversion"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDescriptorUpdateTemplate>>("VkDescriptorUpdateTemplate", "VkDescriptorUpdateTemplate"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSurfaceKHR>>("VkSurfaceKHR", "VkSurfaceKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkSwapchainKHR>>("VkSwapchainKHR", "VkSwapchainKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDisplayKHR>>("VkDisplayKHR", "VkDisplayKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDisplayModeKHR>>("VkDisplayModeKHR", "VkDisplayModeKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDeferredOperationKHR>>("VkDeferredOperationKHR", "VkDeferredOperationKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDebugReportCallbackEXT>>("VkDebugReportCallbackEXT", "VkDebugReportCallbackEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkDebugUtilsMessengerEXT>>("VkDebugUtilsMessengerEXT", "VkDebugUtilsMessengerEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkValidationCacheEXT>>("VkValidationCacheEXT", "VkValidationCacheEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureNV>>("VkAccelerationStructureNV", "VkAccelerationStructureNV"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPerformanceConfigurationINTEL>>("VkPerformanceConfigurationINTEL", "VkPerformanceConfigurationINTEL"));
        addAnnotation(make_smart<VkHandleAnnotation<VkIndirectCommandsLayoutNV>>("VkIndirectCommandsLayoutNV", "VkIndirectCommandsLayoutNV"));
        addAnnotation(make_smart<VkHandleAnnotation<VkPrivateDataSlotEXT>>("VkPrivateDataSlotEXT", "VkPrivateDataSlotEXT"));
        addAnnotation(make_smart<VkHandleAnnotation<VkAccelerationStructureKHR>>("VkAccelerationStructureKHR", "VkAccelerationStructureKHR"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWmonitor_DasHandle>>("GLFWmonitor_DasHandle", "GLFWmonitor_DasHandle"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWwindow_DasHandle>>("GLFWwindow_DasHandle", "GLFWwindow_DasHandle"));
        addAnnotation(make_smart<VkHandleAnnotation<GLFWcursor_DasHandle>>("GLFWcursor_DasHandle", "GLFWcursor_DasHandle"));

        //
        // structs
        //

        addAnnotation(make_smart<VkExtent2DAnnotation>(lib));
        addAnnotation(make_smart<VkExtent3DAnnotation>(lib));
        addAnnotation(make_smart<VkOffset2DAnnotation>(lib));
        addAnnotation(make_smart<VkOffset3DAnnotation>(lib));
        addAnnotation(make_smart<VkRect2DAnnotation>(lib));
        addAnnotation(make_smart<VkBaseInStructureAnnotation>(lib));
        addAnnotation(make_smart<VkBaseOutStructureAnnotation>(lib));
        addAnnotation(make_smart<VkBufferMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkDispatchIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkDrawIndexedIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkDrawIndirectCommandAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceRangeAnnotation>(lib));
        addAnnotation(make_smart<VkImageMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryBarrierAnnotation>(lib));
        addAnnotation(make_smart<VkAllocationCallbacksAnnotation>(lib));
        addAnnotation(make_smart<VkApplicationInfoAnnotation>(lib));
        addAnnotation(make_smart<VkFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkInstanceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryHeapAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryTypeAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLimitsAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSparsePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExtensionPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkLayerPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMappedMemoryRangeAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkSparseMemoryBindAnnotation>(lib));
        addAnnotation(make_smart<VkSparseBufferMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageOpaqueMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryBindAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryBindInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindSparseInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkFenceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkEventCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferViewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubresourceLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkComponentMappingAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkShaderModuleCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCacheCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSpecializationMapEntryAnnotation>(lib));
        addAnnotation(make_smart<VkSpecializationInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineShaderStageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkComputePipelineCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputBindingDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputAttributeDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineVertexInputStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineInputAssemblyStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineTessellationStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkViewportAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineMultisampleStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkStencilOpStateAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDepthStencilStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendAttachmentStateAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDynamicStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsPipelineCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPushConstantRangeAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineLayoutCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCopyDescriptorSetAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorBufferInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorImageInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolSizeAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutBindingAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentReferenceAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDescriptionAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDependencyAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandPoolCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceInfoAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCopyAnnotation>(lib));
        addAnnotation(make_smart<VkImageSubresourceLayersAnnotation>(lib));
        addAnnotation(make_smart<VkBufferImageCopyAnnotation>(lib));
        addAnnotation(make_smart<VkClearColorValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearDepthStencilValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearValueAnnotation>(lib));
        addAnnotation(make_smart<VkClearAttachmentAnnotation>(lib));
        addAnnotation(make_smart<VkClearRectAnnotation>(lib));
        addAnnotation(make_smart<VkImageBlitAnnotation>(lib));
        addAnnotation(make_smart<VkImageCopyAnnotation>(lib));
        addAnnotation(make_smart<VkImageResolveAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkBindBufferMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice16BitStorageFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryDedicatedRequirementsAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryDedicatedAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryAllocateFlagsInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupRenderPassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupCommandBufferBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupBindSparseInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindBufferMemoryDeviceGroupInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemoryDeviceGroupInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceGroupPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupDeviceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkImageMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkImageSparseMemoryRequirementsInfo2Annotation>(lib));
        addAnnotation(make_smart<VkMemoryRequirements2Annotation>(lib));
        addAnnotation(make_smart<VkSparseImageMemoryRequirements2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFeatures2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProperties2Annotation>(lib));
        addAnnotation(make_smart<VkFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkImageFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageFormatInfo2Annotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryProperties2Annotation>(lib));
        addAnnotation(make_smart<VkSparseImageFormatProperties2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSparseImageFormatInfo2Annotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePointClippingPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkInputAttachmentAspectReferenceAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassInputAttachmentAspectCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewUsageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineTessellationDomainOriginStateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassMultiviewCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVariablePointersFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueInfo2Annotation>(lib));
        addAnnotation(make_smart<VkProtectedSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBindImagePlaneMemoryInfoAnnotation>(lib));
        addAnnotation(make_smart<VkImagePlaneMemoryRequirementsInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerYcbcrConversionImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorUpdateTemplateEntryAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorUpdateTemplateCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalImageFormatInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalImageFormatPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalBufferInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalBufferPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceIDPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryImageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryBufferCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExportMemoryAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalFenceInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalFencePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkExportFenceCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExportSemaphoreCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalSemaphoreInfoAnnotation>(lib));
        addAnnotation(make_smart<VkExternalSemaphorePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMaintenance3PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutSupportAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan11FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan11PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan12FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkConformanceVersionAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkan12PropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkImageFormatListCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescription2Annotation>(lib));
        addAnnotation(make_smart<VkAttachmentReference2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassDescription2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassDependency2Annotation>(lib));
        addAnnotation(make_smart<VkRenderPassCreateInfo2Annotation>(lib));
        addAnnotation(make_smart<VkSubpassBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassEndInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice8BitStorageFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDriverPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFloatControlsPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassDescriptionDepthStencilResolveAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkImageStencilUsageCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerReductionModeCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferAttachmentImageInfoAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferAttachmentsCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassAttachmentBeginInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentReferenceStencilLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentDescriptionStencilLayoutAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceHostQueryResetFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreTypeCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkTimelineSemaphoreSubmitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreWaitInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreSignalInfoAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation>(lib));
        addAnnotation(make_smart<VkBufferDeviceAddressInfoAnnotation>(lib));
        addAnnotation(make_smart<VkBufferOpaqueCaptureAddressCreateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceFormatKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkBindImageMemorySwapchainInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAcquireNextImageInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupPresentCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceGroupSwapchainCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeParametersKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlanePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplaySurfaceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPresentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportMemoryFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryFdPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportSemaphoreFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSemaphoreGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePushDescriptorPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRectLayerKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentRegionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPresentRegionsKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSharedPresentSurfaceCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkImportFenceFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkFenceGetFdInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePerformanceQueryFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePerformanceQueryPropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterDescriptionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolPerformanceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceCounterResultKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAcquireProfilingLockInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceQuerySubmitInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSurfaceInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilities2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceFormat2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayModeProperties2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPlaneCapabilities2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderClockFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkFragmentShadingRateAttachmentInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineFragmentShadingRateStateCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRatePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateKHRAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceProtectedCapabilitiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutablePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableStatisticValueKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableStatisticKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineExecutableInternalRepresentationKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineLibraryCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkBufferCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyBufferInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkBufferImageCopy2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyBufferToImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyImageToBufferInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageBlit2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkBlitImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkImageResolve2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkResolveImageInfo2KHRAnnotation>(lib));
        addAnnotation(make_smart<VkDebugReportCallbackCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateRasterizationOrderAMDAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerObjectNameInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerObjectTagInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugMarkerMarkerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationImageCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationBufferCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkDedicatedAllocationMemoryAllocateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTransformFeedbackPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationStateStreamCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewHandleInfoNVXAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewAddressPropertiesNVXAnnotation>(lib));
        addAnnotation(make_smart<VkTextureLODGatherFormatPropertiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkShaderResourceUsageAMDAnnotation>(lib));
        addAnnotation(make_smart<VkShaderStatisticsInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCornerSampledImageFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkExternalImageFormatPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkExternalMemoryImageCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkExportMemoryAllocateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkValidationFlagsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageViewASTCDecodeModeEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceASTCDecodeFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkConditionalRenderingBeginInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceConditionalRenderingFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceConditionalRenderingInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkViewportWScalingNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportWScalingStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkSurfaceCapabilities2EXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayPowerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceEventInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayEventInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainCounterCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRefreshCycleDurationGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPastPresentationTimingGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPresentTimeGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPresentTimesInfoGOOGLEAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXAnnotation>(lib));
        addAnnotation(make_smart<VkViewportSwizzleNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportSwizzleStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDiscardRectanglePropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineDiscardRectangleStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceConservativeRasterizationPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationConservativeStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDepthClipEnableFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationDepthClipStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkXYColorEXTAnnotation>(lib));
        addAnnotation(make_smart<VkHdrMetadataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsLabelEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsObjectNameInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsMessengerCallbackDataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsMessengerCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDebugUtilsObjectTagInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceInlineUniformBlockPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetInlineUniformBlockEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDescriptorPoolInlineUniformBlockCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSampleLocationEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSampleLocationsInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkAttachmentSampleLocationsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSubpassSampleLocationsEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassSampleLocationsBeginInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineSampleLocationsStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSampleLocationsPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMultisamplePropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineColorBlendAdvancedStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageToColorStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageModulationStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderSMBuiltinsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDrmFormatModifierPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDrmFormatModifierPropertiesListEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageDrmFormatModifierInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierListCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierExplicitCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImageDrmFormatModifierPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkValidationCacheCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkShaderModuleValidationCacheCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkShadingRatePaletteNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportShadingRateImageStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShadingRateImageFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShadingRateImagePropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkCoarseSampleLocationNVAnnotation>(lib));
        addAnnotation(make_smart<VkCoarseSampleOrderCustomNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportCoarseSampleOrderStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingShaderGroupCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryTrianglesNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryAABBNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryDataNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeometryNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindAccelerationStructureMemoryInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAccelerationStructureNVAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureMemoryRequirementsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkTransformMatrixKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAabbPositionsKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureInstanceKHRAnnotation>(lib));
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_instanceCustomIndex)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_instanceCustomIndex",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_instanceCustomIndex)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_instanceCustomIndex",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_mask)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_mask",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_mask)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_mask",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_instanceShaderBindingTableRecordOffset",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_instanceShaderBindingTableRecordOffset",
            SideEffects::modifyArgument, "{field.setter_name}");
        
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_get_flags)>(*this, lib, "VkAccelerationStructureInstanceKHR_get_flags",
            SideEffects::none, "{field.getter_name}");
        addExtern<DAS_BIND_FUN(VkAccelerationStructureInstanceKHR_set_flags)>(*this, lib, "VkAccelerationStructureInstanceKHR_set_flags",
            SideEffects::modifyArgument, "{field.setter_name}");
        addAnnotation(make_smart<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRepresentativeFragmentTestStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageViewImageFormatInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkFilterCubicImageViewImageFormatPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceQueueGlobalPriorityCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkImportMemoryHostPointerInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryHostPointerPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExternalMemoryHostPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCompilerControlCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkCalibratedTimestampInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderCorePropertiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryOverallocationCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkVertexInputBindingDivisorDescriptionEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineVertexInputDivisorStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCreationFeedbackEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCreationFeedbackCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceComputeShaderDerivativesFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMeshShaderFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMeshShaderPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDrawMeshTasksIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderImageFootprintFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineViewportExclusiveScissorStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExclusiveScissorFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkQueueFamilyCheckpointPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkCheckpointDataNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceValueDataINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceValueINTELAnnotation>(lib));
        addAnnotation(make_smart<VkInitializePerformanceApiInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkQueryPoolPerformanceQueryCreateInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceMarkerInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceStreamMarkerInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceOverrideInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPerformanceConfigurationAcquireInfoINTELAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePCIBusInfoPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDisplayNativeHdrSurfaceCapabilitiesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkSwapchainDisplayNativeHdrCreateInfoAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMapPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassFragmentDensityMapCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceSubgroupSizeControlPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderCoreProperties2AMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCoherentMemoryFeaturesAMDAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryBudgetPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceMemoryPriorityFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkMemoryPriorityAllocateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkBufferDeviceAddressCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceToolPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkValidationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCooperativeMatrixPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCooperativeMatrixPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCoverageReductionModeFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineCoverageReductionStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkFramebufferMixedSamplesCombinationNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceYcbcrImageArraysFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkHeadlessSurfaceCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceLineRasterizationPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineRasterizationLineStateCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicFloatFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceIndexTypeUint8FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceExtendedDynamicStateFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsShaderGroupCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGraphicsPipelineShaderGroupsCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindShaderGroupIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindIndexBufferIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkBindVertexBufferIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkSetStateFlagsIndirectCommandNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsStreamNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsLayoutTokenNVAnnotation>(lib));
        addAnnotation(make_smart<VkIndirectCommandsLayoutCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeneratedCommandsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkGeneratedCommandsMemoryRequirementsInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkRenderPassTransformBeginInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkCommandBufferInheritanceRenderPassTransformInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDeviceMemoryReportFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceMemoryReportCallbackDataEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceDeviceMemoryReportCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRobustness2FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRobustness2PropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkSamplerCustomBorderColorCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorPropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceCustomBorderColorFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePrivateDataFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDevicePrivateDataCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPrivateDataSlotCreateInfoEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceDiagnosticsConfigFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceDiagnosticsConfigCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVAnnotation>(lib));
        addAnnotation(make_smart<VkPipelineFragmentShadingRateEnumStateCreateInfoNVAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2FeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceFragmentDensityMap2PropertiesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkCopyCommandTransformInfoQCOMAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceImageRobustnessFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDevice4444FormatsFeaturesEXTAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceOrHostAddressKHRAnnotation>(lib));
        addAnnotation(make_smart<VkDeviceOrHostAddressConstKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildRangeInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryTrianglesDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryAabbsDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryInstancesDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryDataKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureGeometryKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildGeometryInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkWriteDescriptorSetAccelerationStructureKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructureFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceAccelerationStructurePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureDeviceAddressInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureVersionInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyAccelerationStructureToMemoryInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyMemoryToAccelerationStructureInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkCopyAccelerationStructureInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkAccelerationStructureBuildSizesInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingShaderGroupCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineInterfaceCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkRayTracingPipelineCreateInfoKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelineFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayTracingPipelinePropertiesKHRAnnotation>(lib));
        addAnnotation(make_smart<VkStridedDeviceAddressRegionKHRAnnotation>(lib));
        addAnnotation(make_smart<VkTraceRaysIndirectCommandKHRAnnotation>(lib));
        addAnnotation(make_smart<VkPhysicalDeviceRayQueryFeaturesKHRAnnotation>(lib));
        addAnnotation(make_smart<GLFWvidmodeAnnotation>(lib));
        addAnnotation(make_smart<GLFWgammarampAnnotation>(lib));
        addAnnotation(make_smart<GLFWimageAnnotation>(lib));
        addAnnotation(make_smart<GLFWgamepadstateAnnotation>(lib));

        //
        // functions
        //

        addExtern<DAS_BIND_FUN(vkCreateInstance)>(*this, lib, "vkCreateInstance",
            SideEffects::worstDefault, "vkCreateInstance");
        addExtern<DAS_BIND_FUN(vkDestroyInstance)>(*this, lib, "vkDestroyInstance",
            SideEffects::worstDefault, "vkDestroyInstance");
        addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDevices)>(*this, lib, "vkEnumeratePhysicalDevices",
            SideEffects::worstDefault, "vkEnumeratePhysicalDevices");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures)>(*this, lib, "vkGetPhysicalDeviceFeatures",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties)>(*this, lib, "vkGetPhysicalDeviceFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties)>(*this, lib, "vkGetPhysicalDeviceProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties");
        addExtern<DAS_BIND_FUN(vkCreateDevice)>(*this, lib, "vkCreateDevice",
            SideEffects::worstDefault, "vkCreateDevice");
        addExtern<DAS_BIND_FUN(vkDestroyDevice)>(*this, lib, "vkDestroyDevice",
            SideEffects::worstDefault, "vkDestroyDevice");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceExtensionProperties)>(*this, lib, "vkEnumerateInstanceExtensionProperties",
            SideEffects::worstDefault, "vkEnumerateInstanceExtensionProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateDeviceExtensionProperties)>(*this, lib, "vkEnumerateDeviceExtensionProperties",
            SideEffects::worstDefault, "vkEnumerateDeviceExtensionProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceLayerProperties)>(*this, lib, "vkEnumerateInstanceLayerProperties",
            SideEffects::worstDefault, "vkEnumerateInstanceLayerProperties");
        addExtern<DAS_BIND_FUN(vkEnumerateDeviceLayerProperties)>(*this, lib, "vkEnumerateDeviceLayerProperties",
            SideEffects::worstDefault, "vkEnumerateDeviceLayerProperties");
        addExtern<DAS_BIND_FUN(vkGetDeviceQueue)>(*this, lib, "vkGetDeviceQueue",
            SideEffects::worstDefault, "vkGetDeviceQueue");
        addExtern<DAS_BIND_FUN(vkQueueSubmit)>(*this, lib, "vkQueueSubmit",
            SideEffects::worstDefault, "vkQueueSubmit");
        addExtern<DAS_BIND_FUN(vkQueueWaitIdle)>(*this, lib, "vkQueueWaitIdle",
            SideEffects::worstDefault, "vkQueueWaitIdle");
        addExtern<DAS_BIND_FUN(vkDeviceWaitIdle)>(*this, lib, "vkDeviceWaitIdle",
            SideEffects::worstDefault, "vkDeviceWaitIdle");
        addExtern<DAS_BIND_FUN(vkAllocateMemory)>(*this, lib, "vkAllocateMemory",
            SideEffects::worstDefault, "vkAllocateMemory");
        addExtern<DAS_BIND_FUN(vkFreeMemory)>(*this, lib, "vkFreeMemory",
            SideEffects::worstDefault, "vkFreeMemory");
        addExtern<DAS_BIND_FUN(vkMapMemory)>(*this, lib, "vkMapMemory",
            SideEffects::worstDefault, "vkMapMemory");
        addExtern<DAS_BIND_FUN(vkUnmapMemory)>(*this, lib, "vkUnmapMemory",
            SideEffects::worstDefault, "vkUnmapMemory");
        addExtern<DAS_BIND_FUN(vkFlushMappedMemoryRanges)>(*this, lib, "vkFlushMappedMemoryRanges",
            SideEffects::worstDefault, "vkFlushMappedMemoryRanges");
        addExtern<DAS_BIND_FUN(vkInvalidateMappedMemoryRanges)>(*this, lib, "vkInvalidateMappedMemoryRanges",
            SideEffects::worstDefault, "vkInvalidateMappedMemoryRanges");
        addExtern<DAS_BIND_FUN(vkGetDeviceMemoryCommitment)>(*this, lib, "vkGetDeviceMemoryCommitment",
            SideEffects::worstDefault, "vkGetDeviceMemoryCommitment");
        addExtern<DAS_BIND_FUN(vkBindBufferMemory)>(*this, lib, "vkBindBufferMemory",
            SideEffects::worstDefault, "vkBindBufferMemory");
        addExtern<DAS_BIND_FUN(vkBindImageMemory)>(*this, lib, "vkBindImageMemory",
            SideEffects::worstDefault, "vkBindImageMemory");
        addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements)>(*this, lib, "vkGetBufferMemoryRequirements",
            SideEffects::worstDefault, "vkGetBufferMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements)>(*this, lib, "vkGetImageMemoryRequirements",
            SideEffects::worstDefault, "vkGetImageMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements)>(*this, lib, "vkGetImageSparseMemoryRequirements",
            SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties");
        addExtern<DAS_BIND_FUN(vkQueueBindSparse)>(*this, lib, "vkQueueBindSparse",
            SideEffects::worstDefault, "vkQueueBindSparse");
        addExtern<DAS_BIND_FUN(vkCreateFence)>(*this, lib, "vkCreateFence",
            SideEffects::worstDefault, "vkCreateFence");
        addExtern<DAS_BIND_FUN(vkDestroyFence)>(*this, lib, "vkDestroyFence",
            SideEffects::worstDefault, "vkDestroyFence");
        addExtern<DAS_BIND_FUN(vkResetFences)>(*this, lib, "vkResetFences",
            SideEffects::worstDefault, "vkResetFences");
        addExtern<DAS_BIND_FUN(vkGetFenceStatus)>(*this, lib, "vkGetFenceStatus",
            SideEffects::worstDefault, "vkGetFenceStatus");
        addExtern<DAS_BIND_FUN(vkWaitForFences)>(*this, lib, "vkWaitForFences",
            SideEffects::worstDefault, "vkWaitForFences");
        addExtern<DAS_BIND_FUN(vkCreateSemaphore)>(*this, lib, "vkCreateSemaphore",
            SideEffects::worstDefault, "vkCreateSemaphore");
        addExtern<DAS_BIND_FUN(vkDestroySemaphore)>(*this, lib, "vkDestroySemaphore",
            SideEffects::worstDefault, "vkDestroySemaphore");
        addExtern<DAS_BIND_FUN(vkCreateEvent)>(*this, lib, "vkCreateEvent",
            SideEffects::worstDefault, "vkCreateEvent");
        addExtern<DAS_BIND_FUN(vkDestroyEvent)>(*this, lib, "vkDestroyEvent",
            SideEffects::worstDefault, "vkDestroyEvent");
        addExtern<DAS_BIND_FUN(vkGetEventStatus)>(*this, lib, "vkGetEventStatus",
            SideEffects::worstDefault, "vkGetEventStatus");
        addExtern<DAS_BIND_FUN(vkSetEvent)>(*this, lib, "vkSetEvent",
            SideEffects::worstDefault, "vkSetEvent");
        addExtern<DAS_BIND_FUN(vkResetEvent)>(*this, lib, "vkResetEvent",
            SideEffects::worstDefault, "vkResetEvent");
        addExtern<DAS_BIND_FUN(vkCreateQueryPool)>(*this, lib, "vkCreateQueryPool",
            SideEffects::worstDefault, "vkCreateQueryPool");
        addExtern<DAS_BIND_FUN(vkDestroyQueryPool)>(*this, lib, "vkDestroyQueryPool",
            SideEffects::worstDefault, "vkDestroyQueryPool");
        addExtern<DAS_BIND_FUN(vkGetQueryPoolResults)>(*this, lib, "vkGetQueryPoolResults",
            SideEffects::worstDefault, "vkGetQueryPoolResults");
        addExtern<DAS_BIND_FUN(vkCreateBuffer)>(*this, lib, "vkCreateBuffer",
            SideEffects::worstDefault, "vkCreateBuffer");
        addExtern<DAS_BIND_FUN(vkDestroyBuffer)>(*this, lib, "vkDestroyBuffer",
            SideEffects::worstDefault, "vkDestroyBuffer");
        addExtern<DAS_BIND_FUN(vkCreateBufferView)>(*this, lib, "vkCreateBufferView",
            SideEffects::worstDefault, "vkCreateBufferView");
        addExtern<DAS_BIND_FUN(vkDestroyBufferView)>(*this, lib, "vkDestroyBufferView",
            SideEffects::worstDefault, "vkDestroyBufferView");
        addExtern<DAS_BIND_FUN(vkCreateImage)>(*this, lib, "vkCreateImage",
            SideEffects::worstDefault, "vkCreateImage");
        addExtern<DAS_BIND_FUN(vkDestroyImage)>(*this, lib, "vkDestroyImage",
            SideEffects::worstDefault, "vkDestroyImage");
        addExtern<DAS_BIND_FUN(vkGetImageSubresourceLayout)>(*this, lib, "vkGetImageSubresourceLayout",
            SideEffects::worstDefault, "vkGetImageSubresourceLayout");
        addExtern<DAS_BIND_FUN(vkCreateImageView)>(*this, lib, "vkCreateImageView",
            SideEffects::worstDefault, "vkCreateImageView");
        addExtern<DAS_BIND_FUN(vkDestroyImageView)>(*this, lib, "vkDestroyImageView",
            SideEffects::worstDefault, "vkDestroyImageView");
        addExtern<DAS_BIND_FUN(vkCreateShaderModule)>(*this, lib, "vkCreateShaderModule",
            SideEffects::worstDefault, "vkCreateShaderModule");
        addExtern<DAS_BIND_FUN(vkDestroyShaderModule)>(*this, lib, "vkDestroyShaderModule",
            SideEffects::worstDefault, "vkDestroyShaderModule");
        addExtern<DAS_BIND_FUN(vkCreatePipelineCache)>(*this, lib, "vkCreatePipelineCache",
            SideEffects::worstDefault, "vkCreatePipelineCache");
        addExtern<DAS_BIND_FUN(vkDestroyPipelineCache)>(*this, lib, "vkDestroyPipelineCache",
            SideEffects::worstDefault, "vkDestroyPipelineCache");
        addExtern<DAS_BIND_FUN(vkGetPipelineCacheData)>(*this, lib, "vkGetPipelineCacheData",
            SideEffects::worstDefault, "vkGetPipelineCacheData");
        addExtern<DAS_BIND_FUN(vkMergePipelineCaches)>(*this, lib, "vkMergePipelineCaches",
            SideEffects::worstDefault, "vkMergePipelineCaches");
        addExtern<DAS_BIND_FUN(vkCreateGraphicsPipelines)>(*this, lib, "vkCreateGraphicsPipelines",
            SideEffects::worstDefault, "vkCreateGraphicsPipelines");
        addExtern<DAS_BIND_FUN(vkCreateComputePipelines)>(*this, lib, "vkCreateComputePipelines",
            SideEffects::worstDefault, "vkCreateComputePipelines");
        addExtern<DAS_BIND_FUN(vkDestroyPipeline)>(*this, lib, "vkDestroyPipeline",
            SideEffects::worstDefault, "vkDestroyPipeline");
        addExtern<DAS_BIND_FUN(vkCreatePipelineLayout)>(*this, lib, "vkCreatePipelineLayout",
            SideEffects::worstDefault, "vkCreatePipelineLayout");
        addExtern<DAS_BIND_FUN(vkDestroyPipelineLayout)>(*this, lib, "vkDestroyPipelineLayout",
            SideEffects::worstDefault, "vkDestroyPipelineLayout");
        addExtern<DAS_BIND_FUN(vkCreateSampler)>(*this, lib, "vkCreateSampler",
            SideEffects::worstDefault, "vkCreateSampler");
        addExtern<DAS_BIND_FUN(vkDestroySampler)>(*this, lib, "vkDestroySampler",
            SideEffects::worstDefault, "vkDestroySampler");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorSetLayout)>(*this, lib, "vkCreateDescriptorSetLayout",
            SideEffects::worstDefault, "vkCreateDescriptorSetLayout");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorSetLayout)>(*this, lib, "vkDestroyDescriptorSetLayout",
            SideEffects::worstDefault, "vkDestroyDescriptorSetLayout");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorPool)>(*this, lib, "vkCreateDescriptorPool",
            SideEffects::worstDefault, "vkCreateDescriptorPool");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorPool)>(*this, lib, "vkDestroyDescriptorPool",
            SideEffects::worstDefault, "vkDestroyDescriptorPool");
        addExtern<DAS_BIND_FUN(vkResetDescriptorPool)>(*this, lib, "vkResetDescriptorPool",
            SideEffects::worstDefault, "vkResetDescriptorPool");
        addExtern<DAS_BIND_FUN(vkAllocateDescriptorSets)>(*this, lib, "vkAllocateDescriptorSets",
            SideEffects::worstDefault, "vkAllocateDescriptorSets");
        addExtern<DAS_BIND_FUN(vkFreeDescriptorSets)>(*this, lib, "vkFreeDescriptorSets",
            SideEffects::worstDefault, "vkFreeDescriptorSets");
        addExtern<DAS_BIND_FUN(vkUpdateDescriptorSets)>(*this, lib, "vkUpdateDescriptorSets",
            SideEffects::worstDefault, "vkUpdateDescriptorSets");
        addExtern<DAS_BIND_FUN(vkCreateFramebuffer)>(*this, lib, "vkCreateFramebuffer",
            SideEffects::worstDefault, "vkCreateFramebuffer");
        addExtern<DAS_BIND_FUN(vkDestroyFramebuffer)>(*this, lib, "vkDestroyFramebuffer",
            SideEffects::worstDefault, "vkDestroyFramebuffer");
        addExtern<DAS_BIND_FUN(vkCreateRenderPass)>(*this, lib, "vkCreateRenderPass",
            SideEffects::worstDefault, "vkCreateRenderPass");
        addExtern<DAS_BIND_FUN(vkDestroyRenderPass)>(*this, lib, "vkDestroyRenderPass",
            SideEffects::worstDefault, "vkDestroyRenderPass");
        addExtern<DAS_BIND_FUN(vkGetRenderAreaGranularity)>(*this, lib, "vkGetRenderAreaGranularity",
            SideEffects::worstDefault, "vkGetRenderAreaGranularity");
        addExtern<DAS_BIND_FUN(vkCreateCommandPool)>(*this, lib, "vkCreateCommandPool",
            SideEffects::worstDefault, "vkCreateCommandPool");
        addExtern<DAS_BIND_FUN(vkDestroyCommandPool)>(*this, lib, "vkDestroyCommandPool",
            SideEffects::worstDefault, "vkDestroyCommandPool");
        addExtern<DAS_BIND_FUN(vkResetCommandPool)>(*this, lib, "vkResetCommandPool",
            SideEffects::worstDefault, "vkResetCommandPool");
        addExtern<DAS_BIND_FUN(vkAllocateCommandBuffers)>(*this, lib, "vkAllocateCommandBuffers",
            SideEffects::worstDefault, "vkAllocateCommandBuffers");
        addExtern<DAS_BIND_FUN(vkFreeCommandBuffers)>(*this, lib, "vkFreeCommandBuffers",
            SideEffects::worstDefault, "vkFreeCommandBuffers");
        addExtern<DAS_BIND_FUN(vkBeginCommandBuffer)>(*this, lib, "vkBeginCommandBuffer",
            SideEffects::worstDefault, "vkBeginCommandBuffer");
        addExtern<DAS_BIND_FUN(vkEndCommandBuffer)>(*this, lib, "vkEndCommandBuffer",
            SideEffects::worstDefault, "vkEndCommandBuffer");
        addExtern<DAS_BIND_FUN(vkResetCommandBuffer)>(*this, lib, "vkResetCommandBuffer",
            SideEffects::worstDefault, "vkResetCommandBuffer");
        addExtern<DAS_BIND_FUN(vkCmdBindPipeline)>(*this, lib, "vkCmdBindPipeline",
            SideEffects::worstDefault, "vkCmdBindPipeline");
        addExtern<DAS_BIND_FUN(vkCmdSetViewport)>(*this, lib, "vkCmdSetViewport",
            SideEffects::worstDefault, "vkCmdSetViewport");
        addExtern<DAS_BIND_FUN(vkCmdSetScissor)>(*this, lib, "vkCmdSetScissor",
            SideEffects::worstDefault, "vkCmdSetScissor");
        addExtern<DAS_BIND_FUN(vkCmdSetLineWidth)>(*this, lib, "vkCmdSetLineWidth",
            SideEffects::worstDefault, "vkCmdSetLineWidth");
        addExtern<DAS_BIND_FUN(vkCmdSetDepthBias)>(*this, lib, "vkCmdSetDepthBias",
            SideEffects::worstDefault, "vkCmdSetDepthBias");
        addExtern<DAS_BIND_FUN(vkCmdSetBlendConstants)>(*this, lib, "vkCmdSetBlendConstants",
            SideEffects::worstDefault, "vkCmdSetBlendConstants");
        addExtern<DAS_BIND_FUN(vkCmdSetDepthBounds)>(*this, lib, "vkCmdSetDepthBounds",
            SideEffects::worstDefault, "vkCmdSetDepthBounds");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilCompareMask)>(*this, lib, "vkCmdSetStencilCompareMask",
            SideEffects::worstDefault, "vkCmdSetStencilCompareMask");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilWriteMask)>(*this, lib, "vkCmdSetStencilWriteMask",
            SideEffects::worstDefault, "vkCmdSetStencilWriteMask");
        addExtern<DAS_BIND_FUN(vkCmdSetStencilReference)>(*this, lib, "vkCmdSetStencilReference",
            SideEffects::worstDefault, "vkCmdSetStencilReference");
        addExtern<DAS_BIND_FUN(vkCmdBindDescriptorSets)>(*this, lib, "vkCmdBindDescriptorSets",
            SideEffects::worstDefault, "vkCmdBindDescriptorSets");
        addExtern<DAS_BIND_FUN(vkCmdBindIndexBuffer)>(*this, lib, "vkCmdBindIndexBuffer",
            SideEffects::worstDefault, "vkCmdBindIndexBuffer");
        addExtern<DAS_BIND_FUN(vkCmdBindVertexBuffers)>(*this, lib, "vkCmdBindVertexBuffers",
            SideEffects::worstDefault, "vkCmdBindVertexBuffers");
        addExtern<DAS_BIND_FUN(vkCmdDraw)>(*this, lib, "vkCmdDraw",
            SideEffects::worstDefault, "vkCmdDraw");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexed)>(*this, lib, "vkCmdDrawIndexed",
            SideEffects::worstDefault, "vkCmdDrawIndexed");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndirect)>(*this, lib, "vkCmdDrawIndirect",
            SideEffects::worstDefault, "vkCmdDrawIndirect");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirect)>(*this, lib, "vkCmdDrawIndexedIndirect",
            SideEffects::worstDefault, "vkCmdDrawIndexedIndirect");
        addExtern<DAS_BIND_FUN(vkCmdDispatch)>(*this, lib, "vkCmdDispatch",
            SideEffects::worstDefault, "vkCmdDispatch");
        addExtern<DAS_BIND_FUN(vkCmdDispatchIndirect)>(*this, lib, "vkCmdDispatchIndirect",
            SideEffects::worstDefault, "vkCmdDispatchIndirect");
        addExtern<DAS_BIND_FUN(vkCmdCopyBuffer)>(*this, lib, "vkCmdCopyBuffer",
            SideEffects::worstDefault, "vkCmdCopyBuffer");
        addExtern<DAS_BIND_FUN(vkCmdCopyImage)>(*this, lib, "vkCmdCopyImage",
            SideEffects::worstDefault, "vkCmdCopyImage");
        addExtern<DAS_BIND_FUN(vkCmdBlitImage)>(*this, lib, "vkCmdBlitImage",
            SideEffects::worstDefault, "vkCmdBlitImage");
        addExtern<DAS_BIND_FUN(vkCmdCopyBufferToImage)>(*this, lib, "vkCmdCopyBufferToImage",
            SideEffects::worstDefault, "vkCmdCopyBufferToImage");
        addExtern<DAS_BIND_FUN(vkCmdCopyImageToBuffer)>(*this, lib, "vkCmdCopyImageToBuffer",
            SideEffects::worstDefault, "vkCmdCopyImageToBuffer");
        addExtern<DAS_BIND_FUN(vkCmdUpdateBuffer)>(*this, lib, "vkCmdUpdateBuffer",
            SideEffects::worstDefault, "vkCmdUpdateBuffer");
        addExtern<DAS_BIND_FUN(vkCmdFillBuffer)>(*this, lib, "vkCmdFillBuffer",
            SideEffects::worstDefault, "vkCmdFillBuffer");
        addExtern<DAS_BIND_FUN(vkCmdClearColorImage)>(*this, lib, "vkCmdClearColorImage",
            SideEffects::worstDefault, "vkCmdClearColorImage");
        addExtern<DAS_BIND_FUN(vkCmdClearDepthStencilImage)>(*this, lib, "vkCmdClearDepthStencilImage",
            SideEffects::worstDefault, "vkCmdClearDepthStencilImage");
        addExtern<DAS_BIND_FUN(vkCmdClearAttachments)>(*this, lib, "vkCmdClearAttachments",
            SideEffects::worstDefault, "vkCmdClearAttachments");
        addExtern<DAS_BIND_FUN(vkCmdResolveImage)>(*this, lib, "vkCmdResolveImage",
            SideEffects::worstDefault, "vkCmdResolveImage");
        addExtern<DAS_BIND_FUN(vkCmdSetEvent)>(*this, lib, "vkCmdSetEvent",
            SideEffects::worstDefault, "vkCmdSetEvent");
        addExtern<DAS_BIND_FUN(vkCmdResetEvent)>(*this, lib, "vkCmdResetEvent",
            SideEffects::worstDefault, "vkCmdResetEvent");
        addExtern<DAS_BIND_FUN(vkCmdWaitEvents)>(*this, lib, "vkCmdWaitEvents",
            SideEffects::worstDefault, "vkCmdWaitEvents");
        addExtern<DAS_BIND_FUN(vkCmdPipelineBarrier)>(*this, lib, "vkCmdPipelineBarrier",
            SideEffects::worstDefault, "vkCmdPipelineBarrier");
        addExtern<DAS_BIND_FUN(vkCmdBeginQuery)>(*this, lib, "vkCmdBeginQuery",
            SideEffects::worstDefault, "vkCmdBeginQuery");
        addExtern<DAS_BIND_FUN(vkCmdEndQuery)>(*this, lib, "vkCmdEndQuery",
            SideEffects::worstDefault, "vkCmdEndQuery");
        addExtern<DAS_BIND_FUN(vkCmdResetQueryPool)>(*this, lib, "vkCmdResetQueryPool",
            SideEffects::worstDefault, "vkCmdResetQueryPool");
        addExtern<DAS_BIND_FUN(vkCmdWriteTimestamp)>(*this, lib, "vkCmdWriteTimestamp",
            SideEffects::worstDefault, "vkCmdWriteTimestamp");
        addExtern<DAS_BIND_FUN(vkCmdCopyQueryPoolResults)>(*this, lib, "vkCmdCopyQueryPoolResults",
            SideEffects::worstDefault, "vkCmdCopyQueryPoolResults");
        addExtern<DAS_BIND_FUN(vkCmdPushConstants)>(*this, lib, "vkCmdPushConstants",
            SideEffects::worstDefault, "vkCmdPushConstants");
        addExtern<DAS_BIND_FUN(vkCmdBeginRenderPass)>(*this, lib, "vkCmdBeginRenderPass",
            SideEffects::worstDefault, "vkCmdBeginRenderPass");
        addExtern<DAS_BIND_FUN(vkCmdNextSubpass)>(*this, lib, "vkCmdNextSubpass",
            SideEffects::worstDefault, "vkCmdNextSubpass");
        addExtern<DAS_BIND_FUN(vkCmdEndRenderPass)>(*this, lib, "vkCmdEndRenderPass",
            SideEffects::worstDefault, "vkCmdEndRenderPass");
        addExtern<DAS_BIND_FUN(vkCmdExecuteCommands)>(*this, lib, "vkCmdExecuteCommands",
            SideEffects::worstDefault, "vkCmdExecuteCommands");
        addExtern<DAS_BIND_FUN(vkEnumerateInstanceVersion)>(*this, lib, "vkEnumerateInstanceVersion",
            SideEffects::worstDefault, "vkEnumerateInstanceVersion");
        addExtern<DAS_BIND_FUN(vkBindBufferMemory2)>(*this, lib, "vkBindBufferMemory2",
            SideEffects::worstDefault, "vkBindBufferMemory2");
        addExtern<DAS_BIND_FUN(vkBindImageMemory2)>(*this, lib, "vkBindImageMemory2",
            SideEffects::worstDefault, "vkBindImageMemory2");
        addExtern<DAS_BIND_FUN(vkGetDeviceGroupPeerMemoryFeatures)>(*this, lib, "vkGetDeviceGroupPeerMemoryFeatures",
            SideEffects::worstDefault, "vkGetDeviceGroupPeerMemoryFeatures");
        addExtern<DAS_BIND_FUN(vkCmdSetDeviceMask)>(*this, lib, "vkCmdSetDeviceMask",
            SideEffects::worstDefault, "vkCmdSetDeviceMask");
        addExtern<DAS_BIND_FUN(vkCmdDispatchBase)>(*this, lib, "vkCmdDispatchBase",
            SideEffects::worstDefault, "vkCmdDispatchBase");
        addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDeviceGroups)>(*this, lib, "vkEnumeratePhysicalDeviceGroups",
            SideEffects::worstDefault, "vkEnumeratePhysicalDeviceGroups");
        addExtern<DAS_BIND_FUN(vkGetImageMemoryRequirements2)>(*this, lib, "vkGetImageMemoryRequirements2",
            SideEffects::worstDefault, "vkGetImageMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetBufferMemoryRequirements2)>(*this, lib, "vkGetBufferMemoryRequirements2",
            SideEffects::worstDefault, "vkGetBufferMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetImageSparseMemoryRequirements2)>(*this, lib, "vkGetImageSparseMemoryRequirements2",
            SideEffects::worstDefault, "vkGetImageSparseMemoryRequirements2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures2)>(*this, lib, "vkGetPhysicalDeviceFeatures2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties2)>(*this, lib, "vkGetPhysicalDeviceProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties2)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties2)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties2");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSparseImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties2",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSparseImageFormatProperties2");
        addExtern<DAS_BIND_FUN(vkTrimCommandPool)>(*this, lib, "vkTrimCommandPool",
            SideEffects::worstDefault, "vkTrimCommandPool");
        addExtern<DAS_BIND_FUN(vkGetDeviceQueue2)>(*this, lib, "vkGetDeviceQueue2",
            SideEffects::worstDefault, "vkGetDeviceQueue2");
        addExtern<DAS_BIND_FUN(vkCreateSamplerYcbcrConversion)>(*this, lib, "vkCreateSamplerYcbcrConversion",
            SideEffects::worstDefault, "vkCreateSamplerYcbcrConversion");
        addExtern<DAS_BIND_FUN(vkDestroySamplerYcbcrConversion)>(*this, lib, "vkDestroySamplerYcbcrConversion",
            SideEffects::worstDefault, "vkDestroySamplerYcbcrConversion");
        addExtern<DAS_BIND_FUN(vkCreateDescriptorUpdateTemplate)>(*this, lib, "vkCreateDescriptorUpdateTemplate",
            SideEffects::worstDefault, "vkCreateDescriptorUpdateTemplate");
        addExtern<DAS_BIND_FUN(vkDestroyDescriptorUpdateTemplate)>(*this, lib, "vkDestroyDescriptorUpdateTemplate",
            SideEffects::worstDefault, "vkDestroyDescriptorUpdateTemplate");
        addExtern<DAS_BIND_FUN(vkUpdateDescriptorSetWithTemplate)>(*this, lib, "vkUpdateDescriptorSetWithTemplate",
            SideEffects::worstDefault, "vkUpdateDescriptorSetWithTemplate");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalBufferProperties)>(*this, lib, "vkGetPhysicalDeviceExternalBufferProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalBufferProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalFenceProperties)>(*this, lib, "vkGetPhysicalDeviceExternalFenceProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalFenceProperties");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceExternalSemaphoreProperties)>(*this, lib, "vkGetPhysicalDeviceExternalSemaphoreProperties",
            SideEffects::worstDefault, "vkGetPhysicalDeviceExternalSemaphoreProperties");
        addExtern<DAS_BIND_FUN(vkGetDescriptorSetLayoutSupport)>(*this, lib, "vkGetDescriptorSetLayoutSupport",
            SideEffects::worstDefault, "vkGetDescriptorSetLayoutSupport");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndirectCount)>(*this, lib, "vkCmdDrawIndirectCount",
            SideEffects::worstDefault, "vkCmdDrawIndirectCount");
        addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirectCount)>(*this, lib, "vkCmdDrawIndexedIndirectCount",
            SideEffects::worstDefault, "vkCmdDrawIndexedIndirectCount");
        addExtern<DAS_BIND_FUN(vkCreateRenderPass2)>(*this, lib, "vkCreateRenderPass2",
            SideEffects::worstDefault, "vkCreateRenderPass2");
        addExtern<DAS_BIND_FUN(vkCmdBeginRenderPass2)>(*this, lib, "vkCmdBeginRenderPass2",
            SideEffects::worstDefault, "vkCmdBeginRenderPass2");
        addExtern<DAS_BIND_FUN(vkCmdNextSubpass2)>(*this, lib, "vkCmdNextSubpass2",
            SideEffects::worstDefault, "vkCmdNextSubpass2");
        addExtern<DAS_BIND_FUN(vkCmdEndRenderPass2)>(*this, lib, "vkCmdEndRenderPass2",
            SideEffects::worstDefault, "vkCmdEndRenderPass2");
        addExtern<DAS_BIND_FUN(vkResetQueryPool)>(*this, lib, "vkResetQueryPool",
            SideEffects::worstDefault, "vkResetQueryPool");
        addExtern<DAS_BIND_FUN(vkGetSemaphoreCounterValue)>(*this, lib, "vkGetSemaphoreCounterValue",
            SideEffects::worstDefault, "vkGetSemaphoreCounterValue");
        addExtern<DAS_BIND_FUN(vkWaitSemaphores)>(*this, lib, "vkWaitSemaphores",
            SideEffects::worstDefault, "vkWaitSemaphores");
        addExtern<DAS_BIND_FUN(vkSignalSemaphore)>(*this, lib, "vkSignalSemaphore",
            SideEffects::worstDefault, "vkSignalSemaphore");
        addExtern<DAS_BIND_FUN(vkGetBufferDeviceAddress)>(*this, lib, "vkGetBufferDeviceAddress",
            SideEffects::worstDefault, "vkGetBufferDeviceAddress");
        addExtern<DAS_BIND_FUN(vkGetBufferOpaqueCaptureAddress)>(*this, lib, "vkGetBufferOpaqueCaptureAddress",
            SideEffects::worstDefault, "vkGetBufferOpaqueCaptureAddress");
        addExtern<DAS_BIND_FUN(vkGetDeviceMemoryOpaqueCaptureAddress)>(*this, lib, "vkGetDeviceMemoryOpaqueCaptureAddress",
            SideEffects::worstDefault, "vkGetDeviceMemoryOpaqueCaptureAddress");
        addExtern<DAS_BIND_FUN(vkDestroySurfaceKHR)>(*this, lib, "vkDestroySurfaceKHR",
            SideEffects::worstDefault, "vkDestroySurfaceKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceSupportKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceSupportKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceSupportKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfaceFormatsKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceFormatsKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfaceFormatsKHR");
        addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceSurfacePresentModesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfacePresentModesKHR",
            SideEffects::worstDefault, "vkGetPhysicalDeviceSurfacePresentModesKHR");
        addExtern<DAS_BIND_FUN(vkCreateSwapchainKHR)>(*this, lib, "vkCreateSwapchainKHR",
            SideEffects::worstDefault, "vkCreateSwapchainKHR");
        addExtern<DAS_BIND_FUN(vkDestroySwapchainKHR)>(*this, lib, "vkDestroySwapchainKHR",
            SideEffects::worstDefault, "vkDestroySwapchainKHR");
        addExtern<DAS_BIND_FUN(vkGetSwapchainImagesKHR)>(*this, lib, "vkGetSwapchainImagesKHR",
            SideEffects::worstDefault, "vkGetSwapchainImagesKHR");
        addExtern<DAS_BIND_FUN(vkAcquireNextImageKHR)>(*this, lib, "vkAcquireNextImageKHR",
            SideEffects::worstDefault, "vkAcquireNextImageKHR");
        addExtern<DAS_BIND_FUN(vkQueuePresentKHR)>(*this, lib, "vkQueuePresentKHR",
            SideEffects::worstDefault, "vkQueuePresentKHR");
        addExtern<DAS_BIND_FUN(vkCreateDebugUtilsMessengerEXT)>(*this, lib, "vkCreateDebugUtilsMessengerEXT",
            SideEffects::worstDefault, "vkCreateDebugUtilsMessengerEXT");
        addExtern<DAS_BIND_FUN(vkDestroyDebugUtilsMessengerEXT)>(*this, lib, "vkDestroyDebugUtilsMessengerEXT",
            SideEffects::worstDefault, "vkDestroyDebugUtilsMessengerEXT");
        addExtern<DAS_BIND_FUN(glfwInit)>(*this, lib, "glfwInit",
            SideEffects::worstDefault, "glfwInit");
        addExtern<DAS_BIND_FUN(glfwTerminate)>(*this, lib, "glfwTerminate",
            SideEffects::worstDefault, "glfwTerminate");
        addExtern<DAS_BIND_FUN(glfwInitHint)>(*this, lib, "glfwInitHint",
            SideEffects::worstDefault, "glfwInitHint");
        addExtern<DAS_BIND_FUN(glfwGetVersion)>(*this, lib, "glfwGetVersion",
            SideEffects::worstDefault, "glfwGetVersion");
        addExtern<DAS_BIND_FUN(glfwGetVersionString)>(*this, lib, "glfwGetVersionString",
            SideEffects::worstDefault, "glfwGetVersionString");
        addExtern<DAS_BIND_FUN(glfwGetError)>(*this, lib, "glfwGetError",
            SideEffects::worstDefault, "glfwGetError");
        addExtern<DAS_BIND_FUN(glfwGetMonitors)>(*this, lib, "glfwGetMonitors",
            SideEffects::worstDefault, "glfwGetMonitors");
        addExtern<DAS_BIND_FUN(glfwGetPrimaryMonitor)>(*this, lib, "glfwGetPrimaryMonitor",
            SideEffects::worstDefault, "glfwGetPrimaryMonitor");
        addExtern<DAS_BIND_FUN(glfwGetMonitorPos)>(*this, lib, "glfwGetMonitorPos",
            SideEffects::worstDefault, "glfwGetMonitorPos");
        addExtern<DAS_BIND_FUN(glfwGetMonitorWorkarea)>(*this, lib, "glfwGetMonitorWorkarea",
            SideEffects::worstDefault, "glfwGetMonitorWorkarea");
        addExtern<DAS_BIND_FUN(glfwGetMonitorPhysicalSize)>(*this, lib, "glfwGetMonitorPhysicalSize",
            SideEffects::worstDefault, "glfwGetMonitorPhysicalSize");
        addExtern<DAS_BIND_FUN(glfwGetMonitorContentScale)>(*this, lib, "glfwGetMonitorContentScale",
            SideEffects::worstDefault, "glfwGetMonitorContentScale");
        addExtern<DAS_BIND_FUN(glfwGetMonitorName)>(*this, lib, "glfwGetMonitorName",
            SideEffects::worstDefault, "glfwGetMonitorName");
        addExtern<DAS_BIND_FUN(glfwSetMonitorUserPointer)>(*this, lib, "glfwSetMonitorUserPointer",
            SideEffects::worstDefault, "glfwSetMonitorUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetMonitorUserPointer)>(*this, lib, "glfwGetMonitorUserPointer",
            SideEffects::worstDefault, "glfwGetMonitorUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetVideoModes)>(*this, lib, "glfwGetVideoModes",
            SideEffects::worstDefault, "glfwGetVideoModes");
        addExtern<DAS_BIND_FUN(glfwGetVideoMode)>(*this, lib, "glfwGetVideoMode",
            SideEffects::worstDefault, "glfwGetVideoMode");
        addExtern<DAS_BIND_FUN(glfwSetGamma)>(*this, lib, "glfwSetGamma",
            SideEffects::worstDefault, "glfwSetGamma");
        addExtern<DAS_BIND_FUN(glfwGetGammaRamp)>(*this, lib, "glfwGetGammaRamp",
            SideEffects::worstDefault, "glfwGetGammaRamp");
        addExtern<DAS_BIND_FUN(glfwSetGammaRamp)>(*this, lib, "glfwSetGammaRamp",
            SideEffects::worstDefault, "glfwSetGammaRamp");
        addExtern<DAS_BIND_FUN(glfwDefaultWindowHints)>(*this, lib, "glfwDefaultWindowHints",
            SideEffects::worstDefault, "glfwDefaultWindowHints");
        addExtern<DAS_BIND_FUN(glfwWindowHint)>(*this, lib, "glfwWindowHint",
            SideEffects::worstDefault, "glfwWindowHint");
        addExtern<DAS_BIND_FUN(glfwWindowHintString)>(*this, lib, "glfwWindowHintString",
            SideEffects::worstDefault, "glfwWindowHintString");
        addExtern<DAS_BIND_FUN(glfwWindowShouldClose)>(*this, lib, "glfwWindowShouldClose",
            SideEffects::worstDefault, "glfwWindowShouldClose");
        addExtern<DAS_BIND_FUN(glfwSetWindowShouldClose)>(*this, lib, "glfwSetWindowShouldClose",
            SideEffects::worstDefault, "glfwSetWindowShouldClose");
        addExtern<DAS_BIND_FUN(glfwSetWindowTitle)>(*this, lib, "glfwSetWindowTitle",
            SideEffects::worstDefault, "glfwSetWindowTitle");
        addExtern<DAS_BIND_FUN(glfwSetWindowIcon)>(*this, lib, "glfwSetWindowIcon",
            SideEffects::worstDefault, "glfwSetWindowIcon");
        addExtern<DAS_BIND_FUN(glfwGetWindowPos)>(*this, lib, "glfwGetWindowPos",
            SideEffects::worstDefault, "glfwGetWindowPos");
        addExtern<DAS_BIND_FUN(glfwSetWindowPos)>(*this, lib, "glfwSetWindowPos",
            SideEffects::worstDefault, "glfwSetWindowPos");
        addExtern<DAS_BIND_FUN(glfwGetWindowSize)>(*this, lib, "glfwGetWindowSize",
            SideEffects::worstDefault, "glfwGetWindowSize");
        addExtern<DAS_BIND_FUN(glfwSetWindowSizeLimits)>(*this, lib, "glfwSetWindowSizeLimits",
            SideEffects::worstDefault, "glfwSetWindowSizeLimits");
        addExtern<DAS_BIND_FUN(glfwSetWindowAspectRatio)>(*this, lib, "glfwSetWindowAspectRatio",
            SideEffects::worstDefault, "glfwSetWindowAspectRatio");
        addExtern<DAS_BIND_FUN(glfwSetWindowSize)>(*this, lib, "glfwSetWindowSize",
            SideEffects::worstDefault, "glfwSetWindowSize");
        addExtern<DAS_BIND_FUN(glfwGetFramebufferSize)>(*this, lib, "glfwGetFramebufferSize",
            SideEffects::worstDefault, "glfwGetFramebufferSize");
        addExtern<DAS_BIND_FUN(glfwGetWindowFrameSize)>(*this, lib, "glfwGetWindowFrameSize",
            SideEffects::worstDefault, "glfwGetWindowFrameSize");
        addExtern<DAS_BIND_FUN(glfwGetWindowContentScale)>(*this, lib, "glfwGetWindowContentScale",
            SideEffects::worstDefault, "glfwGetWindowContentScale");
        addExtern<DAS_BIND_FUN(glfwGetWindowOpacity)>(*this, lib, "glfwGetWindowOpacity",
            SideEffects::worstDefault, "glfwGetWindowOpacity");
        addExtern<DAS_BIND_FUN(glfwSetWindowOpacity)>(*this, lib, "glfwSetWindowOpacity",
            SideEffects::worstDefault, "glfwSetWindowOpacity");
        addExtern<DAS_BIND_FUN(glfwIconifyWindow)>(*this, lib, "glfwIconifyWindow",
            SideEffects::worstDefault, "glfwIconifyWindow");
        addExtern<DAS_BIND_FUN(glfwRestoreWindow)>(*this, lib, "glfwRestoreWindow",
            SideEffects::worstDefault, "glfwRestoreWindow");
        addExtern<DAS_BIND_FUN(glfwMaximizeWindow)>(*this, lib, "glfwMaximizeWindow",
            SideEffects::worstDefault, "glfwMaximizeWindow");
        addExtern<DAS_BIND_FUN(glfwShowWindow)>(*this, lib, "glfwShowWindow",
            SideEffects::worstDefault, "glfwShowWindow");
        addExtern<DAS_BIND_FUN(glfwHideWindow)>(*this, lib, "glfwHideWindow",
            SideEffects::worstDefault, "glfwHideWindow");
        addExtern<DAS_BIND_FUN(glfwFocusWindow)>(*this, lib, "glfwFocusWindow",
            SideEffects::worstDefault, "glfwFocusWindow");
        addExtern<DAS_BIND_FUN(glfwRequestWindowAttention)>(*this, lib, "glfwRequestWindowAttention",
            SideEffects::worstDefault, "glfwRequestWindowAttention");
        addExtern<DAS_BIND_FUN(glfwGetWindowMonitor)>(*this, lib, "glfwGetWindowMonitor",
            SideEffects::worstDefault, "glfwGetWindowMonitor");
        addExtern<DAS_BIND_FUN(glfwSetWindowMonitor)>(*this, lib, "glfwSetWindowMonitor",
            SideEffects::worstDefault, "glfwSetWindowMonitor");
        addExtern<DAS_BIND_FUN(glfwGetWindowAttrib)>(*this, lib, "glfwGetWindowAttrib",
            SideEffects::worstDefault, "glfwGetWindowAttrib");
        addExtern<DAS_BIND_FUN(glfwSetWindowAttrib)>(*this, lib, "glfwSetWindowAttrib",
            SideEffects::worstDefault, "glfwSetWindowAttrib");
        addExtern<DAS_BIND_FUN(glfwGetWindowUserPointer)>(*this, lib, "glfwGetWindowUserPointer",
            SideEffects::worstDefault, "glfwGetWindowUserPointer");
        addExtern<DAS_BIND_FUN(glfwPollEvents)>(*this, lib, "glfwPollEvents",
            SideEffects::worstDefault, "glfwPollEvents");
        addExtern<DAS_BIND_FUN(glfwWaitEvents)>(*this, lib, "glfwWaitEvents",
            SideEffects::worstDefault, "glfwWaitEvents");
        addExtern<DAS_BIND_FUN(glfwWaitEventsTimeout)>(*this, lib, "glfwWaitEventsTimeout",
            SideEffects::worstDefault, "glfwWaitEventsTimeout");
        addExtern<DAS_BIND_FUN(glfwPostEmptyEvent)>(*this, lib, "glfwPostEmptyEvent",
            SideEffects::worstDefault, "glfwPostEmptyEvent");
        addExtern<DAS_BIND_FUN(glfwGetInputMode)>(*this, lib, "glfwGetInputMode",
            SideEffects::worstDefault, "glfwGetInputMode");
        addExtern<DAS_BIND_FUN(glfwSetInputMode)>(*this, lib, "glfwSetInputMode",
            SideEffects::worstDefault, "glfwSetInputMode");
        addExtern<DAS_BIND_FUN(glfwRawMouseMotionSupported)>(*this, lib, "glfwRawMouseMotionSupported",
            SideEffects::worstDefault, "glfwRawMouseMotionSupported");
        addExtern<DAS_BIND_FUN(glfwGetKeyName)>(*this, lib, "glfwGetKeyName",
            SideEffects::worstDefault, "glfwGetKeyName");
        addExtern<DAS_BIND_FUN(glfwGetKeyScancode)>(*this, lib, "glfwGetKeyScancode",
            SideEffects::worstDefault, "glfwGetKeyScancode");
        addExtern<DAS_BIND_FUN(glfwGetKey)>(*this, lib, "glfwGetKey",
            SideEffects::worstDefault, "glfwGetKey");
        addExtern<DAS_BIND_FUN(glfwGetMouseButton)>(*this, lib, "glfwGetMouseButton",
            SideEffects::worstDefault, "glfwGetMouseButton");
        addExtern<DAS_BIND_FUN(glfwGetCursorPos)>(*this, lib, "glfwGetCursorPos",
            SideEffects::worstDefault, "glfwGetCursorPos");
        addExtern<DAS_BIND_FUN(glfwSetCursorPos)>(*this, lib, "glfwSetCursorPos",
            SideEffects::worstDefault, "glfwSetCursorPos");
        addExtern<DAS_BIND_FUN(glfwCreateCursor)>(*this, lib, "glfwCreateCursor",
            SideEffects::worstDefault, "glfwCreateCursor");
        addExtern<DAS_BIND_FUN(glfwCreateStandardCursor)>(*this, lib, "glfwCreateStandardCursor",
            SideEffects::worstDefault, "glfwCreateStandardCursor");
        addExtern<DAS_BIND_FUN(glfwDestroyCursor)>(*this, lib, "glfwDestroyCursor",
            SideEffects::worstDefault, "glfwDestroyCursor");
        addExtern<DAS_BIND_FUN(glfwSetCursor)>(*this, lib, "glfwSetCursor",
            SideEffects::worstDefault, "glfwSetCursor");
        addExtern<DAS_BIND_FUN(glfwJoystickPresent)>(*this, lib, "glfwJoystickPresent",
            SideEffects::worstDefault, "glfwJoystickPresent");
        addExtern<DAS_BIND_FUN(glfwGetJoystickAxes)>(*this, lib, "glfwGetJoystickAxes",
            SideEffects::worstDefault, "glfwGetJoystickAxes");
        addExtern<DAS_BIND_FUN(glfwGetJoystickButtons)>(*this, lib, "glfwGetJoystickButtons",
            SideEffects::worstDefault, "glfwGetJoystickButtons");
        addExtern<DAS_BIND_FUN(glfwGetJoystickHats)>(*this, lib, "glfwGetJoystickHats",
            SideEffects::worstDefault, "glfwGetJoystickHats");
        addExtern<DAS_BIND_FUN(glfwGetJoystickName)>(*this, lib, "glfwGetJoystickName",
            SideEffects::worstDefault, "glfwGetJoystickName");
        addExtern<DAS_BIND_FUN(glfwGetJoystickGUID)>(*this, lib, "glfwGetJoystickGUID",
            SideEffects::worstDefault, "glfwGetJoystickGUID");
        addExtern<DAS_BIND_FUN(glfwSetJoystickUserPointer)>(*this, lib, "glfwSetJoystickUserPointer",
            SideEffects::worstDefault, "glfwSetJoystickUserPointer");
        addExtern<DAS_BIND_FUN(glfwGetJoystickUserPointer)>(*this, lib, "glfwGetJoystickUserPointer",
            SideEffects::worstDefault, "glfwGetJoystickUserPointer");
        addExtern<DAS_BIND_FUN(glfwJoystickIsGamepad)>(*this, lib, "glfwJoystickIsGamepad",
            SideEffects::worstDefault, "glfwJoystickIsGamepad");
        addExtern<DAS_BIND_FUN(glfwUpdateGamepadMappings)>(*this, lib, "glfwUpdateGamepadMappings",
            SideEffects::worstDefault, "glfwUpdateGamepadMappings");
        addExtern<DAS_BIND_FUN(glfwGetGamepadName)>(*this, lib, "glfwGetGamepadName",
            SideEffects::worstDefault, "glfwGetGamepadName");
        addExtern<DAS_BIND_FUN(glfwGetGamepadState)>(*this, lib, "glfwGetGamepadState",
            SideEffects::worstDefault, "glfwGetGamepadState");
        addExtern<DAS_BIND_FUN(glfwSetClipboardString)>(*this, lib, "glfwSetClipboardString",
            SideEffects::worstDefault, "glfwSetClipboardString");
        addExtern<DAS_BIND_FUN(glfwGetClipboardString)>(*this, lib, "glfwGetClipboardString",
            SideEffects::worstDefault, "glfwGetClipboardString");
        addExtern<DAS_BIND_FUN(glfwGetTime)>(*this, lib, "glfwGetTime",
            SideEffects::worstDefault, "glfwGetTime");
        addExtern<DAS_BIND_FUN(glfwSetTime)>(*this, lib, "glfwSetTime",
            SideEffects::worstDefault, "glfwSetTime");
        addExtern<DAS_BIND_FUN(glfwGetTimerValue)>(*this, lib, "glfwGetTimerValue",
            SideEffects::worstDefault, "glfwGetTimerValue");
        addExtern<DAS_BIND_FUN(glfwGetTimerFrequency)>(*this, lib, "glfwGetTimerFrequency",
            SideEffects::worstDefault, "glfwGetTimerFrequency");
        addExtern<DAS_BIND_FUN(glfwMakeContextCurrent)>(*this, lib, "glfwMakeContextCurrent",
            SideEffects::worstDefault, "glfwMakeContextCurrent");
        addExtern<DAS_BIND_FUN(glfwGetCurrentContext)>(*this, lib, "glfwGetCurrentContext",
            SideEffects::worstDefault, "glfwGetCurrentContext");
        addExtern<DAS_BIND_FUN(glfwSwapBuffers)>(*this, lib, "glfwSwapBuffers",
            SideEffects::worstDefault, "glfwSwapBuffers");
        addExtern<DAS_BIND_FUN(glfwSwapInterval)>(*this, lib, "glfwSwapInterval",
            SideEffects::worstDefault, "glfwSwapInterval");
        addExtern<DAS_BIND_FUN(glfwExtensionSupported)>(*this, lib, "glfwExtensionSupported",
            SideEffects::worstDefault, "glfwExtensionSupported");
        addExtern<DAS_BIND_FUN(glfwVulkanSupported)>(*this, lib, "glfwVulkanSupported",
            SideEffects::worstDefault, "glfwVulkanSupported");
        addExtern<DAS_BIND_FUN(glfwGetRequiredInstanceExtensions)>(*this, lib, "glfwGetRequiredInstanceExtensions",
            SideEffects::worstDefault, "glfwGetRequiredInstanceExtensions");
        addExtern<DAS_BIND_FUN(glfwGetPhysicalDevicePresentationSupport)>(*this, lib, "glfwGetPhysicalDevicePresentationSupport",
            SideEffects::worstDefault, "glfwGetPhysicalDevicePresentationSupport");
        addExtern<DAS_BIND_FUN(glfwCreateWindowSurface)>(*this, lib, "glfwCreateWindowSurface",
            SideEffects::worstDefault, "glfwCreateWindowSurface");

        //
        // macro constants
        //

        addConstant(*this,"GLFW_VERSION_MAJOR",3);
        addConstant(*this,"GLFW_VERSION_MINOR",3);
        addConstant(*this,"GLFW_VERSION_REVISION",2);
        addConstant(*this,"GLFW_TRUE",1);
        addConstant(*this,"GLFW_FALSE",0);
        addConstant(*this,"GLFW_RELEASE",0);
        addConstant(*this,"GLFW_PRESS",1);
        addConstant(*this,"GLFW_REPEAT",2);
        addConstant(*this,"GLFW_HAT_CENTERED",0);
        addConstant(*this,"GLFW_HAT_UP",1);
        addConstant(*this,"GLFW_HAT_RIGHT",2);
        addConstant(*this,"GLFW_HAT_DOWN",4);
        addConstant(*this,"GLFW_HAT_LEFT",8);
        addConstant(*this,"GLFW_HAT_RIGHT_UP",(GLFW_HAT_RIGHT | GLFW_HAT_UP));
        addConstant(*this,"GLFW_HAT_RIGHT_DOWN",(GLFW_HAT_RIGHT | GLFW_HAT_DOWN));
        addConstant(*this,"GLFW_HAT_LEFT_UP",(GLFW_HAT_LEFT  | GLFW_HAT_UP));
        addConstant(*this,"GLFW_HAT_LEFT_DOWN",(GLFW_HAT_LEFT  | GLFW_HAT_DOWN));
        addConstant(*this,"GLFW_KEY_UNKNOWN",-1);
        addConstant(*this,"GLFW_KEY_SPACE",32);
        addConstant(*this,"GLFW_KEY_APOSTROPHE",39  /* ' */);
        addConstant(*this,"GLFW_KEY_COMMA",44  /* , */);
        addConstant(*this,"GLFW_KEY_MINUS",45  /* - */);
        addConstant(*this,"GLFW_KEY_PERIOD",46  /* . */);
        addConstant(*this,"GLFW_KEY_SLASH",47  /* / */);
        addConstant(*this,"GLFW_KEY_0",48);
        addConstant(*this,"GLFW_KEY_1",49);
        addConstant(*this,"GLFW_KEY_2",50);
        addConstant(*this,"GLFW_KEY_3",51);
        addConstant(*this,"GLFW_KEY_4",52);
        addConstant(*this,"GLFW_KEY_5",53);
        addConstant(*this,"GLFW_KEY_6",54);
        addConstant(*this,"GLFW_KEY_7",55);
        addConstant(*this,"GLFW_KEY_8",56);
        addConstant(*this,"GLFW_KEY_9",57);
        addConstant(*this,"GLFW_KEY_SEMICOLON",59  /* ; */);
        addConstant(*this,"GLFW_KEY_EQUAL",61  /* = */);
        addConstant(*this,"GLFW_KEY_A",65);
        addConstant(*this,"GLFW_KEY_B",66);
        addConstant(*this,"GLFW_KEY_C",67);
        addConstant(*this,"GLFW_KEY_D",68);
        addConstant(*this,"GLFW_KEY_E",69);
        addConstant(*this,"GLFW_KEY_F",70);
        addConstant(*this,"GLFW_KEY_G",71);
        addConstant(*this,"GLFW_KEY_H",72);
        addConstant(*this,"GLFW_KEY_I",73);
        addConstant(*this,"GLFW_KEY_J",74);
        addConstant(*this,"GLFW_KEY_K",75);
        addConstant(*this,"GLFW_KEY_L",76);
        addConstant(*this,"GLFW_KEY_M",77);
        addConstant(*this,"GLFW_KEY_N",78);
        addConstant(*this,"GLFW_KEY_O",79);
        addConstant(*this,"GLFW_KEY_P",80);
        addConstant(*this,"GLFW_KEY_Q",81);
        addConstant(*this,"GLFW_KEY_R",82);
        addConstant(*this,"GLFW_KEY_S",83);
        addConstant(*this,"GLFW_KEY_T",84);
        addConstant(*this,"GLFW_KEY_U",85);
        addConstant(*this,"GLFW_KEY_V",86);
        addConstant(*this,"GLFW_KEY_W",87);
        addConstant(*this,"GLFW_KEY_X",88);
        addConstant(*this,"GLFW_KEY_Y",89);
        addConstant(*this,"GLFW_KEY_Z",90);
        addConstant(*this,"GLFW_KEY_LEFT_BRACKET",91  /* [ */);
        addConstant(*this,"GLFW_KEY_BACKSLASH",92  /* \ */);
        addConstant(*this,"GLFW_KEY_RIGHT_BRACKET",93  /* ] */);
        addConstant(*this,"GLFW_KEY_GRAVE_ACCENT",96  /* ` */);
        addConstant(*this,"GLFW_KEY_WORLD_1",161 /* non-US #1 */);
        addConstant(*this,"GLFW_KEY_WORLD_2",162 /* non-US #2 */);
        addConstant(*this,"GLFW_KEY_ESCAPE",256);
        addConstant(*this,"GLFW_KEY_ENTER",257);
        addConstant(*this,"GLFW_KEY_TAB",258);
        addConstant(*this,"GLFW_KEY_BACKSPACE",259);
        addConstant(*this,"GLFW_KEY_INSERT",260);
        addConstant(*this,"GLFW_KEY_DELETE",261);
        addConstant(*this,"GLFW_KEY_RIGHT",262);
        addConstant(*this,"GLFW_KEY_LEFT",263);
        addConstant(*this,"GLFW_KEY_DOWN",264);
        addConstant(*this,"GLFW_KEY_UP",265);
        addConstant(*this,"GLFW_KEY_PAGE_UP",266);
        addConstant(*this,"GLFW_KEY_PAGE_DOWN",267);
        addConstant(*this,"GLFW_KEY_HOME",268);
        addConstant(*this,"GLFW_KEY_END",269);
        addConstant(*this,"GLFW_KEY_CAPS_LOCK",280);
        addConstant(*this,"GLFW_KEY_SCROLL_LOCK",281);
        addConstant(*this,"GLFW_KEY_NUM_LOCK",282);
        addConstant(*this,"GLFW_KEY_PRINT_SCREEN",283);
        addConstant(*this,"GLFW_KEY_PAUSE",284);
        addConstant(*this,"GLFW_KEY_F1",290);
        addConstant(*this,"GLFW_KEY_F2",291);
        addConstant(*this,"GLFW_KEY_F3",292);
        addConstant(*this,"GLFW_KEY_F4",293);
        addConstant(*this,"GLFW_KEY_F5",294);
        addConstant(*this,"GLFW_KEY_F6",295);
        addConstant(*this,"GLFW_KEY_F7",296);
        addConstant(*this,"GLFW_KEY_F8",297);
        addConstant(*this,"GLFW_KEY_F9",298);
        addConstant(*this,"GLFW_KEY_F10",299);
        addConstant(*this,"GLFW_KEY_F11",300);
        addConstant(*this,"GLFW_KEY_F12",301);
        addConstant(*this,"GLFW_KEY_F13",302);
        addConstant(*this,"GLFW_KEY_F14",303);
        addConstant(*this,"GLFW_KEY_F15",304);
        addConstant(*this,"GLFW_KEY_F16",305);
        addConstant(*this,"GLFW_KEY_F17",306);
        addConstant(*this,"GLFW_KEY_F18",307);
        addConstant(*this,"GLFW_KEY_F19",308);
        addConstant(*this,"GLFW_KEY_F20",309);
        addConstant(*this,"GLFW_KEY_F21",310);
        addConstant(*this,"GLFW_KEY_F22",311);
        addConstant(*this,"GLFW_KEY_F23",312);
        addConstant(*this,"GLFW_KEY_F24",313);
        addConstant(*this,"GLFW_KEY_F25",314);
        addConstant(*this,"GLFW_KEY_KP_0",320);
        addConstant(*this,"GLFW_KEY_KP_1",321);
        addConstant(*this,"GLFW_KEY_KP_2",322);
        addConstant(*this,"GLFW_KEY_KP_3",323);
        addConstant(*this,"GLFW_KEY_KP_4",324);
        addConstant(*this,"GLFW_KEY_KP_5",325);
        addConstant(*this,"GLFW_KEY_KP_6",326);
        addConstant(*this,"GLFW_KEY_KP_7",327);
        addConstant(*this,"GLFW_KEY_KP_8",328);
        addConstant(*this,"GLFW_KEY_KP_9",329);
        addConstant(*this,"GLFW_KEY_KP_DECIMAL",330);
        addConstant(*this,"GLFW_KEY_KP_DIVIDE",331);
        addConstant(*this,"GLFW_KEY_KP_MULTIPLY",332);
        addConstant(*this,"GLFW_KEY_KP_SUBTRACT",333);
        addConstant(*this,"GLFW_KEY_KP_ADD",334);
        addConstant(*this,"GLFW_KEY_KP_ENTER",335);
        addConstant(*this,"GLFW_KEY_KP_EQUAL",336);
        addConstant(*this,"GLFW_KEY_LEFT_SHIFT",340);
        addConstant(*this,"GLFW_KEY_LEFT_CONTROL",341);
        addConstant(*this,"GLFW_KEY_LEFT_ALT",342);
        addConstant(*this,"GLFW_KEY_LEFT_SUPER",343);
        addConstant(*this,"GLFW_KEY_RIGHT_SHIFT",344);
        addConstant(*this,"GLFW_KEY_RIGHT_CONTROL",345);
        addConstant(*this,"GLFW_KEY_RIGHT_ALT",346);
        addConstant(*this,"GLFW_KEY_RIGHT_SUPER",347);
        addConstant(*this,"GLFW_KEY_MENU",348);
        addConstant(*this,"GLFW_KEY_LAST",GLFW_KEY_MENU);
        addConstant(*this,"GLFW_MOD_SHIFT",0x0001);
        addConstant(*this,"GLFW_MOD_CONTROL",0x0002);
        addConstant(*this,"GLFW_MOD_ALT",0x0004);
        addConstant(*this,"GLFW_MOD_SUPER",0x0008);
        addConstant(*this,"GLFW_MOD_CAPS_LOCK",0x0010);
        addConstant(*this,"GLFW_MOD_NUM_LOCK",0x0020);
        addConstant(*this,"GLFW_MOUSE_BUTTON_1",0);
        addConstant(*this,"GLFW_MOUSE_BUTTON_2",1);
        addConstant(*this,"GLFW_MOUSE_BUTTON_3",2);
        addConstant(*this,"GLFW_MOUSE_BUTTON_4",3);
        addConstant(*this,"GLFW_MOUSE_BUTTON_5",4);
        addConstant(*this,"GLFW_MOUSE_BUTTON_6",5);
        addConstant(*this,"GLFW_MOUSE_BUTTON_7",6);
        addConstant(*this,"GLFW_MOUSE_BUTTON_8",7);
        addConstant(*this,"GLFW_MOUSE_BUTTON_LAST",GLFW_MOUSE_BUTTON_8);
        addConstant(*this,"GLFW_MOUSE_BUTTON_LEFT",GLFW_MOUSE_BUTTON_1);
        addConstant(*this,"GLFW_MOUSE_BUTTON_RIGHT",GLFW_MOUSE_BUTTON_2);
        addConstant(*this,"GLFW_MOUSE_BUTTON_MIDDLE",GLFW_MOUSE_BUTTON_3);
        addConstant(*this,"GLFW_JOYSTICK_1",0);
        addConstant(*this,"GLFW_JOYSTICK_2",1);
        addConstant(*this,"GLFW_JOYSTICK_3",2);
        addConstant(*this,"GLFW_JOYSTICK_4",3);
        addConstant(*this,"GLFW_JOYSTICK_5",4);
        addConstant(*this,"GLFW_JOYSTICK_6",5);
        addConstant(*this,"GLFW_JOYSTICK_7",6);
        addConstant(*this,"GLFW_JOYSTICK_8",7);
        addConstant(*this,"GLFW_JOYSTICK_9",8);
        addConstant(*this,"GLFW_JOYSTICK_10",9);
        addConstant(*this,"GLFW_JOYSTICK_11",10);
        addConstant(*this,"GLFW_JOYSTICK_12",11);
        addConstant(*this,"GLFW_JOYSTICK_13",12);
        addConstant(*this,"GLFW_JOYSTICK_14",13);
        addConstant(*this,"GLFW_JOYSTICK_15",14);
        addConstant(*this,"GLFW_JOYSTICK_16",15);
        addConstant(*this,"GLFW_JOYSTICK_LAST",GLFW_JOYSTICK_16);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_A",0);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_B",1);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_X",2);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_Y",3);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LEFT_BUMPER",4);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER",5);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_BACK",6);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_START",7);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_GUIDE",8);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LEFT_THUMB",9);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_RIGHT_THUMB",10);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_UP",11);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_RIGHT",12);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_DOWN",13);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_LEFT",14);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_LAST",GLFW_GAMEPAD_BUTTON_DPAD_LEFT);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_CROSS",GLFW_GAMEPAD_BUTTON_A);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_CIRCLE",GLFW_GAMEPAD_BUTTON_B);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_SQUARE",GLFW_GAMEPAD_BUTTON_X);
        addConstant(*this,"GLFW_GAMEPAD_BUTTON_TRIANGLE",GLFW_GAMEPAD_BUTTON_Y);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_X",0);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_Y",1);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_X",2);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_Y",3);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_TRIGGER",4);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER",5);
        addConstant(*this,"GLFW_GAMEPAD_AXIS_LAST",GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER);
        addConstant(*this,"GLFW_NO_ERROR",0);
        addConstant(*this,"GLFW_NOT_INITIALIZED",0x00010001);
        addConstant(*this,"GLFW_NO_CURRENT_CONTEXT",0x00010002);
        addConstant(*this,"GLFW_INVALID_ENUM",0x00010003);
        addConstant(*this,"GLFW_INVALID_VALUE",0x00010004);
        addConstant(*this,"GLFW_OUT_OF_MEMORY",0x00010005);
        addConstant(*this,"GLFW_API_UNAVAILABLE",0x00010006);
        addConstant(*this,"GLFW_VERSION_UNAVAILABLE",0x00010007);
        addConstant(*this,"GLFW_PLATFORM_ERROR",0x00010008);
        addConstant(*this,"GLFW_FORMAT_UNAVAILABLE",0x00010009);
        addConstant(*this,"GLFW_NO_WINDOW_CONTEXT",0x0001000A);
        addConstant(*this,"GLFW_FOCUSED",0x00020001);
        addConstant(*this,"GLFW_ICONIFIED",0x00020002);
        addConstant(*this,"GLFW_RESIZABLE",0x00020003);
        addConstant(*this,"GLFW_VISIBLE",0x00020004);
        addConstant(*this,"GLFW_DECORATED",0x00020005);
        addConstant(*this,"GLFW_AUTO_ICONIFY",0x00020006);
        addConstant(*this,"GLFW_FLOATING",0x00020007);
        addConstant(*this,"GLFW_MAXIMIZED",0x00020008);
        addConstant(*this,"GLFW_CENTER_CURSOR",0x00020009);
        addConstant(*this,"GLFW_TRANSPARENT_FRAMEBUFFER",0x0002000A);
        addConstant(*this,"GLFW_HOVERED",0x0002000B);
        addConstant(*this,"GLFW_FOCUS_ON_SHOW",0x0002000C);
        addConstant(*this,"GLFW_RED_BITS",0x00021001);
        addConstant(*this,"GLFW_GREEN_BITS",0x00021002);
        addConstant(*this,"GLFW_BLUE_BITS",0x00021003);
        addConstant(*this,"GLFW_ALPHA_BITS",0x00021004);
        addConstant(*this,"GLFW_DEPTH_BITS",0x00021005);
        addConstant(*this,"GLFW_STENCIL_BITS",0x00021006);
        addConstant(*this,"GLFW_ACCUM_RED_BITS",0x00021007);
        addConstant(*this,"GLFW_ACCUM_GREEN_BITS",0x00021008);
        addConstant(*this,"GLFW_ACCUM_BLUE_BITS",0x00021009);
        addConstant(*this,"GLFW_ACCUM_ALPHA_BITS",0x0002100A);
        addConstant(*this,"GLFW_AUX_BUFFERS",0x0002100B);
        addConstant(*this,"GLFW_STEREO",0x0002100C);
        addConstant(*this,"GLFW_SAMPLES",0x0002100D);
        addConstant(*this,"GLFW_SRGB_CAPABLE",0x0002100E);
        addConstant(*this,"GLFW_REFRESH_RATE",0x0002100F);
        addConstant(*this,"GLFW_DOUBLEBUFFER",0x00021010);
        addConstant(*this,"GLFW_CLIENT_API",0x00022001);
        addConstant(*this,"GLFW_CONTEXT_VERSION_MAJOR",0x00022002);
        addConstant(*this,"GLFW_CONTEXT_VERSION_MINOR",0x00022003);
        addConstant(*this,"GLFW_CONTEXT_REVISION",0x00022004);
        addConstant(*this,"GLFW_CONTEXT_ROBUSTNESS",0x00022005);
        addConstant(*this,"GLFW_OPENGL_FORWARD_COMPAT",0x00022006);
        addConstant(*this,"GLFW_OPENGL_DEBUG_CONTEXT",0x00022007);
        addConstant(*this,"GLFW_OPENGL_PROFILE",0x00022008);
        addConstant(*this,"GLFW_CONTEXT_RELEASE_BEHAVIOR",0x00022009);
        addConstant(*this,"GLFW_CONTEXT_NO_ERROR",0x0002200A);
        addConstant(*this,"GLFW_CONTEXT_CREATION_API",0x0002200B);
        addConstant(*this,"GLFW_SCALE_TO_MONITOR",0x0002200C);
        addConstant(*this,"GLFW_COCOA_RETINA_FRAMEBUFFER",0x00023001);
        addConstant(*this,"GLFW_COCOA_FRAME_NAME",0x00023002);
        addConstant(*this,"GLFW_COCOA_GRAPHICS_SWITCHING",0x00023003);
        addConstant(*this,"GLFW_X11_CLASS_NAME",0x00024001);
        addConstant(*this,"GLFW_X11_INSTANCE_NAME",0x00024002);
        addConstant(*this,"GLFW_NO_API",0);
        addConstant(*this,"GLFW_OPENGL_API",0x00030001);
        addConstant(*this,"GLFW_OPENGL_ES_API",0x00030002);
        addConstant(*this,"GLFW_NO_ROBUSTNESS",0);
        addConstant(*this,"GLFW_NO_RESET_NOTIFICATION",0x00031001);
        addConstant(*this,"GLFW_LOSE_CONTEXT_ON_RESET",0x00031002);
        addConstant(*this,"GLFW_OPENGL_ANY_PROFILE",0);
        addConstant(*this,"GLFW_OPENGL_CORE_PROFILE",0x00032001);
        addConstant(*this,"GLFW_OPENGL_COMPAT_PROFILE",0x00032002);
        addConstant(*this,"GLFW_CURSOR",0x00033001);
        addConstant(*this,"GLFW_STICKY_KEYS",0x00033002);
        addConstant(*this,"GLFW_STICKY_MOUSE_BUTTONS",0x00033003);
        addConstant(*this,"GLFW_LOCK_KEY_MODS",0x00033004);
        addConstant(*this,"GLFW_RAW_MOUSE_MOTION",0x00033005);
        addConstant(*this,"GLFW_CURSOR_NORMAL",0x00034001);
        addConstant(*this,"GLFW_CURSOR_HIDDEN",0x00034002);
        addConstant(*this,"GLFW_CURSOR_DISABLED",0x00034003);
        addConstant(*this,"GLFW_ANY_RELEASE_BEHAVIOR",0);
        addConstant(*this,"GLFW_RELEASE_BEHAVIOR_FLUSH",0x00035001);
        addConstant(*this,"GLFW_RELEASE_BEHAVIOR_NONE",0x00035002);
        addConstant(*this,"GLFW_NATIVE_CONTEXT_API",0x00036001);
        addConstant(*this,"GLFW_EGL_CONTEXT_API",0x00036002);
        addConstant(*this,"GLFW_OSMESA_CONTEXT_API",0x00036003);
        addConstant(*this,"GLFW_ARROW_CURSOR",0x00036001);
        addConstant(*this,"GLFW_IBEAM_CURSOR",0x00036002);
        addConstant(*this,"GLFW_CROSSHAIR_CURSOR",0x00036003);
        addConstant(*this,"GLFW_HAND_CURSOR",0x00036004);
        addConstant(*this,"GLFW_HRESIZE_CURSOR",0x00036005);
        addConstant(*this,"GLFW_VRESIZE_CURSOR",0x00036006);
        addConstant(*this,"GLFW_CONNECTED",0x00040001);
        addConstant(*this,"GLFW_DISCONNECTED",0x00040002);
        addConstant(*this,"GLFW_JOYSTICK_HAT_BUTTONS",0x00050001);
        addConstant(*this,"GLFW_COCOA_CHDIR_RESOURCES",0x00051001);
        addConstant(*this,"GLFW_COCOA_MENUBAR",0x00051002);
        addConstant(*this,"GLFW_DONT_CARE",-1);
        addConstant(*this,"VK_VERSION_1_0",1);
        addConstant(*this,"VK_API_VERSION_1_0",VK_MAKE_VERSION(1, 0, 0));
        addConstant(*this,"VK_HEADER_VERSION",162);
        addConstant(*this,"VK_HEADER_VERSION_COMPLETE",VK_MAKE_VERSION(1, 2, VK_HEADER_VERSION));
        addConstant(*this,"VK_NULL_HANDLE",0);
        addConstant(*this,"VK_ATTACHMENT_UNUSED",(~0U));
        addConstant(*this,"VK_FALSE",0);
        addConstant(*this,"VK_LOD_CLAMP_NONE",1000.0f);
        addConstant(*this,"VK_QUEUE_FAMILY_IGNORED",(~0U));
        addConstant(*this,"VK_REMAINING_ARRAY_LAYERS",(~0U));
        addConstant(*this,"VK_REMAINING_MIP_LEVELS",(~0U));
        addConstant(*this,"VK_SUBPASS_EXTERNAL",(~0U));
        addConstant(*this,"VK_TRUE",1);
        addConstant(*this,"VK_WHOLE_SIZE",(~0ULL));
        addConstant(*this,"VK_MAX_MEMORY_TYPES",32);
        addConstant(*this,"VK_MAX_MEMORY_HEAPS",16);
        addConstant(*this,"VK_MAX_PHYSICAL_DEVICE_NAME_SIZE",256);
        addConstant(*this,"VK_UUID_SIZE",16);
        addConstant(*this,"VK_MAX_EXTENSION_NAME_SIZE",256);
        addConstant(*this,"VK_MAX_DESCRIPTION_SIZE",256);
        addConstant(*this,"VK_VERSION_1_1",1);
        addConstant(*this,"VK_API_VERSION_1_1",VK_MAKE_VERSION(1, 1, 0));
        addConstant(*this,"VK_MAX_DEVICE_GROUP_SIZE",32);
        addConstant(*this,"VK_LUID_SIZE",8);
        addConstant(*this,"VK_QUEUE_FAMILY_EXTERNAL",(~0U-1));
        addConstant(*this,"VK_VERSION_1_2",1);
        addConstant(*this,"VK_API_VERSION_1_2",VK_MAKE_VERSION(1, 2, 0));
        addConstant(*this,"VK_MAX_DRIVER_NAME_SIZE",256);
        addConstant(*this,"VK_MAX_DRIVER_INFO_SIZE",256);
        addConstant(*this,"VK_KHR_surface",1);
        addConstant(*this,"VK_KHR_SURFACE_SPEC_VERSION",25);
        addConstant(*this,"VK_KHR_swapchain",1);
        addConstant(*this,"VK_KHR_SWAPCHAIN_SPEC_VERSION",70);
        addConstant(*this,"VK_KHR_display",1);
        addConstant(*this,"VK_KHR_DISPLAY_SPEC_VERSION",23);
        addConstant(*this,"VK_KHR_display_swapchain",1);
        addConstant(*this,"VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION",10);
        addConstant(*this,"VK_KHR_sampler_mirror_clamp_to_edge",1);
        addConstant(*this,"VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_multiview",1);
        addConstant(*this,"VK_KHR_MULTIVIEW_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_physical_device_properties2",1);
        addConstant(*this,"VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_device_group",1);
        addConstant(*this,"VK_KHR_DEVICE_GROUP_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_shader_draw_parameters",1);
        addConstant(*this,"VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance1",1);
        addConstant(*this,"VK_KHR_MAINTENANCE1_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_device_group_creation",1);
        addConstant(*this,"VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION",1);
        addConstant(*this,"VK_MAX_DEVICE_GROUP_SIZE_KHR",VK_MAX_DEVICE_GROUP_SIZE);
        addConstant(*this,"VK_KHR_external_memory_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_LUID_SIZE_KHR",VK_LUID_SIZE);
        addConstant(*this,"VK_KHR_external_memory",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_QUEUE_FAMILY_EXTERNAL_KHR",VK_QUEUE_FAMILY_EXTERNAL);
        addConstant(*this,"VK_KHR_external_memory_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_semaphore_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_push_descriptor",1);
        addConstant(*this,"VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_shader_float16_int8",1);
        addConstant(*this,"VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_16bit_storage",1);
        addConstant(*this,"VK_KHR_16BIT_STORAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_incremental_present",1);
        addConstant(*this,"VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_descriptor_update_template",1);
        addConstant(*this,"VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_imageless_framebuffer",1);
        addConstant(*this,"VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_create_renderpass2",1);
        addConstant(*this,"VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shared_presentable_image",1);
        addConstant(*this,"VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence_capabilities",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_external_fence_fd",1);
        addConstant(*this,"VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_performance_query",1);
        addConstant(*this,"VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance2",1);
        addConstant(*this,"VK_KHR_MAINTENANCE2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_surface_capabilities2",1);
        addConstant(*this,"VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_variable_pointers",1);
        addConstant(*this,"VK_KHR_VARIABLE_POINTERS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_display_properties2",1);
        addConstant(*this,"VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_dedicated_allocation",1);
        addConstant(*this,"VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_storage_buffer_storage_class",1);
        addConstant(*this,"VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_relaxed_block_layout",1);
        addConstant(*this,"VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_get_memory_requirements2",1);
        addConstant(*this,"VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_image_format_list",1);
        addConstant(*this,"VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_sampler_ycbcr_conversion",1);
        addConstant(*this,"VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION",14);
        addConstant(*this,"VK_KHR_bind_memory2",1);
        addConstant(*this,"VK_KHR_BIND_MEMORY_2_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_maintenance3",1);
        addConstant(*this,"VK_KHR_MAINTENANCE3_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_draw_indirect_count",1);
        addConstant(*this,"VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_subgroup_extended_types",1);
        addConstant(*this,"VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_8bit_storage",1);
        addConstant(*this,"VK_KHR_8BIT_STORAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_atomic_int64",1);
        addConstant(*this,"VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_clock",1);
        addConstant(*this,"VK_KHR_SHADER_CLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_driver_properties",1);
        addConstant(*this,"VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION",1);
        addConstant(*this,"VK_MAX_DRIVER_NAME_SIZE_KHR",VK_MAX_DRIVER_NAME_SIZE);
        addConstant(*this,"VK_MAX_DRIVER_INFO_SIZE_KHR",VK_MAX_DRIVER_INFO_SIZE);
        addConstant(*this,"VK_KHR_shader_float_controls",1);
        addConstant(*this,"VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_depth_stencil_resolve",1);
        addConstant(*this,"VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_swapchain_mutable_format",1);
        addConstant(*this,"VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_timeline_semaphore",1);
        addConstant(*this,"VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION",2);
        addConstant(*this,"VK_KHR_vulkan_memory_model",1);
        addConstant(*this,"VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION",3);
        addConstant(*this,"VK_KHR_shader_terminate_invocation",1);
        addConstant(*this,"VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_fragment_shading_rate",1);
        addConstant(*this,"VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_spirv_1_4",1);
        addConstant(*this,"VK_KHR_SPIRV_1_4_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_surface_protected_capabilities",1);
        addConstant(*this,"VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_separate_depth_stencil_layouts",1);
        addConstant(*this,"VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_uniform_buffer_standard_layout",1);
        addConstant(*this,"VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_buffer_device_address",1);
        addConstant(*this,"VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_deferred_host_operations",1);
        addConstant(*this,"VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION",4);
        addConstant(*this,"VK_KHR_pipeline_executable_properties",1);
        addConstant(*this,"VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_pipeline_library",1);
        addConstant(*this,"VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_shader_non_semantic_info",1);
        addConstant(*this,"VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_copy_commands2",1);
        addConstant(*this,"VK_KHR_COPY_COMMANDS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_debug_report",1);
        addConstant(*this,"VK_EXT_DEBUG_REPORT_SPEC_VERSION",9);
        addConstant(*this,"VK_NV_glsl_shader",1);
        addConstant(*this,"VK_NV_GLSL_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_depth_range_unrestricted",1);
        addConstant(*this,"VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION",1);
        addConstant(*this,"VK_IMG_filter_cubic",1);
        addConstant(*this,"VK_IMG_FILTER_CUBIC_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_rasterization_order",1);
        addConstant(*this,"VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_trinary_minmax",1);
        addConstant(*this,"VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_explicit_vertex_parameter",1);
        addConstant(*this,"VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_debug_marker",1);
        addConstant(*this,"VK_EXT_DEBUG_MARKER_SPEC_VERSION",4);
        addConstant(*this,"VK_AMD_gcn_shader",1);
        addConstant(*this,"VK_AMD_GCN_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_dedicated_allocation",1);
        addConstant(*this,"VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_transform_feedback",1);
        addConstant(*this,"VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION",1);
        addConstant(*this,"VK_NVX_image_view_handle",1);
        addConstant(*this,"VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_draw_indirect_count",1);
        addConstant(*this,"VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_negative_viewport_height",1);
        addConstant(*this,"VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_gpu_shader_half_float",1);
        addConstant(*this,"VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_shader_ballot",1);
        addConstant(*this,"VK_AMD_SHADER_BALLOT_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_texture_gather_bias_lod",1);
        addConstant(*this,"VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_info",1);
        addConstant(*this,"VK_AMD_SHADER_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_image_load_store_lod",1);
        addConstant(*this,"VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_corner_sampled_image",1);
        addConstant(*this,"VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION",2);
        addConstant(*this,"VK_IMG_format_pvrtc",1);
        addConstant(*this,"VK_IMG_FORMAT_PVRTC_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_external_memory_capabilities",1);
        addConstant(*this,"VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_external_memory",1);
        addConstant(*this,"VK_NV_EXTERNAL_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_flags",1);
        addConstant(*this,"VK_EXT_VALIDATION_FLAGS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_shader_subgroup_ballot",1);
        addConstant(*this,"VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_subgroup_vote",1);
        addConstant(*this,"VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_texture_compression_astc_hdr",1);
        addConstant(*this,"VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_astc_decode_mode",1);
        addConstant(*this,"VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_conditional_rendering",1);
        addConstant(*this,"VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_clip_space_w_scaling",1);
        addConstant(*this,"VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_direct_mode_display",1);
        addConstant(*this,"VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_display_surface_counter",1);
        addConstant(*this,"VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_display_control",1);
        addConstant(*this,"VK_EXT_DISPLAY_CONTROL_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_display_timing",1);
        addConstant(*this,"VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_sample_mask_override_coverage",1);
        addConstant(*this,"VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_geometry_shader_passthrough",1);
        addConstant(*this,"VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_viewport_array2",1);
        addConstant(*this,"VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION",1);
        addConstant(*this,"VK_NVX_multiview_per_view_attributes",1);
        addConstant(*this,"VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_viewport_swizzle",1);
        addConstant(*this,"VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_discard_rectangles",1);
        addConstant(*this,"VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_conservative_rasterization",1);
        addConstant(*this,"VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_depth_clip_enable",1);
        addConstant(*this,"VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_swapchain_colorspace",1);
        addConstant(*this,"VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION",4);
        addConstant(*this,"VK_EXT_hdr_metadata",1);
        addConstant(*this,"VK_EXT_HDR_METADATA_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_external_memory_dma_buf",1);
        addConstant(*this,"VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_queue_family_foreign",1);
        addConstant(*this,"VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION",1);
        addConstant(*this,"VK_QUEUE_FAMILY_FOREIGN_EXT",(~0U-2));
        addConstant(*this,"VK_EXT_debug_utils",1);
        addConstant(*this,"VK_EXT_DEBUG_UTILS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_sampler_filter_minmax",1);
        addConstant(*this,"VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_gpu_shader_int16",1);
        addConstant(*this,"VK_AMD_GPU_SHADER_INT16_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_mixed_attachment_samples",1);
        addConstant(*this,"VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_fragment_mask",1);
        addConstant(*this,"VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_inline_uniform_block",1);
        addConstant(*this,"VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_stencil_export",1);
        addConstant(*this,"VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_sample_locations",1);
        addConstant(*this,"VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_blend_operation_advanced",1);
        addConstant(*this,"VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_fragment_coverage_to_color",1);
        addConstant(*this,"VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_framebuffer_mixed_samples",1);
        addConstant(*this,"VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_fill_rectangle",1);
        addConstant(*this,"VK_NV_FILL_RECTANGLE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_sm_builtins",1);
        addConstant(*this,"VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_post_depth_coverage",1);
        addConstant(*this,"VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_image_drm_format_modifier",1);
        addConstant(*this,"VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_cache",1);
        addConstant(*this,"VK_EXT_VALIDATION_CACHE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_descriptor_indexing",1);
        addConstant(*this,"VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_shader_viewport_index_layer",1);
        addConstant(*this,"VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shading_rate_image",1);
        addConstant(*this,"VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION",3);
        addConstant(*this,"VK_NV_ray_tracing",1);
        addConstant(*this,"VK_NV_RAY_TRACING_SPEC_VERSION",3);
        addConstant(*this,"VK_SHADER_UNUSED_KHR",(~0U));
        addConstant(*this,"VK_SHADER_UNUSED_NV",VK_SHADER_UNUSED_KHR);
        addConstant(*this,"VK_NV_representative_fragment_test",1);
        addConstant(*this,"VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_filter_cubic",1);
        addConstant(*this,"VK_EXT_FILTER_CUBIC_SPEC_VERSION",3);
        addConstant(*this,"VK_QCOM_render_pass_shader_resolve",1);
        addConstant(*this,"VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION",4);
        addConstant(*this,"VK_EXT_global_priority",1);
        addConstant(*this,"VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_external_memory_host",1);
        addConstant(*this,"VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_buffer_marker",1);
        addConstant(*this,"VK_AMD_BUFFER_MARKER_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_pipeline_compiler_control",1);
        addConstant(*this,"VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_calibrated_timestamps",1);
        addConstant(*this,"VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_shader_core_properties",1);
        addConstant(*this,"VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_memory_overallocation_behavior",1);
        addConstant(*this,"VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_vertex_attribute_divisor",1);
        addConstant(*this,"VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION",3);
        addConstant(*this,"VK_EXT_pipeline_creation_feedback",1);
        addConstant(*this,"VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_subgroup_partitioned",1);
        addConstant(*this,"VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_compute_shader_derivatives",1);
        addConstant(*this,"VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_mesh_shader",1);
        addConstant(*this,"VK_NV_MESH_SHADER_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_fragment_shader_barycentric",1);
        addConstant(*this,"VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_shader_image_footprint",1);
        addConstant(*this,"VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_scissor_exclusive",1);
        addConstant(*this,"VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_device_diagnostic_checkpoints",1);
        addConstant(*this,"VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION",2);
        addConstant(*this,"VK_INTEL_shader_integer_functions2",1);
        addConstant(*this,"VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_INTEL_performance_query",1);
        addConstant(*this,"VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_pci_bus_info",1);
        addConstant(*this,"VK_EXT_PCI_BUS_INFO_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_display_native_hdr",1);
        addConstant(*this,"VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_density_map",1);
        addConstant(*this,"VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_scalar_block_layout",1);
        addConstant(*this,"VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_hlsl_functionality1",1);
        addConstant(*this,"VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION",1);
        addConstant(*this,"VK_GOOGLE_decorate_string",1);
        addConstant(*this,"VK_GOOGLE_DECORATE_STRING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_subgroup_size_control",1);
        addConstant(*this,"VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION",2);
        addConstant(*this,"VK_AMD_shader_core_properties2",1);
        addConstant(*this,"VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION",1);
        addConstant(*this,"VK_AMD_device_coherent_memory",1);
        addConstant(*this,"VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_image_atomic_int64",1);
        addConstant(*this,"VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_memory_budget",1);
        addConstant(*this,"VK_EXT_MEMORY_BUDGET_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_memory_priority",1);
        addConstant(*this,"VK_EXT_MEMORY_PRIORITY_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_dedicated_allocation_image_aliasing",1);
        addConstant(*this,"VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_buffer_device_address",1);
        addConstant(*this,"VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION",2);
        addConstant(*this,"VK_EXT_tooling_info",1);
        addConstant(*this,"VK_EXT_TOOLING_INFO_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_separate_stencil_usage",1);
        addConstant(*this,"VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_validation_features",1);
        addConstant(*this,"VK_EXT_VALIDATION_FEATURES_SPEC_VERSION",4);
        addConstant(*this,"VK_NV_cooperative_matrix",1);
        addConstant(*this,"VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_coverage_reduction_mode",1);
        addConstant(*this,"VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_shader_interlock",1);
        addConstant(*this,"VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_ycbcr_image_arrays",1);
        addConstant(*this,"VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_headless_surface",1);
        addConstant(*this,"VK_EXT_HEADLESS_SURFACE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_line_rasterization",1);
        addConstant(*this,"VK_EXT_LINE_RASTERIZATION_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_atomic_float",1);
        addConstant(*this,"VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_host_query_reset",1);
        addConstant(*this,"VK_EXT_HOST_QUERY_RESET_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_index_type_uint8",1);
        addConstant(*this,"VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_extended_dynamic_state",1);
        addConstant(*this,"VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_shader_demote_to_helper_invocation",1);
        addConstant(*this,"VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION",1);
        addConstant(*this,"VK_NV_device_generated_commands",1);
        addConstant(*this,"VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION",3);
        addConstant(*this,"VK_EXT_texel_buffer_alignment",1);
        addConstant(*this,"VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_render_pass_transform",1);
        addConstant(*this,"VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_device_memory_report",1);
        addConstant(*this,"VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_robustness2",1);
        addConstant(*this,"VK_EXT_ROBUSTNESS_2_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_custom_border_color",1);
        addConstant(*this,"VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION",12);
        addConstant(*this,"VK_GOOGLE_user_type",1);
        addConstant(*this,"VK_GOOGLE_USER_TYPE_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_private_data",1);
        addConstant(*this,"VK_EXT_PRIVATE_DATA_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_pipeline_creation_cache_control",1);
        addConstant(*this,"VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION",3);
        addConstant(*this,"VK_NV_device_diagnostics_config",1);
        addConstant(*this,"VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_render_pass_store_ops",1);
        addConstant(*this,"VK_QCOM_render_pass_store_ops_SPEC_VERSION",2);
        addConstant(*this,"VK_NV_fragment_shading_rate_enums",1);
        addConstant(*this,"VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_fragment_density_map2",1);
        addConstant(*this,"VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION",1);
        addConstant(*this,"VK_QCOM_rotated_copy_commands",1);
        addConstant(*this,"VK_QCOM_rotated_copy_commands_SPEC_VERSION",0);
        addConstant(*this,"VK_EXT_image_robustness",1);
        addConstant(*this,"VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION",1);
        addConstant(*this,"VK_EXT_4444_formats",1);
        addConstant(*this,"VK_EXT_4444_FORMATS_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_acceleration_structure",1);
        addConstant(*this,"VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION",11);
        addConstant(*this,"VK_KHR_ray_tracing_pipeline",1);
        addConstant(*this,"VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION",1);
        addConstant(*this,"VK_KHR_ray_query",1);
        addConstant(*this,"VK_KHR_RAY_QUERY_SPEC_VERSION",1);
    }
};
