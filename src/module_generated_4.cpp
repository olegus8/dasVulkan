// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkEvent, VkEvent)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueryPool, VkQueryPool)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferView, VkBufferView)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSparseImageFormatProperties2, VkSparseImageFormatProperties2);

struct VkSparseImageFormatProperties2Annotation
: public ManagedStructureAnnotation<VkSparseImageFormatProperties2,true,true> {
    VkSparseImageFormatProperties2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSparseImageFormatProperties2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(properties)>("properties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSparseImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2);

struct VkPhysicalDeviceSparseImageFormatInfo2Annotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseImageFormatInfo2,true,true> {
    VkPhysicalDeviceSparseImageFormatInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseImageFormatInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(type)>("type_");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(tiling)>("tiling");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePointClippingProperties);

struct VkPhysicalDevicePointClippingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevicePointClippingProperties,true,true> {
    VkPhysicalDevicePointClippingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevicePointClippingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInputAttachmentAspectReference, VkInputAttachmentAspectReference);

struct VkInputAttachmentAspectReferenceAnnotation
: public ManagedStructureAnnotation<VkInputAttachmentAspectReference,true,true> {
    VkInputAttachmentAspectReferenceAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInputAttachmentAspectReference", ml) {
        addField<DAS_BIND_MANAGED_FIELD(subpass)>("subpass");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentIndex)>("inputAttachmentIndex");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassInputAttachmentAspectCreateInfo, VkRenderPassInputAttachmentAspectCreateInfo);

struct VkRenderPassInputAttachmentAspectCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassInputAttachmentAspectCreateInfo,true,true> {
    VkRenderPassInputAttachmentAspectCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassInputAttachmentAspectCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(aspectReferenceCount)>("aspectReferenceCount");
        addField<DAS_BIND_MANAGED_FIELD(pAspectReferences)>("pAspectReferences");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageViewUsageCreateInfo, VkImageViewUsageCreateInfo);

struct VkImageViewUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageViewUsageCreateInfo,true,true> {
    VkImageViewUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageViewUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineTessellationDomainOriginStateCreateInfo, VkPipelineTessellationDomainOriginStateCreateInfo);

struct VkPipelineTessellationDomainOriginStateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkPipelineTessellationDomainOriginStateCreateInfo,true,true> {
    VkPipelineTessellationDomainOriginStateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPipelineTessellationDomainOriginStateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(domainOrigin)>("domainOrigin");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassMultiviewCreateInfo, VkRenderPassMultiviewCreateInfo);

struct VkRenderPassMultiviewCreateInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassMultiviewCreateInfo,true,true> {
    VkRenderPassMultiviewCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassMultiviewCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewMasks)>("pViewMasks");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewOffsets)>("pViewOffsets");
        addField<DAS_BIND_MANAGED_FIELD(correlationMaskCount)>("correlationMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelationMasks)>("pCorrelationMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewFeatures);

struct VkPhysicalDeviceMultiviewFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewFeatures,true,true> {
    VkPhysicalDeviceMultiviewFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceMultiviewProperties);

struct VkPhysicalDeviceMultiviewPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMultiviewProperties,true,true> {
    VkPhysicalDeviceMultiviewPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMultiviewProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVariablePointersFeatures);

struct VkPhysicalDeviceVariablePointersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVariablePointersFeatures,true,true> {
    VkPhysicalDeviceVariablePointersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVariablePointersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProtectedMemoryFeatures);

struct VkPhysicalDeviceProtectedMemoryFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryFeatures,true,true> {
    VkPhysicalDeviceProtectedMemoryFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProtectedMemoryProperties);

struct VkPhysicalDeviceProtectedMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProtectedMemoryProperties,true,true> {
    VkPhysicalDeviceProtectedMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProtectedMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueInfo2, VkDeviceQueueInfo2);

struct VkDeviceQueueInfo2Annotation
: public ManagedStructureAnnotation<VkDeviceQueueInfo2,true,true> {
    VkDeviceQueueInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueIndex)>("queueIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkProtectedSubmitInfo, VkProtectedSubmitInfo);

struct VkProtectedSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkProtectedSubmitInfo,true,true> {
    VkProtectedSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkProtectedSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(protectedSubmit)>("protectedSubmit");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionCreateInfo, VkSamplerYcbcrConversionCreateInfo);

struct VkSamplerYcbcrConversionCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionCreateInfo,true,true> {
    VkSamplerYcbcrConversionCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrModel)>("ycbcrModel");
        addField<DAS_BIND_MANAGED_FIELD(ycbcrRange)>("ycbcrRange");
        addField<DAS_BIND_MANAGED_FIELD(components)>("components");
        addField<DAS_BIND_MANAGED_FIELD(xChromaOffset)>("xChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(yChromaOffset)>("yChromaOffset");
        addField<DAS_BIND_MANAGED_FIELD(chromaFilter)>("chromaFilter");
        addField<DAS_BIND_MANAGED_FIELD(forceExplicitReconstruction)>("forceExplicitReconstruction");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionInfo, VkSamplerYcbcrConversionInfo);

struct VkSamplerYcbcrConversionInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionInfo,true,true> {
    VkSamplerYcbcrConversionInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(conversion)>("conversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImagePlaneMemoryInfo, VkBindImagePlaneMemoryInfo);

struct VkBindImagePlaneMemoryInfoAnnotation
: public ManagedStructureAnnotation<VkBindImagePlaneMemoryInfo,true,true> {
    VkBindImagePlaneMemoryInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImagePlaneMemoryInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImagePlaneMemoryRequirementsInfo, VkImagePlaneMemoryRequirementsInfo);

struct VkImagePlaneMemoryRequirementsInfoAnnotation
: public ManagedStructureAnnotation<VkImagePlaneMemoryRequirementsInfo,true,true> {
    VkImagePlaneMemoryRequirementsInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImagePlaneMemoryRequirementsInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(planeAspect)>("planeAspect");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures);

struct VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerYcbcrConversionFeatures,true,true> {
    VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerYcbcrConversionFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerYcbcrConversionImageFormatProperties, VkSamplerYcbcrConversionImageFormatProperties);

struct VkSamplerYcbcrConversionImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkSamplerYcbcrConversionImageFormatProperties,true,true> {
    VkSamplerYcbcrConversionImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerYcbcrConversionImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(combinedImageSamplerDescriptorCount)>("combinedImageSamplerDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplateEntry, VkDescriptorUpdateTemplateEntry);

struct VkDescriptorUpdateTemplateEntryAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateEntry,true,true> {
    VkDescriptorUpdateTemplateEntryAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateEntry", ml) {
        addField<DAS_BIND_MANAGED_FIELD(dstBinding)>("dstBinding");
        addField<DAS_BIND_MANAGED_FIELD(dstArrayElement)>("dstArrayElement");
        addField<DAS_BIND_MANAGED_FIELD(descriptorCount)>("descriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(descriptorType)>("descriptorType");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(stride)>("stride");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorUpdateTemplateCreateInfo, VkDescriptorUpdateTemplateCreateInfo);

struct VkDescriptorUpdateTemplateCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorUpdateTemplateCreateInfo,true,true> {
    VkDescriptorUpdateTemplateCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorUpdateTemplateCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(descriptorUpdateEntryCount)>("descriptorUpdateEntryCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorUpdateEntries)>("pDescriptorUpdateEntries");
        addField<DAS_BIND_MANAGED_FIELD(templateType)>("templateType");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetLayout)>("descriptorSetLayout");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(pipelineLayout)>("pipelineLayout");
        addField<DAS_BIND_MANAGED_FIELD(set)>("set");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryProperties, VkExternalMemoryProperties);

struct VkExternalMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryProperties,true,true> {
    VkExternalMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryFeatures)>("externalMemoryFeatures");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceExternalImageFormatInfo);

struct VkPhysicalDeviceExternalImageFormatInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalImageFormatInfo,true,true> {
    VkPhysicalDeviceExternalImageFormatInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalImageFormatInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalImageFormatProperties, VkExternalImageFormatProperties);

struct VkExternalImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalImageFormatProperties,true,true> {
    VkExternalImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalBufferInfo, VkPhysicalDeviceExternalBufferInfo);

struct VkPhysicalDeviceExternalBufferInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalBufferInfo,true,true> {
    VkPhysicalDeviceExternalBufferInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalBufferInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalBufferProperties, VkExternalBufferProperties);

struct VkExternalBufferPropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalBufferProperties,true,true> {
    VkExternalBufferPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalBufferProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(externalMemoryProperties)>("externalMemoryProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceIDProperties, VkPhysicalDeviceIDProperties);

struct VkPhysicalDeviceIDPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceIDProperties,true,true> {
    VkPhysicalDeviceIDPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceIDProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfo);

struct VkExternalMemoryImageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryImageCreateInfo,true,true> {
    VkExternalMemoryImageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryImageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalMemoryBufferCreateInfo, VkExternalMemoryBufferCreateInfo);

struct VkExternalMemoryBufferCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExternalMemoryBufferCreateInfo,true,true> {
    VkExternalMemoryBufferCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalMemoryBufferCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfo);

struct VkExportMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkExportMemoryAllocateInfo,true,true> {
    VkExportMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalFenceInfo, VkPhysicalDeviceExternalFenceInfo);

struct VkPhysicalDeviceExternalFenceInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalFenceInfo,true,true> {
    VkPhysicalDeviceExternalFenceInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalFenceInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalFenceProperties, VkExternalFenceProperties);

struct VkExternalFencePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalFenceProperties,true,true> {
    VkExternalFencePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalFenceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalFenceFeatures)>("externalFenceFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_4(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkMemoryPropertyFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkQueueFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkDeviceQueueCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPipelineStageFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSparseMemoryBindFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSparseImageFormatFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkFenceCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkQueryPipelineStatisticFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkQueryResultFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkBufferCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkBufferUsageFlagBits>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkEvent>>("VkEvent", "VkEvent"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkQueryPool>>("VkQueryPool", "VkQueryPool"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkBufferView>>("VkBufferView", "VkBufferView"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkSparseImageFormatProperties2Annotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSparseImageFormatInfo2Annotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDevicePointClippingPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkInputAttachmentAspectReferenceAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassInputAttachmentAspectCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageViewUsageCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPipelineTessellationDomainOriginStateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassMultiviewCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMultiviewFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMultiviewPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceVariablePointersFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceProtectedMemoryPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceQueueInfo2Annotation>(lib));
    module.addAnnotation(make_smart<VkProtectedSubmitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerYcbcrConversionCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerYcbcrConversionInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindImagePlaneMemoryInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkImagePlaneMemoryRequirementsInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSamplerYcbcrConversionFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerYcbcrConversionImageFormatPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorUpdateTemplateEntryAnnotation>(lib));
    module.addAnnotation(make_smart<VkDescriptorUpdateTemplateCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalMemoryPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExternalImageFormatInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalImageFormatPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExternalBufferInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalBufferPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceIDPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalMemoryImageCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalMemoryBufferCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExportMemoryAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceExternalFenceInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExternalFencePropertiesAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkCreateDescriptorSetLayout)>(*this, lib, "vkCreateDescriptorSetLayout",
        SideEffects::worstDefault, "vkCreateDescriptorSetLayout");
    addExtern<DAS_BIND_FUN(vkDestroyDescriptorSetLayout)>(*this, lib, "vkDestroyDescriptorSetLayout",
        SideEffects::worstDefault, "vkDestroyDescriptorSetLayout");
    addExtern<DAS_BIND_FUN(vkCreateDescriptorPool)>(*this, lib, "vkCreateDescriptorPool",
        SideEffects::worstDefault, "vkCreateDescriptorPool");
    addExtern<DAS_BIND_FUN(vkDestroyDescriptorPool)>(*this, lib, "vkDestroyDescriptorPool",
        SideEffects::worstDefault, "vkDestroyDescriptorPool");
    addExtern<DAS_BIND_FUN(vkResetDescriptorPool)>(*this, lib, "vkResetDescriptorPool",
        SideEffects::worstDefault, "vkResetDescriptorPool");
    addExtern<DAS_BIND_FUN(vkAllocateDescriptorSets)>(*this, lib, "vkAllocateDescriptorSets",
        SideEffects::worstDefault, "vkAllocateDescriptorSets");
    addExtern<DAS_BIND_FUN(vkFreeDescriptorSets)>(*this, lib, "vkFreeDescriptorSets",
        SideEffects::worstDefault, "vkFreeDescriptorSets");
    addExtern<DAS_BIND_FUN(vkUpdateDescriptorSets)>(*this, lib, "vkUpdateDescriptorSets",
        SideEffects::worstDefault, "vkUpdateDescriptorSets");
    addExtern<DAS_BIND_FUN(vkCreateFramebuffer)>(*this, lib, "vkCreateFramebuffer",
        SideEffects::worstDefault, "vkCreateFramebuffer");
    addExtern<DAS_BIND_FUN(vkDestroyFramebuffer)>(*this, lib, "vkDestroyFramebuffer",
        SideEffects::worstDefault, "vkDestroyFramebuffer");
    addExtern<DAS_BIND_FUN(vkCreateRenderPass)>(*this, lib, "vkCreateRenderPass",
        SideEffects::worstDefault, "vkCreateRenderPass");
    addExtern<DAS_BIND_FUN(vkDestroyRenderPass)>(*this, lib, "vkDestroyRenderPass",
        SideEffects::worstDefault, "vkDestroyRenderPass");
    addExtern<DAS_BIND_FUN(vkGetRenderAreaGranularity)>(*this, lib, "vkGetRenderAreaGranularity",
        SideEffects::worstDefault, "vkGetRenderAreaGranularity");
    addExtern<DAS_BIND_FUN(vkCreateCommandPool)>(*this, lib, "vkCreateCommandPool",
        SideEffects::worstDefault, "vkCreateCommandPool");
    addExtern<DAS_BIND_FUN(vkDestroyCommandPool)>(*this, lib, "vkDestroyCommandPool",
        SideEffects::worstDefault, "vkDestroyCommandPool");
    addExtern<DAS_BIND_FUN(vkResetCommandPool)>(*this, lib, "vkResetCommandPool",
        SideEffects::worstDefault, "vkResetCommandPool");
    addExtern<DAS_BIND_FUN(vkAllocateCommandBuffers)>(*this, lib, "vkAllocateCommandBuffers",
        SideEffects::worstDefault, "vkAllocateCommandBuffers");
    addExtern<DAS_BIND_FUN(vkFreeCommandBuffers)>(*this, lib, "vkFreeCommandBuffers",
        SideEffects::worstDefault, "vkFreeCommandBuffers");

    //
    // macro constants
    //

    addConstant(*this,"GLFW_GAMEPAD_BUTTON_START",7);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_GUIDE",8);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_LEFT_THUMB",9);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_RIGHT_THUMB",10);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_UP",11);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_RIGHT",12);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_DOWN",13);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_DPAD_LEFT",14);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_LAST",GLFW_GAMEPAD_BUTTON_DPAD_LEFT);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_CROSS",GLFW_GAMEPAD_BUTTON_A);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_CIRCLE",GLFW_GAMEPAD_BUTTON_B);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_SQUARE",GLFW_GAMEPAD_BUTTON_X);
    addConstant(*this,"GLFW_GAMEPAD_BUTTON_TRIANGLE",GLFW_GAMEPAD_BUTTON_Y);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_X",0);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_Y",1);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_X",2);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_Y",3);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_LEFT_TRIGGER",4);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER",5);
    addConstant(*this,"GLFW_GAMEPAD_AXIS_LAST",GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER);
    addConstant(*this,"GLFW_NO_ERROR",0);
    addConstant(*this,"GLFW_NOT_INITIALIZED",0x00010001);
    addConstant(*this,"GLFW_NO_CURRENT_CONTEXT",0x00010002);
    addConstant(*this,"GLFW_INVALID_ENUM",0x00010003);
    addConstant(*this,"GLFW_INVALID_VALUE",0x00010004);
    addConstant(*this,"GLFW_OUT_OF_MEMORY",0x00010005);
    addConstant(*this,"GLFW_API_UNAVAILABLE",0x00010006);
    addConstant(*this,"GLFW_VERSION_UNAVAILABLE",0x00010007);
    addConstant(*this,"GLFW_PLATFORM_ERROR",0x00010008);
    addConstant(*this,"GLFW_FORMAT_UNAVAILABLE",0x00010009);
    addConstant(*this,"GLFW_NO_WINDOW_CONTEXT",0x0001000A);
    addConstant(*this,"GLFW_FOCUSED",0x00020001);
    addConstant(*this,"GLFW_ICONIFIED",0x00020002);
    addConstant(*this,"GLFW_RESIZABLE",0x00020003);
    addConstant(*this,"GLFW_VISIBLE",0x00020004);
    addConstant(*this,"GLFW_DECORATED",0x00020005);
    addConstant(*this,"GLFW_AUTO_ICONIFY",0x00020006);
    addConstant(*this,"GLFW_FLOATING",0x00020007);
    addConstant(*this,"GLFW_MAXIMIZED",0x00020008);
    addConstant(*this,"GLFW_CENTER_CURSOR",0x00020009);
    addConstant(*this,"GLFW_TRANSPARENT_FRAMEBUFFER",0x0002000A);
    addConstant(*this,"GLFW_HOVERED",0x0002000B);
    addConstant(*this,"GLFW_FOCUS_ON_SHOW",0x0002000C);
    addConstant(*this,"GLFW_RED_BITS",0x00021001);
    addConstant(*this,"GLFW_GREEN_BITS",0x00021002);
};
