// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayout, VkPipelineLayout)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipeline, VkPipeline)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceSamplerFilterMinmaxProperties);

struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerFilterMinmaxProperties,true,true> {
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerFilterMinmaxProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceVulkanMemoryModelFeatures);

struct VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkanMemoryModelFeatures,true,true> {
    VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkanMemoryModelFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceImagelessFramebufferFeatures);

struct VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImagelessFramebufferFeatures,true,true> {
    VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImagelessFramebufferFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentImageInfo, VkFramebufferAttachmentImageInfo);

struct VkFramebufferAttachmentImageInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentImageInfo,true,true> {
    VkFramebufferAttachmentImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentsCreateInfo, VkFramebufferAttachmentsCreateInfo);

struct VkFramebufferAttachmentsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentsCreateInfo,true,true> {
    VkFramebufferAttachmentsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentImageInfoCount)>("attachmentImageInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentImageInfos)>("pAttachmentImageInfos");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassAttachmentBeginInfo, VkRenderPassAttachmentBeginInfo);

struct VkRenderPassAttachmentBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassAttachmentBeginInfo,true,true> {
    VkRenderPassAttachmentBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassAttachmentBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);

struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceUniformBufferStandardLayoutFeatures,true,true> {
    VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceUniformBufferStandardLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,true,true> {
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,true,true> {
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReferenceStencilLayout, VkAttachmentReferenceStencilLayout);

struct VkAttachmentReferenceStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentReferenceStencilLayout,true,true> {
    VkAttachmentReferenceStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReferenceStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilLayout)>("stencilLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescriptionStencilLayout, VkAttachmentDescriptionStencilLayout);

struct VkAttachmentDescriptionStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescriptionStencilLayout,true,true> {
    VkAttachmentDescriptionStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescriptionStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilInitialLayout)>("stencilInitialLayout");
        addField<DAS_BIND_MANAGED_FIELD(stencilFinalLayout)>("stencilFinalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceHostQueryResetFeatures);

struct VkPhysicalDeviceHostQueryResetFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceHostQueryResetFeatures,true,true> {
    VkPhysicalDeviceHostQueryResetFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceHostQueryResetFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures);

struct VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreFeatures,true,true> {
    VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTimelineSemaphoreProperties);

struct VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreProperties,true,true> {
    VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreTypeCreateInfo, VkSemaphoreTypeCreateInfo);

struct VkSemaphoreTypeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreTypeCreateInfo,true,true> {
    VkSemaphoreTypeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreTypeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreType)>("semaphoreType");
        addField<DAS_BIND_MANAGED_FIELD(initialValue)>("initialValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTimelineSemaphoreSubmitInfo, VkTimelineSemaphoreSubmitInfo);

struct VkTimelineSemaphoreSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkTimelineSemaphoreSubmitInfo,true,true> {
    VkTimelineSemaphoreSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTimelineSemaphoreSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreValueCount)>("waitSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreValues)>("pWaitSemaphoreValues");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreValueCount)>("signalSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreValues)>("pSignalSemaphoreValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreWaitInfo, VkSemaphoreWaitInfo);

struct VkSemaphoreWaitInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreWaitInfo,true,true> {
    VkSemaphoreWaitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreWaitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreCount)>("semaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSemaphores)>("pSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pValues)>("pValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreSignalInfo, VkSemaphoreSignalInfo);

struct VkSemaphoreSignalInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreSignalInfo,true,true> {
    VkSemaphoreSignalInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreSignalInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeatures,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressInfo, VkBufferDeviceAddressInfo);

struct VkBufferDeviceAddressInfoAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressInfo,true,true> {
    VkBufferDeviceAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferOpaqueCaptureAddressCreateInfo, VkBufferOpaqueCaptureAddressCreateInfo);

struct VkBufferOpaqueCaptureAddressCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferOpaqueCaptureAddressCreateInfo,true,true> {
    VkBufferOpaqueCaptureAddressCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferOpaqueCaptureAddressCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryOpaqueCaptureAddressAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo);

struct VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryOpaqueCaptureAddressAllocateInfo,true,true> {
    VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryOpaqueCaptureAddressAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOpaqueCaptureAddressInfo, VkDeviceMemoryOpaqueCaptureAddressInfo);

struct VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOpaqueCaptureAddressInfo,true,true> {
    VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOpaqueCaptureAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesKHR);

struct VkSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilitiesKHR,true,true> {
    VkSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceFormatKHR, VkSurfaceFormatKHR);

struct VkSurfaceFormatKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormatKHR,true,true> {
    VkSurfaceFormatKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormatKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(colorSpace)>("colorSpace");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCreateInfoKHR, VkSwapchainCreateInfoKHR);

struct VkSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSwapchainCreateInfoKHR,true,true> {
    VkSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(imageFormat)>("imageFormat");
        addField<DAS_BIND_MANAGED_FIELD(imageColorSpace)>("imageColorSpace");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
        addField<DAS_BIND_MANAGED_FIELD(imageArrayLayers)>("imageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(imageUsage)>("imageUsage");
        addField<DAS_BIND_MANAGED_FIELD(imageSharingMode)>("imageSharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(preTransform)>("preTransform");
        addField<DAS_BIND_MANAGED_FIELD(compositeAlpha)>("compositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(presentMode)>("presentMode");
        addField<DAS_BIND_MANAGED_FIELD(clipped)>("clipped");
        addField<DAS_BIND_MANAGED_FIELD(oldSwapchain)>("oldSwapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentInfoKHR, VkPresentInfoKHR);

struct VkPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPresentInfoKHR,true,true> {
    VkPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pSwapchains)>("pSwapchains");
        addField<DAS_BIND_MANAGED_FIELD(pImageIndices)>("pImageIndices");
        addField<DAS_BIND_MANAGED_FIELD(pResults)>("pResults");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSwapchainCreateInfoKHR, VkImageSwapchainCreateInfoKHR);

struct VkImageSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImageSwapchainCreateInfoKHR,true,true> {
    VkImageSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImageMemorySwapchainInfoKHR, VkBindImageMemorySwapchainInfoKHR);

struct VkBindImageMemorySwapchainInfoKHRAnnotation
: public ManagedStructureAnnotation<VkBindImageMemorySwapchainInfoKHR,true,true> {
    VkBindImageMemorySwapchainInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemorySwapchainInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(imageIndex)>("imageIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAcquireNextImageInfoKHR, VkAcquireNextImageInfoKHR);

struct VkAcquireNextImageInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireNextImageInfoKHR,true,true> {
    VkAcquireNextImageInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireNextImageInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentCapabilitiesKHR);

struct VkDeviceGroupPresentCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentCapabilitiesKHR,true,true> {
    VkDeviceGroupPresentCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(presentMask)>("presentMask");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentInfoKHR, VkDeviceGroupPresentInfoKHR);

struct VkDeviceGroupPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentInfoKHR,true,true> {
    VkDeviceGroupPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceMasks)>("pDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupSwapchainCreateInfoKHR, VkDeviceGroupSwapchainCreateInfoKHR);

struct VkDeviceGroupSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupSwapchainCreateInfoKHR,true,true> {
    VkDeviceGroupSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDisplayModeParametersKHR, VkDisplayModeParametersKHR);

struct VkDisplayModeParametersKHRAnnotation
: public ManagedStructureAnnotation<VkDisplayModeParametersKHR,true,true> {
    VkDisplayModeParametersKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDisplayModeParametersKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(visibleRegion)>("visibleRegion");
        addField<DAS_BIND_MANAGED_FIELD(refreshRate)>("refreshRate");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_6(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkAttachmentDescriptionFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkDependencyFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkFramebufferCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkRenderPassCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSubpassDescriptionFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandPoolCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandPoolResetFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandBufferUsageFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkQueryControlFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandBufferResetFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkStencilFaceFlagBits>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkPipelineLayout>>("VkPipelineLayout", "VkPipelineLayout"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPipeline>>("VkPipeline", "VkPipeline"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferAttachmentImageInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferAttachmentsCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassAttachmentBeginInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentReferenceStencilLayoutAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentDescriptionStencilLayoutAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceHostQueryResetFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreTypeCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkTimelineSemaphoreSubmitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreWaitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreSignalInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferDeviceAddressInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferOpaqueCaptureAddressCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceCapabilitiesKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceFormatKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkSwapchainCreateInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSwapchainCreateInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindImageMemorySwapchainInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkAcquireNextImageInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceGroupPresentCapabilitiesKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceGroupPresentInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceGroupSwapchainCreateInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDisplayModeParametersKHRAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkCmdDrawIndexed)>(module, lib, "vkCmdDrawIndexed",
        SideEffects::worstDefault, "vkCmdDrawIndexed");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndirect)>(module, lib, "vkCmdDrawIndirect",
        SideEffects::worstDefault, "vkCmdDrawIndirect");
    addExtern<DAS_BIND_FUN(vkCmdDrawIndexedIndirect)>(module, lib, "vkCmdDrawIndexedIndirect",
        SideEffects::worstDefault, "vkCmdDrawIndexedIndirect");
    addExtern<DAS_BIND_FUN(vkCmdDispatch)>(module, lib, "vkCmdDispatch",
        SideEffects::worstDefault, "vkCmdDispatch");
    addExtern<DAS_BIND_FUN(vkCmdDispatchIndirect)>(module, lib, "vkCmdDispatchIndirect",
        SideEffects::worstDefault, "vkCmdDispatchIndirect");
    addExtern<DAS_BIND_FUN(vkCmdCopyBuffer)>(module, lib, "vkCmdCopyBuffer",
        SideEffects::worstDefault, "vkCmdCopyBuffer");
    addExtern<DAS_BIND_FUN(vkCmdCopyImage)>(module, lib, "vkCmdCopyImage",
        SideEffects::worstDefault, "vkCmdCopyImage");
    addExtern<DAS_BIND_FUN(vkCmdBlitImage)>(module, lib, "vkCmdBlitImage",
        SideEffects::worstDefault, "vkCmdBlitImage");
    addExtern<DAS_BIND_FUN(vkCmdCopyBufferToImage)>(module, lib, "vkCmdCopyBufferToImage",
        SideEffects::worstDefault, "vkCmdCopyBufferToImage");
    addExtern<DAS_BIND_FUN(vkCmdCopyImageToBuffer)>(module, lib, "vkCmdCopyImageToBuffer",
        SideEffects::worstDefault, "vkCmdCopyImageToBuffer");
    addExtern<DAS_BIND_FUN(vkCmdUpdateBuffer)>(module, lib, "vkCmdUpdateBuffer",
        SideEffects::worstDefault, "vkCmdUpdateBuffer");
    addExtern<DAS_BIND_FUN(vkCmdFillBuffer)>(module, lib, "vkCmdFillBuffer",
        SideEffects::worstDefault, "vkCmdFillBuffer");
    addExtern<DAS_BIND_FUN(vkCmdClearColorImage)>(module, lib, "vkCmdClearColorImage",
        SideEffects::worstDefault, "vkCmdClearColorImage");
    addExtern<DAS_BIND_FUN(vkCmdClearDepthStencilImage)>(module, lib, "vkCmdClearDepthStencilImage",
        SideEffects::worstDefault, "vkCmdClearDepthStencilImage");
    addExtern<DAS_BIND_FUN(vkCmdClearAttachments)>(module, lib, "vkCmdClearAttachments",
        SideEffects::worstDefault, "vkCmdClearAttachments");
    addExtern<DAS_BIND_FUN(vkCmdResolveImage)>(module, lib, "vkCmdResolveImage",
        SideEffects::worstDefault, "vkCmdResolveImage");
    addExtern<DAS_BIND_FUN(vkCmdSetEvent)>(module, lib, "vkCmdSetEvent",
        SideEffects::worstDefault, "vkCmdSetEvent");
    addExtern<DAS_BIND_FUN(vkCmdResetEvent)>(module, lib, "vkCmdResetEvent",
        SideEffects::worstDefault, "vkCmdResetEvent");

    //
    // macro constants
    //

    addConstant(module, "GLFW_CURSOR_NORMAL", 0x00034001);
    addConstant(module, "GLFW_CURSOR_HIDDEN", 0x00034002);
    addConstant(module, "GLFW_CURSOR_DISABLED", 0x00034003);
    addConstant(module, "GLFW_ANY_RELEASE_BEHAVIOR", 0);
    addConstant(module, "GLFW_RELEASE_BEHAVIOR_FLUSH", 0x00035001);
    addConstant(module, "GLFW_RELEASE_BEHAVIOR_NONE", 0x00035002);
    addConstant(module, "GLFW_NATIVE_CONTEXT_API", 0x00036001);
    addConstant(module, "GLFW_EGL_CONTEXT_API", 0x00036002);
    addConstant(module, "GLFW_OSMESA_CONTEXT_API", 0x00036003);
    addConstant(module, "GLFW_ARROW_CURSOR", 0x00036001);
    addConstant(module, "GLFW_IBEAM_CURSOR", 0x00036002);
    addConstant(module, "GLFW_CROSSHAIR_CURSOR", 0x00036003);
    addConstant(module, "GLFW_HAND_CURSOR", 0x00036004);
    addConstant(module, "GLFW_HRESIZE_CURSOR", 0x00036005);
    addConstant(module, "GLFW_VRESIZE_CURSOR", 0x00036006);
    addConstant(module, "GLFW_CONNECTED", 0x00040001);
    addConstant(module, "GLFW_DISCONNECTED", 0x00040002);
    addConstant(module, "GLFW_JOYSTICK_HAT_BUTTONS", 0x00050001);
    addConstant(module, "GLFW_COCOA_CHDIR_RESOURCES", 0x00051001);
    addConstant(module, "GLFW_COCOA_MENUBAR", 0x00051002);
    addConstant(module, "GLFW_DONT_CARE", -1);
    addConstant(module, "VK_VERSION_1_0", 1);
    addConstant(module, "VK_API_VERSION_1_0", VK_MAKE_VERSION(1, 0, 0));
    addConstant(module, "VK_HEADER_VERSION", 162);
    addConstant(module, "VK_HEADER_VERSION_COMPLETE", VK_MAKE_VERSION(1, 2, VK_HEADER_VERSION));
    addConstant(module, "VK_NULL_HANDLE", 0);
    addConstant(module, "VK_ATTACHMENT_UNUSED", (~0U));
    addConstant(module, "VK_FALSE", 0);
    addConstant(module, "VK_LOD_CLAMP_NONE", 1000.0f);
    addConstant(module, "VK_QUEUE_FAMILY_IGNORED", (~0U));
    addConstant(module, "VK_REMAINING_ARRAY_LAYERS", (~0U));
    addConstant(module, "VK_REMAINING_MIP_LEVELS", (~0U));
    addConstant(module, "VK_SUBPASS_EXTERNAL", (~0U));
    addConstant(module, "VK_TRUE", 1);
    addConstant(module, "VK_WHOLE_SIZE", (~0ULL));
    addConstant(module, "VK_MAX_MEMORY_TYPES", 32);
    addConstant(module, "VK_MAX_MEMORY_HEAPS", 16);
    addConstant(module, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE", 256);
    addConstant(module, "VK_UUID_SIZE", 16);
    addConstant(module, "VK_MAX_EXTENSION_NAME_SIZE", 256);
    addConstant(module, "VK_MAX_DESCRIPTION_SIZE", 256);
    addConstant(module, "VK_VERSION_1_1", 1);
    addConstant(module, "VK_API_VERSION_1_1", VK_MAKE_VERSION(1, 1, 0));
    addConstant(module, "VK_MAX_DEVICE_GROUP_SIZE", 32);
    addConstant(module, "VK_LUID_SIZE", 8);
    addConstant(module, "VK_QUEUE_FAMILY_EXTERNAL", (~0U-1));
};
