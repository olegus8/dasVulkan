// generated by dasVulkan for Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4100)   // unreferenced formal parameter
#endif
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCache, VkPipelineCache)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineLayout, VkPipelineLayout)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageStencilUsageCreateInfo, VkImageStencilUsageCreateInfo);

struct VkImageStencilUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageStencilUsageCreateInfo,true,true> {
    VkImageStencilUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageStencilUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilUsage)>("stencilUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerReductionModeCreateInfo, VkSamplerReductionModeCreateInfo);

struct VkSamplerReductionModeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerReductionModeCreateInfo,true,true> {
    VkSamplerReductionModeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerReductionModeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(reductionMode)>("reductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceSamplerFilterMinmaxProperties);

struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSamplerFilterMinmaxProperties,true,true> {
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSamplerFilterMinmaxProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceVulkanMemoryModelFeatures);

struct VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkanMemoryModelFeatures,true,true> {
    VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkanMemoryModelFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceImagelessFramebufferFeatures);

struct VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceImagelessFramebufferFeatures,true,true> {
    VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceImagelessFramebufferFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentImageInfo, VkFramebufferAttachmentImageInfo);

struct VkFramebufferAttachmentImageInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentImageInfo,true,true> {
    VkFramebufferAttachmentImageInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentImageInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(usage)>("usage");
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFramebufferAttachmentsCreateInfo, VkFramebufferAttachmentsCreateInfo);

struct VkFramebufferAttachmentsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkFramebufferAttachmentsCreateInfo,true,true> {
    VkFramebufferAttachmentsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFramebufferAttachmentsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentImageInfoCount)>("attachmentImageInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachmentImageInfos)>("pAttachmentImageInfos");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassAttachmentBeginInfo, VkRenderPassAttachmentBeginInfo);

struct VkRenderPassAttachmentBeginInfoAnnotation
: public ManagedStructureAnnotation<VkRenderPassAttachmentBeginInfo,true,true> {
    VkRenderPassAttachmentBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassAttachmentBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures);

struct VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceUniformBufferStandardLayoutFeatures,true,true> {
    VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceUniformBufferStandardLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);

struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,true,true> {
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);

struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,true,true> {
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReferenceStencilLayout, VkAttachmentReferenceStencilLayout);

struct VkAttachmentReferenceStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentReferenceStencilLayout,true,true> {
    VkAttachmentReferenceStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReferenceStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilLayout)>("stencilLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescriptionStencilLayout, VkAttachmentDescriptionStencilLayout);

struct VkAttachmentDescriptionStencilLayoutAnnotation
: public ManagedStructureAnnotation<VkAttachmentDescriptionStencilLayout,true,true> {
    VkAttachmentDescriptionStencilLayoutAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescriptionStencilLayout", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilInitialLayout)>("stencilInitialLayout");
        addField<DAS_BIND_MANAGED_FIELD(stencilFinalLayout)>("stencilFinalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceHostQueryResetFeatures);

struct VkPhysicalDeviceHostQueryResetFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceHostQueryResetFeatures,true,true> {
    VkPhysicalDeviceHostQueryResetFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceHostQueryResetFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures);

struct VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreFeatures,true,true> {
    VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTimelineSemaphoreProperties);

struct VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceTimelineSemaphoreProperties,true,true> {
    VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceTimelineSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreTypeCreateInfo, VkSemaphoreTypeCreateInfo);

struct VkSemaphoreTypeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreTypeCreateInfo,true,true> {
    VkSemaphoreTypeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreTypeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreType)>("semaphoreType");
        addField<DAS_BIND_MANAGED_FIELD(initialValue)>("initialValue");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkTimelineSemaphoreSubmitInfo, VkTimelineSemaphoreSubmitInfo);

struct VkTimelineSemaphoreSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkTimelineSemaphoreSubmitInfo,true,true> {
    VkTimelineSemaphoreSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkTimelineSemaphoreSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreValueCount)>("waitSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphoreValues)>("pWaitSemaphoreValues");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreValueCount)>("signalSemaphoreValueCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphoreValues)>("pSignalSemaphoreValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreWaitInfo, VkSemaphoreWaitInfo);

struct VkSemaphoreWaitInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreWaitInfo,true,true> {
    VkSemaphoreWaitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreWaitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(semaphoreCount)>("semaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSemaphores)>("pSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pValues)>("pValues");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSemaphoreSignalInfo, VkSemaphoreSignalInfo);

struct VkSemaphoreSignalInfoAnnotation
: public ManagedStructureAnnotation<VkSemaphoreSignalInfo,true,true> {
    VkSemaphoreSignalInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSemaphoreSignalInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(value)>("value");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures);

struct VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceBufferDeviceAddressFeatures,true,true> {
    VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceBufferDeviceAddressFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferDeviceAddressInfo, VkBufferDeviceAddressInfo);

struct VkBufferDeviceAddressInfoAnnotation
: public ManagedStructureAnnotation<VkBufferDeviceAddressInfo,true,true> {
    VkBufferDeviceAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferDeviceAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferOpaqueCaptureAddressCreateInfo, VkBufferOpaqueCaptureAddressCreateInfo);

struct VkBufferOpaqueCaptureAddressCreateInfoAnnotation
: public ManagedStructureAnnotation<VkBufferOpaqueCaptureAddressCreateInfo,true,true> {
    VkBufferOpaqueCaptureAddressCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferOpaqueCaptureAddressCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryOpaqueCaptureAddressAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo);

struct VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryOpaqueCaptureAddressAllocateInfo,true,true> {
    VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryOpaqueCaptureAddressAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(opaqueCaptureAddress)>("opaqueCaptureAddress");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceMemoryOpaqueCaptureAddressInfo, VkDeviceMemoryOpaqueCaptureAddressInfo);

struct VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceMemoryOpaqueCaptureAddressInfo,true,true> {
    VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceMemoryOpaqueCaptureAddressInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesKHR);

struct VkSurfaceCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceCapabilitiesKHR,true,true> {
    VkSurfaceCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(maxImageCount)>("maxImageCount");
        addField<DAS_BIND_MANAGED_FIELD(currentExtent)>("currentExtent");
        addField<DAS_BIND_MANAGED_FIELD(minImageExtent)>("minImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageExtent)>("maxImageExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(supportedTransforms)>("supportedTransforms");
        addField<DAS_BIND_MANAGED_FIELD(currentTransform)>("currentTransform");
        addField<DAS_BIND_MANAGED_FIELD(supportedCompositeAlpha)>("supportedCompositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(supportedUsageFlags)>("supportedUsageFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSurfaceFormatKHR, VkSurfaceFormatKHR);

struct VkSurfaceFormatKHRAnnotation
: public ManagedStructureAnnotation<VkSurfaceFormatKHR,true,true> {
    VkSurfaceFormatKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSurfaceFormatKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(colorSpace)>("colorSpace");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSwapchainCreateInfoKHR, VkSwapchainCreateInfoKHR);

struct VkSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkSwapchainCreateInfoKHR,true,true> {
    VkSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(surface)>("surface");
        addField<DAS_BIND_MANAGED_FIELD(minImageCount)>("minImageCount");
        addField<DAS_BIND_MANAGED_FIELD(imageFormat)>("imageFormat");
        addField<DAS_BIND_MANAGED_FIELD(imageColorSpace)>("imageColorSpace");
        addField<DAS_BIND_MANAGED_FIELD(imageExtent)>("imageExtent");
        addField<DAS_BIND_MANAGED_FIELD(imageArrayLayers)>("imageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(imageUsage)>("imageUsage");
        addField<DAS_BIND_MANAGED_FIELD(imageSharingMode)>("imageSharingMode");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndexCount)>("queueFamilyIndexCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueFamilyIndices)>("pQueueFamilyIndices");
        addField<DAS_BIND_MANAGED_FIELD(preTransform)>("preTransform");
        addField<DAS_BIND_MANAGED_FIELD(compositeAlpha)>("compositeAlpha");
        addField<DAS_BIND_MANAGED_FIELD(presentMode)>("presentMode");
        addField<DAS_BIND_MANAGED_FIELD(clipped)>("clipped");
        addField<DAS_BIND_MANAGED_FIELD(oldSwapchain)>("oldSwapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPresentInfoKHR, VkPresentInfoKHR);

struct VkPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkPresentInfoKHR,true,true> {
    VkPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pSwapchains)>("pSwapchains");
        addField<DAS_BIND_MANAGED_FIELD(pImageIndices)>("pImageIndices");
        addField<DAS_BIND_MANAGED_FIELD(pResults)>("pResults");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSwapchainCreateInfoKHR, VkImageSwapchainCreateInfoKHR);

struct VkImageSwapchainCreateInfoKHRAnnotation
: public ManagedStructureAnnotation<VkImageSwapchainCreateInfoKHR,true,true> {
    VkImageSwapchainCreateInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSwapchainCreateInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBindImageMemorySwapchainInfoKHR, VkBindImageMemorySwapchainInfoKHR);

struct VkBindImageMemorySwapchainInfoKHRAnnotation
: public ManagedStructureAnnotation<VkBindImageMemorySwapchainInfoKHR,true,true> {
    VkBindImageMemorySwapchainInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBindImageMemorySwapchainInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(imageIndex)>("imageIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAcquireNextImageInfoKHR, VkAcquireNextImageInfoKHR);

struct VkAcquireNextImageInfoKHRAnnotation
: public ManagedStructureAnnotation<VkAcquireNextImageInfoKHR,true,true> {
    VkAcquireNextImageInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAcquireNextImageInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchain)>("swapchain");
        addField<DAS_BIND_MANAGED_FIELD(timeout)>("timeout");
        addField<DAS_BIND_MANAGED_FIELD(semaphore)>("semaphore");
        addField<DAS_BIND_MANAGED_FIELD(fence)>("fence");
        addField<DAS_BIND_MANAGED_FIELD(deviceMask)>("deviceMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentCapabilitiesKHR);

struct VkDeviceGroupPresentCapabilitiesKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentCapabilitiesKHR,true,true> {
    VkDeviceGroupPresentCapabilitiesKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentCapabilitiesKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(presentMask)>("presentMask");
        addField<DAS_BIND_MANAGED_FIELD(modes)>("modes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceGroupPresentInfoKHR, VkDeviceGroupPresentInfoKHR);

struct VkDeviceGroupPresentInfoKHRAnnotation
: public ManagedStructureAnnotation<VkDeviceGroupPresentInfoKHR,true,true> {
    VkDeviceGroupPresentInfoKHRAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceGroupPresentInfoKHR", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(swapchainCount)>("swapchainCount");
        addField<DAS_BIND_MANAGED_FIELD(pDeviceMasks)>("pDeviceMasks");
        addField<DAS_BIND_MANAGED_FIELD(mode)>("mode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGeneratedEnums_6(Module & module, ModuleLibrary & lib) {
    module.addEnumeration(make_smart<EnumerationVkAttachmentDescriptionFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkDependencyFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkFramebufferCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkRenderPassCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSubpassDescriptionFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandPoolCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandPoolResetFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandBufferUsageFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkQueryControlFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCommandBufferResetFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkStencilFaceFlagBits>());
}

void addVulkanGeneratedOpaqueStructs_6(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPipelineCache>>("VkPipelineCache", "VkPipelineCache"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPipelineLayout>>("VkPipelineLayout", "VkPipelineLayout"));
}

void addVulkanGeneratedStructs_6(Module & module, ModuleLibrary & lib) {
    module.addAnnotation(make_smart<VkImageStencilUsageCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSamplerReductionModeCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSamplerFilterMinmaxPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceVulkanMemoryModelFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceImagelessFramebufferFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferAttachmentImageInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkFramebufferAttachmentsCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkRenderPassAttachmentBeginInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentReferenceStencilLayoutAnnotation>(lib));
    module.addAnnotation(make_smart<VkAttachmentDescriptionStencilLayoutAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceHostQueryResetFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphoreFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceTimelineSemaphorePropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreTypeCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkTimelineSemaphoreSubmitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreWaitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSemaphoreSignalInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceBufferDeviceAddressFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferDeviceAddressInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferOpaqueCaptureAddressCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryOpaqueCaptureAddressAllocateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceMemoryOpaqueCaptureAddressInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceCapabilitiesKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkSurfaceFormatKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkSwapchainCreateInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkPresentInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSwapchainCreateInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkBindImageMemorySwapchainInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkAcquireNextImageInfoKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceGroupPresentCapabilitiesKHRAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceGroupPresentInfoKHRAnnotation>(lib));
}

void addVulkanGeneratedFunctions_6(Module & module, ModuleLibrary & lib) {
    addExtern<DAS_BIND_FUN(vkCreateDescriptorSetLayout)>(module, lib, "vkCreateDescriptorSetLayout",
        SideEffects::worstDefault, "vkCreateDescriptorSetLayout");
    addExtern<DAS_BIND_FUN(vkDestroyDescriptorSetLayout)>(module, lib, "vkDestroyDescriptorSetLayout",
        SideEffects::worstDefault, "vkDestroyDescriptorSetLayout");
    addExtern<DAS_BIND_FUN(vkCreateDescriptorPool)>(module, lib, "vkCreateDescriptorPool",
        SideEffects::worstDefault, "vkCreateDescriptorPool");
    addExtern<DAS_BIND_FUN(vkDestroyDescriptorPool)>(module, lib, "vkDestroyDescriptorPool",
        SideEffects::worstDefault, "vkDestroyDescriptorPool");
    addExtern<DAS_BIND_FUN(vkResetDescriptorPool)>(module, lib, "vkResetDescriptorPool",
        SideEffects::worstDefault, "vkResetDescriptorPool");
    addExtern<DAS_BIND_FUN(vkAllocateDescriptorSets)>(module, lib, "vkAllocateDescriptorSets",
        SideEffects::worstDefault, "vkAllocateDescriptorSets");
    addExtern<DAS_BIND_FUN(vkFreeDescriptorSets)>(module, lib, "vkFreeDescriptorSets",
        SideEffects::worstDefault, "vkFreeDescriptorSets");
    addExtern<DAS_BIND_FUN(vkUpdateDescriptorSets)>(module, lib, "vkUpdateDescriptorSets",
        SideEffects::worstDefault, "vkUpdateDescriptorSets");
    addExtern<DAS_BIND_FUN(vkCreateFramebuffer)>(module, lib, "vkCreateFramebuffer",
        SideEffects::worstDefault, "vkCreateFramebuffer");
    addExtern<DAS_BIND_FUN(vkDestroyFramebuffer)>(module, lib, "vkDestroyFramebuffer",
        SideEffects::worstDefault, "vkDestroyFramebuffer");
    addExtern<DAS_BIND_FUN(vkCreateRenderPass)>(module, lib, "vkCreateRenderPass",
        SideEffects::worstDefault, "vkCreateRenderPass");
    addExtern<DAS_BIND_FUN(vkDestroyRenderPass)>(module, lib, "vkDestroyRenderPass",
        SideEffects::worstDefault, "vkDestroyRenderPass");
}

void addVulkanGeneratedConsts_6(Module & module, ModuleLibrary & lib) {
    addConstant(module, "VK_EXT_debug_report", 1);
    addConstant(module, "VK_EXT_DEBUG_REPORT_SPEC_VERSION", 9);
    addConstant(module, "VK_NV_glsl_shader", 1);
    addConstant(module, "VK_NV_GLSL_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_depth_range_unrestricted", 1);
    addConstant(module, "VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION", 1);
    addConstant(module, "VK_IMG_filter_cubic", 1);
    addConstant(module, "VK_IMG_FILTER_CUBIC_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_rasterization_order", 1);
    addConstant(module, "VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_trinary_minmax", 1);
    addConstant(module, "VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION", 1);
    addConstant(module, "VK_AMD_shader_explicit_vertex_parameter", 1);
    addConstant(module, "VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_debug_marker", 1);
    addConstant(module, "VK_EXT_DEBUG_MARKER_SPEC_VERSION", 4);
    addConstant(module, "VK_AMD_gcn_shader", 1);
    addConstant(module, "VK_AMD_GCN_SHADER_SPEC_VERSION", 1);
    addConstant(module, "VK_NV_dedicated_allocation", 1);
    addConstant(module, "VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION", 1);
    addConstant(module, "VK_EXT_transform_feedback", 1);
    addConstant(module, "VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION", 1);
    addConstant(module, "VK_NVX_image_view_handle", 1);
    addConstant(module, "VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_draw_indirect_count", 1);
    addConstant(module, "VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION", 2);
    addConstant(module, "VK_AMD_negative_viewport_height", 1);
}
