// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageView, VkImageView)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkShaderModule, VkShaderModule)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPipelineCache, VkPipelineCache)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportFenceCreateInfo, VkExportFenceCreateInfo);

struct VkExportFenceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportFenceCreateInfo,true,true> {
    VkExportFenceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportFenceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExportSemaphoreCreateInfo, VkExportSemaphoreCreateInfo);

struct VkExportSemaphoreCreateInfoAnnotation
: public ManagedStructureAnnotation<VkExportSemaphoreCreateInfo,true,true> {
    VkExportSemaphoreCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExportSemaphoreCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleTypes)>("handleTypes");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceExternalSemaphoreInfo, VkPhysicalDeviceExternalSemaphoreInfo);

struct VkPhysicalDeviceExternalSemaphoreInfoAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceExternalSemaphoreInfo,true,true> {
    VkPhysicalDeviceExternalSemaphoreInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceExternalSemaphoreInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(handleType)>("handleType");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExternalSemaphoreProperties, VkExternalSemaphoreProperties);

struct VkExternalSemaphorePropertiesAnnotation
: public ManagedStructureAnnotation<VkExternalSemaphoreProperties,true,true> {
    VkExternalSemaphorePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExternalSemaphoreProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(exportFromImportedHandleTypes)>("exportFromImportedHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(compatibleHandleTypes)>("compatibleHandleTypes");
        addField<DAS_BIND_MANAGED_FIELD(externalSemaphoreFeatures)>("externalSemaphoreFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance3Properties);

struct VkPhysicalDeviceMaintenance3PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMaintenance3Properties,true,true> {
    VkPhysicalDeviceMaintenance3PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMaintenance3Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutSupport, VkDescriptorSetLayoutSupport);

struct VkDescriptorSetLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutSupport,true,true> {
    VkDescriptorSetLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supported)>("supported");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderDrawParametersFeatures);

struct VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderDrawParametersFeatures,true,true> {
    VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderDrawParametersFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan11Features);

struct VkPhysicalDeviceVulkan11FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Features,true,true> {
    VkPhysicalDeviceVulkan11FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer16BitAccess)>("storageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer16BitAccess)>("uniformAndStorageBuffer16BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant16)>("storagePushConstant16");
        addField<DAS_BIND_MANAGED_FIELD(storageInputOutput16)>("storageInputOutput16");
        addField<DAS_BIND_MANAGED_FIELD(multiview)>("multiview");
        addField<DAS_BIND_MANAGED_FIELD(multiviewGeometryShader)>("multiviewGeometryShader");
        addField<DAS_BIND_MANAGED_FIELD(multiviewTessellationShader)>("multiviewTessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(variablePointersStorageBuffer)>("variablePointersStorageBuffer");
        addField<DAS_BIND_MANAGED_FIELD(variablePointers)>("variablePointers");
        addField<DAS_BIND_MANAGED_FIELD(protectedMemory)>("protectedMemory");
        addField<DAS_BIND_MANAGED_FIELD(samplerYcbcrConversion)>("samplerYcbcrConversion");
        addField<DAS_BIND_MANAGED_FIELD(shaderDrawParameters)>("shaderDrawParameters");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan11Properties);

struct VkPhysicalDeviceVulkan11PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan11Properties,true,true> {
    VkPhysicalDeviceVulkan11PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan11Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(deviceUUID)>("deviceUUID");
        addField<DAS_BIND_MANAGED_FIELD(driverUUID)>("driverUUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUID)>("deviceLUID");
        addField<DAS_BIND_MANAGED_FIELD(deviceNodeMask)>("deviceNodeMask");
        addField<DAS_BIND_MANAGED_FIELD(deviceLUIDValid)>("deviceLUIDValid");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSize)>("subgroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedStages)>("subgroupSupportedStages");
        addField<DAS_BIND_MANAGED_FIELD(subgroupSupportedOperations)>("subgroupSupportedOperations");
        addField<DAS_BIND_MANAGED_FIELD(subgroupQuadOperationsInAllStages)>("subgroupQuadOperationsInAllStages");
        addField<DAS_BIND_MANAGED_FIELD(pointClippingBehavior)>("pointClippingBehavior");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewViewCount)>("maxMultiviewViewCount");
        addField<DAS_BIND_MANAGED_FIELD(maxMultiviewInstanceIndex)>("maxMultiviewInstanceIndex");
        addField<DAS_BIND_MANAGED_FIELD(protectedNoFault)>("protectedNoFault");
        addField<DAS_BIND_MANAGED_FIELD(maxPerSetDescriptors)>("maxPerSetDescriptors");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationSize)>("maxMemoryAllocationSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan12Features);

struct VkPhysicalDeviceVulkan12FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Features,true,true> {
    VkPhysicalDeviceVulkan12FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(samplerMirrorClampToEdge)>("samplerMirrorClampToEdge");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectCount)>("drawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
        addField<DAS_BIND_MANAGED_FIELD(descriptorIndexing)>("descriptorIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
        addField<DAS_BIND_MANAGED_FIELD(samplerFilterMinmax)>("samplerFilterMinmax");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
        addField<DAS_BIND_MANAGED_FIELD(imagelessFramebuffer)>("imagelessFramebuffer");
        addField<DAS_BIND_MANAGED_FIELD(uniformBufferStandardLayout)>("uniformBufferStandardLayout");
        addField<DAS_BIND_MANAGED_FIELD(shaderSubgroupExtendedTypes)>("shaderSubgroupExtendedTypes");
        addField<DAS_BIND_MANAGED_FIELD(separateDepthStencilLayouts)>("separateDepthStencilLayouts");
        addField<DAS_BIND_MANAGED_FIELD(hostQueryReset)>("hostQueryReset");
        addField<DAS_BIND_MANAGED_FIELD(timelineSemaphore)>("timelineSemaphore");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddress)>("bufferDeviceAddress");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressCaptureReplay)>("bufferDeviceAddressCaptureReplay");
        addField<DAS_BIND_MANAGED_FIELD(bufferDeviceAddressMultiDevice)>("bufferDeviceAddressMultiDevice");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModel)>("vulkanMemoryModel");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelDeviceScope)>("vulkanMemoryModelDeviceScope");
        addField<DAS_BIND_MANAGED_FIELD(vulkanMemoryModelAvailabilityVisibilityChains)>("vulkanMemoryModelAvailabilityVisibilityChains");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputViewportIndex)>("shaderOutputViewportIndex");
        addField<DAS_BIND_MANAGED_FIELD(shaderOutputLayer)>("shaderOutputLayer");
        addField<DAS_BIND_MANAGED_FIELD(subgroupBroadcastDynamicId)>("subgroupBroadcastDynamicId");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkConformanceVersion, VkConformanceVersion);

struct VkConformanceVersionAnnotation
: public ManagedStructureAnnotation<VkConformanceVersion,true,true> {
    VkConformanceVersionAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkConformanceVersion", ml) {
        addField<DAS_BIND_MANAGED_FIELD(major)>("major");
        addField<DAS_BIND_MANAGED_FIELD(minor)>("minor");
        addField<DAS_BIND_MANAGED_FIELD(subminor)>("subminor");
        addField<DAS_BIND_MANAGED_FIELD(patch)>("patch");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan12Properties);

struct VkPhysicalDeviceVulkan12PropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceVulkan12Properties,true,true> {
    VkPhysicalDeviceVulkan12PropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceVulkan12Properties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxSingleComponentFormats)>("filterMinmaxSingleComponentFormats");
        addField<DAS_BIND_MANAGED_FIELD(filterMinmaxImageComponentMapping)>("filterMinmaxImageComponentMapping");
        addField<DAS_BIND_MANAGED_FIELD(maxTimelineSemaphoreValueDifference)>("maxTimelineSemaphoreValueDifference");
        addField<DAS_BIND_MANAGED_FIELD(framebufferIntegerColorSampleCounts)>("framebufferIntegerColorSampleCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageFormatListCreateInfo, VkImageFormatListCreateInfo);

struct VkImageFormatListCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageFormatListCreateInfo,true,true> {
    VkImageFormatListCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatListCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(viewFormatCount)>("viewFormatCount");
        addField<DAS_BIND_MANAGED_FIELD(pViewFormats)>("pViewFormats");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentDescription2, VkAttachmentDescription2);

struct VkAttachmentDescription2Annotation
: public ManagedStructureAnnotation<VkAttachmentDescription2,true,true> {
    VkAttachmentDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(format)>("format");
        addField<DAS_BIND_MANAGED_FIELD(samples)>("samples");
        addField<DAS_BIND_MANAGED_FIELD(loadOp)>("loadOp");
        addField<DAS_BIND_MANAGED_FIELD(storeOp)>("storeOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilLoadOp)>("stencilLoadOp");
        addField<DAS_BIND_MANAGED_FIELD(stencilStoreOp)>("stencilStoreOp");
        addField<DAS_BIND_MANAGED_FIELD(initialLayout)>("initialLayout");
        addField<DAS_BIND_MANAGED_FIELD(finalLayout)>("finalLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAttachmentReference2, VkAttachmentReference2);

struct VkAttachmentReference2Annotation
: public ManagedStructureAnnotation<VkAttachmentReference2,true,true> {
    VkAttachmentReference2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAttachmentReference2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(attachment)>("attachment");
        addField<DAS_BIND_MANAGED_FIELD(layout)>("layout");
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescription2, VkSubpassDescription2);

struct VkSubpassDescription2Annotation
: public ManagedStructureAnnotation<VkSubpassDescription2,true,true> {
    VkSubpassDescription2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescription2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pipelineBindPoint)>("pipelineBindPoint");
        addField<DAS_BIND_MANAGED_FIELD(viewMask)>("viewMask");
        addField<DAS_BIND_MANAGED_FIELD(inputAttachmentCount)>("inputAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pInputAttachments)>("pInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(colorAttachmentCount)>("colorAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pColorAttachments)>("pColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pResolveAttachments)>("pResolveAttachments");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilAttachment)>("pDepthStencilAttachment");
        addField<DAS_BIND_MANAGED_FIELD(preserveAttachmentCount)>("preserveAttachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pPreserveAttachments)>("pPreserveAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDependency2, VkSubpassDependency2);

struct VkSubpassDependency2Annotation
: public ManagedStructureAnnotation<VkSubpassDependency2,true,true> {
    VkSubpassDependency2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDependency2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcSubpass)>("srcSubpass");
        addField<DAS_BIND_MANAGED_FIELD(dstSubpass)>("dstSubpass");
        addField<DAS_BIND_MANAGED_FIELD(srcStageMask)>("srcStageMask");
        addField<DAS_BIND_MANAGED_FIELD(dstStageMask)>("dstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dependencyFlags)>("dependencyFlags");
        addField<DAS_BIND_MANAGED_FIELD(viewOffset)>("viewOffset");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRenderPassCreateInfo2, VkRenderPassCreateInfo2);

struct VkRenderPassCreateInfo2Annotation
: public ManagedStructureAnnotation<VkRenderPassCreateInfo2,true,true> {
    VkRenderPassCreateInfo2Annotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRenderPassCreateInfo2", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(attachmentCount)>("attachmentCount");
        addField<DAS_BIND_MANAGED_FIELD(pAttachments)>("pAttachments");
        addField<DAS_BIND_MANAGED_FIELD(subpassCount)>("subpassCount");
        addField<DAS_BIND_MANAGED_FIELD(pSubpasses)>("pSubpasses");
        addField<DAS_BIND_MANAGED_FIELD(dependencyCount)>("dependencyCount");
        addField<DAS_BIND_MANAGED_FIELD(pDependencies)>("pDependencies");
        addField<DAS_BIND_MANAGED_FIELD(correlatedViewMaskCount)>("correlatedViewMaskCount");
        addField<DAS_BIND_MANAGED_FIELD(pCorrelatedViewMasks)>("pCorrelatedViewMasks");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassBeginInfo, VkSubpassBeginInfo);

struct VkSubpassBeginInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassBeginInfo,true,true> {
    VkSubpassBeginInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassBeginInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(contents)>("contents");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassEndInfo, VkSubpassEndInfo);

struct VkSubpassEndInfoAnnotation
: public ManagedStructureAnnotation<VkSubpassEndInfo,true,true> {
    VkSubpassEndInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassEndInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDevice8BitStorageFeatures, VkPhysicalDevice8BitStorageFeatures);

struct VkPhysicalDevice8BitStorageFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDevice8BitStorageFeatures,true,true> {
    VkPhysicalDevice8BitStorageFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDevice8BitStorageFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(storageBuffer8BitAccess)>("storageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(uniformAndStorageBuffer8BitAccess)>("uniformAndStorageBuffer8BitAccess");
        addField<DAS_BIND_MANAGED_FIELD(storagePushConstant8)>("storagePushConstant8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDriverProperties);

struct VkPhysicalDeviceDriverPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDriverProperties,true,true> {
    VkPhysicalDeviceDriverPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDriverProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(driverID)>("driverID");
        addField<DAS_BIND_MANAGED_FIELD(driverName)>("driverName");
        addField<DAS_BIND_MANAGED_FIELD(driverInfo)>("driverInfo");
        addField<DAS_BIND_MANAGED_FIELD(conformanceVersion)>("conformanceVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderAtomicInt64Features);

struct VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderAtomicInt64Features,true,true> {
    VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderAtomicInt64Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderBufferInt64Atomics)>("shaderBufferInt64Atomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderSharedInt64Atomics)>("shaderSharedInt64Atomics");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderFloat16Int8Features);

struct VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceShaderFloat16Int8Features,true,true> {
    VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceShaderFloat16Int8Features", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat16)>("shaderFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt8)>("shaderInt8");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFloatControlsProperties);

struct VkPhysicalDeviceFloatControlsPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFloatControlsProperties,true,true> {
    VkPhysicalDeviceFloatControlsPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFloatControlsProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(denormBehaviorIndependence)>("denormBehaviorIndependence");
        addField<DAS_BIND_MANAGED_FIELD(roundingModeIndependence)>("roundingModeIndependence");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat16)>("shaderSignedZeroInfNanPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat32)>("shaderSignedZeroInfNanPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderSignedZeroInfNanPreserveFloat64)>("shaderSignedZeroInfNanPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat16)>("shaderDenormPreserveFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat32)>("shaderDenormPreserveFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormPreserveFloat64)>("shaderDenormPreserveFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat16)>("shaderDenormFlushToZeroFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat32)>("shaderDenormFlushToZeroFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderDenormFlushToZeroFloat64)>("shaderDenormFlushToZeroFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat16)>("shaderRoundingModeRTEFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat32)>("shaderRoundingModeRTEFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTEFloat64)>("shaderRoundingModeRTEFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat16)>("shaderRoundingModeRTZFloat16");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat32)>("shaderRoundingModeRTZFloat32");
        addField<DAS_BIND_MANAGED_FIELD(shaderRoundingModeRTZFloat64)>("shaderRoundingModeRTZFloat64");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetLayoutBindingFlagsCreateInfo, VkDescriptorSetLayoutBindingFlagsCreateInfo);

struct VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetLayoutBindingFlagsCreateInfo,true,true> {
    VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetLayoutBindingFlagsCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(bindingCount)>("bindingCount");
        addField<DAS_BIND_MANAGED_FIELD(pBindingFlags)>("pBindingFlags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorIndexingFeatures);

struct VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingFeatures,true,true> {
    VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayDynamicIndexing)>("shaderInputAttachmentArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayDynamicIndexing)>("shaderUniformTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayDynamicIndexing)>("shaderStorageTexelBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexing)>("shaderUniformBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexing)>("shaderSampledImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexing)>("shaderStorageBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexing)>("shaderStorageImageArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexing)>("shaderInputAttachmentArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformTexelBufferArrayNonUniformIndexing)>("shaderUniformTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageTexelBufferArrayNonUniformIndexing)>("shaderStorageTexelBufferArrayNonUniformIndexing");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformBufferUpdateAfterBind)>("descriptorBindingUniformBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingSampledImageUpdateAfterBind)>("descriptorBindingSampledImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageImageUpdateAfterBind)>("descriptorBindingStorageImageUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageBufferUpdateAfterBind)>("descriptorBindingStorageBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUniformTexelBufferUpdateAfterBind)>("descriptorBindingUniformTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingStorageTexelBufferUpdateAfterBind)>("descriptorBindingStorageTexelBufferUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingUpdateUnusedWhilePending)>("descriptorBindingUpdateUnusedWhilePending");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingPartiallyBound)>("descriptorBindingPartiallyBound");
        addField<DAS_BIND_MANAGED_FIELD(descriptorBindingVariableDescriptorCount)>("descriptorBindingVariableDescriptorCount");
        addField<DAS_BIND_MANAGED_FIELD(runtimeDescriptorArray)>("runtimeDescriptorArray");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDescriptorIndexingProperties);

struct VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDescriptorIndexingProperties,true,true> {
    VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDescriptorIndexingProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxUpdateAfterBindDescriptorsInAllPools)>("maxUpdateAfterBindDescriptorsInAllPools");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayNonUniformIndexingNative)>("shaderUniformBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayNonUniformIndexingNative)>("shaderSampledImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayNonUniformIndexingNative)>("shaderStorageBufferArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayNonUniformIndexingNative)>("shaderStorageImageArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(shaderInputAttachmentArrayNonUniformIndexingNative)>("shaderInputAttachmentArrayNonUniformIndexingNative");
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccessUpdateAfterBind)>("robustBufferAccessUpdateAfterBind");
        addField<DAS_BIND_MANAGED_FIELD(quadDivergentImplicitLod)>("quadDivergentImplicitLod");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSamplers)>("maxPerStageDescriptorUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindUniformBuffers)>("maxPerStageDescriptorUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageBuffers)>("maxPerStageDescriptorUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindSampledImages)>("maxPerStageDescriptorUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindStorageImages)>("maxPerStageDescriptorUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUpdateAfterBindInputAttachments)>("maxPerStageDescriptorUpdateAfterBindInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageUpdateAfterBindResources)>("maxPerStageUpdateAfterBindResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSamplers)>("maxDescriptorSetUpdateAfterBindSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffers)>("maxDescriptorSetUpdateAfterBindUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)>("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffers)>("maxDescriptorSetUpdateAfterBindStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)>("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindSampledImages)>("maxDescriptorSetUpdateAfterBindSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindStorageImages)>("maxDescriptorSetUpdateAfterBindStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUpdateAfterBindInputAttachments)>("maxDescriptorSetUpdateAfterBindInputAttachments");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountAllocateInfo, VkDescriptorSetVariableDescriptorCountAllocateInfo);

struct VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountAllocateInfo,true,true> {
    VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(descriptorSetCount)>("descriptorSetCount");
        addField<DAS_BIND_MANAGED_FIELD(pDescriptorCounts)>("pDescriptorCounts");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDescriptorSetVariableDescriptorCountLayoutSupport, VkDescriptorSetVariableDescriptorCountLayoutSupport);

struct VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation
: public ManagedStructureAnnotation<VkDescriptorSetVariableDescriptorCountLayoutSupport,true,true> {
    VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDescriptorSetVariableDescriptorCountLayoutSupport", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(maxVariableDescriptorCount)>("maxVariableDescriptorCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubpassDescriptionDepthStencilResolve, VkSubpassDescriptionDepthStencilResolve);

struct VkSubpassDescriptionDepthStencilResolveAnnotation
: public ManagedStructureAnnotation<VkSubpassDescriptionDepthStencilResolve,true,true> {
    VkSubpassDescriptionDepthStencilResolveAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubpassDescriptionDepthStencilResolve", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(depthResolveMode)>("depthResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(stencilResolveMode)>("stencilResolveMode");
        addField<DAS_BIND_MANAGED_FIELD(pDepthStencilResolveAttachment)>("pDepthStencilResolveAttachment");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDepthStencilResolveProperties);

struct VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceDepthStencilResolveProperties,true,true> {
    VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceDepthStencilResolveProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(supportedDepthResolveModes)>("supportedDepthResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(supportedStencilResolveModes)>("supportedStencilResolveModes");
        addField<DAS_BIND_MANAGED_FIELD(independentResolveNone)>("independentResolveNone");
        addField<DAS_BIND_MANAGED_FIELD(independentResolve)>("independentResolve");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures);

struct VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceScalarBlockLayoutFeatures,true,true> {
    VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceScalarBlockLayoutFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(scalarBlockLayout)>("scalarBlockLayout");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageStencilUsageCreateInfo, VkImageStencilUsageCreateInfo);

struct VkImageStencilUsageCreateInfoAnnotation
: public ManagedStructureAnnotation<VkImageStencilUsageCreateInfo,true,true> {
    VkImageStencilUsageCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageStencilUsageCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(stencilUsage)>("stencilUsage");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSamplerReductionModeCreateInfo, VkSamplerReductionModeCreateInfo);

struct VkSamplerReductionModeCreateInfoAnnotation
: public ManagedStructureAnnotation<VkSamplerReductionModeCreateInfo,true,true> {
    VkSamplerReductionModeCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSamplerReductionModeCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(reductionMode)>("reductionMode");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_5(Module & module, ModuleLibrary & lib) {{

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkImageViewCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkShaderModuleCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCacheCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkColorComponentFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkPipelineShaderStageCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkShaderStageFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkCullModeFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkSamplerCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkDescriptorPoolCreateFlagBits>());
    module.addEnumeration(make_smart<EnumerationVkDescriptorSetLayoutCreateFlagBits>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkImageView>>("VkImageView", "VkImageView"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkShaderModule>>("VkShaderModule", "VkShaderModule"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkPipelineCache>>("VkPipelineCache", "VkPipelineCache"));

    //
    // structs
    //

    addAnnotation(make_smart<VkExportFenceCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkExportSemaphoreCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceExternalSemaphoreInfoAnnotation>(lib));
    addAnnotation(make_smart<VkExternalSemaphorePropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceMaintenance3PropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkDescriptorSetLayoutSupportAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderDrawParametersFeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVulkan11FeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVulkan11PropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVulkan12FeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkConformanceVersionAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceVulkan12PropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkImageFormatListCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkAttachmentDescription2Annotation>(lib));
    addAnnotation(make_smart<VkAttachmentReference2Annotation>(lib));
    addAnnotation(make_smart<VkSubpassDescription2Annotation>(lib));
    addAnnotation(make_smart<VkSubpassDependency2Annotation>(lib));
    addAnnotation(make_smart<VkRenderPassCreateInfo2Annotation>(lib));
    addAnnotation(make_smart<VkSubpassBeginInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSubpassEndInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDevice8BitStorageFeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceDriverPropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderAtomicInt64FeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceShaderFloat16Int8FeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceFloatControlsPropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkDescriptorSetLayoutBindingFlagsCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingFeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceDescriptorIndexingPropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountAllocateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkDescriptorSetVariableDescriptorCountLayoutSupportAnnotation>(lib));
    addAnnotation(make_smart<VkSubpassDescriptionDepthStencilResolveAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceDepthStencilResolvePropertiesAnnotation>(lib));
    addAnnotation(make_smart<VkPhysicalDeviceScalarBlockLayoutFeaturesAnnotation>(lib));
    addAnnotation(make_smart<VkImageStencilUsageCreateInfoAnnotation>(lib));
    addAnnotation(make_smart<VkSamplerReductionModeCreateInfoAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkBeginCommandBuffer)>(*this, lib, "vkBeginCommandBuffer",
        SideEffects::worstDefault, "vkBeginCommandBuffer");
    addExtern<DAS_BIND_FUN(vkEndCommandBuffer)>(*this, lib, "vkEndCommandBuffer",
        SideEffects::worstDefault, "vkEndCommandBuffer");
    addExtern<DAS_BIND_FUN(vkResetCommandBuffer)>(*this, lib, "vkResetCommandBuffer",
        SideEffects::worstDefault, "vkResetCommandBuffer");
    addExtern<DAS_BIND_FUN(vkCmdBindPipeline)>(*this, lib, "vkCmdBindPipeline",
        SideEffects::worstDefault, "vkCmdBindPipeline");
    addExtern<DAS_BIND_FUN(vkCmdSetViewport)>(*this, lib, "vkCmdSetViewport",
        SideEffects::worstDefault, "vkCmdSetViewport");
    addExtern<DAS_BIND_FUN(vkCmdSetScissor)>(*this, lib, "vkCmdSetScissor",
        SideEffects::worstDefault, "vkCmdSetScissor");
    addExtern<DAS_BIND_FUN(vkCmdSetLineWidth)>(*this, lib, "vkCmdSetLineWidth",
        SideEffects::worstDefault, "vkCmdSetLineWidth");
    addExtern<DAS_BIND_FUN(vkCmdSetDepthBias)>(*this, lib, "vkCmdSetDepthBias",
        SideEffects::worstDefault, "vkCmdSetDepthBias");
    addExtern<DAS_BIND_FUN(vkCmdSetBlendConstants)>(*this, lib, "vkCmdSetBlendConstants",
        SideEffects::worstDefault, "vkCmdSetBlendConstants");
    addExtern<DAS_BIND_FUN(vkCmdSetDepthBounds)>(*this, lib, "vkCmdSetDepthBounds",
        SideEffects::worstDefault, "vkCmdSetDepthBounds");
    addExtern<DAS_BIND_FUN(vkCmdSetStencilCompareMask)>(*this, lib, "vkCmdSetStencilCompareMask",
        SideEffects::worstDefault, "vkCmdSetStencilCompareMask");
    addExtern<DAS_BIND_FUN(vkCmdSetStencilWriteMask)>(*this, lib, "vkCmdSetStencilWriteMask",
        SideEffects::worstDefault, "vkCmdSetStencilWriteMask");
    addExtern<DAS_BIND_FUN(vkCmdSetStencilReference)>(*this, lib, "vkCmdSetStencilReference",
        SideEffects::worstDefault, "vkCmdSetStencilReference");
    addExtern<DAS_BIND_FUN(vkCmdBindDescriptorSets)>(*this, lib, "vkCmdBindDescriptorSets",
        SideEffects::worstDefault, "vkCmdBindDescriptorSets");
    addExtern<DAS_BIND_FUN(vkCmdBindIndexBuffer)>(*this, lib, "vkCmdBindIndexBuffer",
        SideEffects::worstDefault, "vkCmdBindIndexBuffer");
    addExtern<DAS_BIND_FUN(vkCmdBindVertexBuffers)>(*this, lib, "vkCmdBindVertexBuffers",
        SideEffects::worstDefault, "vkCmdBindVertexBuffers");
    addExtern<DAS_BIND_FUN(vkCmdDraw)>(*this, lib, "vkCmdDraw",
        SideEffects::worstDefault, "vkCmdDraw");

    //
    // macro constants
    //

    addConstant(*this,"GLFW_BLUE_BITS",0x00021003);
    addConstant(*this,"GLFW_ALPHA_BITS",0x00021004);
    addConstant(*this,"GLFW_DEPTH_BITS",0x00021005);
    addConstant(*this,"GLFW_STENCIL_BITS",0x00021006);
    addConstant(*this,"GLFW_ACCUM_RED_BITS",0x00021007);
    addConstant(*this,"GLFW_ACCUM_GREEN_BITS",0x00021008);
    addConstant(*this,"GLFW_ACCUM_BLUE_BITS",0x00021009);
    addConstant(*this,"GLFW_ACCUM_ALPHA_BITS",0x0002100A);
    addConstant(*this,"GLFW_AUX_BUFFERS",0x0002100B);
    addConstant(*this,"GLFW_STEREO",0x0002100C);
    addConstant(*this,"GLFW_SAMPLES",0x0002100D);
    addConstant(*this,"GLFW_SRGB_CAPABLE",0x0002100E);
    addConstant(*this,"GLFW_REFRESH_RATE",0x0002100F);
    addConstant(*this,"GLFW_DOUBLEBUFFER",0x00021010);
    addConstant(*this,"GLFW_CLIENT_API",0x00022001);
    addConstant(*this,"GLFW_CONTEXT_VERSION_MAJOR",0x00022002);
    addConstant(*this,"GLFW_CONTEXT_VERSION_MINOR",0x00022003);
    addConstant(*this,"GLFW_CONTEXT_REVISION",0x00022004);
    addConstant(*this,"GLFW_CONTEXT_ROBUSTNESS",0x00022005);
    addConstant(*this,"GLFW_OPENGL_FORWARD_COMPAT",0x00022006);
    addConstant(*this,"GLFW_OPENGL_DEBUG_CONTEXT",0x00022007);
    addConstant(*this,"GLFW_OPENGL_PROFILE",0x00022008);
    addConstant(*this,"GLFW_CONTEXT_RELEASE_BEHAVIOR",0x00022009);
    addConstant(*this,"GLFW_CONTEXT_NO_ERROR",0x0002200A);
    addConstant(*this,"GLFW_CONTEXT_CREATION_API",0x0002200B);
    addConstant(*this,"GLFW_SCALE_TO_MONITOR",0x0002200C);
    addConstant(*this,"GLFW_COCOA_RETINA_FRAMEBUFFER",0x00023001);
    addConstant(*this,"GLFW_COCOA_FRAME_NAME",0x00023002);
    addConstant(*this,"GLFW_COCOA_GRAPHICS_SWITCHING",0x00023003);
    addConstant(*this,"GLFW_X11_CLASS_NAME",0x00024001);
    addConstant(*this,"GLFW_X11_INSTANCE_NAME",0x00024002);
    addConstant(*this,"GLFW_NO_API",0);
    addConstant(*this,"GLFW_OPENGL_API",0x00030001);
    addConstant(*this,"GLFW_OPENGL_ES_API",0x00030002);
    addConstant(*this,"GLFW_NO_ROBUSTNESS",0);
    addConstant(*this,"GLFW_NO_RESET_NOTIFICATION",0x00031001);
    addConstant(*this,"GLFW_LOSE_CONTEXT_ON_RESET",0x00031002);
    addConstant(*this,"GLFW_OPENGL_ANY_PROFILE",0);
    addConstant(*this,"GLFW_OPENGL_CORE_PROFILE",0x00032001);
    addConstant(*this,"GLFW_OPENGL_COMPAT_PROFILE",0x00032002);
    addConstant(*this,"GLFW_CURSOR",0x00033001);
    addConstant(*this,"GLFW_STICKY_KEYS",0x00033002);
    addConstant(*this,"GLFW_STICKY_MOUSE_BUTTONS",0x00033003);
    addConstant(*this,"GLFW_LOCK_KEY_MODS",0x00033004);
    addConstant(*this,"GLFW_RAW_MOUSE_MOTION",0x00033005);
};
