// generated by dasVulkan for GLFW 3.3.2 and Vulkan 1.2.162
#include "..\include\dasVulkan\module.h"

using namespace das;

//
// opaque structs
//

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBuffer, VkBuffer)
IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImage, VkImage)

//
// structs
//


IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtent2D, VkExtent2D);

struct VkExtent2DAnnotation
: public ManagedStructureAnnotation<VkExtent2D,true,true> {
    VkExtent2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtent3D, VkExtent3D);

struct VkExtent3DAnnotation
: public ManagedStructureAnnotation<VkExtent3D,true,true> {
    VkExtent3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtent3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(width)>("width");
        addField<DAS_BIND_MANAGED_FIELD(height)>("height");
        addField<DAS_BIND_MANAGED_FIELD(depth)>("depth");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkOffset2D, VkOffset2D);

struct VkOffset2DAnnotation
: public ManagedStructureAnnotation<VkOffset2D,true,true> {
    VkOffset2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkOffset3D, VkOffset3D);

struct VkOffset3DAnnotation
: public ManagedStructureAnnotation<VkOffset3D,true,true> {
    VkOffset3DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkOffset3D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkRect2D, VkRect2D);

struct VkRect2DAnnotation
: public ManagedStructureAnnotation<VkRect2D,true,true> {
    VkRect2DAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkRect2D", ml) {
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(extent)>("extent");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBaseInStructure, VkBaseInStructure);

struct VkBaseInStructureAnnotation
: public ManagedStructureAnnotation<VkBaseInStructure,true,true> {
    VkBaseInStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseInStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBaseOutStructure, VkBaseOutStructure);

struct VkBaseOutStructureAnnotation
: public ManagedStructureAnnotation<VkBaseOutStructure,true,true> {
    VkBaseOutStructureAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBaseOutStructure", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
    }
    void init() {
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkBufferMemoryBarrier, VkBufferMemoryBarrier);

struct VkBufferMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkBufferMemoryBarrier,true,true> {
    VkBufferMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkBufferMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(buffer)>("buffer");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDispatchIndirectCommand, VkDispatchIndirectCommand);

struct VkDispatchIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDispatchIndirectCommand,true,true> {
    VkDispatchIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDispatchIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(x)>("x");
        addField<DAS_BIND_MANAGED_FIELD(y)>("y");
        addField<DAS_BIND_MANAGED_FIELD(z)>("z");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawIndexedIndirectCommand, VkDrawIndexedIndirectCommand);

struct VkDrawIndexedIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndexedIndirectCommand,true,true> {
    VkDrawIndexedIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndexedIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(indexCount)>("indexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstIndex)>("firstIndex");
        addField<DAS_BIND_MANAGED_FIELD(vertexOffset)>("vertexOffset");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDrawIndirectCommand, VkDrawIndirectCommand);

struct VkDrawIndirectCommandAnnotation
: public ManagedStructureAnnotation<VkDrawIndirectCommand,true,true> {
    VkDrawIndirectCommandAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDrawIndirectCommand", ml) {
        addField<DAS_BIND_MANAGED_FIELD(vertexCount)>("vertexCount");
        addField<DAS_BIND_MANAGED_FIELD(instanceCount)>("instanceCount");
        addField<DAS_BIND_MANAGED_FIELD(firstVertex)>("firstVertex");
        addField<DAS_BIND_MANAGED_FIELD(firstInstance)>("firstInstance");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageSubresourceRange, VkImageSubresourceRange);

struct VkImageSubresourceRangeAnnotation
: public ManagedStructureAnnotation<VkImageSubresourceRange,true,true> {
    VkImageSubresourceRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageSubresourceRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(aspectMask)>("aspectMask");
        addField<DAS_BIND_MANAGED_FIELD(baseMipLevel)>("baseMipLevel");
        addField<DAS_BIND_MANAGED_FIELD(levelCount)>("levelCount");
        addField<DAS_BIND_MANAGED_FIELD(baseArrayLayer)>("baseArrayLayer");
        addField<DAS_BIND_MANAGED_FIELD(layerCount)>("layerCount");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageMemoryBarrier, VkImageMemoryBarrier);

struct VkImageMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkImageMemoryBarrier,true,true> {
    VkImageMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(oldLayout)>("oldLayout");
        addField<DAS_BIND_MANAGED_FIELD(newLayout)>("newLayout");
        addField<DAS_BIND_MANAGED_FIELD(srcQueueFamilyIndex)>("srcQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(dstQueueFamilyIndex)>("dstQueueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(image)>("image");
        addField<DAS_BIND_MANAGED_FIELD(subresourceRange)>("subresourceRange");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryBarrier, VkMemoryBarrier);

struct VkMemoryBarrierAnnotation
: public ManagedStructureAnnotation<VkMemoryBarrier,true,true> {
    VkMemoryBarrierAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryBarrier", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(srcAccessMask)>("srcAccessMask");
        addField<DAS_BIND_MANAGED_FIELD(dstAccessMask)>("dstAccessMask");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkAllocationCallbacks, VkAllocationCallbacks);

struct VkAllocationCallbacksAnnotation
: public ManagedStructureAnnotation<VkAllocationCallbacks,true,true> {
    VkAllocationCallbacksAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkAllocationCallbacks", ml) {
        addField<DAS_BIND_MANAGED_FIELD(pUserData)>("pUserData");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkApplicationInfo, VkApplicationInfo);

struct VkApplicationInfoAnnotation
: public ManagedStructureAnnotation<VkApplicationInfo,true,true> {
    VkApplicationInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkApplicationInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationName)>("pApplicationName");
        addField<DAS_BIND_MANAGED_FIELD(applicationVersion)>("applicationVersion");
        addField<DAS_BIND_MANAGED_FIELD(pEngineName)>("pEngineName");
        addField<DAS_BIND_MANAGED_FIELD(engineVersion)>("engineVersion");
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkFormatProperties, VkFormatProperties);

struct VkFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkFormatProperties,true,true> {
    VkFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(linearTilingFeatures)>("linearTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(optimalTilingFeatures)>("optimalTilingFeatures");
        addField<DAS_BIND_MANAGED_FIELD(bufferFeatures)>("bufferFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkImageFormatProperties, VkImageFormatProperties);

struct VkImageFormatPropertiesAnnotation
: public ManagedStructureAnnotation<VkImageFormatProperties,true,true> {
    VkImageFormatPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkImageFormatProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxExtent)>("maxExtent");
        addField<DAS_BIND_MANAGED_FIELD(maxMipLevels)>("maxMipLevels");
        addField<DAS_BIND_MANAGED_FIELD(maxArrayLayers)>("maxArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(sampleCounts)>("sampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxResourceSize)>("maxResourceSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkInstanceCreateInfo, VkInstanceCreateInfo);

struct VkInstanceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkInstanceCreateInfo,true,true> {
    VkInstanceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkInstanceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(pApplicationInfo)>("pApplicationInfo");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryHeap, VkMemoryHeap);

struct VkMemoryHeapAnnotation
: public ManagedStructureAnnotation<VkMemoryHeap,true,true> {
    VkMemoryHeapAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryHeap", ml) {
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryType, VkMemoryType);

struct VkMemoryTypeAnnotation
: public ManagedStructureAnnotation<VkMemoryType,true,true> {
    VkMemoryTypeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryType", ml) {
        addField<DAS_BIND_MANAGED_FIELD(propertyFlags)>("propertyFlags");
        addField<DAS_BIND_MANAGED_FIELD(heapIndex)>("heapIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceFeatures, VkPhysicalDeviceFeatures);

struct VkPhysicalDeviceFeaturesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceFeatures,true,true> {
    VkPhysicalDeviceFeaturesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceFeatures", ml) {
        addField<DAS_BIND_MANAGED_FIELD(robustBufferAccess)>("robustBufferAccess");
        addField<DAS_BIND_MANAGED_FIELD(fullDrawIndexUint32)>("fullDrawIndexUint32");
        addField<DAS_BIND_MANAGED_FIELD(imageCubeArray)>("imageCubeArray");
        addField<DAS_BIND_MANAGED_FIELD(independentBlend)>("independentBlend");
        addField<DAS_BIND_MANAGED_FIELD(geometryShader)>("geometryShader");
        addField<DAS_BIND_MANAGED_FIELD(tessellationShader)>("tessellationShader");
        addField<DAS_BIND_MANAGED_FIELD(sampleRateShading)>("sampleRateShading");
        addField<DAS_BIND_MANAGED_FIELD(dualSrcBlend)>("dualSrcBlend");
        addField<DAS_BIND_MANAGED_FIELD(logicOp)>("logicOp");
        addField<DAS_BIND_MANAGED_FIELD(multiDrawIndirect)>("multiDrawIndirect");
        addField<DAS_BIND_MANAGED_FIELD(drawIndirectFirstInstance)>("drawIndirectFirstInstance");
        addField<DAS_BIND_MANAGED_FIELD(depthClamp)>("depthClamp");
        addField<DAS_BIND_MANAGED_FIELD(depthBiasClamp)>("depthBiasClamp");
        addField<DAS_BIND_MANAGED_FIELD(fillModeNonSolid)>("fillModeNonSolid");
        addField<DAS_BIND_MANAGED_FIELD(depthBounds)>("depthBounds");
        addField<DAS_BIND_MANAGED_FIELD(wideLines)>("wideLines");
        addField<DAS_BIND_MANAGED_FIELD(largePoints)>("largePoints");
        addField<DAS_BIND_MANAGED_FIELD(alphaToOne)>("alphaToOne");
        addField<DAS_BIND_MANAGED_FIELD(multiViewport)>("multiViewport");
        addField<DAS_BIND_MANAGED_FIELD(samplerAnisotropy)>("samplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionETC2)>("textureCompressionETC2");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionASTC_LDR)>("textureCompressionASTC_LDR");
        addField<DAS_BIND_MANAGED_FIELD(textureCompressionBC)>("textureCompressionBC");
        addField<DAS_BIND_MANAGED_FIELD(occlusionQueryPrecise)>("occlusionQueryPrecise");
        addField<DAS_BIND_MANAGED_FIELD(pipelineStatisticsQuery)>("pipelineStatisticsQuery");
        addField<DAS_BIND_MANAGED_FIELD(vertexPipelineStoresAndAtomics)>("vertexPipelineStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(fragmentStoresAndAtomics)>("fragmentStoresAndAtomics");
        addField<DAS_BIND_MANAGED_FIELD(shaderTessellationAndGeometryPointSize)>("shaderTessellationAndGeometryPointSize");
        addField<DAS_BIND_MANAGED_FIELD(shaderImageGatherExtended)>("shaderImageGatherExtended");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageExtendedFormats)>("shaderStorageImageExtendedFormats");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageMultisample)>("shaderStorageImageMultisample");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageReadWithoutFormat)>("shaderStorageImageReadWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageWriteWithoutFormat)>("shaderStorageImageWriteWithoutFormat");
        addField<DAS_BIND_MANAGED_FIELD(shaderUniformBufferArrayDynamicIndexing)>("shaderUniformBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderSampledImageArrayDynamicIndexing)>("shaderSampledImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageBufferArrayDynamicIndexing)>("shaderStorageBufferArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderStorageImageArrayDynamicIndexing)>("shaderStorageImageArrayDynamicIndexing");
        addField<DAS_BIND_MANAGED_FIELD(shaderClipDistance)>("shaderClipDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderCullDistance)>("shaderCullDistance");
        addField<DAS_BIND_MANAGED_FIELD(shaderFloat64)>("shaderFloat64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt64)>("shaderInt64");
        addField<DAS_BIND_MANAGED_FIELD(shaderInt16)>("shaderInt16");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceResidency)>("shaderResourceResidency");
        addField<DAS_BIND_MANAGED_FIELD(shaderResourceMinLod)>("shaderResourceMinLod");
        addField<DAS_BIND_MANAGED_FIELD(sparseBinding)>("sparseBinding");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyBuffer)>("sparseResidencyBuffer");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage2D)>("sparseResidencyImage2D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyImage3D)>("sparseResidencyImage3D");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency2Samples)>("sparseResidency2Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency4Samples)>("sparseResidency4Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency8Samples)>("sparseResidency8Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidency16Samples)>("sparseResidency16Samples");
        addField<DAS_BIND_MANAGED_FIELD(sparseResidencyAliased)>("sparseResidencyAliased");
        addField<DAS_BIND_MANAGED_FIELD(variableMultisampleRate)>("variableMultisampleRate");
        addField<DAS_BIND_MANAGED_FIELD(inheritedQueries)>("inheritedQueries");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceLimits, VkPhysicalDeviceLimits);

struct VkPhysicalDeviceLimitsAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceLimits,true,true> {
    VkPhysicalDeviceLimitsAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceLimits", ml) {
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension1D)>("maxImageDimension1D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension2D)>("maxImageDimension2D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimension3D)>("maxImageDimension3D");
        addField<DAS_BIND_MANAGED_FIELD(maxImageDimensionCube)>("maxImageDimensionCube");
        addField<DAS_BIND_MANAGED_FIELD(maxImageArrayLayers)>("maxImageArrayLayers");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelBufferElements)>("maxTexelBufferElements");
        addField<DAS_BIND_MANAGED_FIELD(maxUniformBufferRange)>("maxUniformBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxStorageBufferRange)>("maxStorageBufferRange");
        addField<DAS_BIND_MANAGED_FIELD(maxPushConstantsSize)>("maxPushConstantsSize");
        addField<DAS_BIND_MANAGED_FIELD(maxMemoryAllocationCount)>("maxMemoryAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAllocationCount)>("maxSamplerAllocationCount");
        addField<DAS_BIND_MANAGED_FIELD(bufferImageGranularity)>("bufferImageGranularity");
        addField<DAS_BIND_MANAGED_FIELD(sparseAddressSpaceSize)>("sparseAddressSpaceSize");
        addField<DAS_BIND_MANAGED_FIELD(maxBoundDescriptorSets)>("maxBoundDescriptorSets");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSamplers)>("maxPerStageDescriptorSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorUniformBuffers)>("maxPerStageDescriptorUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageBuffers)>("maxPerStageDescriptorStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorSampledImages)>("maxPerStageDescriptorSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorStorageImages)>("maxPerStageDescriptorStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageDescriptorInputAttachments)>("maxPerStageDescriptorInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxPerStageResources)>("maxPerStageResources");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSamplers)>("maxDescriptorSetSamplers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffers)>("maxDescriptorSetUniformBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetUniformBuffersDynamic)>("maxDescriptorSetUniformBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffers)>("maxDescriptorSetStorageBuffers");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageBuffersDynamic)>("maxDescriptorSetStorageBuffersDynamic");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetSampledImages)>("maxDescriptorSetSampledImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetStorageImages)>("maxDescriptorSetStorageImages");
        addField<DAS_BIND_MANAGED_FIELD(maxDescriptorSetInputAttachments)>("maxDescriptorSetInputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributes)>("maxVertexInputAttributes");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindings)>("maxVertexInputBindings");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputAttributeOffset)>("maxVertexInputAttributeOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexInputBindingStride)>("maxVertexInputBindingStride");
        addField<DAS_BIND_MANAGED_FIELD(maxVertexOutputComponents)>("maxVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationGenerationLevel)>("maxTessellationGenerationLevel");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationPatchSize)>("maxTessellationPatchSize");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexInputComponents)>("maxTessellationControlPerVertexInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerVertexOutputComponents)>("maxTessellationControlPerVertexOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlPerPatchOutputComponents)>("maxTessellationControlPerPatchOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationControlTotalOutputComponents)>("maxTessellationControlTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationInputComponents)>("maxTessellationEvaluationInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxTessellationEvaluationOutputComponents)>("maxTessellationEvaluationOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryShaderInvocations)>("maxGeometryShaderInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryInputComponents)>("maxGeometryInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputComponents)>("maxGeometryOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryOutputVertices)>("maxGeometryOutputVertices");
        addField<DAS_BIND_MANAGED_FIELD(maxGeometryTotalOutputComponents)>("maxGeometryTotalOutputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentInputComponents)>("maxFragmentInputComponents");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentOutputAttachments)>("maxFragmentOutputAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentDualSrcAttachments)>("maxFragmentDualSrcAttachments");
        addField<DAS_BIND_MANAGED_FIELD(maxFragmentCombinedOutputResources)>("maxFragmentCombinedOutputResources");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeSharedMemorySize)>("maxComputeSharedMemorySize");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupCount)>("maxComputeWorkGroupCount");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupInvocations)>("maxComputeWorkGroupInvocations");
        addField<DAS_BIND_MANAGED_FIELD(maxComputeWorkGroupSize)>("maxComputeWorkGroupSize");
        addField<DAS_BIND_MANAGED_FIELD(subPixelPrecisionBits)>("subPixelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(subTexelPrecisionBits)>("subTexelPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(mipmapPrecisionBits)>("mipmapPrecisionBits");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndexedIndexValue)>("maxDrawIndexedIndexValue");
        addField<DAS_BIND_MANAGED_FIELD(maxDrawIndirectCount)>("maxDrawIndirectCount");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerLodBias)>("maxSamplerLodBias");
        addField<DAS_BIND_MANAGED_FIELD(maxSamplerAnisotropy)>("maxSamplerAnisotropy");
        addField<DAS_BIND_MANAGED_FIELD(maxViewports)>("maxViewports");
        addField<DAS_BIND_MANAGED_FIELD(maxViewportDimensions)>("maxViewportDimensions");
        addField<DAS_BIND_MANAGED_FIELD(viewportBoundsRange)>("viewportBoundsRange");
        addField<DAS_BIND_MANAGED_FIELD(viewportSubPixelBits)>("viewportSubPixelBits");
        addField<DAS_BIND_MANAGED_FIELD(minMemoryMapAlignment)>("minMemoryMapAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelBufferOffsetAlignment)>("minTexelBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minUniformBufferOffsetAlignment)>("minUniformBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minStorageBufferOffsetAlignment)>("minStorageBufferOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(minTexelOffset)>("minTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelOffset)>("maxTexelOffset");
        addField<DAS_BIND_MANAGED_FIELD(minTexelGatherOffset)>("minTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxTexelGatherOffset)>("maxTexelGatherOffset");
        addField<DAS_BIND_MANAGED_FIELD(minInterpolationOffset)>("minInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(maxInterpolationOffset)>("maxInterpolationOffset");
        addField<DAS_BIND_MANAGED_FIELD(subPixelInterpolationOffsetBits)>("subPixelInterpolationOffsetBits");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferWidth)>("maxFramebufferWidth");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferHeight)>("maxFramebufferHeight");
        addField<DAS_BIND_MANAGED_FIELD(maxFramebufferLayers)>("maxFramebufferLayers");
        addField<DAS_BIND_MANAGED_FIELD(framebufferColorSampleCounts)>("framebufferColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferDepthSampleCounts)>("framebufferDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferStencilSampleCounts)>("framebufferStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(framebufferNoAttachmentsSampleCounts)>("framebufferNoAttachmentsSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxColorAttachments)>("maxColorAttachments");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageColorSampleCounts)>("sampledImageColorSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageIntegerSampleCounts)>("sampledImageIntegerSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageDepthSampleCounts)>("sampledImageDepthSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(sampledImageStencilSampleCounts)>("sampledImageStencilSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(storageImageSampleCounts)>("storageImageSampleCounts");
        addField<DAS_BIND_MANAGED_FIELD(maxSampleMaskWords)>("maxSampleMaskWords");
        addField<DAS_BIND_MANAGED_FIELD(timestampComputeAndGraphics)>("timestampComputeAndGraphics");
        addField<DAS_BIND_MANAGED_FIELD(timestampPeriod)>("timestampPeriod");
        addField<DAS_BIND_MANAGED_FIELD(maxClipDistances)>("maxClipDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCullDistances)>("maxCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(maxCombinedClipAndCullDistances)>("maxCombinedClipAndCullDistances");
        addField<DAS_BIND_MANAGED_FIELD(discreteQueuePriorities)>("discreteQueuePriorities");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeRange)>("pointSizeRange");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthRange)>("lineWidthRange");
        addField<DAS_BIND_MANAGED_FIELD(pointSizeGranularity)>("pointSizeGranularity");
        addField<DAS_BIND_MANAGED_FIELD(lineWidthGranularity)>("lineWidthGranularity");
        addField<DAS_BIND_MANAGED_FIELD(strictLines)>("strictLines");
        addField<DAS_BIND_MANAGED_FIELD(standardSampleLocations)>("standardSampleLocations");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyOffsetAlignment)>("optimalBufferCopyOffsetAlignment");
        addField<DAS_BIND_MANAGED_FIELD(optimalBufferCopyRowPitchAlignment)>("optimalBufferCopyRowPitchAlignment");
        addField<DAS_BIND_MANAGED_FIELD(nonCoherentAtomSize)>("nonCoherentAtomSize");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceMemoryProperties, VkPhysicalDeviceMemoryProperties);

struct VkPhysicalDeviceMemoryPropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceMemoryProperties,true,true> {
    VkPhysicalDeviceMemoryPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceMemoryProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeCount)>("memoryTypeCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypes)>("memoryTypes");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeapCount)>("memoryHeapCount");
        addField<DAS_BIND_MANAGED_FIELD(memoryHeaps)>("memoryHeaps");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceSparseProperties, VkPhysicalDeviceSparseProperties);

struct VkPhysicalDeviceSparsePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceSparseProperties,true,true> {
    VkPhysicalDeviceSparsePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceSparseProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DBlockShape)>("residencyStandard2DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard2DMultisampleBlockShape)>("residencyStandard2DMultisampleBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyStandard3DBlockShape)>("residencyStandard3DBlockShape");
        addField<DAS_BIND_MANAGED_FIELD(residencyAlignedMipSize)>("residencyAlignedMipSize");
        addField<DAS_BIND_MANAGED_FIELD(residencyNonResidentStrict)>("residencyNonResidentStrict");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkPhysicalDeviceProperties, VkPhysicalDeviceProperties);

struct VkPhysicalDevicePropertiesAnnotation
: public ManagedStructureAnnotation<VkPhysicalDeviceProperties,true,true> {
    VkPhysicalDevicePropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkPhysicalDeviceProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(apiVersion)>("apiVersion");
        addField<DAS_BIND_MANAGED_FIELD(driverVersion)>("driverVersion");
        addField<DAS_BIND_MANAGED_FIELD(vendorID)>("vendorID");
        addField<DAS_BIND_MANAGED_FIELD(deviceID)>("deviceID");
        addField<DAS_BIND_MANAGED_FIELD(deviceType)>("deviceType");
        addField<DAS_BIND_MANAGED_FIELD(deviceName)>("deviceName");
        addField<DAS_BIND_MANAGED_FIELD(pipelineCacheUUID)>("pipelineCacheUUID");
        addField<DAS_BIND_MANAGED_FIELD(limits)>("limits");
        addField<DAS_BIND_MANAGED_FIELD(sparseProperties)>("sparseProperties");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkQueueFamilyProperties, VkQueueFamilyProperties);

struct VkQueueFamilyPropertiesAnnotation
: public ManagedStructureAnnotation<VkQueueFamilyProperties,true,true> {
    VkQueueFamilyPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkQueueFamilyProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(queueFlags)>("queueFlags");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(timestampValidBits)>("timestampValidBits");
        addField<DAS_BIND_MANAGED_FIELD(minImageTransferGranularity)>("minImageTransferGranularity");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceQueueCreateInfo, VkDeviceQueueCreateInfo);

struct VkDeviceQueueCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceQueueCreateInfo,true,true> {
    VkDeviceQueueCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceQueueCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueFamilyIndex)>("queueFamilyIndex");
        addField<DAS_BIND_MANAGED_FIELD(queueCount)>("queueCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueuePriorities)>("pQueuePriorities");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkDeviceCreateInfo, VkDeviceCreateInfo);

struct VkDeviceCreateInfoAnnotation
: public ManagedStructureAnnotation<VkDeviceCreateInfo,true,true> {
    VkDeviceCreateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkDeviceCreateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(flags)>("flags");
        addField<DAS_BIND_MANAGED_FIELD(queueCreateInfoCount)>("queueCreateInfoCount");
        addField<DAS_BIND_MANAGED_FIELD(pQueueCreateInfos)>("pQueueCreateInfos");
        addField<DAS_BIND_MANAGED_FIELD(enabledLayerCount)>("enabledLayerCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledLayerNames)>("ppEnabledLayerNames");
        addField<DAS_BIND_MANAGED_FIELD(enabledExtensionCount)>("enabledExtensionCount");
        addField<DAS_BIND_MANAGED_FIELD(ppEnabledExtensionNames)>("ppEnabledExtensionNames");
        addField<DAS_BIND_MANAGED_FIELD(pEnabledFeatures)>("pEnabledFeatures");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkExtensionProperties, VkExtensionProperties);

struct VkExtensionPropertiesAnnotation
: public ManagedStructureAnnotation<VkExtensionProperties,true,true> {
    VkExtensionPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkExtensionProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(extensionName)>("extensionName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkLayerProperties, VkLayerProperties);

struct VkLayerPropertiesAnnotation
: public ManagedStructureAnnotation<VkLayerProperties,true,true> {
    VkLayerPropertiesAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkLayerProperties", ml) {
        addField<DAS_BIND_MANAGED_FIELD(layerName)>("layerName");
        addField<DAS_BIND_MANAGED_FIELD(specVersion)>("specVersion");
        addField<DAS_BIND_MANAGED_FIELD(implementationVersion)>("implementationVersion");
        addField<DAS_BIND_MANAGED_FIELD(description)>("description");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkSubmitInfo, VkSubmitInfo);

struct VkSubmitInfoAnnotation
: public ManagedStructureAnnotation<VkSubmitInfo,true,true> {
    VkSubmitInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkSubmitInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(waitSemaphoreCount)>("waitSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pWaitSemaphores)>("pWaitSemaphores");
        addField<DAS_BIND_MANAGED_FIELD(pWaitDstStageMask)>("pWaitDstStageMask");
        addField<DAS_BIND_MANAGED_FIELD(commandBufferCount)>("commandBufferCount");
        addField<DAS_BIND_MANAGED_FIELD(pCommandBuffers)>("pCommandBuffers");
        addField<DAS_BIND_MANAGED_FIELD(signalSemaphoreCount)>("signalSemaphoreCount");
        addField<DAS_BIND_MANAGED_FIELD(pSignalSemaphores)>("pSignalSemaphores");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMappedMemoryRange, VkMappedMemoryRange);

struct VkMappedMemoryRangeAnnotation
: public ManagedStructureAnnotation<VkMappedMemoryRange,true,true> {
    VkMappedMemoryRangeAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMappedMemoryRange", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(memory)>("memory");
        addField<DAS_BIND_MANAGED_FIELD(offset)>("offset");
        addField<DAS_BIND_MANAGED_FIELD(size)>("size");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

IMPLEMENT_EXTERNAL_TYPE_FACTORY(VkMemoryAllocateInfo, VkMemoryAllocateInfo);

struct VkMemoryAllocateInfoAnnotation
: public ManagedStructureAnnotation<VkMemoryAllocateInfo,true,true> {
    VkMemoryAllocateInfoAnnotation(ModuleLibrary & ml)
    : ManagedStructureAnnotation ("VkMemoryAllocateInfo", ml) {
        addField<DAS_BIND_MANAGED_FIELD(sType)>("sType");
        addField<DAS_BIND_MANAGED_FIELD(pNext)>("pNext");
        addField<DAS_BIND_MANAGED_FIELD(allocationSize)>("allocationSize");
        addField<DAS_BIND_MANAGED_FIELD(memoryTypeIndex)>("memoryTypeIndex");
    }
    void init() {
    }
    virtual bool isLocal() const override { return true; }
    virtual bool canCopy() const override { return true; }
    virtual bool canMove() const override { return true; }
    virtual bool canClone() const override { return true; }
    virtual SimNode * simulateCopy ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return context.code->makeNode<SimNode_CopyRefValue>(at, l, r, getSizeOf());
    }
    virtual SimNode * simulateClone ( Context & context, const LineInfo & at, SimNode * l, SimNode * r ) const override {
        return simulateCopy(context, at, l, r);
    }
};

void addVulkanGenerated_0(Module & module, ModuleLibrary & lib) {

    //
    // enums
    //

    module.addEnumeration(make_smart<EnumerationVkResult>());
    module.addEnumeration(make_smart<EnumerationVkStructureType>());
    module.addEnumeration(make_smart<EnumerationVkImageLayout>());
    module.addEnumeration(make_smart<EnumerationVkObjectType>());
    module.addEnumeration(make_smart<EnumerationVkVendorId>());
    module.addEnumeration(make_smart<EnumerationVkPipelineCacheHeaderVersion>());
    module.addEnumeration(make_smart<EnumerationVkSystemAllocationScope>());
    module.addEnumeration(make_smart<EnumerationVkInternalAllocationType>());
    module.addEnumeration(make_smart<EnumerationVkFormat>());
    module.addEnumeration(make_smart<EnumerationVkImageTiling>());
    module.addEnumeration(make_smart<EnumerationVkImageType>());

    //
    // opaque structs
    //

    module.addAnnotation(make_smart<VkHandleAnnotation<VkBuffer>>("VkBuffer", "VkBuffer"));
    module.addAnnotation(make_smart<VkHandleAnnotation<VkImage>>("VkImage", "VkImage"));

    //
    // structs
    //

    module.addAnnotation(make_smart<VkExtent2DAnnotation>(lib));
    module.addAnnotation(make_smart<VkExtent3DAnnotation>(lib));
    module.addAnnotation(make_smart<VkOffset2DAnnotation>(lib));
    module.addAnnotation(make_smart<VkOffset3DAnnotation>(lib));
    module.addAnnotation(make_smart<VkRect2DAnnotation>(lib));
    module.addAnnotation(make_smart<VkBaseInStructureAnnotation>(lib));
    module.addAnnotation(make_smart<VkBaseOutStructureAnnotation>(lib));
    module.addAnnotation(make_smart<VkBufferMemoryBarrierAnnotation>(lib));
    module.addAnnotation(make_smart<VkDispatchIndirectCommandAnnotation>(lib));
    module.addAnnotation(make_smart<VkDrawIndexedIndirectCommandAnnotation>(lib));
    module.addAnnotation(make_smart<VkDrawIndirectCommandAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageSubresourceRangeAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageMemoryBarrierAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryBarrierAnnotation>(lib));
    module.addAnnotation(make_smart<VkAllocationCallbacksAnnotation>(lib));
    module.addAnnotation(make_smart<VkApplicationInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkFormatPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkImageFormatPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkInstanceCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryHeapAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryTypeAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceFeaturesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceLimitsAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceMemoryPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDeviceSparsePropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkPhysicalDevicePropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkQueueFamilyPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceQueueCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkDeviceCreateInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkExtensionPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkLayerPropertiesAnnotation>(lib));
    module.addAnnotation(make_smart<VkSubmitInfoAnnotation>(lib));
    module.addAnnotation(make_smart<VkMappedMemoryRangeAnnotation>(lib));
    module.addAnnotation(make_smart<VkMemoryAllocateInfoAnnotation>(lib));

    //
    // functions
    //

    addExtern<DAS_BIND_FUN(vkCreateInstance)>(module, lib, "vkCreateInstance",
        SideEffects::worstDefault, "vkCreateInstance");
    addExtern<DAS_BIND_FUN(vkDestroyInstance)>(module, lib, "vkDestroyInstance",
        SideEffects::worstDefault, "vkDestroyInstance");
    addExtern<DAS_BIND_FUN(vkEnumeratePhysicalDevices)>(module, lib, "vkEnumeratePhysicalDevices",
        SideEffects::worstDefault, "vkEnumeratePhysicalDevices");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFeatures)>(module, lib, "vkGetPhysicalDeviceFeatures",
        SideEffects::worstDefault, "vkGetPhysicalDeviceFeatures");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceFormatProperties)>(module, lib, "vkGetPhysicalDeviceFormatProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceFormatProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceImageFormatProperties)>(module, lib, "vkGetPhysicalDeviceImageFormatProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceImageFormatProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceProperties)>(module, lib, "vkGetPhysicalDeviceProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceQueueFamilyProperties)>(module, lib, "vkGetPhysicalDeviceQueueFamilyProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceQueueFamilyProperties");
    addExtern<DAS_BIND_FUN(vkGetPhysicalDeviceMemoryProperties)>(module, lib, "vkGetPhysicalDeviceMemoryProperties",
        SideEffects::worstDefault, "vkGetPhysicalDeviceMemoryProperties");
    addExtern<DAS_BIND_FUN(vkCreateDevice)>(module, lib, "vkCreateDevice",
        SideEffects::worstDefault, "vkCreateDevice");
    addExtern<DAS_BIND_FUN(vkDestroyDevice)>(module, lib, "vkDestroyDevice",
        SideEffects::worstDefault, "vkDestroyDevice");
    addExtern<DAS_BIND_FUN(vkEnumerateInstanceExtensionProperties)>(module, lib, "vkEnumerateInstanceExtensionProperties",
        SideEffects::worstDefault, "vkEnumerateInstanceExtensionProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateDeviceExtensionProperties)>(module, lib, "vkEnumerateDeviceExtensionProperties",
        SideEffects::worstDefault, "vkEnumerateDeviceExtensionProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateInstanceLayerProperties)>(module, lib, "vkEnumerateInstanceLayerProperties",
        SideEffects::worstDefault, "vkEnumerateInstanceLayerProperties");
    addExtern<DAS_BIND_FUN(vkEnumerateDeviceLayerProperties)>(module, lib, "vkEnumerateDeviceLayerProperties",
        SideEffects::worstDefault, "vkEnumerateDeviceLayerProperties");
    addExtern<DAS_BIND_FUN(vkGetDeviceQueue)>(module, lib, "vkGetDeviceQueue",
        SideEffects::worstDefault, "vkGetDeviceQueue");
    addExtern<DAS_BIND_FUN(vkQueueSubmit)>(module, lib, "vkQueueSubmit",
        SideEffects::worstDefault, "vkQueueSubmit");

    //
    // macro constants
    //

    addConstant(module, "GLFW_VERSION_MAJOR", 3);
    addConstant(module, "GLFW_VERSION_MINOR", 3);
    addConstant(module, "GLFW_VERSION_REVISION", 2);
    addConstant(module, "GLFW_TRUE", 1);
    addConstant(module, "GLFW_FALSE", 0);
    addConstant(module, "GLFW_RELEASE", 0);
    addConstant(module, "GLFW_PRESS", 1);
    addConstant(module, "GLFW_REPEAT", 2);
    addConstant(module, "GLFW_HAT_CENTERED", 0);
    addConstant(module, "GLFW_HAT_UP", 1);
    addConstant(module, "GLFW_HAT_RIGHT", 2);
    addConstant(module, "GLFW_HAT_DOWN", 4);
    addConstant(module, "GLFW_HAT_LEFT", 8);
    addConstant(module, "GLFW_HAT_RIGHT_UP", (GLFW_HAT_RIGHT | GLFW_HAT_UP));
    addConstant(module, "GLFW_HAT_RIGHT_DOWN", (GLFW_HAT_RIGHT | GLFW_HAT_DOWN));
    addConstant(module, "GLFW_HAT_LEFT_UP", (GLFW_HAT_LEFT  | GLFW_HAT_UP));
    addConstant(module, "GLFW_HAT_LEFT_DOWN", (GLFW_HAT_LEFT  | GLFW_HAT_DOWN));
    addConstant(module, "GLFW_KEY_UNKNOWN", -1);
    addConstant(module, "GLFW_KEY_SPACE", 32);
    addConstant(module, "GLFW_KEY_APOSTROPHE", 39  /* ' */);
    addConstant(module, "GLFW_KEY_COMMA", 44  /* , */);
    addConstant(module, "GLFW_KEY_MINUS", 45  /* - */);
    addConstant(module, "GLFW_KEY_PERIOD", 46  /* . */);
    addConstant(module, "GLFW_KEY_SLASH", 47  /* / */);
    addConstant(module, "GLFW_KEY_0", 48);
    addConstant(module, "GLFW_KEY_1", 49);
    addConstant(module, "GLFW_KEY_2", 50);
    addConstant(module, "GLFW_KEY_3", 51);
    addConstant(module, "GLFW_KEY_4", 52);
    addConstant(module, "GLFW_KEY_5", 53);
    addConstant(module, "GLFW_KEY_6", 54);
    addConstant(module, "GLFW_KEY_7", 55);
    addConstant(module, "GLFW_KEY_8", 56);
    addConstant(module, "GLFW_KEY_9", 57);
    addConstant(module, "GLFW_KEY_SEMICOLON", 59  /* ; */);
    addConstant(module, "GLFW_KEY_EQUAL", 61  /* = */);
    addConstant(module, "GLFW_KEY_A", 65);
    addConstant(module, "GLFW_KEY_B", 66);
    addConstant(module, "GLFW_KEY_C", 67);
    addConstant(module, "GLFW_KEY_D", 68);
    addConstant(module, "GLFW_KEY_E", 69);
    addConstant(module, "GLFW_KEY_F", 70);
    addConstant(module, "GLFW_KEY_G", 71);
    addConstant(module, "GLFW_KEY_H", 72);
    addConstant(module, "GLFW_KEY_I", 73);
};
