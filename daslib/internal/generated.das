// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan
require instance

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    p_enabled_layer_names : array<string>
    p_enabled_extension_names : array<string>

//
// Instance
//

struct Instance
    instance : VkInstance

def create_instance(
    create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var instance : Instance
    create_info |> with_view() <| $(vk_info)
        var result_ = VkResult VK_SUCCESS
        result ?? result_ = vkCreateInstance(
            safe_addr(vk_info), null, safe_addr(instance.instance)
        )
        assert(result_ == VkResult VK_SUCCESS)
    return <- instance

def finalize(var instance : Instance)
    vkDestroyInstance(instance.instance, null)
    memzero(instance)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice

struct PhysicalDeviceBatch
    physical_device_batch : array<VkPhysicalDevice>

def split(batch : PhysicalDeviceBatch) : array<PhysicalDevice>
    return <- [{for h in batch.physical_device_batch ;
        [[PhysicalDevice physical_device=h]]}]

def enumerate_physical_devices(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
) : PhysicalDeviceBatch

    var count : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        instance.instance, safe_addr(count), null
    )
    assert(result_ == VkResult VK_SUCCESS)

    var vk_handles : array<VkPhysicalDevice>
    if result ?? result_ == VkResult VK_SUCCESS && count > 0u
        vk_handles |> resize(int(count))
        vk_handles |> lock() <| $(thandles)
            result ?? result_ = vkEnumeratePhysicalDevices(
                instance.instance, safe_addr(count), addr(thandles[0])
            )
            assert(result_ == VkResult VK_SUCCESS)

    return <- [[PhysicalDeviceBatch physical_device_batch <- vk_handles]]

def enumerate_physical_devices_no_batch(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
): array<PhysicalDevice>
    var handles <- enumerate_physical_devices(instance, result)
    defer() <| ${ delete handles; }
    return <- handles |> split()
