// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_p_view(
    p_boost_struct : auto(BOOST_T)?;
    b : block<(p_vk_struct : auto(VK_T)?)>
)
    if p_boost_struct == null
        b |> invoke([[VK_T?]])
    else
        *p_boost_struct |> with_view() <| $(vk_struct)
            unsafe
                b |> invoke(addr(vk_struct))

def to_string(bytes : int8[])
    unsafe
        return reinterpret<string>(addr(bytes[0]))

//
// Functions
//


def get_physical_device_properties(
    physical_device : PhysicalDevice
) : PhysicalDeviceProperties
    var vk_output : VkPhysicalDeviceProperties
    vkGetPhysicalDeviceProperties(
        physical_device.physical_device,
        safe_addr(vk_output)
    )
    return <- vk_output

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint

def with_view(
    boost_struct : ApplicationInfo;
    b : block<(vk_struct : VkApplicationInfo)>
) {
    let vk_struct <- [[ VkApplicationInfo
        pApplicationName = boost_struct.application_name,
        applicationVersion = boost_struct.application_version,
        pEngineName = boost_struct.engine_name,
        engineVersion = boost_struct.engine_version,
        apiVersion = boost_struct.api_version,
        sType = VkStructureType VK_STRUCTURE_TYPE_APPLICATION_INFO
    ]];
    b |> invoke(vk_struct);
}

//
// ExtensionProperties
//

struct ExtensionProperties
    extension_name : string
    spec_version : uint

def construct(vk_struct : VkExtensionProperties) : ExtensionProperties
    return <- [[ExtensionProperties
        extension_name = to_string(vk_struct.extensionName),
        spec_version = vk_struct.specVersion
    ]]

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>

def with_view(
    boost_struct : InstanceCreateInfo;
    b : block<(vk_struct : VkInstanceCreateInfo)>
) {
    boost_struct.p_application_info |> with_p_view() <| $(
        vk_p_application_info : VkApplicationInfo const ?
    ) {
    boost_struct.enabled_layer_names |> lock_data() <| $(
        vk_p_enabled_layer_names, vk_enabled_layer_count
    ) {
    boost_struct.enabled_extension_names |> lock_data() <| $(
        vk_p_enabled_extension_names, vk_enabled_extension_count
    ) {
    let vk_struct <- [[ VkInstanceCreateInfo
        flags = boost_struct.flags,
        pApplicationInfo = vk_p_application_info,
        enabledLayerCount = uint(vk_enabled_layer_count),
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = uint(vk_enabled_extension_count),
        ppEnabledExtensionNames = vk_p_enabled_extension_names,
        sType = VkStructureType VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    ]];
    b |> invoke(vk_struct);
    }}};
}

//
// Instance
//

struct Instance
    instance : VkInstance

def create_instance(
    create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var instance : Instance
    create_info |> with_view() <| $(vk_info)
        var result_ = VkResult VK_SUCCESS
        result ?? result_ = vkCreateInstance(
            safe_addr(vk_info),
            null,
            safe_addr(instance.instance)
        )
        assert(result_ == VkResult VK_SUCCESS)
    return <- instance

def finalize(var instance : Instance)
    vkDestroyInstance(
        instance.instance,
        null
    )
    memzero(instance)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice

struct PhysicalDeviceBatch
    physical_device_batch : array<VkPhysicalDevice>

def split(batch : PhysicalDeviceBatch) : array<PhysicalDevice>
    return <- [{for h in batch.physical_device_batch ;
        [[PhysicalDevice physical_device=h]]}]

def enumerate_physical_devices(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
) : PhysicalDeviceBatch

    var count : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        instance.instance,
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    var vk_handles : array<VkPhysicalDevice>
    if result ?? result_ == VkResult VK_SUCCESS && count > 0u
        vk_handles |> resize(int(count))
        vk_handles |> lock() <| $(thandles)
            result ?? result_ = vkEnumeratePhysicalDevices(
                instance.instance,
                safe_addr(count),
                addr(thandles[0])
            )
            assert(result_ == VkResult VK_SUCCESS)

    return <- [[PhysicalDeviceBatch physical_device_batch <- vk_handles]]

def enumerate_physical_devices_no_batch(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
): array<PhysicalDevice>
    var handles <- enumerate_physical_devices(instance, result)
    defer() <| ${ delete handles; }
    return <- handles |> split()
