// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_view(
    var boost_struct : auto(BOOST_T);
    b : block<(vk_struct : auto(VK_T))>
)
    var vk_struct : VK_T
    unsafe
        vk_struct <- boost_struct |> vk_view_create_unsafe()
    b |> invoke(vk_struct)
    boost_struct |> vk_view_destroy()

def boost_value_to_vk(b : auto(T)[]) : T[]
    return b

def boost_value_to_vk(b : auto(T)) : T
    return b

def vk_value_to_boost(v : auto(T)[]) : T[]
    return v

def vk_value_to_boost(v : auto(T)) : T
    return v

def vk_value_to_boost(v : int8[]) : string
    unsafe
        let s := reinterpret<string>(addr(v[0]))
        return s

def array_addr_unsafe(var ar : array<auto(T)>) : T?
    unsafe
        return length(ar) > 0 ? addr(ar[0]) : [[T ?]]

def addr_unsafe(v)
    unsafe
        return addr(v)

//TODO: refactor into clone() and disable can_copy on boost handles.
//  after that transfer ownership with move, and create weak copies via clone.
//  OR disable can_copy and can_clone, and only allow move and weak_copy.
def weak_copy(b : auto(T)) : T
    static_if typeinfo(has_field<_needs_delete> b)
        var bc : T = b
        bc._needs_delete = false
        return <- bc
    else
        concept_assert(0, "can't weak copy this type")

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def boost_value_to_vk(b : SurfaceKHR) : VkSurfaceKHR
    return b.surface_khr

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR explicit)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)

//
// CommandBuffers
//

struct CommandBuffers
    command_buffers : array<CommandBuffer>
    _device : Device
    _command_pool : CommandPool
    _needs_delete : bool

def allocate_command_buffers(
    device : Device = [[ Device ]];
    var allocate_info : CommandBufferAllocateInfo = [[ CommandBufferAllocateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : CommandBuffers
    var buffers <- [[ CommandBuffers
        _needs_delete = true,
        _device = weak_copy(device),
        _command_pool = weak_copy(allocate_info.command_pool)
    ]]
    buffers.command_buffers <- allocate_command_buffers__inner([
        device = device, allocate_info = allocate_info, result = result])
    return <- buffers

def finalize(var bufs : CommandBuffers explicit)
    if bufs._needs_delete
        bufs._device |> free_command_buffers(bufs._command_pool,
            bufs.command_buffers)
    delete bufs.command_buffers
    memzero(bufs)

//
// Functions
//

[private]
def allocate_command_buffers__inner(
    device : Device = [[ Device ]];
    var allocate_info : CommandBufferAllocateInfo = [[ CommandBufferAllocateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : array<CommandBuffer>

    var vk_allocate_info <- allocate_info |> vk_view_create_unsafe()
    defer() <| ${ allocate_info |> vk_view_destroy(); }
    var vk_command_buffers : array<VkCommandBuffer>
    defer() <| ${ delete vk_command_buffers; }
    var result_ = VkResult VK_SUCCESS

    vk_command_buffers |> resize(int(allocate_info.command_buffer_count))
    result ?? result_ = vkAllocateCommandBuffers(
        boost_value_to_vk(device),
        safe_addr(vk_allocate_info),
        array_addr_unsafe(vk_command_buffers)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_command_buffers; vk_value_to_boost(x)}]

def begin_command_buffer(
    command_buffer : CommandBuffer = [[ CommandBuffer ]];
    var begin_info : CommandBufferBeginInfo = [[ CommandBufferBeginInfo ]];
    var result : VkResult? = [[VkResult?]]
) : void

    var vk_begin_info <- begin_info |> vk_view_create_unsafe()
    defer() <| ${ begin_info |> vk_view_destroy(); }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkBeginCommandBuffer(
        boost_value_to_vk(command_buffer),
        safe_addr(vk_begin_info)
    )
    assert(result_ == VkResult VK_SUCCESS)

def cmd_begin_render_pass(
    command_buffer : CommandBuffer = [[ CommandBuffer ]];
    var render_pass_begin : RenderPassBeginInfo = [[ RenderPassBeginInfo ]];
    contents : VkSubpassContents = [[ VkSubpassContents ]]
) : void

    var vk_render_pass_begin <- render_pass_begin |> vk_view_create_unsafe()
    defer() <| ${ render_pass_begin |> vk_view_destroy(); }

    vkCmdBeginRenderPass(
        boost_value_to_vk(command_buffer),
        safe_addr(vk_render_pass_begin),
        boost_value_to_vk(contents)
    )

def device_wait_idle(
    device : Device = [[ Device ]];
    var result : VkResult? = [[VkResult?]]
) : void

    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkDeviceWaitIdle(
        boost_value_to_vk(device)
    )
    assert(result_ == VkResult VK_SUCCESS)

def end_command_buffer(
    command_buffer : CommandBuffer = [[ CommandBuffer ]];
    var result : VkResult? = [[VkResult?]]
) : void

    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEndCommandBuffer(
        boost_value_to_vk(command_buffer)
    )
    assert(result_ == VkResult VK_SUCCESS)

def cmd_end_render_pass(
    command_buffer : CommandBuffer = [[ CommandBuffer ]]
) : void

    vkCmdEndRenderPass(
        boost_value_to_vk(command_buffer)
    )

def enumerate_device_extension_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    layer_name : string = [[ string ]];
    var result : VkResult? = [[VkResult?]]
) : array<ExtensionProperties>

    var vk_pPropertyCount : uint
    var vk_properties : array<VkExtensionProperties>
    defer() <| ${ delete vk_properties; }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumerateDeviceExtensionProperties(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(layer_name),
        safe_addr(vk_pPropertyCount),
        [[ VkExtensionProperties ? ]]
    )
    assert(result_ == VkResult VK_SUCCESS)
    if result_ != VkResult VK_SUCCESS
        return <- [[ array<ExtensionProperties> ]]
    vk_properties |> resize(int(vk_pPropertyCount))
    result ?? result_ = vkEnumerateDeviceExtensionProperties(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(layer_name),
        safe_addr(vk_pPropertyCount),
        array_addr_unsafe(vk_properties)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_properties; vk_value_to_boost(x)}]

def enumerate_physical_devices(
    instance : Instance = [[ Instance ]];
    var result : VkResult? = [[VkResult?]]
) : array<PhysicalDevice>

    var vk_pPhysicalDeviceCount : uint
    var vk_physical_devices : array<VkPhysicalDevice>
    defer() <| ${ delete vk_physical_devices; }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        boost_value_to_vk(instance),
        safe_addr(vk_pPhysicalDeviceCount),
        [[ VkPhysicalDevice ? ]]
    )
    assert(result_ == VkResult VK_SUCCESS)
    if result_ != VkResult VK_SUCCESS
        return <- [[ array<PhysicalDevice> ]]
    vk_physical_devices |> resize(int(vk_pPhysicalDeviceCount))
    result ?? result_ = vkEnumeratePhysicalDevices(
        boost_value_to_vk(instance),
        safe_addr(vk_pPhysicalDeviceCount),
        array_addr_unsafe(vk_physical_devices)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_physical_devices; vk_value_to_boost(x)}]

[private]
def free_command_buffers(
    device : Device = [[ Device ]];
    command_pool : CommandPool = [[ CommandPool ]];
    command_buffers : array<CommandBuffer> = [[ array<CommandBuffer> ]]
) : void

    let vk_commandBufferCount = uint(command_buffers |> length())
    var vk_command_buffers : array<VkCommandBuffer>
    defer() <| ${ delete vk_command_buffers; }
    vk_command_buffers <- [{ for item in command_buffers ; boost_value_to_vk(item) }]

    vkFreeCommandBuffers(
        boost_value_to_vk(device),
        boost_value_to_vk(command_pool),
        vk_commandBufferCount,
        array_addr_unsafe(vk_command_buffers)
    )

def get_device_queue(
    device : Device = [[ Device ]];
    queue_family_index : uint = [[ uint ]];
    queue_index : uint = [[ uint ]]
) : Queue

    var vk_queue : VkQueue

    vkGetDeviceQueue(
        boost_value_to_vk(device),
        boost_value_to_vk(queue_family_index),
        boost_value_to_vk(queue_index),
        safe_addr(vk_queue)
    )
    return vk_value_to_boost(vk_queue)

def get_buffer_memory_requirements(
    device : Device = [[ Device ]];
    buffer : Buffer = [[ Buffer ]]
) : MemoryRequirements

    var vk_memory_requirements : VkMemoryRequirements

    vkGetBufferMemoryRequirements(
        boost_value_to_vk(device),
        boost_value_to_vk(buffer),
        safe_addr(vk_memory_requirements)
    )
    return <- vk_value_to_boost(vk_memory_requirements)

def get_physical_device_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : PhysicalDeviceProperties

    var vk_properties : VkPhysicalDeviceProperties

    vkGetPhysicalDeviceProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_properties)
    )
    return <- vk_value_to_boost(vk_properties)

def get_physical_device_surface_capabilities_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceCapabilitiesKHR

    var vk_surface_capabilities : VkSurfaceCapabilitiesKHR
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(vk_surface_capabilities)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- vk_value_to_boost(vk_surface_capabilities)

def get_physical_device_surface_support_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    queue_family_index : uint = [[ uint ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : uint

    var vk_supported : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkGetPhysicalDeviceSurfaceSupportKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(queue_family_index),
        boost_value_to_vk(surface),
        safe_addr(vk_supported)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_supported)

def get_physical_device_queue_family_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : array<QueueFamilyProperties>

    var vk_pQueueFamilyPropertyCount : uint
    var vk_queue_family_properties : array<VkQueueFamilyProperties>
    defer() <| ${ delete vk_queue_family_properties; }

    vkGetPhysicalDeviceQueueFamilyProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_pQueueFamilyPropertyCount),
        [[ VkQueueFamilyProperties ? ]]
    )
    vk_queue_family_properties |> resize(int(vk_pQueueFamilyPropertyCount))
    vkGetPhysicalDeviceQueueFamilyProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_pQueueFamilyPropertyCount),
        array_addr_unsafe(vk_queue_family_properties)
    )
    return <- [{for x in vk_queue_family_properties; vk_value_to_boost(x)}]

def get_physical_device_surface_formats_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<SurfaceFormatKHR>

    var vk_pSurfaceFormatCount : uint
    var vk_surface_formats : array<VkSurfaceFormatKHR>
    defer() <| ${ delete vk_surface_formats; }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(vk_pSurfaceFormatCount),
        [[ VkSurfaceFormatKHR ? ]]
    )
    assert(result_ == VkResult VK_SUCCESS)
    if result_ != VkResult VK_SUCCESS
        return <- [[ array<SurfaceFormatKHR> ]]
    vk_surface_formats |> resize(int(vk_pSurfaceFormatCount))
    result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(vk_pSurfaceFormatCount),
        array_addr_unsafe(vk_surface_formats)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_surface_formats; vk_value_to_boost(x)}]

def get_physical_device_surface_present_modes_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<VkPresentModeKHR>

    var vk_pPresentModeCount : uint
    var vk_present_modes : array<VkPresentModeKHR>
    defer() <| ${ delete vk_present_modes; }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(vk_pPresentModeCount),
        [[ VkPresentModeKHR ? ]]
    )
    assert(result_ == VkResult VK_SUCCESS)
    if result_ != VkResult VK_SUCCESS
        return <- [[ array<VkPresentModeKHR> ]]
    vk_present_modes |> resize(int(vk_pPresentModeCount))
    result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(vk_pPresentModeCount),
        array_addr_unsafe(vk_present_modes)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_present_modes; vk_value_to_boost(x)}]

def get_physical_device_memory_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : PhysicalDeviceMemoryProperties

    var vk_memory_properties : VkPhysicalDeviceMemoryProperties

    vkGetPhysicalDeviceMemoryProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_memory_properties)
    )
    return <- vk_value_to_boost(vk_memory_properties)

def get_swapchain_images_khr(
    device : Device = [[ Device ]];
    swapchain : SwapchainKHR = [[ SwapchainKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<Image>

    var vk_pSwapchainImageCount : uint
    var vk_swapchain_images : array<VkImage>
    defer() <| ${ delete vk_swapchain_images; }
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkGetSwapchainImagesKHR(
        boost_value_to_vk(device),
        boost_value_to_vk(swapchain),
        safe_addr(vk_pSwapchainImageCount),
        [[ VkImage ? ]]
    )
    assert(result_ == VkResult VK_SUCCESS)
    if result_ != VkResult VK_SUCCESS
        return <- [[ array<Image> ]]
    vk_swapchain_images |> resize(int(vk_pSwapchainImageCount))
    result ?? result_ = vkGetSwapchainImagesKHR(
        boost_value_to_vk(device),
        boost_value_to_vk(swapchain),
        safe_addr(vk_pSwapchainImageCount),
        array_addr_unsafe(vk_swapchain_images)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_swapchain_images; vk_value_to_boost(x)}]

def map_memory(
    device : Device = [[ Device ]];
    memory : DeviceMemory = [[ DeviceMemory ]];
    offset : uint64 = [[ uint64 ]];
    size : uint64 = [[ uint64 ]];
    flags : uint = [[ uint ]];
    var result : VkResult? = [[VkResult?]]
) : void ?

    var vk_data : void ?
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkMapMemory(
        boost_value_to_vk(device),
        boost_value_to_vk(memory),
        boost_value_to_vk(offset),
        boost_value_to_vk(size),
        boost_value_to_vk(flags),
        safe_addr(vk_data)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_data)

def queue_wait_idle(
    queue : Queue = [[ Queue ]];
    var result : VkResult? = [[VkResult?]]
) : void

    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkQueueWaitIdle(
        boost_value_to_vk(queue)
    )
    assert(result_ == VkResult VK_SUCCESS)

def unmap_memory(
    device : Device = [[ Device ]];
    memory : DeviceMemory = [[ DeviceMemory ]]
) : void

    vkUnmapMemory(
        boost_value_to_vk(device),
        boost_value_to_vk(memory)
    )

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ApplicationInfo
) : VkApplicationInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkApplicationInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_APPLICATION_INFO,
        pApplicationName = boost_value_to_vk(boost_struct.application_name),
        applicationVersion = boost_value_to_vk(boost_struct.application_version),
        pEngineName = boost_value_to_vk(boost_struct.engine_name),
        engineVersion = boost_value_to_vk(boost_struct.engine_version),
        apiVersion = boost_value_to_vk(boost_struct.api_version)
    ]]

def vk_view_destroy(var boost_struct : ApplicationInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkApplicationInfo) : ApplicationInfo
    return <- [[ApplicationInfo
        application_name = vk_value_to_boost(vk_struct.pApplicationName),
        application_version = vk_value_to_boost(vk_struct.applicationVersion),
        engine_name = vk_value_to_boost(vk_struct.pEngineName),
        engine_version = vk_value_to_boost(vk_struct.engineVersion),
        api_version = vk_value_to_boost(vk_struct.apiVersion)
    ]]

//
// AttachmentDescription
//

struct AttachmentDescription
    flags : uint
    format : VkFormat
    samples : VkSampleCountFlagBits
    load_op : VkAttachmentLoadOp
    store_op : VkAttachmentStoreOp
    stencil_load_op : VkAttachmentLoadOp
    stencil_store_op : VkAttachmentStoreOp
    initial_layout : VkImageLayout
    final_layout : VkImageLayout
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : AttachmentDescription
) : VkAttachmentDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkAttachmentDescription
        flags = boost_value_to_vk(boost_struct.flags),
        format = boost_value_to_vk(boost_struct.format),
        samples = boost_value_to_vk(boost_struct.samples),
        loadOp = boost_value_to_vk(boost_struct.load_op),
        storeOp = boost_value_to_vk(boost_struct.store_op),
        stencilLoadOp = boost_value_to_vk(boost_struct.stencil_load_op),
        stencilStoreOp = boost_value_to_vk(boost_struct.stencil_store_op),
        initialLayout = boost_value_to_vk(boost_struct.initial_layout),
        finalLayout = boost_value_to_vk(boost_struct.final_layout)
    ]]

def vk_view_destroy(var boost_struct : AttachmentDescription)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkAttachmentDescription) : AttachmentDescription
    return <- [[AttachmentDescription
        flags = vk_value_to_boost(vk_struct.flags),
        format = vk_value_to_boost(vk_struct.format),
        samples = vk_value_to_boost(vk_struct.samples),
        load_op = vk_value_to_boost(vk_struct.loadOp),
        store_op = vk_value_to_boost(vk_struct.storeOp),
        stencil_load_op = vk_value_to_boost(vk_struct.stencilLoadOp),
        stencil_store_op = vk_value_to_boost(vk_struct.stencilStoreOp),
        initial_layout = vk_value_to_boost(vk_struct.initialLayout),
        final_layout = vk_value_to_boost(vk_struct.finalLayout)
    ]]

//
// AttachmentReference
//

struct AttachmentReference
    attachment : uint
    layout : VkImageLayout
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : AttachmentReference
) : VkAttachmentReference

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkAttachmentReference
        attachment = boost_value_to_vk(boost_struct.attachment),
        layout = boost_value_to_vk(boost_struct.layout)
    ]]

def vk_view_destroy(var boost_struct : AttachmentReference)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkAttachmentReference) : AttachmentReference
    return <- [[AttachmentReference
        attachment = vk_value_to_boost(vk_struct.attachment),
        layout = vk_value_to_boost(vk_struct.layout)
    ]]

//
// ComponentMapping
//

struct ComponentMapping
    r : VkComponentSwizzle
    g : VkComponentSwizzle
    b : VkComponentSwizzle
    a : VkComponentSwizzle
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ComponentMapping
) : VkComponentMapping

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkComponentMapping
        r = boost_value_to_vk(boost_struct.r),
        g = boost_value_to_vk(boost_struct.g),
        b = boost_value_to_vk(boost_struct.b),
        a = boost_value_to_vk(boost_struct.a)
    ]]

def vk_view_destroy(var boost_struct : ComponentMapping)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkComponentMapping) : ComponentMapping
    return <- [[ComponentMapping
        r = vk_value_to_boost(vk_struct.r),
        g = vk_value_to_boost(vk_struct.g),
        b = vk_value_to_boost(vk_struct.b),
        a = vk_value_to_boost(vk_struct.a)
    ]]

//
// Extent2D
//

struct Extent2D
    width : uint
    height : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Extent2D
) : VkExtent2D

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkExtent2D
        width = boost_value_to_vk(boost_struct.width),
        height = boost_value_to_vk(boost_struct.height)
    ]]

def vk_view_destroy(var boost_struct : Extent2D)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkExtent2D) : Extent2D
    return <- [[Extent2D
        width = vk_value_to_boost(vk_struct.width),
        height = vk_value_to_boost(vk_struct.height)
    ]]

//
// Extent3D
//

struct Extent3D
    width : uint
    height : uint
    depth : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Extent3D
) : VkExtent3D

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkExtent3D
        width = boost_value_to_vk(boost_struct.width),
        height = boost_value_to_vk(boost_struct.height),
        depth = boost_value_to_vk(boost_struct.depth)
    ]]

def vk_view_destroy(var boost_struct : Extent3D)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkExtent3D) : Extent3D
    return <- [[Extent3D
        width = vk_value_to_boost(vk_struct.width),
        height = vk_value_to_boost(vk_struct.height),
        depth = vk_value_to_boost(vk_struct.depth)
    ]]

//
// ImageSubresourceRange
//

struct ImageSubresourceRange
    aspect_mask : uint
    base_mip_level : uint
    level_count : uint
    base_array_layer : uint
    layer_count : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ImageSubresourceRange
) : VkImageSubresourceRange

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkImageSubresourceRange
        aspectMask = boost_value_to_vk(boost_struct.aspect_mask),
        baseMipLevel = boost_value_to_vk(boost_struct.base_mip_level),
        levelCount = boost_value_to_vk(boost_struct.level_count),
        baseArrayLayer = boost_value_to_vk(boost_struct.base_array_layer),
        layerCount = boost_value_to_vk(boost_struct.layer_count)
    ]]

def vk_view_destroy(var boost_struct : ImageSubresourceRange)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkImageSubresourceRange) : ImageSubresourceRange
    return <- [[ImageSubresourceRange
        aspect_mask = vk_value_to_boost(vk_struct.aspectMask),
        base_mip_level = vk_value_to_boost(vk_struct.baseMipLevel),
        level_count = vk_value_to_boost(vk_struct.levelCount),
        base_array_layer = vk_value_to_boost(vk_struct.baseArrayLayer),
        layer_count = vk_value_to_boost(vk_struct.layerCount)
    ]]

//
// MemoryRequirements
//

struct MemoryRequirements
    size : uint64
    alignment : uint64
    memory_type_bits : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : MemoryRequirements
) : VkMemoryRequirements

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkMemoryRequirements
        size = boost_value_to_vk(boost_struct.size),
        alignment = boost_value_to_vk(boost_struct.alignment),
        memoryTypeBits = boost_value_to_vk(boost_struct.memory_type_bits)
    ]]

def vk_view_destroy(var boost_struct : MemoryRequirements)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkMemoryRequirements) : MemoryRequirements
    return <- [[MemoryRequirements
        size = vk_value_to_boost(vk_struct.size),
        alignment = vk_value_to_boost(vk_struct.alignment),
        memory_type_bits = vk_value_to_boost(vk_struct.memoryTypeBits)
    ]]

//
// Offset2D
//

struct Offset2D
    x : int
    y : int
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Offset2D
) : VkOffset2D

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkOffset2D
        x = boost_value_to_vk(boost_struct.x),
        y = boost_value_to_vk(boost_struct.y)
    ]]

def vk_view_destroy(var boost_struct : Offset2D)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkOffset2D) : Offset2D
    return <- [[Offset2D
        x = vk_value_to_boost(vk_struct.x),
        y = vk_value_to_boost(vk_struct.y)
    ]]

//
// PhysicalDeviceFeatures
//

struct PhysicalDeviceFeatures
    robust_buffer_access : uint
    full_draw_index_uint_32 : uint
    image_cube_array : uint
    independent_blend : uint
    geometry_shader : uint
    tessellation_shader : uint
    sample_rate_shading : uint
    dual_src_blend : uint
    logic_op : uint
    multi_draw_indirect : uint
    draw_indirect_first_instance : uint
    depth_clamp : uint
    depth_bias_clamp : uint
    fill_mode_non_solid : uint
    depth_bounds : uint
    wide_lines : uint
    large_points : uint
    alpha_to_one : uint
    multi_viewport : uint
    sampler_anisotropy : uint
    texture_compression_etc2 : uint
    texture_compression_astc_ldr : uint
    texture_compression_bc : uint
    occlusion_query_precise : uint
    pipeline_statistics_query : uint
    vertex_pipeline_stores_and_atomics : uint
    fragment_stores_and_atomics : uint
    shader_tessellation_and_geometry_point_size : uint
    shader_image_gather_extended : uint
    shader_storage_image_extended_formats : uint
    shader_storage_image_multisample : uint
    shader_storage_image_read_without_format : uint
    shader_storage_image_write_without_format : uint
    shader_uniform_buffer_array_dynamic_indexing : uint
    shader_sampled_image_array_dynamic_indexing : uint
    shader_storage_buffer_array_dynamic_indexing : uint
    shader_storage_image_array_dynamic_indexing : uint
    shader_clip_distance : uint
    shader_cull_distance : uint
    shader_float_64 : uint
    shader_int_64 : uint
    shader_int_16 : uint
    shader_resource_residency : uint
    shader_resource_min_lod : uint
    sparse_binding : uint
    sparse_residency_buffer : uint
    sparse_residency_image_2d_ : uint
    sparse_residency_image_3d_ : uint
    sparse_residency_2samples : uint
    sparse_residency_4samples : uint
    sparse_residency_8samples : uint
    sparse_residency_16samples : uint
    sparse_residency_aliased : uint
    variable_multisample_rate : uint
    inherited_queries : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PhysicalDeviceFeatures
) : VkPhysicalDeviceFeatures

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPhysicalDeviceFeatures
        robustBufferAccess = boost_value_to_vk(boost_struct.robust_buffer_access),
        fullDrawIndexUint32 = boost_value_to_vk(boost_struct.full_draw_index_uint_32),
        imageCubeArray = boost_value_to_vk(boost_struct.image_cube_array),
        independentBlend = boost_value_to_vk(boost_struct.independent_blend),
        geometryShader = boost_value_to_vk(boost_struct.geometry_shader),
        tessellationShader = boost_value_to_vk(boost_struct.tessellation_shader),
        sampleRateShading = boost_value_to_vk(boost_struct.sample_rate_shading),
        dualSrcBlend = boost_value_to_vk(boost_struct.dual_src_blend),
        logicOp = boost_value_to_vk(boost_struct.logic_op),
        multiDrawIndirect = boost_value_to_vk(boost_struct.multi_draw_indirect),
        drawIndirectFirstInstance = boost_value_to_vk(boost_struct.draw_indirect_first_instance),
        depthClamp = boost_value_to_vk(boost_struct.depth_clamp),
        depthBiasClamp = boost_value_to_vk(boost_struct.depth_bias_clamp),
        fillModeNonSolid = boost_value_to_vk(boost_struct.fill_mode_non_solid),
        depthBounds = boost_value_to_vk(boost_struct.depth_bounds),
        wideLines = boost_value_to_vk(boost_struct.wide_lines),
        largePoints = boost_value_to_vk(boost_struct.large_points),
        alphaToOne = boost_value_to_vk(boost_struct.alpha_to_one),
        multiViewport = boost_value_to_vk(boost_struct.multi_viewport),
        samplerAnisotropy = boost_value_to_vk(boost_struct.sampler_anisotropy),
        textureCompressionETC2 = boost_value_to_vk(boost_struct.texture_compression_etc2),
        textureCompressionASTC_LDR = boost_value_to_vk(boost_struct.texture_compression_astc_ldr),
        textureCompressionBC = boost_value_to_vk(boost_struct.texture_compression_bc),
        occlusionQueryPrecise = boost_value_to_vk(boost_struct.occlusion_query_precise),
        pipelineStatisticsQuery = boost_value_to_vk(boost_struct.pipeline_statistics_query),
        vertexPipelineStoresAndAtomics = boost_value_to_vk(boost_struct.vertex_pipeline_stores_and_atomics),
        fragmentStoresAndAtomics = boost_value_to_vk(boost_struct.fragment_stores_and_atomics),
        shaderTessellationAndGeometryPointSize = boost_value_to_vk(boost_struct.shader_tessellation_and_geometry_point_size),
        shaderImageGatherExtended = boost_value_to_vk(boost_struct.shader_image_gather_extended),
        shaderStorageImageExtendedFormats = boost_value_to_vk(boost_struct.shader_storage_image_extended_formats),
        shaderStorageImageMultisample = boost_value_to_vk(boost_struct.shader_storage_image_multisample),
        shaderStorageImageReadWithoutFormat = boost_value_to_vk(boost_struct.shader_storage_image_read_without_format),
        shaderStorageImageWriteWithoutFormat = boost_value_to_vk(boost_struct.shader_storage_image_write_without_format),
        shaderUniformBufferArrayDynamicIndexing = boost_value_to_vk(boost_struct.shader_uniform_buffer_array_dynamic_indexing),
        shaderSampledImageArrayDynamicIndexing = boost_value_to_vk(boost_struct.shader_sampled_image_array_dynamic_indexing),
        shaderStorageBufferArrayDynamicIndexing = boost_value_to_vk(boost_struct.shader_storage_buffer_array_dynamic_indexing),
        shaderStorageImageArrayDynamicIndexing = boost_value_to_vk(boost_struct.shader_storage_image_array_dynamic_indexing),
        shaderClipDistance = boost_value_to_vk(boost_struct.shader_clip_distance),
        shaderCullDistance = boost_value_to_vk(boost_struct.shader_cull_distance),
        shaderFloat64 = boost_value_to_vk(boost_struct.shader_float_64),
        shaderInt64 = boost_value_to_vk(boost_struct.shader_int_64),
        shaderInt16 = boost_value_to_vk(boost_struct.shader_int_16),
        shaderResourceResidency = boost_value_to_vk(boost_struct.shader_resource_residency),
        shaderResourceMinLod = boost_value_to_vk(boost_struct.shader_resource_min_lod),
        sparseBinding = boost_value_to_vk(boost_struct.sparse_binding),
        sparseResidencyBuffer = boost_value_to_vk(boost_struct.sparse_residency_buffer),
        sparseResidencyImage2D = boost_value_to_vk(boost_struct.sparse_residency_image_2d_),
        sparseResidencyImage3D = boost_value_to_vk(boost_struct.sparse_residency_image_3d_),
        sparseResidency2Samples = boost_value_to_vk(boost_struct.sparse_residency_2samples),
        sparseResidency4Samples = boost_value_to_vk(boost_struct.sparse_residency_4samples),
        sparseResidency8Samples = boost_value_to_vk(boost_struct.sparse_residency_8samples),
        sparseResidency16Samples = boost_value_to_vk(boost_struct.sparse_residency_16samples),
        sparseResidencyAliased = boost_value_to_vk(boost_struct.sparse_residency_aliased),
        variableMultisampleRate = boost_value_to_vk(boost_struct.variable_multisample_rate),
        inheritedQueries = boost_value_to_vk(boost_struct.inherited_queries)
    ]]

def vk_view_destroy(var boost_struct : PhysicalDeviceFeatures)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkPhysicalDeviceFeatures) : PhysicalDeviceFeatures
    return <- [[PhysicalDeviceFeatures
        robust_buffer_access = vk_value_to_boost(vk_struct.robustBufferAccess),
        full_draw_index_uint_32 = vk_value_to_boost(vk_struct.fullDrawIndexUint32),
        image_cube_array = vk_value_to_boost(vk_struct.imageCubeArray),
        independent_blend = vk_value_to_boost(vk_struct.independentBlend),
        geometry_shader = vk_value_to_boost(vk_struct.geometryShader),
        tessellation_shader = vk_value_to_boost(vk_struct.tessellationShader),
        sample_rate_shading = vk_value_to_boost(vk_struct.sampleRateShading),
        dual_src_blend = vk_value_to_boost(vk_struct.dualSrcBlend),
        logic_op = vk_value_to_boost(vk_struct.logicOp),
        multi_draw_indirect = vk_value_to_boost(vk_struct.multiDrawIndirect),
        draw_indirect_first_instance = vk_value_to_boost(vk_struct.drawIndirectFirstInstance),
        depth_clamp = vk_value_to_boost(vk_struct.depthClamp),
        depth_bias_clamp = vk_value_to_boost(vk_struct.depthBiasClamp),
        fill_mode_non_solid = vk_value_to_boost(vk_struct.fillModeNonSolid),
        depth_bounds = vk_value_to_boost(vk_struct.depthBounds),
        wide_lines = vk_value_to_boost(vk_struct.wideLines),
        large_points = vk_value_to_boost(vk_struct.largePoints),
        alpha_to_one = vk_value_to_boost(vk_struct.alphaToOne),
        multi_viewport = vk_value_to_boost(vk_struct.multiViewport),
        sampler_anisotropy = vk_value_to_boost(vk_struct.samplerAnisotropy),
        texture_compression_etc2 = vk_value_to_boost(vk_struct.textureCompressionETC2),
        texture_compression_astc_ldr = vk_value_to_boost(vk_struct.textureCompressionASTC_LDR),
        texture_compression_bc = vk_value_to_boost(vk_struct.textureCompressionBC),
        occlusion_query_precise = vk_value_to_boost(vk_struct.occlusionQueryPrecise),
        pipeline_statistics_query = vk_value_to_boost(vk_struct.pipelineStatisticsQuery),
        vertex_pipeline_stores_and_atomics = vk_value_to_boost(vk_struct.vertexPipelineStoresAndAtomics),
        fragment_stores_and_atomics = vk_value_to_boost(vk_struct.fragmentStoresAndAtomics),
        shader_tessellation_and_geometry_point_size = vk_value_to_boost(vk_struct.shaderTessellationAndGeometryPointSize),
        shader_image_gather_extended = vk_value_to_boost(vk_struct.shaderImageGatherExtended),
        shader_storage_image_extended_formats = vk_value_to_boost(vk_struct.shaderStorageImageExtendedFormats),
        shader_storage_image_multisample = vk_value_to_boost(vk_struct.shaderStorageImageMultisample),
        shader_storage_image_read_without_format = vk_value_to_boost(vk_struct.shaderStorageImageReadWithoutFormat),
        shader_storage_image_write_without_format = vk_value_to_boost(vk_struct.shaderStorageImageWriteWithoutFormat),
        shader_uniform_buffer_array_dynamic_indexing = vk_value_to_boost(vk_struct.shaderUniformBufferArrayDynamicIndexing),
        shader_sampled_image_array_dynamic_indexing = vk_value_to_boost(vk_struct.shaderSampledImageArrayDynamicIndexing),
        shader_storage_buffer_array_dynamic_indexing = vk_value_to_boost(vk_struct.shaderStorageBufferArrayDynamicIndexing),
        shader_storage_image_array_dynamic_indexing = vk_value_to_boost(vk_struct.shaderStorageImageArrayDynamicIndexing),
        shader_clip_distance = vk_value_to_boost(vk_struct.shaderClipDistance),
        shader_cull_distance = vk_value_to_boost(vk_struct.shaderCullDistance),
        shader_float_64 = vk_value_to_boost(vk_struct.shaderFloat64),
        shader_int_64 = vk_value_to_boost(vk_struct.shaderInt64),
        shader_int_16 = vk_value_to_boost(vk_struct.shaderInt16),
        shader_resource_residency = vk_value_to_boost(vk_struct.shaderResourceResidency),
        shader_resource_min_lod = vk_value_to_boost(vk_struct.shaderResourceMinLod),
        sparse_binding = vk_value_to_boost(vk_struct.sparseBinding),
        sparse_residency_buffer = vk_value_to_boost(vk_struct.sparseResidencyBuffer),
        sparse_residency_image_2d_ = vk_value_to_boost(vk_struct.sparseResidencyImage2D),
        sparse_residency_image_3d_ = vk_value_to_boost(vk_struct.sparseResidencyImage3D),
        sparse_residency_2samples = vk_value_to_boost(vk_struct.sparseResidency2Samples),
        sparse_residency_4samples = vk_value_to_boost(vk_struct.sparseResidency4Samples),
        sparse_residency_8samples = vk_value_to_boost(vk_struct.sparseResidency8Samples),
        sparse_residency_16samples = vk_value_to_boost(vk_struct.sparseResidency16Samples),
        sparse_residency_aliased = vk_value_to_boost(vk_struct.sparseResidencyAliased),
        variable_multisample_rate = vk_value_to_boost(vk_struct.variableMultisampleRate),
        inherited_queries = vk_value_to_boost(vk_struct.inheritedQueries)
    ]]

//
// PhysicalDeviceLimits
//

struct PhysicalDeviceLimits
    max_image_dimension_1d : uint
    max_image_dimension_2d_ : uint
    max_image_dimension_3d_ : uint
    max_image_dimension_cube : uint
    max_image_array_layers : uint
    max_texel_buffer_elements : uint
    max_uniform_buffer_range : uint
    max_storage_buffer_range : uint
    max_push_constants_size : uint
    max_memory_allocation_count : uint
    max_sampler_allocation_count : uint
    buffer_image_granularity : uint64
    sparse_address_space_size : uint64
    max_bound_descriptor_sets : uint
    max_per_stage_descriptor_samplers : uint
    max_per_stage_descriptor_uniform_buffers : uint
    max_per_stage_descriptor_storage_buffers : uint
    max_per_stage_descriptor_sampled_images : uint
    max_per_stage_descriptor_storage_images : uint
    max_per_stage_descriptor_input_attachments : uint
    max_per_stage_resources : uint
    max_descriptor_set_samplers : uint
    max_descriptor_set_uniform_buffers : uint
    max_descriptor_set_uniform_buffers_dynamic : uint
    max_descriptor_set_storage_buffers : uint
    max_descriptor_set_storage_buffers_dynamic : uint
    max_descriptor_set_sampled_images : uint
    max_descriptor_set_storage_images : uint
    max_descriptor_set_input_attachments : uint
    max_vertex_input_attributes : uint
    max_vertex_input_bindings : uint
    max_vertex_input_attribute_offset : uint
    max_vertex_input_binding_stride : uint
    max_vertex_output_components : uint
    max_tessellation_generation_level : uint
    max_tessellation_patch_size : uint
    max_tessellation_control_per_vertex_input_components : uint
    max_tessellation_control_per_vertex_output_components : uint
    max_tessellation_control_per_patch_output_components : uint
    max_tessellation_control_total_output_components : uint
    max_tessellation_evaluation_input_components : uint
    max_tessellation_evaluation_output_components : uint
    max_geometry_shader_invocations : uint
    max_geometry_input_components : uint
    max_geometry_output_components : uint
    max_geometry_output_vertices : uint
    max_geometry_total_output_components : uint
    max_fragment_input_components : uint
    max_fragment_output_attachments : uint
    max_fragment_dual_src_attachments : uint
    max_fragment_combined_output_resources : uint
    max_compute_shared_memory_size : uint
    max_compute_work_group_count : uint [3]
    max_compute_work_group_invocations : uint
    max_compute_work_group_size : uint [3]
    sub_pixel_precision_bits : uint
    sub_texel_precision_bits : uint
    mipmap_precision_bits : uint
    max_draw_indexed_index_value : uint
    max_draw_indirect_count : uint
    max_sampler_lod_bias : float
    max_sampler_anisotropy : float
    max_viewports : uint
    max_viewport_dimensions : uint [2]
    viewport_bounds_range : float [2]
    viewport_sub_pixel_bits : uint
    min_memory_map_alignment : uint64
    min_texel_buffer_offset_alignment : uint64
    min_uniform_buffer_offset_alignment : uint64
    min_storage_buffer_offset_alignment : uint64
    min_texel_offset : int
    max_texel_offset : uint
    min_texel_gather_offset : int
    max_texel_gather_offset : uint
    min_interpolation_offset : float
    max_interpolation_offset : float
    sub_pixel_interpolation_offset_bits : uint
    max_framebuffer_width : uint
    max_framebuffer_height : uint
    max_framebuffer_layers : uint
    framebuffer_color_sample_counts : uint
    framebuffer_depth_sample_counts : uint
    framebuffer_stencil_sample_counts : uint
    framebuffer_no_attachments_sample_counts : uint
    max_color_attachments : uint
    sampled_image_color_sample_counts : uint
    sampled_image_integer_sample_counts : uint
    sampled_image_depth_sample_counts : uint
    sampled_image_stencil_sample_counts : uint
    storage_image_sample_counts : uint
    max_sample_mask_words : uint
    timestamp_compute_and_graphics : uint
    timestamp_period : float
    max_clip_distances : uint
    max_cull_distances : uint
    max_combined_clip_and_cull_distances : uint
    discrete_queue_priorities : uint
    point_size_range : float [2]
    line_width_range : float [2]
    point_size_granularity : float
    line_width_granularity : float
    strict_lines : uint
    standard_sample_locations : uint
    optimal_buffer_copy_offset_alignment : uint64
    optimal_buffer_copy_row_pitch_alignment : uint64
    non_coherent_atom_size : uint64
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PhysicalDeviceLimits
) : VkPhysicalDeviceLimits

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPhysicalDeviceLimits
        maxImageDimension1D = boost_value_to_vk(boost_struct.max_image_dimension_1d),
        maxImageDimension2D = boost_value_to_vk(boost_struct.max_image_dimension_2d_),
        maxImageDimension3D = boost_value_to_vk(boost_struct.max_image_dimension_3d_),
        maxImageDimensionCube = boost_value_to_vk(boost_struct.max_image_dimension_cube),
        maxImageArrayLayers = boost_value_to_vk(boost_struct.max_image_array_layers),
        maxTexelBufferElements = boost_value_to_vk(boost_struct.max_texel_buffer_elements),
        maxUniformBufferRange = boost_value_to_vk(boost_struct.max_uniform_buffer_range),
        maxStorageBufferRange = boost_value_to_vk(boost_struct.max_storage_buffer_range),
        maxPushConstantsSize = boost_value_to_vk(boost_struct.max_push_constants_size),
        maxMemoryAllocationCount = boost_value_to_vk(boost_struct.max_memory_allocation_count),
        maxSamplerAllocationCount = boost_value_to_vk(boost_struct.max_sampler_allocation_count),
        bufferImageGranularity = boost_value_to_vk(boost_struct.buffer_image_granularity),
        sparseAddressSpaceSize = boost_value_to_vk(boost_struct.sparse_address_space_size),
        maxBoundDescriptorSets = boost_value_to_vk(boost_struct.max_bound_descriptor_sets),
        maxPerStageDescriptorSamplers = boost_value_to_vk(boost_struct.max_per_stage_descriptor_samplers),
        maxPerStageDescriptorUniformBuffers = boost_value_to_vk(boost_struct.max_per_stage_descriptor_uniform_buffers),
        maxPerStageDescriptorStorageBuffers = boost_value_to_vk(boost_struct.max_per_stage_descriptor_storage_buffers),
        maxPerStageDescriptorSampledImages = boost_value_to_vk(boost_struct.max_per_stage_descriptor_sampled_images),
        maxPerStageDescriptorStorageImages = boost_value_to_vk(boost_struct.max_per_stage_descriptor_storage_images),
        maxPerStageDescriptorInputAttachments = boost_value_to_vk(boost_struct.max_per_stage_descriptor_input_attachments),
        maxPerStageResources = boost_value_to_vk(boost_struct.max_per_stage_resources),
        maxDescriptorSetSamplers = boost_value_to_vk(boost_struct.max_descriptor_set_samplers),
        maxDescriptorSetUniformBuffers = boost_value_to_vk(boost_struct.max_descriptor_set_uniform_buffers),
        maxDescriptorSetUniformBuffersDynamic = boost_value_to_vk(boost_struct.max_descriptor_set_uniform_buffers_dynamic),
        maxDescriptorSetStorageBuffers = boost_value_to_vk(boost_struct.max_descriptor_set_storage_buffers),
        maxDescriptorSetStorageBuffersDynamic = boost_value_to_vk(boost_struct.max_descriptor_set_storage_buffers_dynamic),
        maxDescriptorSetSampledImages = boost_value_to_vk(boost_struct.max_descriptor_set_sampled_images),
        maxDescriptorSetStorageImages = boost_value_to_vk(boost_struct.max_descriptor_set_storage_images),
        maxDescriptorSetInputAttachments = boost_value_to_vk(boost_struct.max_descriptor_set_input_attachments),
        maxVertexInputAttributes = boost_value_to_vk(boost_struct.max_vertex_input_attributes),
        maxVertexInputBindings = boost_value_to_vk(boost_struct.max_vertex_input_bindings),
        maxVertexInputAttributeOffset = boost_value_to_vk(boost_struct.max_vertex_input_attribute_offset),
        maxVertexInputBindingStride = boost_value_to_vk(boost_struct.max_vertex_input_binding_stride),
        maxVertexOutputComponents = boost_value_to_vk(boost_struct.max_vertex_output_components),
        maxTessellationGenerationLevel = boost_value_to_vk(boost_struct.max_tessellation_generation_level),
        maxTessellationPatchSize = boost_value_to_vk(boost_struct.max_tessellation_patch_size),
        maxTessellationControlPerVertexInputComponents = boost_value_to_vk(boost_struct.max_tessellation_control_per_vertex_input_components),
        maxTessellationControlPerVertexOutputComponents = boost_value_to_vk(boost_struct.max_tessellation_control_per_vertex_output_components),
        maxTessellationControlPerPatchOutputComponents = boost_value_to_vk(boost_struct.max_tessellation_control_per_patch_output_components),
        maxTessellationControlTotalOutputComponents = boost_value_to_vk(boost_struct.max_tessellation_control_total_output_components),
        maxTessellationEvaluationInputComponents = boost_value_to_vk(boost_struct.max_tessellation_evaluation_input_components),
        maxTessellationEvaluationOutputComponents = boost_value_to_vk(boost_struct.max_tessellation_evaluation_output_components),
        maxGeometryShaderInvocations = boost_value_to_vk(boost_struct.max_geometry_shader_invocations),
        maxGeometryInputComponents = boost_value_to_vk(boost_struct.max_geometry_input_components),
        maxGeometryOutputComponents = boost_value_to_vk(boost_struct.max_geometry_output_components),
        maxGeometryOutputVertices = boost_value_to_vk(boost_struct.max_geometry_output_vertices),
        maxGeometryTotalOutputComponents = boost_value_to_vk(boost_struct.max_geometry_total_output_components),
        maxFragmentInputComponents = boost_value_to_vk(boost_struct.max_fragment_input_components),
        maxFragmentOutputAttachments = boost_value_to_vk(boost_struct.max_fragment_output_attachments),
        maxFragmentDualSrcAttachments = boost_value_to_vk(boost_struct.max_fragment_dual_src_attachments),
        maxFragmentCombinedOutputResources = boost_value_to_vk(boost_struct.max_fragment_combined_output_resources),
        maxComputeSharedMemorySize = boost_value_to_vk(boost_struct.max_compute_shared_memory_size),
        maxComputeWorkGroupCount = boost_value_to_vk(boost_struct.max_compute_work_group_count),
        maxComputeWorkGroupInvocations = boost_value_to_vk(boost_struct.max_compute_work_group_invocations),
        maxComputeWorkGroupSize = boost_value_to_vk(boost_struct.max_compute_work_group_size),
        subPixelPrecisionBits = boost_value_to_vk(boost_struct.sub_pixel_precision_bits),
        subTexelPrecisionBits = boost_value_to_vk(boost_struct.sub_texel_precision_bits),
        mipmapPrecisionBits = boost_value_to_vk(boost_struct.mipmap_precision_bits),
        maxDrawIndexedIndexValue = boost_value_to_vk(boost_struct.max_draw_indexed_index_value),
        maxDrawIndirectCount = boost_value_to_vk(boost_struct.max_draw_indirect_count),
        maxSamplerLodBias = boost_value_to_vk(boost_struct.max_sampler_lod_bias),
        maxSamplerAnisotropy = boost_value_to_vk(boost_struct.max_sampler_anisotropy),
        maxViewports = boost_value_to_vk(boost_struct.max_viewports),
        maxViewportDimensions = boost_value_to_vk(boost_struct.max_viewport_dimensions),
        viewportBoundsRange = boost_value_to_vk(boost_struct.viewport_bounds_range),
        viewportSubPixelBits = boost_value_to_vk(boost_struct.viewport_sub_pixel_bits),
        minMemoryMapAlignment = boost_value_to_vk(boost_struct.min_memory_map_alignment),
        minTexelBufferOffsetAlignment = boost_value_to_vk(boost_struct.min_texel_buffer_offset_alignment),
        minUniformBufferOffsetAlignment = boost_value_to_vk(boost_struct.min_uniform_buffer_offset_alignment),
        minStorageBufferOffsetAlignment = boost_value_to_vk(boost_struct.min_storage_buffer_offset_alignment),
        minTexelOffset = boost_value_to_vk(boost_struct.min_texel_offset),
        maxTexelOffset = boost_value_to_vk(boost_struct.max_texel_offset),
        minTexelGatherOffset = boost_value_to_vk(boost_struct.min_texel_gather_offset),
        maxTexelGatherOffset = boost_value_to_vk(boost_struct.max_texel_gather_offset),
        minInterpolationOffset = boost_value_to_vk(boost_struct.min_interpolation_offset),
        maxInterpolationOffset = boost_value_to_vk(boost_struct.max_interpolation_offset),
        subPixelInterpolationOffsetBits = boost_value_to_vk(boost_struct.sub_pixel_interpolation_offset_bits),
        maxFramebufferWidth = boost_value_to_vk(boost_struct.max_framebuffer_width),
        maxFramebufferHeight = boost_value_to_vk(boost_struct.max_framebuffer_height),
        maxFramebufferLayers = boost_value_to_vk(boost_struct.max_framebuffer_layers),
        framebufferColorSampleCounts = boost_value_to_vk(boost_struct.framebuffer_color_sample_counts),
        framebufferDepthSampleCounts = boost_value_to_vk(boost_struct.framebuffer_depth_sample_counts),
        framebufferStencilSampleCounts = boost_value_to_vk(boost_struct.framebuffer_stencil_sample_counts),
        framebufferNoAttachmentsSampleCounts = boost_value_to_vk(boost_struct.framebuffer_no_attachments_sample_counts),
        maxColorAttachments = boost_value_to_vk(boost_struct.max_color_attachments),
        sampledImageColorSampleCounts = boost_value_to_vk(boost_struct.sampled_image_color_sample_counts),
        sampledImageIntegerSampleCounts = boost_value_to_vk(boost_struct.sampled_image_integer_sample_counts),
        sampledImageDepthSampleCounts = boost_value_to_vk(boost_struct.sampled_image_depth_sample_counts),
        sampledImageStencilSampleCounts = boost_value_to_vk(boost_struct.sampled_image_stencil_sample_counts),
        storageImageSampleCounts = boost_value_to_vk(boost_struct.storage_image_sample_counts),
        maxSampleMaskWords = boost_value_to_vk(boost_struct.max_sample_mask_words),
        timestampComputeAndGraphics = boost_value_to_vk(boost_struct.timestamp_compute_and_graphics),
        timestampPeriod = boost_value_to_vk(boost_struct.timestamp_period),
        maxClipDistances = boost_value_to_vk(boost_struct.max_clip_distances),
        maxCullDistances = boost_value_to_vk(boost_struct.max_cull_distances),
        maxCombinedClipAndCullDistances = boost_value_to_vk(boost_struct.max_combined_clip_and_cull_distances),
        discreteQueuePriorities = boost_value_to_vk(boost_struct.discrete_queue_priorities),
        pointSizeRange = boost_value_to_vk(boost_struct.point_size_range),
        lineWidthRange = boost_value_to_vk(boost_struct.line_width_range),
        pointSizeGranularity = boost_value_to_vk(boost_struct.point_size_granularity),
        lineWidthGranularity = boost_value_to_vk(boost_struct.line_width_granularity),
        strictLines = boost_value_to_vk(boost_struct.strict_lines),
        standardSampleLocations = boost_value_to_vk(boost_struct.standard_sample_locations),
        optimalBufferCopyOffsetAlignment = boost_value_to_vk(boost_struct.optimal_buffer_copy_offset_alignment),
        optimalBufferCopyRowPitchAlignment = boost_value_to_vk(boost_struct.optimal_buffer_copy_row_pitch_alignment),
        nonCoherentAtomSize = boost_value_to_vk(boost_struct.non_coherent_atom_size)
    ]]

def vk_view_destroy(var boost_struct : PhysicalDeviceLimits)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkPhysicalDeviceLimits) : PhysicalDeviceLimits
    return <- [[PhysicalDeviceLimits
        max_image_dimension_1d = vk_value_to_boost(vk_struct.maxImageDimension1D),
        max_image_dimension_2d_ = vk_value_to_boost(vk_struct.maxImageDimension2D),
        max_image_dimension_3d_ = vk_value_to_boost(vk_struct.maxImageDimension3D),
        max_image_dimension_cube = vk_value_to_boost(vk_struct.maxImageDimensionCube),
        max_image_array_layers = vk_value_to_boost(vk_struct.maxImageArrayLayers),
        max_texel_buffer_elements = vk_value_to_boost(vk_struct.maxTexelBufferElements),
        max_uniform_buffer_range = vk_value_to_boost(vk_struct.maxUniformBufferRange),
        max_storage_buffer_range = vk_value_to_boost(vk_struct.maxStorageBufferRange),
        max_push_constants_size = vk_value_to_boost(vk_struct.maxPushConstantsSize),
        max_memory_allocation_count = vk_value_to_boost(vk_struct.maxMemoryAllocationCount),
        max_sampler_allocation_count = vk_value_to_boost(vk_struct.maxSamplerAllocationCount),
        buffer_image_granularity = vk_value_to_boost(vk_struct.bufferImageGranularity),
        sparse_address_space_size = vk_value_to_boost(vk_struct.sparseAddressSpaceSize),
        max_bound_descriptor_sets = vk_value_to_boost(vk_struct.maxBoundDescriptorSets),
        max_per_stage_descriptor_samplers = vk_value_to_boost(vk_struct.maxPerStageDescriptorSamplers),
        max_per_stage_descriptor_uniform_buffers = vk_value_to_boost(vk_struct.maxPerStageDescriptorUniformBuffers),
        max_per_stage_descriptor_storage_buffers = vk_value_to_boost(vk_struct.maxPerStageDescriptorStorageBuffers),
        max_per_stage_descriptor_sampled_images = vk_value_to_boost(vk_struct.maxPerStageDescriptorSampledImages),
        max_per_stage_descriptor_storage_images = vk_value_to_boost(vk_struct.maxPerStageDescriptorStorageImages),
        max_per_stage_descriptor_input_attachments = vk_value_to_boost(vk_struct.maxPerStageDescriptorInputAttachments),
        max_per_stage_resources = vk_value_to_boost(vk_struct.maxPerStageResources),
        max_descriptor_set_samplers = vk_value_to_boost(vk_struct.maxDescriptorSetSamplers),
        max_descriptor_set_uniform_buffers = vk_value_to_boost(vk_struct.maxDescriptorSetUniformBuffers),
        max_descriptor_set_uniform_buffers_dynamic = vk_value_to_boost(vk_struct.maxDescriptorSetUniformBuffersDynamic),
        max_descriptor_set_storage_buffers = vk_value_to_boost(vk_struct.maxDescriptorSetStorageBuffers),
        max_descriptor_set_storage_buffers_dynamic = vk_value_to_boost(vk_struct.maxDescriptorSetStorageBuffersDynamic),
        max_descriptor_set_sampled_images = vk_value_to_boost(vk_struct.maxDescriptorSetSampledImages),
        max_descriptor_set_storage_images = vk_value_to_boost(vk_struct.maxDescriptorSetStorageImages),
        max_descriptor_set_input_attachments = vk_value_to_boost(vk_struct.maxDescriptorSetInputAttachments),
        max_vertex_input_attributes = vk_value_to_boost(vk_struct.maxVertexInputAttributes),
        max_vertex_input_bindings = vk_value_to_boost(vk_struct.maxVertexInputBindings),
        max_vertex_input_attribute_offset = vk_value_to_boost(vk_struct.maxVertexInputAttributeOffset),
        max_vertex_input_binding_stride = vk_value_to_boost(vk_struct.maxVertexInputBindingStride),
        max_vertex_output_components = vk_value_to_boost(vk_struct.maxVertexOutputComponents),
        max_tessellation_generation_level = vk_value_to_boost(vk_struct.maxTessellationGenerationLevel),
        max_tessellation_patch_size = vk_value_to_boost(vk_struct.maxTessellationPatchSize),
        max_tessellation_control_per_vertex_input_components = vk_value_to_boost(vk_struct.maxTessellationControlPerVertexInputComponents),
        max_tessellation_control_per_vertex_output_components = vk_value_to_boost(vk_struct.maxTessellationControlPerVertexOutputComponents),
        max_tessellation_control_per_patch_output_components = vk_value_to_boost(vk_struct.maxTessellationControlPerPatchOutputComponents),
        max_tessellation_control_total_output_components = vk_value_to_boost(vk_struct.maxTessellationControlTotalOutputComponents),
        max_tessellation_evaluation_input_components = vk_value_to_boost(vk_struct.maxTessellationEvaluationInputComponents),
        max_tessellation_evaluation_output_components = vk_value_to_boost(vk_struct.maxTessellationEvaluationOutputComponents),
        max_geometry_shader_invocations = vk_value_to_boost(vk_struct.maxGeometryShaderInvocations),
        max_geometry_input_components = vk_value_to_boost(vk_struct.maxGeometryInputComponents),
        max_geometry_output_components = vk_value_to_boost(vk_struct.maxGeometryOutputComponents),
        max_geometry_output_vertices = vk_value_to_boost(vk_struct.maxGeometryOutputVertices),
        max_geometry_total_output_components = vk_value_to_boost(vk_struct.maxGeometryTotalOutputComponents),
        max_fragment_input_components = vk_value_to_boost(vk_struct.maxFragmentInputComponents),
        max_fragment_output_attachments = vk_value_to_boost(vk_struct.maxFragmentOutputAttachments),
        max_fragment_dual_src_attachments = vk_value_to_boost(vk_struct.maxFragmentDualSrcAttachments),
        max_fragment_combined_output_resources = vk_value_to_boost(vk_struct.maxFragmentCombinedOutputResources),
        max_compute_shared_memory_size = vk_value_to_boost(vk_struct.maxComputeSharedMemorySize),
        max_compute_work_group_count = vk_value_to_boost(vk_struct.maxComputeWorkGroupCount),
        max_compute_work_group_invocations = vk_value_to_boost(vk_struct.maxComputeWorkGroupInvocations),
        max_compute_work_group_size = vk_value_to_boost(vk_struct.maxComputeWorkGroupSize),
        sub_pixel_precision_bits = vk_value_to_boost(vk_struct.subPixelPrecisionBits),
        sub_texel_precision_bits = vk_value_to_boost(vk_struct.subTexelPrecisionBits),
        mipmap_precision_bits = vk_value_to_boost(vk_struct.mipmapPrecisionBits),
        max_draw_indexed_index_value = vk_value_to_boost(vk_struct.maxDrawIndexedIndexValue),
        max_draw_indirect_count = vk_value_to_boost(vk_struct.maxDrawIndirectCount),
        max_sampler_lod_bias = vk_value_to_boost(vk_struct.maxSamplerLodBias),
        max_sampler_anisotropy = vk_value_to_boost(vk_struct.maxSamplerAnisotropy),
        max_viewports = vk_value_to_boost(vk_struct.maxViewports),
        max_viewport_dimensions = vk_value_to_boost(vk_struct.maxViewportDimensions),
        viewport_bounds_range = vk_value_to_boost(vk_struct.viewportBoundsRange),
        viewport_sub_pixel_bits = vk_value_to_boost(vk_struct.viewportSubPixelBits),
        min_memory_map_alignment = vk_value_to_boost(vk_struct.minMemoryMapAlignment),
        min_texel_buffer_offset_alignment = vk_value_to_boost(vk_struct.minTexelBufferOffsetAlignment),
        min_uniform_buffer_offset_alignment = vk_value_to_boost(vk_struct.minUniformBufferOffsetAlignment),
        min_storage_buffer_offset_alignment = vk_value_to_boost(vk_struct.minStorageBufferOffsetAlignment),
        min_texel_offset = vk_value_to_boost(vk_struct.minTexelOffset),
        max_texel_offset = vk_value_to_boost(vk_struct.maxTexelOffset),
        min_texel_gather_offset = vk_value_to_boost(vk_struct.minTexelGatherOffset),
        max_texel_gather_offset = vk_value_to_boost(vk_struct.maxTexelGatherOffset),
        min_interpolation_offset = vk_value_to_boost(vk_struct.minInterpolationOffset),
        max_interpolation_offset = vk_value_to_boost(vk_struct.maxInterpolationOffset),
        sub_pixel_interpolation_offset_bits = vk_value_to_boost(vk_struct.subPixelInterpolationOffsetBits),
        max_framebuffer_width = vk_value_to_boost(vk_struct.maxFramebufferWidth),
        max_framebuffer_height = vk_value_to_boost(vk_struct.maxFramebufferHeight),
        max_framebuffer_layers = vk_value_to_boost(vk_struct.maxFramebufferLayers),
        framebuffer_color_sample_counts = vk_value_to_boost(vk_struct.framebufferColorSampleCounts),
        framebuffer_depth_sample_counts = vk_value_to_boost(vk_struct.framebufferDepthSampleCounts),
        framebuffer_stencil_sample_counts = vk_value_to_boost(vk_struct.framebufferStencilSampleCounts),
        framebuffer_no_attachments_sample_counts = vk_value_to_boost(vk_struct.framebufferNoAttachmentsSampleCounts),
        max_color_attachments = vk_value_to_boost(vk_struct.maxColorAttachments),
        sampled_image_color_sample_counts = vk_value_to_boost(vk_struct.sampledImageColorSampleCounts),
        sampled_image_integer_sample_counts = vk_value_to_boost(vk_struct.sampledImageIntegerSampleCounts),
        sampled_image_depth_sample_counts = vk_value_to_boost(vk_struct.sampledImageDepthSampleCounts),
        sampled_image_stencil_sample_counts = vk_value_to_boost(vk_struct.sampledImageStencilSampleCounts),
        storage_image_sample_counts = vk_value_to_boost(vk_struct.storageImageSampleCounts),
        max_sample_mask_words = vk_value_to_boost(vk_struct.maxSampleMaskWords),
        timestamp_compute_and_graphics = vk_value_to_boost(vk_struct.timestampComputeAndGraphics),
        timestamp_period = vk_value_to_boost(vk_struct.timestampPeriod),
        max_clip_distances = vk_value_to_boost(vk_struct.maxClipDistances),
        max_cull_distances = vk_value_to_boost(vk_struct.maxCullDistances),
        max_combined_clip_and_cull_distances = vk_value_to_boost(vk_struct.maxCombinedClipAndCullDistances),
        discrete_queue_priorities = vk_value_to_boost(vk_struct.discreteQueuePriorities),
        point_size_range = vk_value_to_boost(vk_struct.pointSizeRange),
        line_width_range = vk_value_to_boost(vk_struct.lineWidthRange),
        point_size_granularity = vk_value_to_boost(vk_struct.pointSizeGranularity),
        line_width_granularity = vk_value_to_boost(vk_struct.lineWidthGranularity),
        strict_lines = vk_value_to_boost(vk_struct.strictLines),
        standard_sample_locations = vk_value_to_boost(vk_struct.standardSampleLocations),
        optimal_buffer_copy_offset_alignment = vk_value_to_boost(vk_struct.optimalBufferCopyOffsetAlignment),
        optimal_buffer_copy_row_pitch_alignment = vk_value_to_boost(vk_struct.optimalBufferCopyRowPitchAlignment),
        non_coherent_atom_size = vk_value_to_boost(vk_struct.nonCoherentAtomSize)
    ]]

//
// PhysicalDeviceSparseProperties
//

struct PhysicalDeviceSparseProperties
    residency_standard_2d_block_shape : uint
    residency_standard_2d_multisample_block_shape : uint
    residency_standard_3d_block_shape : uint
    residency_aligned_mip_size : uint
    residency_non_resident_strict : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PhysicalDeviceSparseProperties
) : VkPhysicalDeviceSparseProperties

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPhysicalDeviceSparseProperties
        residencyStandard2DBlockShape = boost_value_to_vk(boost_struct.residency_standard_2d_block_shape),
        residencyStandard2DMultisampleBlockShape = boost_value_to_vk(boost_struct.residency_standard_2d_multisample_block_shape),
        residencyStandard3DBlockShape = boost_value_to_vk(boost_struct.residency_standard_3d_block_shape),
        residencyAlignedMipSize = boost_value_to_vk(boost_struct.residency_aligned_mip_size),
        residencyNonResidentStrict = boost_value_to_vk(boost_struct.residency_non_resident_strict)
    ]]

def vk_view_destroy(var boost_struct : PhysicalDeviceSparseProperties)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkPhysicalDeviceSparseProperties) : PhysicalDeviceSparseProperties
    return <- [[PhysicalDeviceSparseProperties
        residency_standard_2d_block_shape = vk_value_to_boost(vk_struct.residencyStandard2DBlockShape),
        residency_standard_2d_multisample_block_shape = vk_value_to_boost(vk_struct.residencyStandard2DMultisampleBlockShape),
        residency_standard_3d_block_shape = vk_value_to_boost(vk_struct.residencyStandard3DBlockShape),
        residency_aligned_mip_size = vk_value_to_boost(vk_struct.residencyAlignedMipSize),
        residency_non_resident_strict = vk_value_to_boost(vk_struct.residencyNonResidentStrict)
    ]]

//
// PushConstantRange
//

struct PushConstantRange
    stage_flags : uint
    offset : uint
    size : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PushConstantRange
) : VkPushConstantRange

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPushConstantRange
        stageFlags = boost_value_to_vk(boost_struct.stage_flags),
        offset = boost_value_to_vk(boost_struct.offset),
        size = boost_value_to_vk(boost_struct.size)
    ]]

def vk_view_destroy(var boost_struct : PushConstantRange)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkPushConstantRange) : PushConstantRange
    return <- [[PushConstantRange
        stage_flags = vk_value_to_boost(vk_struct.stageFlags),
        offset = vk_value_to_boost(vk_struct.offset),
        size = vk_value_to_boost(vk_struct.size)
    ]]

//
// QueueFamilyProperties
//

struct QueueFamilyProperties
    queue_flags : uint
    queue_count : uint
    timestamp_valid_bits : uint
    min_image_transfer_granularity : Extent3D
    _vk_view_p_min_image_transfer_granularity : VkExtent3D ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : QueueFamilyProperties
) : VkQueueFamilyProperties

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_min_image_transfer_granularity = new VkExtent3D
    *(boost_struct._vk_view_p_min_image_transfer_granularity) <- (
        boost_struct.min_image_transfer_granularity |> vk_view_create_unsafe())
    return <- [[ VkQueueFamilyProperties
        queueFlags = boost_value_to_vk(boost_struct.queue_flags),
        queueCount = boost_value_to_vk(boost_struct.queue_count),
        timestampValidBits = boost_value_to_vk(boost_struct.timestamp_valid_bits),
        minImageTransferGranularity = *(boost_struct._vk_view_p_min_image_transfer_granularity)
    ]]

def vk_view_destroy(var boost_struct : QueueFamilyProperties)
    assert(boost_struct._vk_view__active)
    boost_struct.min_image_transfer_granularity |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_min_image_transfer_granularity
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkQueueFamilyProperties) : QueueFamilyProperties
    return <- [[QueueFamilyProperties
        queue_flags = vk_value_to_boost(vk_struct.queueFlags),
        queue_count = vk_value_to_boost(vk_struct.queueCount),
        timestamp_valid_bits = vk_value_to_boost(vk_struct.timestampValidBits),
        min_image_transfer_granularity <- vk_value_to_boost(vk_struct.minImageTransferGranularity)
    ]]

//
// Rect2D
//

struct Rect2D
    offset : Offset2D
    extent : Extent2D
    _vk_view_p_offset : VkOffset2D ?
    _vk_view_p_extent : VkExtent2D ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Rect2D
) : VkRect2D

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_offset = new VkOffset2D
    *(boost_struct._vk_view_p_offset) <- (
        boost_struct.offset |> vk_view_create_unsafe())
    boost_struct._vk_view_p_extent = new VkExtent2D
    *(boost_struct._vk_view_p_extent) <- (
        boost_struct.extent |> vk_view_create_unsafe())
    return <- [[ VkRect2D
        offset = *(boost_struct._vk_view_p_offset),
        extent = *(boost_struct._vk_view_p_extent)
    ]]

def vk_view_destroy(var boost_struct : Rect2D)
    assert(boost_struct._vk_view__active)
    boost_struct.offset |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_offset
    boost_struct.extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_extent
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkRect2D) : Rect2D
    return <- [[Rect2D
        offset <- vk_value_to_boost(vk_struct.offset),
        extent <- vk_value_to_boost(vk_struct.extent)
    ]]

//
// SubpassDependency
//

struct SubpassDependency
    src_subpass : uint
    dst_subpass : uint
    src_stage_mask : uint
    dst_stage_mask : uint
    src_access_mask : uint
    dst_access_mask : uint
    dependency_flags : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SubpassDependency
) : VkSubpassDependency

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkSubpassDependency
        srcSubpass = boost_value_to_vk(boost_struct.src_subpass),
        dstSubpass = boost_value_to_vk(boost_struct.dst_subpass),
        srcStageMask = boost_value_to_vk(boost_struct.src_stage_mask),
        dstStageMask = boost_value_to_vk(boost_struct.dst_stage_mask),
        srcAccessMask = boost_value_to_vk(boost_struct.src_access_mask),
        dstAccessMask = boost_value_to_vk(boost_struct.dst_access_mask),
        dependencyFlags = boost_value_to_vk(boost_struct.dependency_flags)
    ]]

def vk_view_destroy(var boost_struct : SubpassDependency)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkSubpassDependency) : SubpassDependency
    return <- [[SubpassDependency
        src_subpass = vk_value_to_boost(vk_struct.srcSubpass),
        dst_subpass = vk_value_to_boost(vk_struct.dstSubpass),
        src_stage_mask = vk_value_to_boost(vk_struct.srcStageMask),
        dst_stage_mask = vk_value_to_boost(vk_struct.dstStageMask),
        src_access_mask = vk_value_to_boost(vk_struct.srcAccessMask),
        dst_access_mask = vk_value_to_boost(vk_struct.dstAccessMask),
        dependency_flags = vk_value_to_boost(vk_struct.dependencyFlags)
    ]]

//
// SurfaceCapabilitiesKHR
//

struct SurfaceCapabilitiesKHR
    min_image_count : uint
    max_image_count : uint
    current_extent : Extent2D
    min_image_extent : Extent2D
    max_image_extent : Extent2D
    max_image_array_layers : uint
    supported_transforms : uint
    current_transform : VkSurfaceTransformFlagBitsKHR
    supported_composite_alpha : uint
    supported_usage_flags : uint
    _vk_view_p_current_extent : VkExtent2D ?
    _vk_view_p_min_image_extent : VkExtent2D ?
    _vk_view_p_max_image_extent : VkExtent2D ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SurfaceCapabilitiesKHR
) : VkSurfaceCapabilitiesKHR

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_current_extent = new VkExtent2D
    *(boost_struct._vk_view_p_current_extent) <- (
        boost_struct.current_extent |> vk_view_create_unsafe())
    boost_struct._vk_view_p_min_image_extent = new VkExtent2D
    *(boost_struct._vk_view_p_min_image_extent) <- (
        boost_struct.min_image_extent |> vk_view_create_unsafe())
    boost_struct._vk_view_p_max_image_extent = new VkExtent2D
    *(boost_struct._vk_view_p_max_image_extent) <- (
        boost_struct.max_image_extent |> vk_view_create_unsafe())
    return <- [[ VkSurfaceCapabilitiesKHR
        minImageCount = boost_value_to_vk(boost_struct.min_image_count),
        maxImageCount = boost_value_to_vk(boost_struct.max_image_count),
        currentExtent = *(boost_struct._vk_view_p_current_extent),
        minImageExtent = *(boost_struct._vk_view_p_min_image_extent),
        maxImageExtent = *(boost_struct._vk_view_p_max_image_extent),
        maxImageArrayLayers = boost_value_to_vk(boost_struct.max_image_array_layers),
        supportedTransforms = boost_value_to_vk(boost_struct.supported_transforms),
        currentTransform = boost_value_to_vk(boost_struct.current_transform),
        supportedCompositeAlpha = boost_value_to_vk(boost_struct.supported_composite_alpha),
        supportedUsageFlags = boost_value_to_vk(boost_struct.supported_usage_flags)
    ]]

def vk_view_destroy(var boost_struct : SurfaceCapabilitiesKHR)
    assert(boost_struct._vk_view__active)
    boost_struct.current_extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_current_extent
    boost_struct.min_image_extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_min_image_extent
    boost_struct.max_image_extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_max_image_extent
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkSurfaceCapabilitiesKHR) : SurfaceCapabilitiesKHR
    return <- [[SurfaceCapabilitiesKHR
        min_image_count = vk_value_to_boost(vk_struct.minImageCount),
        max_image_count = vk_value_to_boost(vk_struct.maxImageCount),
        current_extent <- vk_value_to_boost(vk_struct.currentExtent),
        min_image_extent <- vk_value_to_boost(vk_struct.minImageExtent),
        max_image_extent <- vk_value_to_boost(vk_struct.maxImageExtent),
        max_image_array_layers = vk_value_to_boost(vk_struct.maxImageArrayLayers),
        supported_transforms = vk_value_to_boost(vk_struct.supportedTransforms),
        current_transform = vk_value_to_boost(vk_struct.currentTransform),
        supported_composite_alpha = vk_value_to_boost(vk_struct.supportedCompositeAlpha),
        supported_usage_flags = vk_value_to_boost(vk_struct.supportedUsageFlags)
    ]]

//
// SurfaceFormatKHR
//

struct SurfaceFormatKHR
    format : VkFormat
    color_space : VkColorSpaceKHR
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SurfaceFormatKHR
) : VkSurfaceFormatKHR

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkSurfaceFormatKHR
        format = boost_value_to_vk(boost_struct.format),
        colorSpace = boost_value_to_vk(boost_struct.color_space)
    ]]

def vk_view_destroy(var boost_struct : SurfaceFormatKHR)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkSurfaceFormatKHR) : SurfaceFormatKHR
    return <- [[SurfaceFormatKHR
        format = vk_value_to_boost(vk_struct.format),
        color_space = vk_value_to_boost(vk_struct.colorSpace)
    ]]

//
// Viewport
//

struct Viewport
    x : float
    y : float
    width : float
    height : float
    min_depth : float
    max_depth : float
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Viewport
) : VkViewport

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkViewport
        x = boost_value_to_vk(boost_struct.x),
        y = boost_value_to_vk(boost_struct.y),
        width = boost_value_to_vk(boost_struct.width),
        height = boost_value_to_vk(boost_struct.height),
        minDepth = boost_value_to_vk(boost_struct.min_depth),
        maxDepth = boost_value_to_vk(boost_struct.max_depth)
    ]]

def vk_view_destroy(var boost_struct : Viewport)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkViewport) : Viewport
    return <- [[Viewport
        x = vk_value_to_boost(vk_struct.x),
        y = vk_value_to_boost(vk_struct.y),
        width = vk_value_to_boost(vk_struct.width),
        height = vk_value_to_boost(vk_struct.height),
        min_depth = vk_value_to_boost(vk_struct.minDepth),
        max_depth = vk_value_to_boost(vk_struct.maxDepth)
    ]]

//
// ExtensionProperties
//

struct ExtensionProperties
    extension_name : string
    spec_version : uint

def vk_value_to_boost(vk_struct : VkExtensionProperties) : ExtensionProperties
    return <- [[ExtensionProperties
        extension_name = vk_value_to_boost(vk_struct.extensionName),
        spec_version = vk_value_to_boost(vk_struct.specVersion)
    ]]

//
// MemoryHeap
//

struct MemoryHeap
    size : uint64
    flags : uint

def vk_value_to_boost(vk_struct : VkMemoryHeap) : MemoryHeap
    return <- [[MemoryHeap
        size = vk_value_to_boost(vk_struct.size),
        flags = vk_value_to_boost(vk_struct.flags)
    ]]

//
// MemoryType
//

struct MemoryType
    property_flags : uint
    heap_index : uint

def vk_value_to_boost(vk_struct : VkMemoryType) : MemoryType
    return <- [[MemoryType
        property_flags = vk_value_to_boost(vk_struct.propertyFlags),
        heap_index = vk_value_to_boost(vk_struct.heapIndex)
    ]]

//
// PhysicalDeviceProperties
//

struct PhysicalDeviceProperties
    api_version : uint
    driver_version : uint
    vendor_id : uint
    device_id : uint
    device_type : VkPhysicalDeviceType
    device_name : string
    pipeline_cache_uuid : uint8 [16]
    limits : PhysicalDeviceLimits
    sparse_properties : PhysicalDeviceSparseProperties

def vk_value_to_boost(vk_struct : VkPhysicalDeviceProperties) : PhysicalDeviceProperties
    return <- [[PhysicalDeviceProperties
        api_version = vk_value_to_boost(vk_struct.apiVersion),
        driver_version = vk_value_to_boost(vk_struct.driverVersion),
        vendor_id = vk_value_to_boost(vk_struct.vendorID),
        device_id = vk_value_to_boost(vk_struct.deviceID),
        device_type = vk_value_to_boost(vk_struct.deviceType),
        device_name = vk_value_to_boost(vk_struct.deviceName),
        pipeline_cache_uuid = vk_value_to_boost(vk_struct.pipelineCacheUUID),
        limits <- vk_value_to_boost(vk_struct.limits),
        sparse_properties <- vk_value_to_boost(vk_struct.sparseProperties)
    ]]

//
// ClearDepthStencilValue
//

struct ClearDepthStencilValue
    depth : float
    stencil : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ClearDepthStencilValue
) : VkClearDepthStencilValue

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkClearDepthStencilValue
        depth = boost_value_to_vk(boost_struct.depth),
        stencil = boost_value_to_vk(boost_struct.stencil)
    ]]

def vk_view_destroy(var boost_struct : ClearDepthStencilValue)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// CommandBufferAllocateInfo
//

struct CommandBufferAllocateInfo
    command_pool : CommandPool
    level : VkCommandBufferLevel
    command_buffer_count : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : CommandBufferAllocateInfo
) : VkCommandBufferAllocateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkCommandBufferAllocateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        commandPool = boost_value_to_vk(boost_struct.command_pool),
        level = boost_value_to_vk(boost_struct.level),
        commandBufferCount = boost_value_to_vk(boost_struct.command_buffer_count)
    ]]

def vk_view_destroy(var boost_struct : CommandBufferAllocateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// CommandBufferBeginInfo
//

struct CommandBufferBeginInfo
    flags : uint
    p_inheritance_info : CommandBufferInheritanceInfo ?
    _vk_view_p_inheritance_info : VkCommandBufferInheritanceInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : CommandBufferBeginInfo
) : VkCommandBufferBeginInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    if boost_struct.p_inheritance_info != null
        boost_struct._vk_view_p_inheritance_info = new VkCommandBufferInheritanceInfo
        *(boost_struct._vk_view_p_inheritance_info) <- (
            *(boost_struct.p_inheritance_info) |> vk_view_create_unsafe())
    return <- [[ VkCommandBufferBeginInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        pInheritanceInfo = boost_struct._vk_view_p_inheritance_info
    ]]

def vk_view_destroy(var boost_struct : CommandBufferBeginInfo)
    assert(boost_struct._vk_view__active)
    if boost_struct.p_inheritance_info != null
        *(boost_struct.p_inheritance_info) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_inheritance_info
    boost_struct._vk_view__active = false

//
// CommandBufferInheritanceInfo
//

struct CommandBufferInheritanceInfo
    render_pass : RenderPass
    subpass : uint
    framebuffer : Framebuffer
    occlusion_query_enable : uint
    query_flags : uint
    pipeline_statistics : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : CommandBufferInheritanceInfo
) : VkCommandBufferInheritanceInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkCommandBufferInheritanceInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        renderPass = boost_value_to_vk(boost_struct.render_pass),
        subpass = boost_value_to_vk(boost_struct.subpass),
        framebuffer = boost_value_to_vk(boost_struct.framebuffer),
        occlusionQueryEnable = boost_value_to_vk(boost_struct.occlusion_query_enable),
        queryFlags = boost_value_to_vk(boost_struct.query_flags),
        pipelineStatistics = boost_value_to_vk(boost_struct.pipeline_statistics)
    ]]

def vk_view_destroy(var boost_struct : CommandBufferInheritanceInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// CommandPoolCreateInfo
//

struct CommandPoolCreateInfo
    flags : uint
    queue_family_index : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : CommandPoolCreateInfo
) : VkCommandPoolCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkCommandPoolCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        queueFamilyIndex = boost_value_to_vk(boost_struct.queue_family_index)
    ]]

def vk_view_destroy(var boost_struct : CommandPoolCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// FenceCreateInfo
//

struct FenceCreateInfo
    flags : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : FenceCreateInfo
) : VkFenceCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkFenceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags)
    ]]

def vk_view_destroy(var boost_struct : FenceCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// ImageViewCreateInfo
//

struct ImageViewCreateInfo
    flags : uint
    image : Image
    view_type : VkImageViewType
    format : VkFormat
    components : ComponentMapping
    subresource_range : ImageSubresourceRange
    _vk_view_p_components : VkComponentMapping ?
    _vk_view_p_subresource_range : VkImageSubresourceRange ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ImageViewCreateInfo
) : VkImageViewCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_components = new VkComponentMapping
    *(boost_struct._vk_view_p_components) <- (
        boost_struct.components |> vk_view_create_unsafe())
    boost_struct._vk_view_p_subresource_range = new VkImageSubresourceRange
    *(boost_struct._vk_view_p_subresource_range) <- (
        boost_struct.subresource_range |> vk_view_create_unsafe())
    return <- [[ VkImageViewCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        image = boost_value_to_vk(boost_struct.image),
        viewType = boost_value_to_vk(boost_struct.view_type),
        format = boost_value_to_vk(boost_struct.format),
        components = *(boost_struct._vk_view_p_components),
        subresourceRange = *(boost_struct._vk_view_p_subresource_range)
    ]]

def vk_view_destroy(var boost_struct : ImageViewCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct.components |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_components
    boost_struct.subresource_range |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_subresource_range
    boost_struct._vk_view__active = false

//
// MemoryAllocateInfo
//

struct MemoryAllocateInfo
    allocation_size : uint64
    memory_type_index : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : MemoryAllocateInfo
) : VkMemoryAllocateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkMemoryAllocateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        allocationSize = boost_value_to_vk(boost_struct.allocation_size),
        memoryTypeIndex = boost_value_to_vk(boost_struct.memory_type_index)
    ]]

def vk_view_destroy(var boost_struct : MemoryAllocateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineColorBlendAttachmentState
//

struct PipelineColorBlendAttachmentState
    blend_enable : uint
    src_color_blend_factor : VkBlendFactor
    dst_color_blend_factor : VkBlendFactor
    color_blend_op : VkBlendOp
    src_alpha_blend_factor : VkBlendFactor
    dst_alpha_blend_factor : VkBlendFactor
    alpha_blend_op : VkBlendOp
    color_write_mask : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineColorBlendAttachmentState
) : VkPipelineColorBlendAttachmentState

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPipelineColorBlendAttachmentState
        blendEnable = boost_value_to_vk(boost_struct.blend_enable),
        srcColorBlendFactor = boost_value_to_vk(boost_struct.src_color_blend_factor),
        dstColorBlendFactor = boost_value_to_vk(boost_struct.dst_color_blend_factor),
        colorBlendOp = boost_value_to_vk(boost_struct.color_blend_op),
        srcAlphaBlendFactor = boost_value_to_vk(boost_struct.src_alpha_blend_factor),
        dstAlphaBlendFactor = boost_value_to_vk(boost_struct.dst_alpha_blend_factor),
        alphaBlendOp = boost_value_to_vk(boost_struct.alpha_blend_op),
        colorWriteMask = boost_value_to_vk(boost_struct.color_write_mask)
    ]]

def vk_view_destroy(var boost_struct : PipelineColorBlendAttachmentState)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineDepthStencilStateCreateInfo
//

struct PipelineDepthStencilStateCreateInfo
    flags : uint
    depth_test_enable : uint
    depth_write_enable : uint
    depth_compare_op : VkCompareOp
    depth_bounds_test_enable : uint
    stencil_test_enable : uint
    front : StencilOpState
    back : StencilOpState
    min_depth_bounds : float
    max_depth_bounds : float
    _vk_view_p_front : VkStencilOpState ?
    _vk_view_p_back : VkStencilOpState ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineDepthStencilStateCreateInfo
) : VkPipelineDepthStencilStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_front = new VkStencilOpState
    *(boost_struct._vk_view_p_front) <- (
        boost_struct.front |> vk_view_create_unsafe())
    boost_struct._vk_view_p_back = new VkStencilOpState
    *(boost_struct._vk_view_p_back) <- (
        boost_struct.back |> vk_view_create_unsafe())
    return <- [[ VkPipelineDepthStencilStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        depthTestEnable = boost_value_to_vk(boost_struct.depth_test_enable),
        depthWriteEnable = boost_value_to_vk(boost_struct.depth_write_enable),
        depthCompareOp = boost_value_to_vk(boost_struct.depth_compare_op),
        depthBoundsTestEnable = boost_value_to_vk(boost_struct.depth_bounds_test_enable),
        stencilTestEnable = boost_value_to_vk(boost_struct.stencil_test_enable),
        front = *(boost_struct._vk_view_p_front),
        back = *(boost_struct._vk_view_p_back),
        minDepthBounds = boost_value_to_vk(boost_struct.min_depth_bounds),
        maxDepthBounds = boost_value_to_vk(boost_struct.max_depth_bounds)
    ]]

def vk_view_destroy(var boost_struct : PipelineDepthStencilStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct.front |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_front
    boost_struct.back |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_back
    boost_struct._vk_view__active = false

//
// PipelineInputAssemblyStateCreateInfo
//

struct PipelineInputAssemblyStateCreateInfo
    flags : uint
    topology : VkPrimitiveTopology
    primitive_restart_enable : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineInputAssemblyStateCreateInfo
) : VkPipelineInputAssemblyStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPipelineInputAssemblyStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        topology = boost_value_to_vk(boost_struct.topology),
        primitiveRestartEnable = boost_value_to_vk(boost_struct.primitive_restart_enable)
    ]]

def vk_view_destroy(var boost_struct : PipelineInputAssemblyStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineMultisampleStateCreateInfo
//

struct PipelineMultisampleStateCreateInfo
    flags : uint
    rasterization_samples : VkSampleCountFlagBits
    sample_shading_enable : uint
    min_sample_shading : float
    p_sample_mask : uint ?
    alpha_to_coverage_enable : uint
    alpha_to_one_enable : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineMultisampleStateCreateInfo
) : VkPipelineMultisampleStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPipelineMultisampleStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        rasterizationSamples = boost_value_to_vk(boost_struct.rasterization_samples),
        sampleShadingEnable = boost_value_to_vk(boost_struct.sample_shading_enable),
        minSampleShading = boost_value_to_vk(boost_struct.min_sample_shading),
        pSampleMask = boost_value_to_vk(boost_struct.p_sample_mask),
        alphaToCoverageEnable = boost_value_to_vk(boost_struct.alpha_to_coverage_enable),
        alphaToOneEnable = boost_value_to_vk(boost_struct.alpha_to_one_enable)
    ]]

def vk_view_destroy(var boost_struct : PipelineMultisampleStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineRasterizationStateCreateInfo
//

struct PipelineRasterizationStateCreateInfo
    flags : uint
    depth_clamp_enable : uint
    rasterizer_discard_enable : uint
    polygon_mode : VkPolygonMode
    cull_mode : uint
    front_face : VkFrontFace
    depth_bias_enable : uint
    depth_bias_constant_factor : float
    depth_bias_clamp : float
    depth_bias_slope_factor : float
    line_width : float
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineRasterizationStateCreateInfo
) : VkPipelineRasterizationStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPipelineRasterizationStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        depthClampEnable = boost_value_to_vk(boost_struct.depth_clamp_enable),
        rasterizerDiscardEnable = boost_value_to_vk(boost_struct.rasterizer_discard_enable),
        polygonMode = boost_value_to_vk(boost_struct.polygon_mode),
        cullMode = boost_value_to_vk(boost_struct.cull_mode),
        frontFace = boost_value_to_vk(boost_struct.front_face),
        depthBiasEnable = boost_value_to_vk(boost_struct.depth_bias_enable),
        depthBiasConstantFactor = boost_value_to_vk(boost_struct.depth_bias_constant_factor),
        depthBiasClamp = boost_value_to_vk(boost_struct.depth_bias_clamp),
        depthBiasSlopeFactor = boost_value_to_vk(boost_struct.depth_bias_slope_factor),
        lineWidth = boost_value_to_vk(boost_struct.line_width)
    ]]

def vk_view_destroy(var boost_struct : PipelineRasterizationStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineShaderStageCreateInfo
//

struct PipelineShaderStageCreateInfo
    flags : uint
    stage : VkShaderStageFlagBits
    module_ : ShaderModule
    name : string
    p_specialization_info : SpecializationInfo ?
    _vk_view_p_specialization_info : VkSpecializationInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineShaderStageCreateInfo
) : VkPipelineShaderStageCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    if boost_struct.p_specialization_info != null
        boost_struct._vk_view_p_specialization_info = new VkSpecializationInfo
        *(boost_struct._vk_view_p_specialization_info) <- (
            *(boost_struct.p_specialization_info) |> vk_view_create_unsafe())
    return <- [[ VkPipelineShaderStageCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        stage = boost_value_to_vk(boost_struct.stage),
        module_ = boost_value_to_vk(boost_struct.module_),
        pName = boost_value_to_vk(boost_struct.name),
        pSpecializationInfo = boost_struct._vk_view_p_specialization_info
    ]]

def vk_view_destroy(var boost_struct : PipelineShaderStageCreateInfo)
    assert(boost_struct._vk_view__active)
    if boost_struct.p_specialization_info != null
        *(boost_struct.p_specialization_info) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_specialization_info
    boost_struct._vk_view__active = false

//
// PipelineTessellationStateCreateInfo
//

struct PipelineTessellationStateCreateInfo
    flags : uint
    patch_control_points : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineTessellationStateCreateInfo
) : VkPipelineTessellationStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkPipelineTessellationStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        patchControlPoints = boost_value_to_vk(boost_struct.patch_control_points)
    ]]

def vk_view_destroy(var boost_struct : PipelineTessellationStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SamplerCreateInfo
//

struct SamplerCreateInfo
    flags : uint
    mag_filter : VkFilter
    min_filter : VkFilter
    mipmap_mode : VkSamplerMipmapMode
    address_mode_u : VkSamplerAddressMode
    address_mode_v : VkSamplerAddressMode
    address_mode_w : VkSamplerAddressMode
    mip_lod_bias : float
    anisotropy_enable : uint
    max_anisotropy : float
    compare_enable : uint
    compare_op : VkCompareOp
    min_lod : float
    max_lod : float
    border_color : VkBorderColor
    unnormalized_coordinates : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SamplerCreateInfo
) : VkSamplerCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkSamplerCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        magFilter = boost_value_to_vk(boost_struct.mag_filter),
        minFilter = boost_value_to_vk(boost_struct.min_filter),
        mipmapMode = boost_value_to_vk(boost_struct.mipmap_mode),
        addressModeU = boost_value_to_vk(boost_struct.address_mode_u),
        addressModeV = boost_value_to_vk(boost_struct.address_mode_v),
        addressModeW = boost_value_to_vk(boost_struct.address_mode_w),
        mipLodBias = boost_value_to_vk(boost_struct.mip_lod_bias),
        anisotropyEnable = boost_value_to_vk(boost_struct.anisotropy_enable),
        maxAnisotropy = boost_value_to_vk(boost_struct.max_anisotropy),
        compareEnable = boost_value_to_vk(boost_struct.compare_enable),
        compareOp = boost_value_to_vk(boost_struct.compare_op),
        minLod = boost_value_to_vk(boost_struct.min_lod),
        maxLod = boost_value_to_vk(boost_struct.max_lod),
        borderColor = boost_value_to_vk(boost_struct.border_color),
        unnormalizedCoordinates = boost_value_to_vk(boost_struct.unnormalized_coordinates)
    ]]

def vk_view_destroy(var boost_struct : SamplerCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SemaphoreCreateInfo
//

struct SemaphoreCreateInfo
    flags : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SemaphoreCreateInfo
) : VkSemaphoreCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkSemaphoreCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags)
    ]]

def vk_view_destroy(var boost_struct : SemaphoreCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SpecializationMapEntry
//

struct SpecializationMapEntry
    constant_id : uint
    offset : uint
    size : uint64
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SpecializationMapEntry
) : VkSpecializationMapEntry

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkSpecializationMapEntry
        constantID = boost_value_to_vk(boost_struct.constant_id),
        offset = boost_value_to_vk(boost_struct.offset),
        size = boost_value_to_vk(boost_struct.size)
    ]]

def vk_view_destroy(var boost_struct : SpecializationMapEntry)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// StencilOpState
//

struct StencilOpState
    fail_op : VkStencilOp
    pass_op : VkStencilOp
    depth_fail_op : VkStencilOp
    compare_op : VkCompareOp
    compare_mask : uint
    write_mask : uint
    reference : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : StencilOpState
) : VkStencilOpState

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkStencilOpState
        failOp = boost_value_to_vk(boost_struct.fail_op),
        passOp = boost_value_to_vk(boost_struct.pass_op),
        depthFailOp = boost_value_to_vk(boost_struct.depth_fail_op),
        compareOp = boost_value_to_vk(boost_struct.compare_op),
        compareMask = boost_value_to_vk(boost_struct.compare_mask),
        writeMask = boost_value_to_vk(boost_struct.write_mask),
        reference = boost_value_to_vk(boost_struct.reference)
    ]]

def vk_view_destroy(var boost_struct : StencilOpState)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// VertexInputAttributeDescription
//

struct VertexInputAttributeDescription
    location : uint
    binding : uint
    format : VkFormat
    offset : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : VertexInputAttributeDescription
) : VkVertexInputAttributeDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkVertexInputAttributeDescription
        location = boost_value_to_vk(boost_struct.location),
        binding = boost_value_to_vk(boost_struct.binding),
        format = boost_value_to_vk(boost_struct.format),
        offset = boost_value_to_vk(boost_struct.offset)
    ]]

def vk_view_destroy(var boost_struct : VertexInputAttributeDescription)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// VertexInputBindingDescription
//

struct VertexInputBindingDescription
    binding : uint
    stride : uint
    input_rate : VkVertexInputRate
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : VertexInputBindingDescription
) : VkVertexInputBindingDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    return <- [[ VkVertexInputBindingDescription
        binding = boost_value_to_vk(boost_struct.binding),
        stride = boost_value_to_vk(boost_struct.stride),
        inputRate = boost_value_to_vk(boost_struct.input_rate)
    ]]

def vk_view_destroy(var boost_struct : VertexInputBindingDescription)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// BufferCreateInfo
//

struct BufferCreateInfo
    flags : uint
    size : uint64
    usage : uint
    sharing_mode : VkSharingMode
    queue_family_indices : array<uint>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : BufferCreateInfo
) : VkBufferCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_queue_family_index_count = uint(boost_struct.queue_family_indices |> length())
    let vk_p_queue_family_indices = array_addr_unsafe(boost_struct.queue_family_indices)
    return <- [[ VkBufferCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        size = boost_value_to_vk(boost_struct.size),
        usage = boost_value_to_vk(boost_struct.usage),
        sharingMode = boost_value_to_vk(boost_struct.sharing_mode),
        queueFamilyIndexCount = vk_queue_family_index_count,
        pQueueFamilyIndices = vk_p_queue_family_indices
    ]]

def vk_view_destroy(var boost_struct : BufferCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// ComputePipelineCreateInfo
//

struct ComputePipelineCreateInfo
    flags : uint
    stage : PipelineShaderStageCreateInfo
    layout : PipelineLayout
    base_pipeline_handle : Pipeline
    base_pipeline_index : int
    _vk_view_p_stage : VkPipelineShaderStageCreateInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ComputePipelineCreateInfo
) : VkComputePipelineCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_stage = new VkPipelineShaderStageCreateInfo
    *(boost_struct._vk_view_p_stage) <- (
        boost_struct.stage |> vk_view_create_unsafe())
    return <- [[ VkComputePipelineCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        stage = *(boost_struct._vk_view_p_stage),
        layout = boost_value_to_vk(boost_struct.layout),
        basePipelineHandle = boost_value_to_vk(boost_struct.base_pipeline_handle),
        basePipelineIndex = boost_value_to_vk(boost_struct.base_pipeline_index)
    ]]

def vk_view_destroy(var boost_struct : ComputePipelineCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct.stage |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_stage
    boost_struct._vk_view__active = false

//
// DescriptorSetLayoutBinding
//

struct DescriptorSetLayoutBinding
    binding : uint
    descriptor_type : VkDescriptorType
    descriptor_count : uint
    stage_flags : uint
    immutable_samplers : array<Sampler>
    _vk_view_immutable_samplers : array<VkSampler>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DescriptorSetLayoutBinding
) : VkDescriptorSetLayoutBinding

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_immutable_samplers <- [{
        for item in boost_struct.immutable_samplers ;
        item |> boost_value_to_vk()}]
    return <- [[ VkDescriptorSetLayoutBinding
        binding = boost_value_to_vk(boost_struct.binding),
        descriptorType = boost_value_to_vk(boost_struct.descriptor_type),
        descriptorCount = boost_value_to_vk(boost_struct.descriptor_count),
        stageFlags = boost_value_to_vk(boost_struct.stage_flags),
        pImmutableSamplers = array_addr_unsafe(boost_struct._vk_view_immutable_samplers)
    ]]

def vk_view_destroy(var boost_struct : DescriptorSetLayoutBinding)
    assert(boost_struct._vk_view__active)
    delete boost_struct._vk_view_immutable_samplers
    boost_struct._vk_view__active = false

//
// DescriptorSetLayoutCreateInfo
//

struct DescriptorSetLayoutCreateInfo
    flags : uint
    bindings : array<DescriptorSetLayoutBinding>
    _vk_view_bindings : array<VkDescriptorSetLayoutBinding>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DescriptorSetLayoutCreateInfo
) : VkDescriptorSetLayoutCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_binding_count = uint(boost_struct.bindings |> length())
    boost_struct._vk_view_bindings <- [{
        for item in boost_struct.bindings ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkDescriptorSetLayoutCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        bindingCount = vk_binding_count,
        pBindings = array_addr_unsafe(boost_struct._vk_view_bindings)
    ]]

def vk_view_destroy(var boost_struct : DescriptorSetLayoutCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.bindings
        item |> vk_view_destroy()
    delete boost_struct._vk_view_bindings
    boost_struct._vk_view__active = false

//
// DeviceCreateInfo
//

struct DeviceCreateInfo
    flags : uint
    queue_create_infos : array<DeviceQueueCreateInfo>
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    p_enabled_features : PhysicalDeviceFeatures ?
    _vk_view_queue_create_infos : array<VkDeviceQueueCreateInfo>
    _vk_view_p_enabled_features : VkPhysicalDeviceFeatures ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DeviceCreateInfo
) : VkDeviceCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_queue_create_info_count = uint(boost_struct.queue_create_infos |> length())
    boost_struct._vk_view_queue_create_infos <- [{
        for item in boost_struct.queue_create_infos ;
        item |> vk_view_create_unsafe()}]
    let vk_enabled_layer_count = uint(boost_struct.enabled_layer_names |> length())
    let vk_p_enabled_layer_names = array_addr_unsafe(boost_struct.enabled_layer_names)
    let vk_enabled_extension_count = uint(boost_struct.enabled_extension_names |> length())
    let vk_p_enabled_extension_names = array_addr_unsafe(boost_struct.enabled_extension_names)
    if boost_struct.p_enabled_features != null
        boost_struct._vk_view_p_enabled_features = new VkPhysicalDeviceFeatures
        *(boost_struct._vk_view_p_enabled_features) <- (
            *(boost_struct.p_enabled_features) |> vk_view_create_unsafe())
    return <- [[ VkDeviceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        queueCreateInfoCount = vk_queue_create_info_count,
        pQueueCreateInfos = array_addr_unsafe(boost_struct._vk_view_queue_create_infos),
        enabledLayerCount = vk_enabled_layer_count,
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = vk_enabled_extension_count,
        ppEnabledExtensionNames = vk_p_enabled_extension_names,
        pEnabledFeatures = boost_struct._vk_view_p_enabled_features
    ]]

def vk_view_destroy(var boost_struct : DeviceCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.queue_create_infos
        item |> vk_view_destroy()
    delete boost_struct._vk_view_queue_create_infos
    if boost_struct.p_enabled_features != null
        *(boost_struct.p_enabled_features) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_enabled_features
    boost_struct._vk_view__active = false

//
// DeviceQueueCreateInfo
//

struct DeviceQueueCreateInfo
    flags : uint
    queue_family_index : uint
    queue_priorities : array<float>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DeviceQueueCreateInfo
) : VkDeviceQueueCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_queue_count = uint(boost_struct.queue_priorities |> length())
    let vk_p_queue_priorities = array_addr_unsafe(boost_struct.queue_priorities)
    return <- [[ VkDeviceQueueCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        queueFamilyIndex = boost_value_to_vk(boost_struct.queue_family_index),
        queueCount = vk_queue_count,
        pQueuePriorities = vk_p_queue_priorities
    ]]

def vk_view_destroy(var boost_struct : DeviceQueueCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// FramebufferCreateInfo
//

struct FramebufferCreateInfo
    flags : uint
    render_pass : RenderPass
    attachments : array<ImageView>
    width : uint
    height : uint
    layers : uint
    _vk_view_attachments : array<VkImageView>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : FramebufferCreateInfo
) : VkFramebufferCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_attachment_count = uint(boost_struct.attachments |> length())
    boost_struct._vk_view_attachments <- [{
        for item in boost_struct.attachments ;
        item |> boost_value_to_vk()}]
    return <- [[ VkFramebufferCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        renderPass = boost_value_to_vk(boost_struct.render_pass),
        attachmentCount = vk_attachment_count,
        pAttachments = array_addr_unsafe(boost_struct._vk_view_attachments),
        width = boost_value_to_vk(boost_struct.width),
        height = boost_value_to_vk(boost_struct.height),
        layers = boost_value_to_vk(boost_struct.layers)
    ]]

def vk_view_destroy(var boost_struct : FramebufferCreateInfo)
    assert(boost_struct._vk_view__active)
    delete boost_struct._vk_view_attachments
    boost_struct._vk_view__active = false

//
// GraphicsPipelineCreateInfo
//

struct GraphicsPipelineCreateInfo
    flags : uint
    stages : array<PipelineShaderStageCreateInfo>
    vertex_input_state : PipelineVertexInputStateCreateInfo
    input_assembly_state : PipelineInputAssemblyStateCreateInfo
    tessellation_state : PipelineTessellationStateCreateInfo
    viewport_state : PipelineViewportStateCreateInfo
    rasterization_state : PipelineRasterizationStateCreateInfo
    multisample_state : PipelineMultisampleStateCreateInfo
    depth_stencil_state : PipelineDepthStencilStateCreateInfo
    color_blend_state : PipelineColorBlendStateCreateInfo
    p_dynamic_state : PipelineDynamicStateCreateInfo ?
    layout : PipelineLayout
    render_pass : RenderPass
    subpass : uint
    base_pipeline_handle : Pipeline
    base_pipeline_index : int
    _vk_view_stages : array<VkPipelineShaderStageCreateInfo>
    _vk_view_p_vertex_input_state : VkPipelineVertexInputStateCreateInfo ?
    _vk_view_p_input_assembly_state : VkPipelineInputAssemblyStateCreateInfo ?
    _vk_view_p_tessellation_state : VkPipelineTessellationStateCreateInfo ?
    _vk_view_p_viewport_state : VkPipelineViewportStateCreateInfo ?
    _vk_view_p_rasterization_state : VkPipelineRasterizationStateCreateInfo ?
    _vk_view_p_multisample_state : VkPipelineMultisampleStateCreateInfo ?
    _vk_view_p_depth_stencil_state : VkPipelineDepthStencilStateCreateInfo ?
    _vk_view_p_color_blend_state : VkPipelineColorBlendStateCreateInfo ?
    _vk_view_p_dynamic_state : VkPipelineDynamicStateCreateInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : GraphicsPipelineCreateInfo
) : VkGraphicsPipelineCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_stage_count = uint(boost_struct.stages |> length())
    boost_struct._vk_view_stages <- [{
        for item in boost_struct.stages ;
        item |> vk_view_create_unsafe()}]
    boost_struct._vk_view_p_vertex_input_state = new VkPipelineVertexInputStateCreateInfo
    *(boost_struct._vk_view_p_vertex_input_state) <- (
        boost_struct.vertex_input_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_input_assembly_state = new VkPipelineInputAssemblyStateCreateInfo
    *(boost_struct._vk_view_p_input_assembly_state) <- (
        boost_struct.input_assembly_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_tessellation_state = new VkPipelineTessellationStateCreateInfo
    *(boost_struct._vk_view_p_tessellation_state) <- (
        boost_struct.tessellation_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_viewport_state = new VkPipelineViewportStateCreateInfo
    *(boost_struct._vk_view_p_viewport_state) <- (
        boost_struct.viewport_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_rasterization_state = new VkPipelineRasterizationStateCreateInfo
    *(boost_struct._vk_view_p_rasterization_state) <- (
        boost_struct.rasterization_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_multisample_state = new VkPipelineMultisampleStateCreateInfo
    *(boost_struct._vk_view_p_multisample_state) <- (
        boost_struct.multisample_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_depth_stencil_state = new VkPipelineDepthStencilStateCreateInfo
    *(boost_struct._vk_view_p_depth_stencil_state) <- (
        boost_struct.depth_stencil_state |> vk_view_create_unsafe())
    boost_struct._vk_view_p_color_blend_state = new VkPipelineColorBlendStateCreateInfo
    *(boost_struct._vk_view_p_color_blend_state) <- (
        boost_struct.color_blend_state |> vk_view_create_unsafe())
    if boost_struct.p_dynamic_state != null
        boost_struct._vk_view_p_dynamic_state = new VkPipelineDynamicStateCreateInfo
        *(boost_struct._vk_view_p_dynamic_state) <- (
            *(boost_struct.p_dynamic_state) |> vk_view_create_unsafe())
    return <- [[ VkGraphicsPipelineCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        stageCount = vk_stage_count,
        pStages = array_addr_unsafe(boost_struct._vk_view_stages),
        pVertexInputState = boost_struct._vk_view_p_vertex_input_state,
        pInputAssemblyState = boost_struct._vk_view_p_input_assembly_state,
        pTessellationState = boost_struct._vk_view_p_tessellation_state,
        pViewportState = boost_struct._vk_view_p_viewport_state,
        pRasterizationState = boost_struct._vk_view_p_rasterization_state,
        pMultisampleState = boost_struct._vk_view_p_multisample_state,
        pDepthStencilState = boost_struct._vk_view_p_depth_stencil_state,
        pColorBlendState = boost_struct._vk_view_p_color_blend_state,
        pDynamicState = boost_struct._vk_view_p_dynamic_state,
        layout = boost_value_to_vk(boost_struct.layout),
        renderPass = boost_value_to_vk(boost_struct.render_pass),
        subpass = boost_value_to_vk(boost_struct.subpass),
        basePipelineHandle = boost_value_to_vk(boost_struct.base_pipeline_handle),
        basePipelineIndex = boost_value_to_vk(boost_struct.base_pipeline_index)
    ]]

def vk_view_destroy(var boost_struct : GraphicsPipelineCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.stages
        item |> vk_view_destroy()
    delete boost_struct._vk_view_stages
    boost_struct.vertex_input_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_vertex_input_state
    boost_struct.input_assembly_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_input_assembly_state
    boost_struct.tessellation_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_tessellation_state
    boost_struct.viewport_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_viewport_state
    boost_struct.rasterization_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_rasterization_state
    boost_struct.multisample_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_multisample_state
    boost_struct.depth_stencil_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_depth_stencil_state
    boost_struct.color_blend_state |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_color_blend_state
    if boost_struct.p_dynamic_state != null
        *(boost_struct.p_dynamic_state) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_dynamic_state
    boost_struct._vk_view__active = false

//
// ImageCreateInfo
//

struct ImageCreateInfo
    flags : uint
    image_type : VkImageType
    format : VkFormat
    extent : Extent3D
    mip_levels : uint
    array_layers : uint
    samples : VkSampleCountFlagBits
    tiling : VkImageTiling
    usage : uint
    sharing_mode : VkSharingMode
    queue_family_indices : array<uint>
    initial_layout : VkImageLayout
    _vk_view_p_extent : VkExtent3D ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ImageCreateInfo
) : VkImageCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_extent = new VkExtent3D
    *(boost_struct._vk_view_p_extent) <- (
        boost_struct.extent |> vk_view_create_unsafe())
    let vk_queue_family_index_count = uint(boost_struct.queue_family_indices |> length())
    let vk_p_queue_family_indices = array_addr_unsafe(boost_struct.queue_family_indices)
    return <- [[ VkImageCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        imageType = boost_value_to_vk(boost_struct.image_type),
        format = boost_value_to_vk(boost_struct.format),
        extent = *(boost_struct._vk_view_p_extent),
        mipLevels = boost_value_to_vk(boost_struct.mip_levels),
        arrayLayers = boost_value_to_vk(boost_struct.array_layers),
        samples = boost_value_to_vk(boost_struct.samples),
        tiling = boost_value_to_vk(boost_struct.tiling),
        usage = boost_value_to_vk(boost_struct.usage),
        sharingMode = boost_value_to_vk(boost_struct.sharing_mode),
        queueFamilyIndexCount = vk_queue_family_index_count,
        pQueueFamilyIndices = vk_p_queue_family_indices,
        initialLayout = boost_value_to_vk(boost_struct.initial_layout)
    ]]

def vk_view_destroy(var boost_struct : ImageCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct.extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_extent
    boost_struct._vk_view__active = false

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    _vk_view_p_application_info : VkApplicationInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : InstanceCreateInfo
) : VkInstanceCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    if boost_struct.p_application_info != null
        boost_struct._vk_view_p_application_info = new VkApplicationInfo
        *(boost_struct._vk_view_p_application_info) <- (
            *(boost_struct.p_application_info) |> vk_view_create_unsafe())
    let vk_enabled_layer_count = uint(boost_struct.enabled_layer_names |> length())
    let vk_p_enabled_layer_names = array_addr_unsafe(boost_struct.enabled_layer_names)
    let vk_enabled_extension_count = uint(boost_struct.enabled_extension_names |> length())
    let vk_p_enabled_extension_names = array_addr_unsafe(boost_struct.enabled_extension_names)
    return <- [[ VkInstanceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        pApplicationInfo = boost_struct._vk_view_p_application_info,
        enabledLayerCount = vk_enabled_layer_count,
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = vk_enabled_extension_count,
        ppEnabledExtensionNames = vk_p_enabled_extension_names
    ]]

def vk_view_destroy(var boost_struct : InstanceCreateInfo)
    assert(boost_struct._vk_view__active)
    if boost_struct.p_application_info != null
        *(boost_struct.p_application_info) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_application_info
    boost_struct._vk_view__active = false

//
// PhysicalDeviceMemoryProperties
//

struct PhysicalDeviceMemoryProperties
    memory_types : array<MemoryType>
    memory_heaps : array<MemoryHeap>

def vk_value_to_boost(vk_struct : VkPhysicalDeviceMemoryProperties) : PhysicalDeviceMemoryProperties
    var b_memory_types : array<MemoryType>
    b_memory_types |> resize(int(vk_struct.memoryTypeCount))
    for b, i in b_memory_types, range(INT_MAX)
        b <- vk_value_to_boost(vk_struct.memoryTypes[i])
    var b_memory_heaps : array<MemoryHeap>
    b_memory_heaps |> resize(int(vk_struct.memoryHeapCount))
    for b, i in b_memory_heaps, range(INT_MAX)
        b <- vk_value_to_boost(vk_struct.memoryHeaps[i])
    return <- [[PhysicalDeviceMemoryProperties
        memory_types <- b_memory_types,
        memory_heaps <- b_memory_heaps
    ]]

//
// PipelineCacheCreateInfo
//

struct PipelineCacheCreateInfo
    flags : uint
    initial_data : array<uint8>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineCacheCreateInfo
) : VkPipelineCacheCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_initial_data_size = uint64(boost_struct.initial_data |> length())
    var vk_p_initial_data : void ?
    unsafe
        vk_p_initial_data = reinterpret<void ?>(array_addr_unsafe(boost_struct.initial_data))
    return <- [[ VkPipelineCacheCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        initialDataSize = vk_initial_data_size,
        pInitialData = vk_p_initial_data
    ]]

def vk_view_destroy(var boost_struct : PipelineCacheCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineColorBlendStateCreateInfo
//

struct PipelineColorBlendStateCreateInfo
    flags : uint
    logic_op_enable : uint
    logic_op : VkLogicOp
    attachments : array<PipelineColorBlendAttachmentState>
    blend_constants : float [4]
    _vk_view_attachments : array<VkPipelineColorBlendAttachmentState>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineColorBlendStateCreateInfo
) : VkPipelineColorBlendStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_attachment_count = uint(boost_struct.attachments |> length())
    boost_struct._vk_view_attachments <- [{
        for item in boost_struct.attachments ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkPipelineColorBlendStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        logicOpEnable = boost_value_to_vk(boost_struct.logic_op_enable),
        logicOp = boost_value_to_vk(boost_struct.logic_op),
        attachmentCount = vk_attachment_count,
        pAttachments = array_addr_unsafe(boost_struct._vk_view_attachments),
        blendConstants = boost_value_to_vk(boost_struct.blend_constants)
    ]]

def vk_view_destroy(var boost_struct : PipelineColorBlendStateCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_attachments
    boost_struct._vk_view__active = false

//
// PipelineDynamicStateCreateInfo
//

struct PipelineDynamicStateCreateInfo
    flags : uint
    dynamic_states : array<VkDynamicState>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineDynamicStateCreateInfo
) : VkPipelineDynamicStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_dynamic_state_count = uint(boost_struct.dynamic_states |> length())
    let vk_p_dynamic_states = array_addr_unsafe(boost_struct.dynamic_states)
    return <- [[ VkPipelineDynamicStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        dynamicStateCount = vk_dynamic_state_count,
        pDynamicStates = vk_p_dynamic_states
    ]]

def vk_view_destroy(var boost_struct : PipelineDynamicStateCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PipelineLayoutCreateInfo
//

struct PipelineLayoutCreateInfo
    flags : uint
    set_layouts : array<DescriptorSetLayout>
    push_constant_ranges : array<PushConstantRange>
    _vk_view_set_layouts : array<VkDescriptorSetLayout>
    _vk_view_push_constant_ranges : array<VkPushConstantRange>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineLayoutCreateInfo
) : VkPipelineLayoutCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_set_layout_count = uint(boost_struct.set_layouts |> length())
    boost_struct._vk_view_set_layouts <- [{
        for item in boost_struct.set_layouts ;
        item |> boost_value_to_vk()}]
    let vk_push_constant_range_count = uint(boost_struct.push_constant_ranges |> length())
    boost_struct._vk_view_push_constant_ranges <- [{
        for item in boost_struct.push_constant_ranges ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkPipelineLayoutCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        setLayoutCount = vk_set_layout_count,
        pSetLayouts = array_addr_unsafe(boost_struct._vk_view_set_layouts),
        pushConstantRangeCount = vk_push_constant_range_count,
        pPushConstantRanges = array_addr_unsafe(boost_struct._vk_view_push_constant_ranges)
    ]]

def vk_view_destroy(var boost_struct : PipelineLayoutCreateInfo)
    assert(boost_struct._vk_view__active)
    delete boost_struct._vk_view_set_layouts
    for item in boost_struct.push_constant_ranges
        item |> vk_view_destroy()
    delete boost_struct._vk_view_push_constant_ranges
    boost_struct._vk_view__active = false

//
// PipelineVertexInputStateCreateInfo
//

struct PipelineVertexInputStateCreateInfo
    flags : uint
    vertex_binding_descriptions : array<VertexInputBindingDescription>
    vertex_attribute_descriptions : array<VertexInputAttributeDescription>
    _vk_view_vertex_binding_descriptions : array<VkVertexInputBindingDescription>
    _vk_view_vertex_attribute_descriptions : array<VkVertexInputAttributeDescription>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineVertexInputStateCreateInfo
) : VkPipelineVertexInputStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_vertex_binding_description_count = uint(boost_struct.vertex_binding_descriptions |> length())
    boost_struct._vk_view_vertex_binding_descriptions <- [{
        for item in boost_struct.vertex_binding_descriptions ;
        item |> vk_view_create_unsafe()}]
    let vk_vertex_attribute_description_count = uint(boost_struct.vertex_attribute_descriptions |> length())
    boost_struct._vk_view_vertex_attribute_descriptions <- [{
        for item in boost_struct.vertex_attribute_descriptions ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkPipelineVertexInputStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        vertexBindingDescriptionCount = vk_vertex_binding_description_count,
        pVertexBindingDescriptions = array_addr_unsafe(boost_struct._vk_view_vertex_binding_descriptions),
        vertexAttributeDescriptionCount = vk_vertex_attribute_description_count,
        pVertexAttributeDescriptions = array_addr_unsafe(boost_struct._vk_view_vertex_attribute_descriptions)
    ]]

def vk_view_destroy(var boost_struct : PipelineVertexInputStateCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.vertex_binding_descriptions
        item |> vk_view_destroy()
    delete boost_struct._vk_view_vertex_binding_descriptions
    for item in boost_struct.vertex_attribute_descriptions
        item |> vk_view_destroy()
    delete boost_struct._vk_view_vertex_attribute_descriptions
    boost_struct._vk_view__active = false

//
// PipelineViewportStateCreateInfo
//

struct PipelineViewportStateCreateInfo
    flags : uint
    viewports : array<Viewport>
    scissors : array<Rect2D>
    _vk_view_viewports : array<VkViewport>
    _vk_view_scissors : array<VkRect2D>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineViewportStateCreateInfo
) : VkPipelineViewportStateCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_viewport_count = uint(boost_struct.viewports |> length())
    boost_struct._vk_view_viewports <- [{
        for item in boost_struct.viewports ;
        item |> vk_view_create_unsafe()}]
    let vk_scissor_count = uint(boost_struct.scissors |> length())
    boost_struct._vk_view_scissors <- [{
        for item in boost_struct.scissors ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkPipelineViewportStateCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        viewportCount = vk_viewport_count,
        pViewports = array_addr_unsafe(boost_struct._vk_view_viewports),
        scissorCount = vk_scissor_count,
        pScissors = array_addr_unsafe(boost_struct._vk_view_scissors)
    ]]

def vk_view_destroy(var boost_struct : PipelineViewportStateCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.viewports
        item |> vk_view_destroy()
    delete boost_struct._vk_view_viewports
    for item in boost_struct.scissors
        item |> vk_view_destroy()
    delete boost_struct._vk_view_scissors
    boost_struct._vk_view__active = false

//
// RenderPassCreateInfo
//

struct RenderPassCreateInfo
    flags : uint
    attachments : array<AttachmentDescription>
    subpasses : array<SubpassDescription>
    dependencies : array<SubpassDependency>
    _vk_view_attachments : array<VkAttachmentDescription>
    _vk_view_subpasses : array<VkSubpassDescription>
    _vk_view_dependencies : array<VkSubpassDependency>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : RenderPassCreateInfo
) : VkRenderPassCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_attachment_count = uint(boost_struct.attachments |> length())
    boost_struct._vk_view_attachments <- [{
        for item in boost_struct.attachments ;
        item |> vk_view_create_unsafe()}]
    let vk_subpass_count = uint(boost_struct.subpasses |> length())
    boost_struct._vk_view_subpasses <- [{
        for item in boost_struct.subpasses ;
        item |> vk_view_create_unsafe()}]
    let vk_dependency_count = uint(boost_struct.dependencies |> length())
    boost_struct._vk_view_dependencies <- [{
        for item in boost_struct.dependencies ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkRenderPassCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        attachmentCount = vk_attachment_count,
        pAttachments = array_addr_unsafe(boost_struct._vk_view_attachments),
        subpassCount = vk_subpass_count,
        pSubpasses = array_addr_unsafe(boost_struct._vk_view_subpasses),
        dependencyCount = vk_dependency_count,
        pDependencies = array_addr_unsafe(boost_struct._vk_view_dependencies)
    ]]

def vk_view_destroy(var boost_struct : RenderPassCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_attachments
    for item in boost_struct.subpasses
        item |> vk_view_destroy()
    delete boost_struct._vk_view_subpasses
    for item in boost_struct.dependencies
        item |> vk_view_destroy()
    delete boost_struct._vk_view_dependencies
    boost_struct._vk_view__active = false

//
// ShaderModuleCreateInfo
//

struct ShaderModuleCreateInfo
    flags : uint
    code : array<uint8>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ShaderModuleCreateInfo
) : VkShaderModuleCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_code_size = uint64(boost_struct.code |> length())
    var vk_p_code : uint ?
    unsafe
        vk_p_code = reinterpret<uint ?>(array_addr_unsafe(boost_struct.code))
    return <- [[ VkShaderModuleCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        flags = boost_value_to_vk(boost_struct.flags),
        codeSize = vk_code_size,
        pCode = vk_p_code
    ]]

def vk_view_destroy(var boost_struct : ShaderModuleCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SpecializationInfo
//

struct SpecializationInfo
    map_entries : array<SpecializationMapEntry>
    data : array<uint8>
    _vk_view_map_entries : array<VkSpecializationMapEntry>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SpecializationInfo
) : VkSpecializationInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_map_entry_count = uint(boost_struct.map_entries |> length())
    boost_struct._vk_view_map_entries <- [{
        for item in boost_struct.map_entries ;
        item |> vk_view_create_unsafe()}]
    let vk_data_size = uint64(boost_struct.data |> length())
    var vk_p_data : void ?
    unsafe
        vk_p_data = reinterpret<void ?>(array_addr_unsafe(boost_struct.data))
    return <- [[ VkSpecializationInfo
        mapEntryCount = vk_map_entry_count,
        pMapEntries = array_addr_unsafe(boost_struct._vk_view_map_entries),
        dataSize = vk_data_size,
        pData = vk_p_data
    ]]

def vk_view_destroy(var boost_struct : SpecializationInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.map_entries
        item |> vk_view_destroy()
    delete boost_struct._vk_view_map_entries
    boost_struct._vk_view__active = false

//
// SubpassDescription
//

struct SubpassDescription
    flags : uint
    pipeline_bind_point : VkPipelineBindPoint
    input_attachments : array<AttachmentReference>
    color_attachments : array<AttachmentReference>
    resolve_attachments : array<AttachmentReference>
    p_depth_stencil_attachment : AttachmentReference ?
    preserve_attachments : array<uint>
    _vk_view_input_attachments : array<VkAttachmentReference>
    _vk_view_color_attachments : array<VkAttachmentReference>
    _vk_view_resolve_attachments : array<VkAttachmentReference>
    _vk_view_p_depth_stencil_attachment : VkAttachmentReference ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SubpassDescription
) : VkSubpassDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    let vk_input_attachment_count = uint(boost_struct.input_attachments |> length())
    boost_struct._vk_view_input_attachments <- [{
        for item in boost_struct.input_attachments ;
        item |> vk_view_create_unsafe()}]
    assert(length(boost_struct.resolve_attachments) == 0 || length(boost_struct.resolve_attachments) == length(boost_struct.color_attachments))
    let vk_color_attachment_count = uint(boost_struct.color_attachments |> length())
    boost_struct._vk_view_color_attachments <- [{
        for item in boost_struct.color_attachments ;
        item |> vk_view_create_unsafe()}]
    boost_struct._vk_view_resolve_attachments <- [{
        for item in boost_struct.resolve_attachments ;
        item |> vk_view_create_unsafe()}]
    if boost_struct.p_depth_stencil_attachment != null
        boost_struct._vk_view_p_depth_stencil_attachment = new VkAttachmentReference
        *(boost_struct._vk_view_p_depth_stencil_attachment) <- (
            *(boost_struct.p_depth_stencil_attachment) |> vk_view_create_unsafe())
    let vk_preserve_attachment_count = uint(boost_struct.preserve_attachments |> length())
    let vk_p_preserve_attachments = array_addr_unsafe(boost_struct.preserve_attachments)
    return <- [[ VkSubpassDescription
        flags = boost_value_to_vk(boost_struct.flags),
        pipelineBindPoint = boost_value_to_vk(boost_struct.pipeline_bind_point),
        inputAttachmentCount = vk_input_attachment_count,
        pInputAttachments = array_addr_unsafe(boost_struct._vk_view_input_attachments),
        colorAttachmentCount = vk_color_attachment_count,
        pColorAttachments = array_addr_unsafe(boost_struct._vk_view_color_attachments),
        pResolveAttachments = array_addr_unsafe(boost_struct._vk_view_resolve_attachments),
        pDepthStencilAttachment = boost_struct._vk_view_p_depth_stencil_attachment,
        preserveAttachmentCount = vk_preserve_attachment_count,
        pPreserveAttachments = vk_p_preserve_attachments
    ]]

def vk_view_destroy(var boost_struct : SubpassDescription)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.input_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_input_attachments
    for item in boost_struct.color_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_color_attachments
    for item in boost_struct.resolve_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_resolve_attachments
    if boost_struct.p_depth_stencil_attachment != null
        *(boost_struct.p_depth_stencil_attachment) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_depth_stencil_attachment
    boost_struct._vk_view__active = false

//
// SwapchainCreateInfoKHR
//

struct SwapchainCreateInfoKHR
    flags : uint
    surface : SurfaceKHR
    min_image_count : uint
    image_format : VkFormat
    image_color_space : VkColorSpaceKHR
    image_extent : Extent2D
    image_array_layers : uint
    image_usage : uint
    image_sharing_mode : VkSharingMode
    queue_family_indices : array<uint>
    pre_transform : VkSurfaceTransformFlagBitsKHR
    composite_alpha : VkCompositeAlphaFlagBitsKHR
    present_mode : VkPresentModeKHR
    clipped : uint
    old_swapchain : SwapchainKHR
    _vk_view_p_image_extent : VkExtent2D ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SwapchainCreateInfoKHR
) : VkSwapchainCreateInfoKHR

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_image_extent = new VkExtent2D
    *(boost_struct._vk_view_p_image_extent) <- (
        boost_struct.image_extent |> vk_view_create_unsafe())
    let vk_queue_family_index_count = uint(boost_struct.queue_family_indices |> length())
    let vk_p_queue_family_indices = array_addr_unsafe(boost_struct.queue_family_indices)
    return <- [[ VkSwapchainCreateInfoKHR
        sType = VkStructureType VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        flags = boost_value_to_vk(boost_struct.flags),
        surface = boost_value_to_vk(boost_struct.surface),
        minImageCount = boost_value_to_vk(boost_struct.min_image_count),
        imageFormat = boost_value_to_vk(boost_struct.image_format),
        imageColorSpace = boost_value_to_vk(boost_struct.image_color_space),
        imageExtent = *(boost_struct._vk_view_p_image_extent),
        imageArrayLayers = boost_value_to_vk(boost_struct.image_array_layers),
        imageUsage = boost_value_to_vk(boost_struct.image_usage),
        imageSharingMode = boost_value_to_vk(boost_struct.image_sharing_mode),
        queueFamilyIndexCount = vk_queue_family_index_count,
        pQueueFamilyIndices = vk_p_queue_family_indices,
        preTransform = boost_value_to_vk(boost_struct.pre_transform),
        compositeAlpha = boost_value_to_vk(boost_struct.composite_alpha),
        presentMode = boost_value_to_vk(boost_struct.present_mode),
        clipped = boost_value_to_vk(boost_struct.clipped),
        oldSwapchain = boost_value_to_vk(boost_struct.old_swapchain)
    ]]

def vk_view_destroy(var boost_struct : SwapchainCreateInfoKHR)
    assert(boost_struct._vk_view__active)
    boost_struct.image_extent |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_image_extent
    boost_struct._vk_view__active = false

//
// RenderPassBeginInfo
//

struct RenderPassBeginInfo
    render_pass : RenderPass
    framebuffer : Framebuffer
    render_area : Rect2D
    clear_values : array<ClearValue>
    _vk_view_p_render_area : VkRect2D ?
    _vk_view_clear_values : array<VkClearValue>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : RenderPassBeginInfo
) : VkRenderPassBeginInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true
    boost_struct._vk_view_p_render_area = new VkRect2D
    *(boost_struct._vk_view_p_render_area) <- (
        boost_struct.render_area |> vk_view_create_unsafe())
    let vk_clear_value_count = uint(boost_struct.clear_values |> length())
    boost_struct._vk_view_clear_values <- [{
        for item in boost_struct.clear_values ;
        item |> vk_view_create_unsafe()}]
    return <- [[ VkRenderPassBeginInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        renderPass = boost_value_to_vk(boost_struct.render_pass),
        framebuffer = boost_value_to_vk(boost_struct.framebuffer),
        renderArea = *(boost_struct._vk_view_p_render_area),
        clearValueCount = vk_clear_value_count,
        pClearValues = array_addr_unsafe(boost_struct._vk_view_clear_values)
    ]]

def vk_view_destroy(var boost_struct : RenderPassBeginInfo)
    assert(boost_struct._vk_view__active)
    boost_struct.render_area |> vk_view_destroy()
    unsafe
        delete boost_struct._vk_view_p_render_area
    for item in boost_struct.clear_values
        item |> vk_view_destroy()
    delete boost_struct._vk_view_clear_values
    boost_struct._vk_view__active = false

//
// Buffer
//

struct Buffer
    buffer : VkBuffer
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Buffer) : VkBuffer
    return b.buffer

def boost_value_to_vk(b : Buffer ?) : VkBuffer ?
    return b?.buffer

def vk_value_to_boost(v : VkBuffer) : Buffer
    return [[ Buffer buffer=v ]]

[private]
def create_buffer__inner(
    device : Device = [[ Device ]];
    var create_info : BufferCreateInfo = [[ BufferCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Buffer

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_buffer : VkBuffer
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateBuffer(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_buffer)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_buffer)

def create_buffer(
    device : Device = [[ Device ]];
    var create_info : BufferCreateInfo = [[ BufferCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Buffer

    var handle <- create_buffer__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_buffer(
    device : Device = [[ Device ]];
    buffer : Buffer = [[ Buffer ]]
) : void

    vkDestroyBuffer(
        boost_value_to_vk(device),
        boost_value_to_vk(buffer),
        null
    )

def finalize(var handle : Buffer explicit)
    if handle._needs_delete
        destroy_buffer(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.buffer)
        )
    memzero(handle)

//
// CommandBuffer
//

struct CommandBuffer
    command_buffer : VkCommandBuffer
    _needs_delete : bool

def boost_value_to_vk(b : CommandBuffer) : VkCommandBuffer
    return b.command_buffer

def boost_value_to_vk(b : CommandBuffer ?) : VkCommandBuffer ?
    return b?.command_buffer

def vk_value_to_boost(v : VkCommandBuffer) : CommandBuffer
    return [[ CommandBuffer command_buffer=v ]]

//
// Device
//

struct Device
    device : VkDevice
    _needs_delete : bool

def boost_value_to_vk(b : Device) : VkDevice
    return b.device

def boost_value_to_vk(b : Device ?) : VkDevice ?
    return b?.device

def vk_value_to_boost(v : VkDevice) : Device
    return [[ Device device=v ]]

[private]
def create_device__inner(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    var create_info : DeviceCreateInfo = [[ DeviceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Device

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_device : VkDevice
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateDevice(
        boost_value_to_vk(physical_device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_device)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_device)

def create_device(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    var create_info : DeviceCreateInfo = [[ DeviceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Device

    var handle <- create_device__inner(
        physical_device,
        create_info,
        result
    )
    handle._needs_delete = true
    return <- handle

[private]
def destroy_device(
    device : Device = [[ Device ]]
) : void

    vkDestroyDevice(
        boost_value_to_vk(device),
        null
    )

def finalize(var handle : Device explicit)
    if handle._needs_delete
        destroy_device(
            vk_value_to_boost(handle.device)
        )
    memzero(handle)

//
// CommandPool
//

struct CommandPool
    command_pool : VkCommandPool
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : CommandPool) : VkCommandPool
    return b.command_pool

def boost_value_to_vk(b : CommandPool ?) : VkCommandPool ?
    return b?.command_pool

def vk_value_to_boost(v : VkCommandPool) : CommandPool
    return [[ CommandPool command_pool=v ]]

[private]
def create_command_pool__inner(
    device : Device = [[ Device ]];
    var create_info : CommandPoolCreateInfo = [[ CommandPoolCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : CommandPool

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_command_pool : VkCommandPool
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateCommandPool(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_command_pool)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_command_pool)

def create_command_pool(
    device : Device = [[ Device ]];
    var create_info : CommandPoolCreateInfo = [[ CommandPoolCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : CommandPool

    var handle <- create_command_pool__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_command_pool(
    device : Device = [[ Device ]];
    command_pool : CommandPool = [[ CommandPool ]]
) : void

    vkDestroyCommandPool(
        boost_value_to_vk(device),
        boost_value_to_vk(command_pool),
        null
    )

def finalize(var handle : CommandPool explicit)
    if handle._needs_delete
        destroy_command_pool(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.command_pool)
        )
    memzero(handle)

//
// DescriptorSetLayout
//

struct DescriptorSetLayout
    descriptor_set_layout : VkDescriptorSetLayout
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : DescriptorSetLayout) : VkDescriptorSetLayout
    return b.descriptor_set_layout

def boost_value_to_vk(b : DescriptorSetLayout ?) : VkDescriptorSetLayout ?
    return b?.descriptor_set_layout

def vk_value_to_boost(v : VkDescriptorSetLayout) : DescriptorSetLayout
    return [[ DescriptorSetLayout descriptor_set_layout=v ]]

[private]
def create_descriptor_set_layout__inner(
    device : Device = [[ Device ]];
    var create_info : DescriptorSetLayoutCreateInfo = [[ DescriptorSetLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : DescriptorSetLayout

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_set_layout : VkDescriptorSetLayout
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateDescriptorSetLayout(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_set_layout)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_set_layout)

def create_descriptor_set_layout(
    device : Device = [[ Device ]];
    var create_info : DescriptorSetLayoutCreateInfo = [[ DescriptorSetLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : DescriptorSetLayout

    var handle <- create_descriptor_set_layout__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_descriptor_set_layout(
    device : Device = [[ Device ]];
    descriptor_set_layout : DescriptorSetLayout = [[ DescriptorSetLayout ]]
) : void

    vkDestroyDescriptorSetLayout(
        boost_value_to_vk(device),
        boost_value_to_vk(descriptor_set_layout),
        null
    )

def finalize(var handle : DescriptorSetLayout explicit)
    if handle._needs_delete
        destroy_descriptor_set_layout(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.descriptor_set_layout)
        )
    memzero(handle)

//
// Fence
//

struct Fence
    fence : VkFence
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Fence) : VkFence
    return b.fence

def boost_value_to_vk(b : Fence ?) : VkFence ?
    return b?.fence

def vk_value_to_boost(v : VkFence) : Fence
    return [[ Fence fence=v ]]

[private]
def create_fence__inner(
    device : Device = [[ Device ]];
    var create_info : FenceCreateInfo = [[ FenceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Fence

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_fence : VkFence
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateFence(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_fence)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_fence)

def create_fence(
    device : Device = [[ Device ]];
    var create_info : FenceCreateInfo = [[ FenceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Fence

    var handle <- create_fence__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_fence(
    device : Device = [[ Device ]];
    fence : Fence = [[ Fence ]]
) : void

    vkDestroyFence(
        boost_value_to_vk(device),
        boost_value_to_vk(fence),
        null
    )

def finalize(var handle : Fence explicit)
    if handle._needs_delete
        destroy_fence(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.fence)
        )
    memzero(handle)

//
// Framebuffer
//

struct Framebuffer
    framebuffer : VkFramebuffer
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Framebuffer) : VkFramebuffer
    return b.framebuffer

def boost_value_to_vk(b : Framebuffer ?) : VkFramebuffer ?
    return b?.framebuffer

def vk_value_to_boost(v : VkFramebuffer) : Framebuffer
    return [[ Framebuffer framebuffer=v ]]

[private]
def create_framebuffer__inner(
    device : Device = [[ Device ]];
    var create_info : FramebufferCreateInfo = [[ FramebufferCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Framebuffer

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_framebuffer : VkFramebuffer
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateFramebuffer(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_framebuffer)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_framebuffer)

def create_framebuffer(
    device : Device = [[ Device ]];
    var create_info : FramebufferCreateInfo = [[ FramebufferCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Framebuffer

    var handle <- create_framebuffer__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_framebuffer(
    device : Device = [[ Device ]];
    framebuffer : Framebuffer = [[ Framebuffer ]]
) : void

    vkDestroyFramebuffer(
        boost_value_to_vk(device),
        boost_value_to_vk(framebuffer),
        null
    )

def finalize(var handle : Framebuffer explicit)
    if handle._needs_delete
        destroy_framebuffer(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.framebuffer)
        )
    memzero(handle)

//
// Image
//

struct Image
    image : VkImage
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Image) : VkImage
    return b.image

def boost_value_to_vk(b : Image ?) : VkImage ?
    return b?.image

def vk_value_to_boost(v : VkImage) : Image
    return [[ Image image=v ]]

[private]
def create_image__inner(
    device : Device = [[ Device ]];
    var create_info : ImageCreateInfo = [[ ImageCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Image

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_image : VkImage
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateImage(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_image)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_image)

def create_image(
    device : Device = [[ Device ]];
    var create_info : ImageCreateInfo = [[ ImageCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Image

    var handle <- create_image__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_image(
    device : Device = [[ Device ]];
    image : Image = [[ Image ]]
) : void

    vkDestroyImage(
        boost_value_to_vk(device),
        boost_value_to_vk(image),
        null
    )

def finalize(var handle : Image explicit)
    if handle._needs_delete
        destroy_image(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.image)
        )
    memzero(handle)

//
// ImageView
//

struct ImageView
    image_view : VkImageView
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : ImageView) : VkImageView
    return b.image_view

def boost_value_to_vk(b : ImageView ?) : VkImageView ?
    return b?.image_view

def vk_value_to_boost(v : VkImageView) : ImageView
    return [[ ImageView image_view=v ]]

[private]
def create_image_view__inner(
    device : Device = [[ Device ]];
    var create_info : ImageViewCreateInfo = [[ ImageViewCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : ImageView

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_view : VkImageView
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateImageView(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_view)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_view)

def create_image_view(
    device : Device = [[ Device ]];
    var create_info : ImageViewCreateInfo = [[ ImageViewCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : ImageView

    var handle <- create_image_view__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_image_view(
    device : Device = [[ Device ]];
    image_view : ImageView = [[ ImageView ]]
) : void

    vkDestroyImageView(
        boost_value_to_vk(device),
        boost_value_to_vk(image_view),
        null
    )

def finalize(var handle : ImageView explicit)
    if handle._needs_delete
        destroy_image_view(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.image_view)
        )
    memzero(handle)

//
// Instance
//

struct Instance
    instance : VkInstance
    _needs_delete : bool

def boost_value_to_vk(b : Instance) : VkInstance
    return b.instance

def boost_value_to_vk(b : Instance ?) : VkInstance ?
    return b?.instance

def vk_value_to_boost(v : VkInstance) : Instance
    return [[ Instance instance=v ]]

[private]
def create_instance__inner(
    var create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_instance : VkInstance
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateInstance(
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_instance)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_instance)

def create_instance(
    var create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var handle <- create_instance__inner(
        create_info,
        result
    )
    handle._needs_delete = true
    return <- handle

[private]
def destroy_instance(
    instance : Instance = [[ Instance ]]
) : void

    vkDestroyInstance(
        boost_value_to_vk(instance),
        null
    )

def finalize(var handle : Instance explicit)
    if handle._needs_delete
        destroy_instance(
            vk_value_to_boost(handle.instance)
        )
    memzero(handle)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice
    _needs_delete : bool

def boost_value_to_vk(b : PhysicalDevice) : VkPhysicalDevice
    return b.physical_device

def boost_value_to_vk(b : PhysicalDevice ?) : VkPhysicalDevice ?
    return b?.physical_device

def vk_value_to_boost(v : VkPhysicalDevice) : PhysicalDevice
    return [[ PhysicalDevice physical_device=v ]]

//
// Queue
//

struct Queue
    queue : VkQueue
    _needs_delete : bool

def boost_value_to_vk(b : Queue) : VkQueue
    return b.queue

def boost_value_to_vk(b : Queue ?) : VkQueue ?
    return b?.queue

def vk_value_to_boost(v : VkQueue) : Queue
    return [[ Queue queue=v ]]

//
// PipelineCache
//

struct PipelineCache
    pipeline_cache : VkPipelineCache
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : PipelineCache) : VkPipelineCache
    return b.pipeline_cache

def boost_value_to_vk(b : PipelineCache ?) : VkPipelineCache ?
    return b?.pipeline_cache

def vk_value_to_boost(v : VkPipelineCache) : PipelineCache
    return [[ PipelineCache pipeline_cache=v ]]

[private]
def create_pipeline_cache__inner(
    device : Device = [[ Device ]];
    var create_info : PipelineCacheCreateInfo = [[ PipelineCacheCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : PipelineCache

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_pipeline_cache : VkPipelineCache
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreatePipelineCache(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_pipeline_cache)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_pipeline_cache)

def create_pipeline_cache(
    device : Device = [[ Device ]];
    var create_info : PipelineCacheCreateInfo = [[ PipelineCacheCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : PipelineCache

    var handle <- create_pipeline_cache__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_pipeline_cache(
    device : Device = [[ Device ]];
    pipeline_cache : PipelineCache = [[ PipelineCache ]]
) : void

    vkDestroyPipelineCache(
        boost_value_to_vk(device),
        boost_value_to_vk(pipeline_cache),
        null
    )

def finalize(var handle : PipelineCache explicit)
    if handle._needs_delete
        destroy_pipeline_cache(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.pipeline_cache)
        )
    memzero(handle)

//
// PipelineLayout
//

struct PipelineLayout
    pipeline_layout : VkPipelineLayout
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : PipelineLayout) : VkPipelineLayout
    return b.pipeline_layout

def boost_value_to_vk(b : PipelineLayout ?) : VkPipelineLayout ?
    return b?.pipeline_layout

def vk_value_to_boost(v : VkPipelineLayout) : PipelineLayout
    return [[ PipelineLayout pipeline_layout=v ]]

[private]
def create_pipeline_layout__inner(
    device : Device = [[ Device ]];
    var create_info : PipelineLayoutCreateInfo = [[ PipelineLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : PipelineLayout

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_pipeline_layout : VkPipelineLayout
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreatePipelineLayout(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_pipeline_layout)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_pipeline_layout)

def create_pipeline_layout(
    device : Device = [[ Device ]];
    var create_info : PipelineLayoutCreateInfo = [[ PipelineLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : PipelineLayout

    var handle <- create_pipeline_layout__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_pipeline_layout(
    device : Device = [[ Device ]];
    pipeline_layout : PipelineLayout = [[ PipelineLayout ]]
) : void

    vkDestroyPipelineLayout(
        boost_value_to_vk(device),
        boost_value_to_vk(pipeline_layout),
        null
    )

def finalize(var handle : PipelineLayout explicit)
    if handle._needs_delete
        destroy_pipeline_layout(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.pipeline_layout)
        )
    memzero(handle)

//
// RenderPass
//

struct RenderPass
    render_pass : VkRenderPass
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : RenderPass) : VkRenderPass
    return b.render_pass

def boost_value_to_vk(b : RenderPass ?) : VkRenderPass ?
    return b?.render_pass

def vk_value_to_boost(v : VkRenderPass) : RenderPass
    return [[ RenderPass render_pass=v ]]

[private]
def create_render_pass__inner(
    device : Device = [[ Device ]];
    var create_info : RenderPassCreateInfo = [[ RenderPassCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : RenderPass

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_render_pass : VkRenderPass
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateRenderPass(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_render_pass)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_render_pass)

def create_render_pass(
    device : Device = [[ Device ]];
    var create_info : RenderPassCreateInfo = [[ RenderPassCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : RenderPass

    var handle <- create_render_pass__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_render_pass(
    device : Device = [[ Device ]];
    render_pass : RenderPass = [[ RenderPass ]]
) : void

    vkDestroyRenderPass(
        boost_value_to_vk(device),
        boost_value_to_vk(render_pass),
        null
    )

def finalize(var handle : RenderPass explicit)
    if handle._needs_delete
        destroy_render_pass(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.render_pass)
        )
    memzero(handle)

//
// Sampler
//

struct Sampler
    sampler : VkSampler
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Sampler) : VkSampler
    return b.sampler

def boost_value_to_vk(b : Sampler ?) : VkSampler ?
    return b?.sampler

def vk_value_to_boost(v : VkSampler) : Sampler
    return [[ Sampler sampler=v ]]

[private]
def create_sampler__inner(
    device : Device = [[ Device ]];
    var create_info : SamplerCreateInfo = [[ SamplerCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Sampler

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_sampler : VkSampler
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateSampler(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_sampler)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_sampler)

def create_sampler(
    device : Device = [[ Device ]];
    var create_info : SamplerCreateInfo = [[ SamplerCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Sampler

    var handle <- create_sampler__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_sampler(
    device : Device = [[ Device ]];
    sampler : Sampler = [[ Sampler ]]
) : void

    vkDestroySampler(
        boost_value_to_vk(device),
        boost_value_to_vk(sampler),
        null
    )

def finalize(var handle : Sampler explicit)
    if handle._needs_delete
        destroy_sampler(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.sampler)
        )
    memzero(handle)

//
// Semaphore
//

struct Semaphore
    semaphore : VkSemaphore
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Semaphore) : VkSemaphore
    return b.semaphore

def boost_value_to_vk(b : Semaphore ?) : VkSemaphore ?
    return b?.semaphore

def vk_value_to_boost(v : VkSemaphore) : Semaphore
    return [[ Semaphore semaphore=v ]]

[private]
def create_semaphore__inner(
    device : Device = [[ Device ]];
    var create_info : SemaphoreCreateInfo = [[ SemaphoreCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Semaphore

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_semaphore : VkSemaphore
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateSemaphore(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_semaphore)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_semaphore)

def create_semaphore(
    device : Device = [[ Device ]];
    var create_info : SemaphoreCreateInfo = [[ SemaphoreCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Semaphore

    var handle <- create_semaphore__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_semaphore(
    device : Device = [[ Device ]];
    semaphore : Semaphore = [[ Semaphore ]]
) : void

    vkDestroySemaphore(
        boost_value_to_vk(device),
        boost_value_to_vk(semaphore),
        null
    )

def finalize(var handle : Semaphore explicit)
    if handle._needs_delete
        destroy_semaphore(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.semaphore)
        )
    memzero(handle)

//
// ShaderModule
//

struct ShaderModule
    shader_module : VkShaderModule
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : ShaderModule) : VkShaderModule
    return b.shader_module

def boost_value_to_vk(b : ShaderModule ?) : VkShaderModule ?
    return b?.shader_module

def vk_value_to_boost(v : VkShaderModule) : ShaderModule
    return [[ ShaderModule shader_module=v ]]

[private]
def create_shader_module__inner(
    device : Device = [[ Device ]];
    var create_info : ShaderModuleCreateInfo = [[ ShaderModuleCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : ShaderModule

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_shader_module : VkShaderModule
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateShaderModule(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_shader_module)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_shader_module)

def create_shader_module(
    device : Device = [[ Device ]];
    var create_info : ShaderModuleCreateInfo = [[ ShaderModuleCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : ShaderModule

    var handle <- create_shader_module__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_shader_module(
    device : Device = [[ Device ]];
    shader_module : ShaderModule = [[ ShaderModule ]]
) : void

    vkDestroyShaderModule(
        boost_value_to_vk(device),
        boost_value_to_vk(shader_module),
        null
    )

def finalize(var handle : ShaderModule explicit)
    if handle._needs_delete
        destroy_shader_module(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.shader_module)
        )
    memzero(handle)

//
// SwapchainKHR
//

struct SwapchainKHR
    swapchain_khr : VkSwapchainKHR
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : SwapchainKHR) : VkSwapchainKHR
    return b.swapchain_khr

def boost_value_to_vk(b : SwapchainKHR ?) : VkSwapchainKHR ?
    return b?.swapchain_khr

def vk_value_to_boost(v : VkSwapchainKHR) : SwapchainKHR
    return [[ SwapchainKHR swapchain_khr=v ]]

[private]
def create_swapchain_khr__inner(
    device : Device = [[ Device ]];
    var create_info : SwapchainCreateInfoKHR = [[ SwapchainCreateInfoKHR ]];
    var result : VkResult? = [[VkResult?]]
) : SwapchainKHR

    var vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }
    var vk_swapchain : VkSwapchainKHR
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkCreateSwapchainKHR(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(vk_swapchain)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_swapchain)

def create_swapchain_khr(
    device : Device = [[ Device ]];
    var create_info : SwapchainCreateInfoKHR = [[ SwapchainCreateInfoKHR ]];
    var result : VkResult? = [[VkResult?]]
) : SwapchainKHR

    var handle <- create_swapchain_khr__inner(
        device,
        create_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def destroy_swapchain_khr(
    device : Device = [[ Device ]];
    swapchain : SwapchainKHR = [[ SwapchainKHR ]]
) : void

    vkDestroySwapchainKHR(
        boost_value_to_vk(device),
        boost_value_to_vk(swapchain),
        null
    )

def finalize(var handle : SwapchainKHR explicit)
    if handle._needs_delete
        destroy_swapchain_khr(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.swapchain_khr)
        )
    memzero(handle)

//
// Pipeline
//

struct Pipeline
    pipeline : VkPipeline
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : Pipeline) : VkPipeline
    return b.pipeline

def boost_value_to_vk(b : Pipeline ?) : VkPipeline ?
    return b?.pipeline

def vk_value_to_boost(v : VkPipeline) : Pipeline
    return [[ Pipeline pipeline=v ]]

[private]
def create_graphics_pipelines__inner(
    device : Device = [[ Device ]];
    pipeline_cache : PipelineCache = [[ PipelineCache ]];
    var create_infos : array<GraphicsPipelineCreateInfo> = [[ array<GraphicsPipelineCreateInfo> ]];
    var result : VkResult? = [[VkResult?]]
) : array<Pipeline>

    let vk_createInfoCount = uint(create_infos |> length())
    var vk_create_infos <- [{ for item in create_infos ;
        item |> vk_view_create_unsafe() }]
    defer() <|
        for item in create_infos
            item |> vk_view_destroy()
        delete vk_create_infos
    var vk_pipelines : array<VkPipeline>
    defer() <| ${ delete vk_pipelines; }
    var result_ = VkResult VK_SUCCESS

    vk_pipelines |> resize(int(vk_createInfoCount))
    result ?? result_ = vkCreateGraphicsPipelines(
        boost_value_to_vk(device),
        boost_value_to_vk(pipeline_cache),
        vk_createInfoCount,
        array_addr_unsafe(vk_create_infos),
        null,
        array_addr_unsafe(vk_pipelines)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_pipelines; vk_value_to_boost(x)}]

def create_graphics_pipelines(
    device : Device = [[ Device ]];
    pipeline_cache : PipelineCache = [[ PipelineCache ]];
    var create_infos : array<GraphicsPipelineCreateInfo> = [[ array<GraphicsPipelineCreateInfo> ]];
    var result : VkResult? = [[VkResult?]]
) : array<Pipeline>

    var handles <- create_graphics_pipelines__inner(
        device,
        pipeline_cache,
        create_infos,
        result
    )
    for handle in handles
        handle._needs_delete = true
        handle._device = boost_value_to_vk(device)
    return <- handles

[private]
def create_compute_pipelines__inner(
    device : Device = [[ Device ]];
    pipeline_cache : PipelineCache = [[ PipelineCache ]];
    var create_infos : array<ComputePipelineCreateInfo> = [[ array<ComputePipelineCreateInfo> ]];
    var result : VkResult? = [[VkResult?]]
) : array<Pipeline>

    let vk_createInfoCount = uint(create_infos |> length())
    var vk_create_infos <- [{ for item in create_infos ;
        item |> vk_view_create_unsafe() }]
    defer() <|
        for item in create_infos
            item |> vk_view_destroy()
        delete vk_create_infos
    var vk_pipelines : array<VkPipeline>
    defer() <| ${ delete vk_pipelines; }
    var result_ = VkResult VK_SUCCESS

    vk_pipelines |> resize(int(vk_createInfoCount))
    result ?? result_ = vkCreateComputePipelines(
        boost_value_to_vk(device),
        boost_value_to_vk(pipeline_cache),
        vk_createInfoCount,
        array_addr_unsafe(vk_create_infos),
        null,
        array_addr_unsafe(vk_pipelines)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- [{for x in vk_pipelines; vk_value_to_boost(x)}]

def create_compute_pipelines(
    device : Device = [[ Device ]];
    pipeline_cache : PipelineCache = [[ PipelineCache ]];
    var create_infos : array<ComputePipelineCreateInfo> = [[ array<ComputePipelineCreateInfo> ]];
    var result : VkResult? = [[VkResult?]]
) : array<Pipeline>

    var handles <- create_compute_pipelines__inner(
        device,
        pipeline_cache,
        create_infos,
        result
    )
    for handle in handles
        handle._needs_delete = true
        handle._device = boost_value_to_vk(device)
    return <- handles

[private]
def destroy_pipeline(
    device : Device = [[ Device ]];
    pipeline : Pipeline = [[ Pipeline ]]
) : void

    vkDestroyPipeline(
        boost_value_to_vk(device),
        boost_value_to_vk(pipeline),
        null
    )

def finalize(var handle : Pipeline explicit)
    if handle._needs_delete
        destroy_pipeline(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.pipeline)
        )
    memzero(handle)

//
// DeviceMemory
//

struct DeviceMemory
    device_memory : VkDeviceMemory
    _needs_delete : bool
    _device : VkDevice

def boost_value_to_vk(b : DeviceMemory) : VkDeviceMemory
    return b.device_memory

def boost_value_to_vk(b : DeviceMemory ?) : VkDeviceMemory ?
    return b?.device_memory

def vk_value_to_boost(v : VkDeviceMemory) : DeviceMemory
    return [[ DeviceMemory device_memory=v ]]

[private]
def allocate_memory__inner(
    device : Device = [[ Device ]];
    var allocate_info : MemoryAllocateInfo = [[ MemoryAllocateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : DeviceMemory

    var vk_allocate_info <- allocate_info |> vk_view_create_unsafe()
    defer() <| ${ allocate_info |> vk_view_destroy(); }
    var vk_memory : VkDeviceMemory
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkAllocateMemory(
        boost_value_to_vk(device),
        safe_addr(vk_allocate_info),
        null,
        safe_addr(vk_memory)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_memory)

def allocate_memory(
    device : Device = [[ Device ]];
    var allocate_info : MemoryAllocateInfo = [[ MemoryAllocateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : DeviceMemory

    var handle <- allocate_memory__inner(
        device,
        allocate_info,
        result
    )
    handle._needs_delete = true
    handle._device = boost_value_to_vk(device)
    return <- handle

[private]
def free_memory(
    device : Device = [[ Device ]];
    memory : DeviceMemory = [[ DeviceMemory ]]
) : void

    vkFreeMemory(
        boost_value_to_vk(device),
        boost_value_to_vk(memory),
        null
    )

def finalize(var handle : DeviceMemory explicit)
    if handle._needs_delete
        free_memory(
            vk_value_to_boost(handle._device),
            vk_value_to_boost(handle.device_memory)
        )
    memzero(handle)
