// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_p_view(
    p_boost_struct : auto(BOOST_T)?;
    b : block<(p_vk_struct : auto(VK_T)?)>
)
    if p_boost_struct == null
        b |> invoke([[VK_T?]])
    else
        *p_boost_struct |> with_view() <| $(vk_struct)
            unsafe
                b |> invoke(addr(vk_struct))

def to_string(bytes : int8[])
    unsafe
        let s := reinterpret<string>(addr(bytes[0]))
        return s

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)

//
// Functions
//

def get_physical_device_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : PhysicalDeviceProperties
    var vk_output : VkPhysicalDeviceProperties
    vkGetPhysicalDeviceProperties(
        physical_device.physical_device,
        safe_addr(vk_output)
    )
    return <- construct(vk_output)

def enumerate_device_extension_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    layer_name : string = [[ string ]];
    var result : VkResult? = [[VkResult?]]
) : array<ExtensionProperties>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkEnumerateDeviceExtensionProperties(
        physical_device.physical_device,
        layer_name,
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<ExtensionProperties>]]

    var vk_items : array<VkExtensionProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkEnumerateDeviceExtensionProperties(
            physical_device.physical_device,
            layer_name,
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; construct(item)}]

def get_physical_device_queue_family_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : array<QueueFamilyProperties>
    var count : uint
    vkGetPhysicalDeviceQueueFamilyProperties(
        physical_device.physical_device,
        safe_addr(count),
        null
    )


    var vk_items : array<VkQueueFamilyProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        vkGetPhysicalDeviceQueueFamilyProperties(
            physical_device.physical_device,
            safe_addr(count),
            vk_p_items
        )

    return <- [{for item in vk_items ; construct(item)}]

def get_physical_device_surface_formats_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<SurfaceFormatKHR>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
        physical_device.physical_device,
        surface.surface_khr,
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<SurfaceFormatKHR>]]

    var vk_items : array<VkSurfaceFormatKHR>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
            physical_device.physical_device,
            surface.surface_khr,
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; construct(item)}]

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint

def with_view(
    boost_struct : ApplicationInfo;
    b : block<(vk_struct : VkApplicationInfo)>
) {
    let vk_struct <- [[ VkApplicationInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_APPLICATION_INFO,
        pApplicationName = boost_struct.application_name,
        applicationVersion = boost_struct.application_version,
        pEngineName = boost_struct.engine_name,
        engineVersion = boost_struct.engine_version,
        apiVersion = boost_struct.api_version
    ]];
    b |> invoke(vk_struct);
}

//
// ExtensionProperties
//

struct ExtensionProperties
    extension_name : string
    spec_version : uint

def construct(vk_struct : VkExtensionProperties) : ExtensionProperties
    return <- [[ExtensionProperties
        extension_name = to_string(vk_struct.extensionName),
        spec_version = vk_struct.specVersion
    ]]

//
// Extent3D
//

struct Extent3D
    width : uint
    height : uint
    depth : uint

def with_view(
    boost_struct : Extent3D;
    b : block<(vk_struct : VkExtent3D)>
) {
    let vk_struct <- [[ VkExtent3D
        width = boost_struct.width,
        height = boost_struct.height,
        depth = boost_struct.depth
    ]];
    b |> invoke(vk_struct);
}

def construct(vk_struct : VkExtent3D) : Extent3D
    return <- [[Extent3D
        width = vk_struct.width,
        height = vk_struct.height,
        depth = vk_struct.depth
    ]]

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>

def with_view(
    boost_struct : InstanceCreateInfo;
    b : block<(vk_struct : VkInstanceCreateInfo)>
) {
    boost_struct.p_application_info |> with_p_view() <| $(
        vk_p_application_info : VkApplicationInfo const ?
    ) {
    boost_struct.enabled_layer_names |> lock_data() <| $(
        vk_p_enabled_layer_names, vk_enabled_layer_count
    ) {
    boost_struct.enabled_extension_names |> lock_data() <| $(
        vk_p_enabled_extension_names, vk_enabled_extension_count
    ) {
    let vk_struct <- [[ VkInstanceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        flags = boost_struct.flags,
        pApplicationInfo = vk_p_application_info,
        enabledLayerCount = uint(vk_enabled_layer_count),
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = uint(vk_enabled_extension_count),
        ppEnabledExtensionNames = vk_p_enabled_extension_names
    ]];
    b |> invoke(vk_struct);
    }}};
}

//
// PhysicalDeviceLimits
//

struct PhysicalDeviceLimits
    max_image_dimension_1d : uint
    max_image_dimension_2d : uint
    max_image_dimension_3d : uint
    max_image_dimension_cube : uint
    max_image_array_layers : uint
    max_texel_buffer_elements : uint
    max_uniform_buffer_range : uint
    max_storage_buffer_range : uint
    max_push_constants_size : uint
    max_memory_allocation_count : uint
    max_sampler_allocation_count : uint
    buffer_image_granularity : uint64
    sparse_address_space_size : uint64
    max_bound_descriptor_sets : uint
    max_per_stage_descriptor_samplers : uint
    max_per_stage_descriptor_uniform_buffers : uint
    max_per_stage_descriptor_storage_buffers : uint
    max_per_stage_descriptor_sampled_images : uint
    max_per_stage_descriptor_storage_images : uint
    max_per_stage_descriptor_input_attachments : uint
    max_per_stage_resources : uint
    max_descriptor_set_samplers : uint
    max_descriptor_set_uniform_buffers : uint
    max_descriptor_set_uniform_buffers_dynamic : uint
    max_descriptor_set_storage_buffers : uint
    max_descriptor_set_storage_buffers_dynamic : uint
    max_descriptor_set_sampled_images : uint
    max_descriptor_set_storage_images : uint
    max_descriptor_set_input_attachments : uint
    max_vertex_input_attributes : uint
    max_vertex_input_bindings : uint
    max_vertex_input_attribute_offset : uint
    max_vertex_input_binding_stride : uint
    max_vertex_output_components : uint
    max_tessellation_generation_level : uint
    max_tessellation_patch_size : uint
    max_tessellation_control_per_vertex_input_components : uint
    max_tessellation_control_per_vertex_output_components : uint
    max_tessellation_control_per_patch_output_components : uint
    max_tessellation_control_total_output_components : uint
    max_tessellation_evaluation_input_components : uint
    max_tessellation_evaluation_output_components : uint
    max_geometry_shader_invocations : uint
    max_geometry_input_components : uint
    max_geometry_output_components : uint
    max_geometry_output_vertices : uint
    max_geometry_total_output_components : uint
    max_fragment_input_components : uint
    max_fragment_output_attachments : uint
    max_fragment_dual_src_attachments : uint
    max_fragment_combined_output_resources : uint
    max_compute_shared_memory_size : uint
    max_compute_work_group_count : uint [3]
    max_compute_work_group_invocations : uint
    max_compute_work_group_size : uint [3]
    sub_pixel_precision_bits : uint
    sub_texel_precision_bits : uint
    mipmap_precision_bits : uint
    max_draw_indexed_index_value : uint
    max_draw_indirect_count : uint
    max_sampler_lod_bias : float
    max_sampler_anisotropy : float
    max_viewports : uint
    max_viewport_dimensions : uint [2]
    viewport_bounds_range : float [2]
    viewport_sub_pixel_bits : uint
    min_memory_map_alignment : uint64
    min_texel_buffer_offset_alignment : uint64
    min_uniform_buffer_offset_alignment : uint64
    min_storage_buffer_offset_alignment : uint64
    min_texel_offset : int
    max_texel_offset : uint
    min_texel_gather_offset : int
    max_texel_gather_offset : uint
    min_interpolation_offset : float
    max_interpolation_offset : float
    sub_pixel_interpolation_offset_bits : uint
    max_framebuffer_width : uint
    max_framebuffer_height : uint
    max_framebuffer_layers : uint
    framebuffer_color_sample_counts : uint
    framebuffer_depth_sample_counts : uint
    framebuffer_stencil_sample_counts : uint
    framebuffer_no_attachments_sample_counts : uint
    max_color_attachments : uint
    sampled_image_color_sample_counts : uint
    sampled_image_integer_sample_counts : uint
    sampled_image_depth_sample_counts : uint
    sampled_image_stencil_sample_counts : uint
    storage_image_sample_counts : uint
    max_sample_mask_words : uint
    timestamp_compute_and_graphics : uint
    timestamp_period : float
    max_clip_distances : uint
    max_cull_distances : uint
    max_combined_clip_and_cull_distances : uint
    discrete_queue_priorities : uint
    point_size_range : float [2]
    line_width_range : float [2]
    point_size_granularity : float
    line_width_granularity : float
    strict_lines : uint
    standard_sample_locations : uint
    optimal_buffer_copy_offset_alignment : uint64
    optimal_buffer_copy_row_pitch_alignment : uint64
    non_coherent_atom_size : uint64

def construct(vk_struct : VkPhysicalDeviceLimits) : PhysicalDeviceLimits
    return <- [[PhysicalDeviceLimits
        max_image_dimension_1d = vk_struct.maxImageDimension1D,
        max_image_dimension_2d = vk_struct.maxImageDimension2D,
        max_image_dimension_3d = vk_struct.maxImageDimension3D,
        max_image_dimension_cube = vk_struct.maxImageDimensionCube,
        max_image_array_layers = vk_struct.maxImageArrayLayers,
        max_texel_buffer_elements = vk_struct.maxTexelBufferElements,
        max_uniform_buffer_range = vk_struct.maxUniformBufferRange,
        max_storage_buffer_range = vk_struct.maxStorageBufferRange,
        max_push_constants_size = vk_struct.maxPushConstantsSize,
        max_memory_allocation_count = vk_struct.maxMemoryAllocationCount,
        max_sampler_allocation_count = vk_struct.maxSamplerAllocationCount,
        buffer_image_granularity = vk_struct.bufferImageGranularity,
        sparse_address_space_size = vk_struct.sparseAddressSpaceSize,
        max_bound_descriptor_sets = vk_struct.maxBoundDescriptorSets,
        max_per_stage_descriptor_samplers = vk_struct.maxPerStageDescriptorSamplers,
        max_per_stage_descriptor_uniform_buffers = vk_struct.maxPerStageDescriptorUniformBuffers,
        max_per_stage_descriptor_storage_buffers = vk_struct.maxPerStageDescriptorStorageBuffers,
        max_per_stage_descriptor_sampled_images = vk_struct.maxPerStageDescriptorSampledImages,
        max_per_stage_descriptor_storage_images = vk_struct.maxPerStageDescriptorStorageImages,
        max_per_stage_descriptor_input_attachments = vk_struct.maxPerStageDescriptorInputAttachments,
        max_per_stage_resources = vk_struct.maxPerStageResources,
        max_descriptor_set_samplers = vk_struct.maxDescriptorSetSamplers,
        max_descriptor_set_uniform_buffers = vk_struct.maxDescriptorSetUniformBuffers,
        max_descriptor_set_uniform_buffers_dynamic = vk_struct.maxDescriptorSetUniformBuffersDynamic,
        max_descriptor_set_storage_buffers = vk_struct.maxDescriptorSetStorageBuffers,
        max_descriptor_set_storage_buffers_dynamic = vk_struct.maxDescriptorSetStorageBuffersDynamic,
        max_descriptor_set_sampled_images = vk_struct.maxDescriptorSetSampledImages,
        max_descriptor_set_storage_images = vk_struct.maxDescriptorSetStorageImages,
        max_descriptor_set_input_attachments = vk_struct.maxDescriptorSetInputAttachments,
        max_vertex_input_attributes = vk_struct.maxVertexInputAttributes,
        max_vertex_input_bindings = vk_struct.maxVertexInputBindings,
        max_vertex_input_attribute_offset = vk_struct.maxVertexInputAttributeOffset,
        max_vertex_input_binding_stride = vk_struct.maxVertexInputBindingStride,
        max_vertex_output_components = vk_struct.maxVertexOutputComponents,
        max_tessellation_generation_level = vk_struct.maxTessellationGenerationLevel,
        max_tessellation_patch_size = vk_struct.maxTessellationPatchSize,
        max_tessellation_control_per_vertex_input_components = vk_struct.maxTessellationControlPerVertexInputComponents,
        max_tessellation_control_per_vertex_output_components = vk_struct.maxTessellationControlPerVertexOutputComponents,
        max_tessellation_control_per_patch_output_components = vk_struct.maxTessellationControlPerPatchOutputComponents,
        max_tessellation_control_total_output_components = vk_struct.maxTessellationControlTotalOutputComponents,
        max_tessellation_evaluation_input_components = vk_struct.maxTessellationEvaluationInputComponents,
        max_tessellation_evaluation_output_components = vk_struct.maxTessellationEvaluationOutputComponents,
        max_geometry_shader_invocations = vk_struct.maxGeometryShaderInvocations,
        max_geometry_input_components = vk_struct.maxGeometryInputComponents,
        max_geometry_output_components = vk_struct.maxGeometryOutputComponents,
        max_geometry_output_vertices = vk_struct.maxGeometryOutputVertices,
        max_geometry_total_output_components = vk_struct.maxGeometryTotalOutputComponents,
        max_fragment_input_components = vk_struct.maxFragmentInputComponents,
        max_fragment_output_attachments = vk_struct.maxFragmentOutputAttachments,
        max_fragment_dual_src_attachments = vk_struct.maxFragmentDualSrcAttachments,
        max_fragment_combined_output_resources = vk_struct.maxFragmentCombinedOutputResources,
        max_compute_shared_memory_size = vk_struct.maxComputeSharedMemorySize,
        max_compute_work_group_count = vk_struct.maxComputeWorkGroupCount,
        max_compute_work_group_invocations = vk_struct.maxComputeWorkGroupInvocations,
        max_compute_work_group_size = vk_struct.maxComputeWorkGroupSize,
        sub_pixel_precision_bits = vk_struct.subPixelPrecisionBits,
        sub_texel_precision_bits = vk_struct.subTexelPrecisionBits,
        mipmap_precision_bits = vk_struct.mipmapPrecisionBits,
        max_draw_indexed_index_value = vk_struct.maxDrawIndexedIndexValue,
        max_draw_indirect_count = vk_struct.maxDrawIndirectCount,
        max_sampler_lod_bias = vk_struct.maxSamplerLodBias,
        max_sampler_anisotropy = vk_struct.maxSamplerAnisotropy,
        max_viewports = vk_struct.maxViewports,
        max_viewport_dimensions = vk_struct.maxViewportDimensions,
        viewport_bounds_range = vk_struct.viewportBoundsRange,
        viewport_sub_pixel_bits = vk_struct.viewportSubPixelBits,
        min_memory_map_alignment = vk_struct.minMemoryMapAlignment,
        min_texel_buffer_offset_alignment = vk_struct.minTexelBufferOffsetAlignment,
        min_uniform_buffer_offset_alignment = vk_struct.minUniformBufferOffsetAlignment,
        min_storage_buffer_offset_alignment = vk_struct.minStorageBufferOffsetAlignment,
        min_texel_offset = vk_struct.minTexelOffset,
        max_texel_offset = vk_struct.maxTexelOffset,
        min_texel_gather_offset = vk_struct.minTexelGatherOffset,
        max_texel_gather_offset = vk_struct.maxTexelGatherOffset,
        min_interpolation_offset = vk_struct.minInterpolationOffset,
        max_interpolation_offset = vk_struct.maxInterpolationOffset,
        sub_pixel_interpolation_offset_bits = vk_struct.subPixelInterpolationOffsetBits,
        max_framebuffer_width = vk_struct.maxFramebufferWidth,
        max_framebuffer_height = vk_struct.maxFramebufferHeight,
        max_framebuffer_layers = vk_struct.maxFramebufferLayers,
        framebuffer_color_sample_counts = vk_struct.framebufferColorSampleCounts,
        framebuffer_depth_sample_counts = vk_struct.framebufferDepthSampleCounts,
        framebuffer_stencil_sample_counts = vk_struct.framebufferStencilSampleCounts,
        framebuffer_no_attachments_sample_counts = vk_struct.framebufferNoAttachmentsSampleCounts,
        max_color_attachments = vk_struct.maxColorAttachments,
        sampled_image_color_sample_counts = vk_struct.sampledImageColorSampleCounts,
        sampled_image_integer_sample_counts = vk_struct.sampledImageIntegerSampleCounts,
        sampled_image_depth_sample_counts = vk_struct.sampledImageDepthSampleCounts,
        sampled_image_stencil_sample_counts = vk_struct.sampledImageStencilSampleCounts,
        storage_image_sample_counts = vk_struct.storageImageSampleCounts,
        max_sample_mask_words = vk_struct.maxSampleMaskWords,
        timestamp_compute_and_graphics = vk_struct.timestampComputeAndGraphics,
        timestamp_period = vk_struct.timestampPeriod,
        max_clip_distances = vk_struct.maxClipDistances,
        max_cull_distances = vk_struct.maxCullDistances,
        max_combined_clip_and_cull_distances = vk_struct.maxCombinedClipAndCullDistances,
        discrete_queue_priorities = vk_struct.discreteQueuePriorities,
        point_size_range = vk_struct.pointSizeRange,
        line_width_range = vk_struct.lineWidthRange,
        point_size_granularity = vk_struct.pointSizeGranularity,
        line_width_granularity = vk_struct.lineWidthGranularity,
        strict_lines = vk_struct.strictLines,
        standard_sample_locations = vk_struct.standardSampleLocations,
        optimal_buffer_copy_offset_alignment = vk_struct.optimalBufferCopyOffsetAlignment,
        optimal_buffer_copy_row_pitch_alignment = vk_struct.optimalBufferCopyRowPitchAlignment,
        non_coherent_atom_size = vk_struct.nonCoherentAtomSize
    ]]

//
// PhysicalDeviceProperties
//

struct PhysicalDeviceProperties
    api_version : uint
    driver_version : uint
    vendor_id : uint
    device_id : uint
    device_type : VkPhysicalDeviceType
    device_name : string
    pipeline_cache_uuid : uint8 [16]
    limits : PhysicalDeviceLimits
    sparse_properties : PhysicalDeviceSparseProperties

def construct(vk_struct : VkPhysicalDeviceProperties) : PhysicalDeviceProperties
    return <- [[PhysicalDeviceProperties
        api_version = vk_struct.apiVersion,
        driver_version = vk_struct.driverVersion,
        vendor_id = vk_struct.vendorID,
        device_id = vk_struct.deviceID,
        device_type = vk_struct.deviceType,
        device_name = to_string(vk_struct.deviceName),
        pipeline_cache_uuid = vk_struct.pipelineCacheUUID,
        limits <- construct(vk_struct.limits),
        sparse_properties <- construct(vk_struct.sparseProperties)
    ]]

//
// PhysicalDeviceSparseProperties
//

struct PhysicalDeviceSparseProperties
    residency_standard_2d_block_shape : uint
    residency_standard_2d_multisample_block_shape : uint
    residency_standard_3d_block_shape : uint
    residency_aligned_mip_size : uint
    residency_non_resident_strict : uint

def construct(vk_struct : VkPhysicalDeviceSparseProperties) : PhysicalDeviceSparseProperties
    return <- [[PhysicalDeviceSparseProperties
        residency_standard_2d_block_shape = vk_struct.residencyStandard2DBlockShape,
        residency_standard_2d_multisample_block_shape = vk_struct.residencyStandard2DMultisampleBlockShape,
        residency_standard_3d_block_shape = vk_struct.residencyStandard3DBlockShape,
        residency_aligned_mip_size = vk_struct.residencyAlignedMipSize,
        residency_non_resident_strict = vk_struct.residencyNonResidentStrict
    ]]

//
// QueueFamilyProperties
//

struct QueueFamilyProperties
    queue_flags : uint
    queue_count : uint
    timestamp_valid_bits : uint
    min_image_transfer_granularity : Extent3D

def construct(vk_struct : VkQueueFamilyProperties) : QueueFamilyProperties
    return <- [[QueueFamilyProperties
        queue_flags = vk_struct.queueFlags,
        queue_count = vk_struct.queueCount,
        timestamp_valid_bits = vk_struct.timestampValidBits,
        min_image_transfer_granularity <- construct(vk_struct.minImageTransferGranularity)
    ]]

//
// SurfaceFormatKHR
//

struct SurfaceFormatKHR
    format : VkFormat
    color_space : VkColorSpaceKHR

def with_view(
    boost_struct : SurfaceFormatKHR;
    b : block<(vk_struct : VkSurfaceFormatKHR)>
) {
    let vk_struct <- [[ VkSurfaceFormatKHR
        format = boost_struct.format,
        colorSpace = boost_struct.color_space
    ]];
    b |> invoke(vk_struct);
}

def construct(vk_struct : VkSurfaceFormatKHR) : SurfaceFormatKHR
    return <- [[SurfaceFormatKHR
        format = vk_struct.format,
        color_space = vk_struct.colorSpace
    ]]

//
// Instance
//

struct Instance
    instance : VkInstance

def create_instance(
    create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var instance : Instance
    create_info |> with_view() <| $(vk_info)
        var result_ = VkResult VK_SUCCESS
        result ?? result_ = vkCreateInstance(
            safe_addr(vk_info),
            null,
            safe_addr(instance.instance)
        )
        assert(result_ == VkResult VK_SUCCESS)
    return <- instance

def finalize(var instance : Instance)
    vkDestroyInstance(
        instance.instance,
        null
    )
    memzero(instance)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice

struct PhysicalDeviceBatch
    physical_device_batch : array<VkPhysicalDevice>

def split(batch : PhysicalDeviceBatch) : array<PhysicalDevice>
    return <- [{for h in batch.physical_device_batch ;
        [[PhysicalDevice physical_device=h]]}]

def enumerate_physical_devices(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
) : PhysicalDeviceBatch

    var count : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        instance.instance,
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    var vk_handles : array<VkPhysicalDevice>
    if result ?? result_ == VkResult VK_SUCCESS && count > 0u
        vk_handles |> resize(int(count))
        vk_handles |> lock() <| $(thandles)
            result ?? result_ = vkEnumeratePhysicalDevices(
                instance.instance,
                safe_addr(count),
                addr(thandles[0])
            )
            assert(result_ == VkResult VK_SUCCESS)

    return <- [[PhysicalDeviceBatch physical_device_batch <- vk_handles]]

def enumerate_physical_devices_no_batch(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
): array<PhysicalDevice>
    var handles <- enumerate_physical_devices(instance, result)
    defer() <| ${ delete handles; }
    return <- handles |> split()

//
// Param helpers
//


def vk_value_to_boost(VkExtent3D v; var Extent3D b)
    v <- construct(vk_value)

def boost_value_to_vk(Instance b; var VkInstance v)
    v = boost_value.instance

def boost_value_to_vk(PhysicalDevice b; var VkPhysicalDevice v)
    v = boost_value.physical_device

def vk_value_to_boost(VkPhysicalDeviceLimits v; var PhysicalDeviceLimits b)
    v <- construct(vk_value)

def vk_value_to_boost(VkPhysicalDeviceSparseProperties v; var PhysicalDeviceSparseProperties b)
    v <- construct(vk_value)

def boost_value_to_vk(SurfaceKHR b; var VkSurfaceKHR v)
    v = boost_value.surface_khr

def boost_value_to_vk(VkColorSpaceKHR b; var VkColorSpaceKHR v)
    v = boost_value
def vk_value_to_boost(VkColorSpaceKHR v; var VkColorSpaceKHR b)
    v = vk_value

def boost_value_to_vk(VkFormat b; var VkFormat v)
    v = boost_value
def vk_value_to_boost(VkFormat v; var VkFormat b)
    v = vk_value

def boost_value_to_vk(VkInstance ? b; var VkInstance ? v)
    v = boost_value?.vk_instance

def boost_value_to_vk(VkPhysicalDevice ? b; var VkPhysicalDevice ? v)
    v = boost_value?.vk_physical_device

def boost_value_to_vk(VkPhysicalDeviceType b; var VkPhysicalDeviceType v)
    v = boost_value
def vk_value_to_boost(VkPhysicalDeviceType v; var VkPhysicalDeviceType b)
    v = vk_value

def boost_value_to_vk(VkStructureType b; var VkStructureType v)
    v = boost_value
def vk_value_to_boost(VkStructureType v; var VkStructureType b)
    v = vk_value

def boost_value_to_vk(float b; var float v)
    v = boost_value
def vk_value_to_boost(float v; var float b)
    v = vk_value

def boost_value_to_vk(float [2] b; var float [2] v)
    v = boost_value
def vk_value_to_boost(float [2] v; var float [2] b)
    v = vk_value

def boost_value_to_vk(int b; var int v)
    v = boost_value
def vk_value_to_boost(int v; var int b)
    v = vk_value

def boost_value_to_vk(string b; var string v)
    v = boost_value
def vk_value_to_boost(string v; var string b)
    v = vk_value

def boost_value_to_vk(string ? b; var string ? v)
    v = boost_value
def vk_value_to_boost(string ? v; var string ? b)
    v = vk_value

def boost_value_to_vk(uint b; var uint v)
    v = boost_value
def vk_value_to_boost(uint v; var uint b)
    v = vk_value

def boost_value_to_vk(uint ? b; var uint ? v)
    v = boost_value
def vk_value_to_boost(uint ? v; var uint ? b)
    v = vk_value

def boost_value_to_vk(uint [2] b; var uint [2] v)
    v = boost_value
def vk_value_to_boost(uint [2] v; var uint [2] b)
    v = vk_value

def boost_value_to_vk(uint [3] b; var uint [3] v)
    v = boost_value
def vk_value_to_boost(uint [3] v; var uint [3] b)
    v = vk_value

def boost_value_to_vk(uint64 b; var uint64 v)
    v = boost_value
def vk_value_to_boost(uint64 v; var uint64 b)
    v = vk_value

def boost_value_to_vk(uint8 [16] b; var uint8 [16] v)
    v = boost_value
def vk_value_to_boost(uint8 [16] v; var uint8 [16] b)
    v = vk_value
