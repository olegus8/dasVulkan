// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_view(
    var boost_struct : auto(BOOST_T);
    b : block<(vk_struct : auto(VK_T))>
)
    var vk_struct : VK_T
    unsafe
        vk_struct <- boost_struct |> vk_view_create()
    b |> invoke(vk_view)
    boost_struct |> vk_view_destroy()

def boost_value_to_vk(b : auto(T)) : T
    return b

def vk_value_to_boost(v : auto(T)) : T
    return v

def vk_value_to_boost(v : int8[]) : string
    unsafe
        let s := reinterpret<string>(addr(v[0]))
        return s

[unsafe_function]
def array_addr(ar : array<auto(T)>) : T?
    unsafe
        return length(ar) > 0 ? addr(ar[0]) : [[T?]]

//
// Device
//

def finalize(var device : Device)
    let vk_device = boost_value_to_vk(device)
    vk_device |> vkDeviceWaitIdle()
    vk_device |> vkDestroyDevice(null)
    memzero(device)

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def boost_value_to_vk(b : SurfaceKHR) : VkSurfaceKHR
    return b.surface_khr

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)

//
// Functions
//

def get_physical_device_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : PhysicalDeviceProperties
    var vk_output : VkPhysicalDeviceProperties
    vkGetPhysicalDeviceProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_output)
    )
    return <- vk_value_to_boost(vk_output)

def get_physical_device_surface_support_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    queue_family_index : uint = [[ uint ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : uint
    var vk_output : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfaceSupportKHR(
        boost_value_to_vk(physical_device),
        queue_family_index,
        boost_value_to_vk(surface),
        safe_addr(vk_output)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_output)

def enumerate_device_extension_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    layer_name : string = [[ string ]];
    var result : VkResult? = [[VkResult?]]
) : array<ExtensionProperties>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkEnumerateDeviceExtensionProperties(
        boost_value_to_vk(physical_device),
        layer_name,
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<ExtensionProperties>]]

    var vk_items : array<VkExtensionProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkEnumerateDeviceExtensionProperties(
            boost_value_to_vk(physical_device),
            layer_name,
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_queue_family_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : array<QueueFamilyProperties>
    var count : uint
    vkGetPhysicalDeviceQueueFamilyProperties(
        boost_value_to_vk(physical_device),
        safe_addr(count),
        null
    )

    var vk_items : array<VkQueueFamilyProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        vkGetPhysicalDeviceQueueFamilyProperties(
            boost_value_to_vk(physical_device),
            safe_addr(count),
            vk_p_items
        )

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_surface_formats_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<SurfaceFormatKHR>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<SurfaceFormatKHR>]]

    var vk_items : array<VkSurfaceFormatKHR>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
            boost_value_to_vk(physical_device),
            boost_value_to_vk(surface),
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_surface_present_modes_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<VkPresentModeKHR>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<VkPresentModeKHR>]]

    var vk_items : array<VkPresentModeKHR>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
            boost_value_to_vk(physical_device),
            boost_value_to_vk(surface),
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : ApplicationInfo) : VkApplicationInfo
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkApplicationInfo
    vk_struct.sType = VkStructureType VK_STRUCTURE_TYPE_APPLICATION_INFO
    vk_struct.pApplicationName = boost_struct.application_name
    vk_struct.applicationVersion = boost_struct.application_version
    vk_struct.pEngineName = boost_struct.engine_name
    vk_struct.engineVersion = boost_struct.engine_version
    vk_struct.apiVersion = boost_struct.api_version

    return <- vk_struct

def vk_view_destroy(boost_struct : ApplicationInfo)
    assert(boost_struct._vk_view_active)
    boost_struct._vk_view_active = false

//
// DeviceCreateInfo
//

struct DeviceCreateInfo
    flags : uint
    queue_create_infos : array<DeviceQueueCreateInfo>
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    p_enabled_features : PhysicalDeviceFeatures ?
    _vk_view_queue_create_infos : array<VkDeviceQueueCreateInfo>
    _vk_view_p_enabled_features : VkPhysicalDeviceFeatures
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : DeviceCreateInfo) : VkDeviceCreateInfo
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkDeviceCreateInfo
    vk_struct.sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
    vk_struct.flags = boost_struct.flags
    vk_struct.queueCreateInfoCount = uint(boost_struct.queue_create_info_count |> length())
    boost_struct._vk_view_queue_create_infos <- [{for item in boost_struct.queue_create_infos ; item |> vk_view_create()}]
    unsafe
        vk_struct.pQueueCreateInfos = array_addr(boost_struct._vk_view_queue_create_infos)
    vk_struct.enabledLayerCount = uint(boost_struct.enabled_layer_count |> length())
    unsafe
        vk_struct.ppEnabledLayerNames = array_addr(boost_struct.enabled_layer_names)
    vk_struct.enabledExtensionCount = uint(boost_struct.enabled_extension_count |> length())
    unsafe
        vk_struct.ppEnabledExtensionNames = array_addr(boost_struct.enabled_extension_names)
    if boost_struct.p_enabled_features != null
        boost_struct._vk_view_p_enabled_features <- *boost_struct.p_enabled_features |> vk_view_create()
        unsafe
            vk_struct.pEnabledFeatures = addr(boost_struct.p_enabled_features)

    return <- vk_struct

def vk_view_destroy(boost_struct : DeviceCreateInfo)
    assert(boost_struct._vk_view_active)
    for item in boost_struct.queue_create_infos
        item |> vk_view_destroy()
    delete boost_struct._vk_view_queue_create_infos
    if boost_struct.p_enabled_features != null
        *boost_struct.p_enabled_features |> vk_view_destroy()
    boost_struct._vk_view_active = false

//
// DeviceQueueCreateInfo
//

struct DeviceQueueCreateInfo
    flags : uint
    queue_family_index : uint
    queue_priorities : array<float>
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : DeviceQueueCreateInfo) : VkDeviceQueueCreateInfo
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkDeviceQueueCreateInfo
    vk_struct.sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    vk_struct.flags = boost_struct.flags
    vk_struct.queueFamilyIndex = boost_struct.queue_family_index
    vk_struct.queueCount = uint(boost_struct.queue_count |> length())
    unsafe
        vk_struct.pQueuePriorities = array_addr(boost_struct.queue_priorities)

    return <- vk_struct

def vk_view_destroy(boost_struct : DeviceQueueCreateInfo)
    assert(boost_struct._vk_view_active)
    boost_struct._vk_view_active = false

//
// ExtensionProperties
//

struct ExtensionProperties
    extension_name : string
    spec_version : uint
    _vk_view_active : bool

def vk_value_to_boost(vk_struct : VkExtensionProperties) : ExtensionProperties
    return <- [[ExtensionProperties
        extension_name = vk_value_to_boost(vk_struct.extensionName),
        spec_version = vk_struct.specVersion
    ]]

//
// Extent3D
//

struct Extent3D
    width : uint
    height : uint
    depth : uint
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : Extent3D) : VkExtent3D
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkExtent3D
    vk_struct.width = boost_struct.width
    vk_struct.height = boost_struct.height
    vk_struct.depth = boost_struct.depth

    return <- vk_struct

def vk_view_destroy(boost_struct : Extent3D)
    assert(boost_struct._vk_view_active)
    boost_struct._vk_view_active = false

def vk_value_to_boost(vk_struct : VkExtent3D) : Extent3D
    return <- [[Extent3D
        width = vk_struct.width,
        height = vk_struct.height,
        depth = vk_struct.depth
    ]]

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    _vk_view_p_application_info : VkApplicationInfo
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : InstanceCreateInfo) : VkInstanceCreateInfo
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkInstanceCreateInfo
    vk_struct.sType = VkStructureType VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    vk_struct.flags = boost_struct.flags
    if boost_struct.p_application_info != null
        boost_struct._vk_view_p_application_info <- *boost_struct.p_application_info |> vk_view_create()
        unsafe
            vk_struct.pApplicationInfo = addr(boost_struct.p_application_info)
    vk_struct.enabledLayerCount = uint(boost_struct.enabled_layer_count |> length())
    unsafe
        vk_struct.ppEnabledLayerNames = array_addr(boost_struct.enabled_layer_names)
    vk_struct.enabledExtensionCount = uint(boost_struct.enabled_extension_count |> length())
    unsafe
        vk_struct.ppEnabledExtensionNames = array_addr(boost_struct.enabled_extension_names)

    return <- vk_struct

def vk_view_destroy(boost_struct : InstanceCreateInfo)
    assert(boost_struct._vk_view_active)
    if boost_struct.p_application_info != null
        *boost_struct.p_application_info |> vk_view_destroy()
    boost_struct._vk_view_active = false

//
// PhysicalDeviceLimits
//

struct PhysicalDeviceLimits
    max_image_dimension_1d : uint
    max_image_dimension_2d : uint
    max_image_dimension_3d : uint
    max_image_dimension_cube : uint
    max_image_array_layers : uint
    max_texel_buffer_elements : uint
    max_uniform_buffer_range : uint
    max_storage_buffer_range : uint
    max_push_constants_size : uint
    max_memory_allocation_count : uint
    max_sampler_allocation_count : uint
    buffer_image_granularity : uint64
    sparse_address_space_size : uint64
    max_bound_descriptor_sets : uint
    max_per_stage_descriptor_samplers : uint
    max_per_stage_descriptor_uniform_buffers : uint
    max_per_stage_descriptor_storage_buffers : uint
    max_per_stage_descriptor_sampled_images : uint
    max_per_stage_descriptor_storage_images : uint
    max_per_stage_descriptor_input_attachments : uint
    max_per_stage_resources : uint
    max_descriptor_set_samplers : uint
    max_descriptor_set_uniform_buffers : uint
    max_descriptor_set_uniform_buffers_dynamic : uint
    max_descriptor_set_storage_buffers : uint
    max_descriptor_set_storage_buffers_dynamic : uint
    max_descriptor_set_sampled_images : uint
    max_descriptor_set_storage_images : uint
    max_descriptor_set_input_attachments : uint
    max_vertex_input_attributes : uint
    max_vertex_input_bindings : uint
    max_vertex_input_attribute_offset : uint
    max_vertex_input_binding_stride : uint
    max_vertex_output_components : uint
    max_tessellation_generation_level : uint
    max_tessellation_patch_size : uint
    max_tessellation_control_per_vertex_input_components : uint
    max_tessellation_control_per_vertex_output_components : uint
    max_tessellation_control_per_patch_output_components : uint
    max_tessellation_control_total_output_components : uint
    max_tessellation_evaluation_input_components : uint
    max_tessellation_evaluation_output_components : uint
    max_geometry_shader_invocations : uint
    max_geometry_input_components : uint
    max_geometry_output_components : uint
    max_geometry_output_vertices : uint
    max_geometry_total_output_components : uint
    max_fragment_input_components : uint
    max_fragment_output_attachments : uint
    max_fragment_dual_src_attachments : uint
    max_fragment_combined_output_resources : uint
    max_compute_shared_memory_size : uint
    max_compute_work_group_count : uint [3]
    max_compute_work_group_invocations : uint
    max_compute_work_group_size : uint [3]
    sub_pixel_precision_bits : uint
    sub_texel_precision_bits : uint
    mipmap_precision_bits : uint
    max_draw_indexed_index_value : uint
    max_draw_indirect_count : uint
    max_sampler_lod_bias : float
    max_sampler_anisotropy : float
    max_viewports : uint
    max_viewport_dimensions : uint [2]
    viewport_bounds_range : float [2]
    viewport_sub_pixel_bits : uint
    min_memory_map_alignment : uint64
    min_texel_buffer_offset_alignment : uint64
    min_uniform_buffer_offset_alignment : uint64
    min_storage_buffer_offset_alignment : uint64
    min_texel_offset : int
    max_texel_offset : uint
    min_texel_gather_offset : int
    max_texel_gather_offset : uint
    min_interpolation_offset : float
    max_interpolation_offset : float
    sub_pixel_interpolation_offset_bits : uint
    max_framebuffer_width : uint
    max_framebuffer_height : uint
    max_framebuffer_layers : uint
    framebuffer_color_sample_counts : uint
    framebuffer_depth_sample_counts : uint
    framebuffer_stencil_sample_counts : uint
    framebuffer_no_attachments_sample_counts : uint
    max_color_attachments : uint
    sampled_image_color_sample_counts : uint
    sampled_image_integer_sample_counts : uint
    sampled_image_depth_sample_counts : uint
    sampled_image_stencil_sample_counts : uint
    storage_image_sample_counts : uint
    max_sample_mask_words : uint
    timestamp_compute_and_graphics : uint
    timestamp_period : float
    max_clip_distances : uint
    max_cull_distances : uint
    max_combined_clip_and_cull_distances : uint
    discrete_queue_priorities : uint
    point_size_range : float [2]
    line_width_range : float [2]
    point_size_granularity : float
    line_width_granularity : float
    strict_lines : uint
    standard_sample_locations : uint
    optimal_buffer_copy_offset_alignment : uint64
    optimal_buffer_copy_row_pitch_alignment : uint64
    non_coherent_atom_size : uint64
    _vk_view_active : bool

def vk_value_to_boost(vk_struct : VkPhysicalDeviceLimits) : PhysicalDeviceLimits
    return <- [[PhysicalDeviceLimits
        max_image_dimension_1d = vk_struct.maxImageDimension1D,
        max_image_dimension_2d = vk_struct.maxImageDimension2D,
        max_image_dimension_3d = vk_struct.maxImageDimension3D,
        max_image_dimension_cube = vk_struct.maxImageDimensionCube,
        max_image_array_layers = vk_struct.maxImageArrayLayers,
        max_texel_buffer_elements = vk_struct.maxTexelBufferElements,
        max_uniform_buffer_range = vk_struct.maxUniformBufferRange,
        max_storage_buffer_range = vk_struct.maxStorageBufferRange,
        max_push_constants_size = vk_struct.maxPushConstantsSize,
        max_memory_allocation_count = vk_struct.maxMemoryAllocationCount,
        max_sampler_allocation_count = vk_struct.maxSamplerAllocationCount,
        buffer_image_granularity = vk_struct.bufferImageGranularity,
        sparse_address_space_size = vk_struct.sparseAddressSpaceSize,
        max_bound_descriptor_sets = vk_struct.maxBoundDescriptorSets,
        max_per_stage_descriptor_samplers = vk_struct.maxPerStageDescriptorSamplers,
        max_per_stage_descriptor_uniform_buffers = vk_struct.maxPerStageDescriptorUniformBuffers,
        max_per_stage_descriptor_storage_buffers = vk_struct.maxPerStageDescriptorStorageBuffers,
        max_per_stage_descriptor_sampled_images = vk_struct.maxPerStageDescriptorSampledImages,
        max_per_stage_descriptor_storage_images = vk_struct.maxPerStageDescriptorStorageImages,
        max_per_stage_descriptor_input_attachments = vk_struct.maxPerStageDescriptorInputAttachments,
        max_per_stage_resources = vk_struct.maxPerStageResources,
        max_descriptor_set_samplers = vk_struct.maxDescriptorSetSamplers,
        max_descriptor_set_uniform_buffers = vk_struct.maxDescriptorSetUniformBuffers,
        max_descriptor_set_uniform_buffers_dynamic = vk_struct.maxDescriptorSetUniformBuffersDynamic,
        max_descriptor_set_storage_buffers = vk_struct.maxDescriptorSetStorageBuffers,
        max_descriptor_set_storage_buffers_dynamic = vk_struct.maxDescriptorSetStorageBuffersDynamic,
        max_descriptor_set_sampled_images = vk_struct.maxDescriptorSetSampledImages,
        max_descriptor_set_storage_images = vk_struct.maxDescriptorSetStorageImages,
        max_descriptor_set_input_attachments = vk_struct.maxDescriptorSetInputAttachments,
        max_vertex_input_attributes = vk_struct.maxVertexInputAttributes,
        max_vertex_input_bindings = vk_struct.maxVertexInputBindings,
        max_vertex_input_attribute_offset = vk_struct.maxVertexInputAttributeOffset,
        max_vertex_input_binding_stride = vk_struct.maxVertexInputBindingStride,
        max_vertex_output_components = vk_struct.maxVertexOutputComponents,
        max_tessellation_generation_level = vk_struct.maxTessellationGenerationLevel,
        max_tessellation_patch_size = vk_struct.maxTessellationPatchSize,
        max_tessellation_control_per_vertex_input_components = vk_struct.maxTessellationControlPerVertexInputComponents,
        max_tessellation_control_per_vertex_output_components = vk_struct.maxTessellationControlPerVertexOutputComponents,
        max_tessellation_control_per_patch_output_components = vk_struct.maxTessellationControlPerPatchOutputComponents,
        max_tessellation_control_total_output_components = vk_struct.maxTessellationControlTotalOutputComponents,
        max_tessellation_evaluation_input_components = vk_struct.maxTessellationEvaluationInputComponents,
        max_tessellation_evaluation_output_components = vk_struct.maxTessellationEvaluationOutputComponents,
        max_geometry_shader_invocations = vk_struct.maxGeometryShaderInvocations,
        max_geometry_input_components = vk_struct.maxGeometryInputComponents,
        max_geometry_output_components = vk_struct.maxGeometryOutputComponents,
        max_geometry_output_vertices = vk_struct.maxGeometryOutputVertices,
        max_geometry_total_output_components = vk_struct.maxGeometryTotalOutputComponents,
        max_fragment_input_components = vk_struct.maxFragmentInputComponents,
        max_fragment_output_attachments = vk_struct.maxFragmentOutputAttachments,
        max_fragment_dual_src_attachments = vk_struct.maxFragmentDualSrcAttachments,
        max_fragment_combined_output_resources = vk_struct.maxFragmentCombinedOutputResources,
        max_compute_shared_memory_size = vk_struct.maxComputeSharedMemorySize,
        max_compute_work_group_count = vk_struct.maxComputeWorkGroupCount,
        max_compute_work_group_invocations = vk_struct.maxComputeWorkGroupInvocations,
        max_compute_work_group_size = vk_struct.maxComputeWorkGroupSize,
        sub_pixel_precision_bits = vk_struct.subPixelPrecisionBits,
        sub_texel_precision_bits = vk_struct.subTexelPrecisionBits,
        mipmap_precision_bits = vk_struct.mipmapPrecisionBits,
        max_draw_indexed_index_value = vk_struct.maxDrawIndexedIndexValue,
        max_draw_indirect_count = vk_struct.maxDrawIndirectCount,
        max_sampler_lod_bias = vk_struct.maxSamplerLodBias,
        max_sampler_anisotropy = vk_struct.maxSamplerAnisotropy,
        max_viewports = vk_struct.maxViewports,
        max_viewport_dimensions = vk_struct.maxViewportDimensions,
        viewport_bounds_range = vk_struct.viewportBoundsRange,
        viewport_sub_pixel_bits = vk_struct.viewportSubPixelBits,
        min_memory_map_alignment = vk_struct.minMemoryMapAlignment,
        min_texel_buffer_offset_alignment = vk_struct.minTexelBufferOffsetAlignment,
        min_uniform_buffer_offset_alignment = vk_struct.minUniformBufferOffsetAlignment,
        min_storage_buffer_offset_alignment = vk_struct.minStorageBufferOffsetAlignment,
        min_texel_offset = vk_struct.minTexelOffset,
        max_texel_offset = vk_struct.maxTexelOffset,
        min_texel_gather_offset = vk_struct.minTexelGatherOffset,
        max_texel_gather_offset = vk_struct.maxTexelGatherOffset,
        min_interpolation_offset = vk_struct.minInterpolationOffset,
        max_interpolation_offset = vk_struct.maxInterpolationOffset,
        sub_pixel_interpolation_offset_bits = vk_struct.subPixelInterpolationOffsetBits,
        max_framebuffer_width = vk_struct.maxFramebufferWidth,
        max_framebuffer_height = vk_struct.maxFramebufferHeight,
        max_framebuffer_layers = vk_struct.maxFramebufferLayers,
        framebuffer_color_sample_counts = vk_struct.framebufferColorSampleCounts,
        framebuffer_depth_sample_counts = vk_struct.framebufferDepthSampleCounts,
        framebuffer_stencil_sample_counts = vk_struct.framebufferStencilSampleCounts,
        framebuffer_no_attachments_sample_counts = vk_struct.framebufferNoAttachmentsSampleCounts,
        max_color_attachments = vk_struct.maxColorAttachments,
        sampled_image_color_sample_counts = vk_struct.sampledImageColorSampleCounts,
        sampled_image_integer_sample_counts = vk_struct.sampledImageIntegerSampleCounts,
        sampled_image_depth_sample_counts = vk_struct.sampledImageDepthSampleCounts,
        sampled_image_stencil_sample_counts = vk_struct.sampledImageStencilSampleCounts,
        storage_image_sample_counts = vk_struct.storageImageSampleCounts,
        max_sample_mask_words = vk_struct.maxSampleMaskWords,
        timestamp_compute_and_graphics = vk_struct.timestampComputeAndGraphics,
        timestamp_period = vk_struct.timestampPeriod,
        max_clip_distances = vk_struct.maxClipDistances,
        max_cull_distances = vk_struct.maxCullDistances,
        max_combined_clip_and_cull_distances = vk_struct.maxCombinedClipAndCullDistances,
        discrete_queue_priorities = vk_struct.discreteQueuePriorities,
        point_size_range = vk_struct.pointSizeRange,
        line_width_range = vk_struct.lineWidthRange,
        point_size_granularity = vk_struct.pointSizeGranularity,
        line_width_granularity = vk_struct.lineWidthGranularity,
        strict_lines = vk_struct.strictLines,
        standard_sample_locations = vk_struct.standardSampleLocations,
        optimal_buffer_copy_offset_alignment = vk_struct.optimalBufferCopyOffsetAlignment,
        optimal_buffer_copy_row_pitch_alignment = vk_struct.optimalBufferCopyRowPitchAlignment,
        non_coherent_atom_size = vk_struct.nonCoherentAtomSize
    ]]

//
// PhysicalDeviceProperties
//

struct PhysicalDeviceProperties
    api_version : uint
    driver_version : uint
    vendor_id : uint
    device_id : uint
    device_type : VkPhysicalDeviceType
    device_name : string
    pipeline_cache_uuid : uint8 [16]
    limits : PhysicalDeviceLimits
    sparse_properties : PhysicalDeviceSparseProperties
    _vk_view_active : bool

def vk_value_to_boost(vk_struct : VkPhysicalDeviceProperties) : PhysicalDeviceProperties
    return <- [[PhysicalDeviceProperties
        api_version = vk_struct.apiVersion,
        driver_version = vk_struct.driverVersion,
        vendor_id = vk_struct.vendorID,
        device_id = vk_struct.deviceID,
        device_type = vk_struct.deviceType,
        device_name = vk_value_to_boost(vk_struct.deviceName),
        pipeline_cache_uuid = vk_struct.pipelineCacheUUID,
        limits <- vk_value_to_boost(vk_struct.limits),
        sparse_properties <- vk_value_to_boost(vk_struct.sparseProperties)
    ]]

//
// PhysicalDeviceFeatures
//

struct PhysicalDeviceFeatures
    robust_buffer_access : uint
    full_draw_index_uint_32 : uint
    image_cube_array : uint
    independent_blend : uint
    geometry_shader : uint
    tessellation_shader : uint
    sample_rate_shading : uint
    dual_src_blend : uint
    logic_op : uint
    multi_draw_indirect : uint
    draw_indirect_first_instance : uint
    depth_clamp : uint
    depth_bias_clamp : uint
    fill_mode_non_solid : uint
    depth_bounds : uint
    wide_lines : uint
    large_points : uint
    alpha_to_one : uint
    multi_viewport : uint
    sampler_anisotropy : uint
    texture_compression_etc2 : uint
    texture_compression_astc_ldr : uint
    texture_compression_bc : uint
    occlusion_query_precise : uint
    pipeline_statistics_query : uint
    vertex_pipeline_stores_and_atomics : uint
    fragment_stores_and_atomics : uint
    shader_tessellation_and_geometry_point_size : uint
    shader_image_gather_extended : uint
    shader_storage_image_extended_formats : uint
    shader_storage_image_multisample : uint
    shader_storage_image_read_without_format : uint
    shader_storage_image_write_without_format : uint
    shader_uniform_buffer_array_dynamic_indexing : uint
    shader_sampled_image_array_dynamic_indexing : uint
    shader_storage_buffer_array_dynamic_indexing : uint
    shader_storage_image_array_dynamic_indexing : uint
    shader_clip_distance : uint
    shader_cull_distance : uint
    shader_float_64 : uint
    shader_int_64 : uint
    shader_int_16 : uint
    shader_resource_residency : uint
    shader_resource_min_lod : uint
    sparse_binding : uint
    sparse_residency_buffer : uint
    sparse_residency_image_2d : uint
    sparse_residency_image_3d : uint
    sparse_residency_2samples : uint
    sparse_residency_4samples : uint
    sparse_residency_8samples : uint
    sparse_residency_16samples : uint
    sparse_residency_aliased : uint
    variable_multisample_rate : uint
    inherited_queries : uint
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : PhysicalDeviceFeatures) : VkPhysicalDeviceFeatures
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkPhysicalDeviceFeatures
    vk_struct.robustBufferAccess = boost_struct.robust_buffer_access
    vk_struct.fullDrawIndexUint32 = boost_struct.full_draw_index_uint_32
    vk_struct.imageCubeArray = boost_struct.image_cube_array
    vk_struct.independentBlend = boost_struct.independent_blend
    vk_struct.geometryShader = boost_struct.geometry_shader
    vk_struct.tessellationShader = boost_struct.tessellation_shader
    vk_struct.sampleRateShading = boost_struct.sample_rate_shading
    vk_struct.dualSrcBlend = boost_struct.dual_src_blend
    vk_struct.logicOp = boost_struct.logic_op
    vk_struct.multiDrawIndirect = boost_struct.multi_draw_indirect
    vk_struct.drawIndirectFirstInstance = boost_struct.draw_indirect_first_instance
    vk_struct.depthClamp = boost_struct.depth_clamp
    vk_struct.depthBiasClamp = boost_struct.depth_bias_clamp
    vk_struct.fillModeNonSolid = boost_struct.fill_mode_non_solid
    vk_struct.depthBounds = boost_struct.depth_bounds
    vk_struct.wideLines = boost_struct.wide_lines
    vk_struct.largePoints = boost_struct.large_points
    vk_struct.alphaToOne = boost_struct.alpha_to_one
    vk_struct.multiViewport = boost_struct.multi_viewport
    vk_struct.samplerAnisotropy = boost_struct.sampler_anisotropy
    vk_struct.textureCompressionETC2 = boost_struct.texture_compression_etc2
    vk_struct.textureCompressionASTC_LDR = boost_struct.texture_compression_astc_ldr
    vk_struct.textureCompressionBC = boost_struct.texture_compression_bc
    vk_struct.occlusionQueryPrecise = boost_struct.occlusion_query_precise
    vk_struct.pipelineStatisticsQuery = boost_struct.pipeline_statistics_query
    vk_struct.vertexPipelineStoresAndAtomics = boost_struct.vertex_pipeline_stores_and_atomics
    vk_struct.fragmentStoresAndAtomics = boost_struct.fragment_stores_and_atomics
    vk_struct.shaderTessellationAndGeometryPointSize = boost_struct.shader_tessellation_and_geometry_point_size
    vk_struct.shaderImageGatherExtended = boost_struct.shader_image_gather_extended
    vk_struct.shaderStorageImageExtendedFormats = boost_struct.shader_storage_image_extended_formats
    vk_struct.shaderStorageImageMultisample = boost_struct.shader_storage_image_multisample
    vk_struct.shaderStorageImageReadWithoutFormat = boost_struct.shader_storage_image_read_without_format
    vk_struct.shaderStorageImageWriteWithoutFormat = boost_struct.shader_storage_image_write_without_format
    vk_struct.shaderUniformBufferArrayDynamicIndexing = boost_struct.shader_uniform_buffer_array_dynamic_indexing
    vk_struct.shaderSampledImageArrayDynamicIndexing = boost_struct.shader_sampled_image_array_dynamic_indexing
    vk_struct.shaderStorageBufferArrayDynamicIndexing = boost_struct.shader_storage_buffer_array_dynamic_indexing
    vk_struct.shaderStorageImageArrayDynamicIndexing = boost_struct.shader_storage_image_array_dynamic_indexing
    vk_struct.shaderClipDistance = boost_struct.shader_clip_distance
    vk_struct.shaderCullDistance = boost_struct.shader_cull_distance
    vk_struct.shaderFloat64 = boost_struct.shader_float_64
    vk_struct.shaderInt64 = boost_struct.shader_int_64
    vk_struct.shaderInt16 = boost_struct.shader_int_16
    vk_struct.shaderResourceResidency = boost_struct.shader_resource_residency
    vk_struct.shaderResourceMinLod = boost_struct.shader_resource_min_lod
    vk_struct.sparseBinding = boost_struct.sparse_binding
    vk_struct.sparseResidencyBuffer = boost_struct.sparse_residency_buffer
    vk_struct.sparseResidencyImage2D = boost_struct.sparse_residency_image_2d
    vk_struct.sparseResidencyImage3D = boost_struct.sparse_residency_image_3d
    vk_struct.sparseResidency2Samples = boost_struct.sparse_residency_2samples
    vk_struct.sparseResidency4Samples = boost_struct.sparse_residency_4samples
    vk_struct.sparseResidency8Samples = boost_struct.sparse_residency_8samples
    vk_struct.sparseResidency16Samples = boost_struct.sparse_residency_16samples
    vk_struct.sparseResidencyAliased = boost_struct.sparse_residency_aliased
    vk_struct.variableMultisampleRate = boost_struct.variable_multisample_rate
    vk_struct.inheritedQueries = boost_struct.inherited_queries

    return <- vk_struct

def vk_view_destroy(boost_struct : PhysicalDeviceFeatures)
    assert(boost_struct._vk_view_active)
    boost_struct._vk_view_active = false

//
// PhysicalDeviceSparseProperties
//

struct PhysicalDeviceSparseProperties
    residency_standard_2d_block_shape : uint
    residency_standard_2d_multisample_block_shape : uint
    residency_standard_3d_block_shape : uint
    residency_aligned_mip_size : uint
    residency_non_resident_strict : uint
    _vk_view_active : bool

def vk_value_to_boost(vk_struct : VkPhysicalDeviceSparseProperties) : PhysicalDeviceSparseProperties
    return <- [[PhysicalDeviceSparseProperties
        residency_standard_2d_block_shape = vk_struct.residencyStandard2DBlockShape,
        residency_standard_2d_multisample_block_shape = vk_struct.residencyStandard2DMultisampleBlockShape,
        residency_standard_3d_block_shape = vk_struct.residencyStandard3DBlockShape,
        residency_aligned_mip_size = vk_struct.residencyAlignedMipSize,
        residency_non_resident_strict = vk_struct.residencyNonResidentStrict
    ]]

//
// QueueFamilyProperties
//

struct QueueFamilyProperties
    queue_flags : uint
    queue_count : uint
    timestamp_valid_bits : uint
    min_image_transfer_granularity : Extent3D
    _vk_view_active : bool

def vk_value_to_boost(vk_struct : VkQueueFamilyProperties) : QueueFamilyProperties
    return <- [[QueueFamilyProperties
        queue_flags = vk_struct.queueFlags,
        queue_count = vk_struct.queueCount,
        timestamp_valid_bits = vk_struct.timestampValidBits,
        min_image_transfer_granularity <- vk_value_to_boost(vk_struct.minImageTransferGranularity)
    ]]

//
// SurfaceFormatKHR
//

struct SurfaceFormatKHR
    format : VkFormat
    color_space : VkColorSpaceKHR
    _vk_view_active : bool

[unsafe_function]
def vk_view_create(boost_struct : SurfaceFormatKHR) : VkSurfaceFormatKHR
    assert(!boost_struct._vk_view_active)
    boost_struct._vk_view_active = true

    var vk_struct : VkSurfaceFormatKHR
    vk_struct.format = boost_struct.format
    vk_struct.colorSpace = boost_struct.color_space

    return <- vk_struct

def vk_view_destroy(boost_struct : SurfaceFormatKHR)
    assert(boost_struct._vk_view_active)
    boost_struct._vk_view_active = false

def vk_value_to_boost(vk_struct : VkSurfaceFormatKHR) : SurfaceFormatKHR
    return <- [[SurfaceFormatKHR
        format = vk_struct.format,
        color_space = vk_struct.colorSpace
    ]]

//
// Device
//

struct Device
    device : VkDevice

def boost_value_to_vk(b : Device) : VkDevice
    return b.device

def create_device(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    create_info : DeviceCreateInfo = [[ DeviceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Device

    var device : Device
    create_info |> with_view() <| $(vk_info)
        var result_ = VkResult VK_SUCCESS
        result ?? result_ = vkCreateDevice(
            boost_value_to_vk(physical_device),
            safe_addr(vk_info),
            null,
            safe_addr(device.device)
        )
        assert(result_ == VkResult VK_SUCCESS)
    return <- device

//
// Instance
//

struct Instance
    instance : VkInstance

def boost_value_to_vk(b : Instance) : VkInstance
    return b.instance

def create_instance(
    create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var instance : Instance
    create_info |> with_view() <| $(vk_info)
        var result_ = VkResult VK_SUCCESS
        result ?? result_ = vkCreateInstance(
            safe_addr(vk_info),
            null,
            safe_addr(instance.instance)
        )
        assert(result_ == VkResult VK_SUCCESS)
    return <- instance

def finalize(var instance : Instance)
    vkDestroyInstance(
        boost_value_to_vk(instance),
        null
    )
    memzero(instance)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice

def boost_value_to_vk(b : PhysicalDevice) : VkPhysicalDevice
    return b.physical_device

struct PhysicalDeviceBatch
    physical_device_batch : array<VkPhysicalDevice>

def split(batch : PhysicalDeviceBatch) : array<PhysicalDevice>
    return <- [{for h in batch.physical_device_batch ;
        [[PhysicalDevice physical_device=h]]}]

def enumerate_physical_devices(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
) : PhysicalDeviceBatch

    var count : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        boost_value_to_vk(instance),
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    var vk_handles : array<VkPhysicalDevice>
    if result ?? result_ == VkResult VK_SUCCESS && count > 0u
        vk_handles |> resize(int(count))
        vk_handles |> lock() <| $(thandles)
            result ?? result_ = vkEnumeratePhysicalDevices(
                boost_value_to_vk(instance),
                safe_addr(count),
                addr(thandles[0])
            )
            assert(result_ == VkResult VK_SUCCESS)

    return <- [[PhysicalDeviceBatch physical_device_batch <- vk_handles]]

def enumerate_physical_devices_no_batch(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
): array<PhysicalDevice>
    var handles <- enumerate_physical_devices(instance, result)
    defer() <| ${ delete handles; }
    return <- handles |> split()
