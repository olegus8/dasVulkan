// generated by dasVulkan

options indenting = 4
options no_aot = true

require daslib/defer
require daslib/safe_addr

require vulkan

//
// Helpers
//

def with_view(
    var boost_struct : auto(BOOST_T);
    b : block<(vk_struct : auto(VK_T))>
)
    var vk_struct : VK_T
    unsafe
        vk_struct <- boost_struct |> vk_view_create_unsafe()
    b |> invoke(vk_struct)
    boost_struct |> vk_view_destroy()

def boost_value_to_vk(b : auto(T)) : T
    return b

def vk_value_to_boost(v : auto(T)) : T
    return v

def vk_value_to_boost(v : int8[]) : string
    unsafe
        let s := reinterpret<string>(addr(v[0]))
        return s

def array_addr_unsafe(var ar : array<auto(T)>) : T?
    unsafe
        return length(ar) > 0 ? addr(ar[0]) : [[T ?]]

def addr_unsafe(v)
    unsafe
        return addr(v)

//
// Surface
//

struct SurfaceKHR
    surface_khr : VkSurfaceKHR
    _instance : VkInstance

def boost_value_to_vk(b : SurfaceKHR) : VkSurfaceKHR
    return b.surface_khr

def create_window_surface(
    instance : Instance = [[ Instance ]];
    window : GLFWwindow_DasHandle = [[ GLFWwindow_DasHandle ]];
    var result : VkResult? = [[VkResult?]]
) : SurfaceKHR

    var surface <- [[SurfaceKHR _instance=instance.instance]]
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = glfwCreateWindowSurface(
        instance.instance,
        window,
        null,
        safe_addr(surface.surface_khr)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- surface

def finalize(var surface : SurfaceKHR explicit)
    vkDestroySurfaceKHR(
        surface._instance,
        surface.surface_khr,
        null
    )
    memzero(surface)

//
// Functions
//

def get_physical_device_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : PhysicalDeviceProperties
    var vk_output : VkPhysicalDeviceProperties
    vkGetPhysicalDeviceProperties(
        boost_value_to_vk(physical_device),
        safe_addr(vk_output)
    )
    return <- vk_value_to_boost(vk_output)

def get_physical_device_surface_support_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    queue_family_index : uint = [[ uint ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : uint
    var vk_output : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfaceSupportKHR(
        boost_value_to_vk(physical_device),
        queue_family_index,
        boost_value_to_vk(surface),
        safe_addr(vk_output)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return vk_value_to_boost(vk_output)

def enumerate_device_extension_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    layer_name : string = [[ string ]];
    var result : VkResult? = [[VkResult?]]
) : array<ExtensionProperties>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkEnumerateDeviceExtensionProperties(
        boost_value_to_vk(physical_device),
        layer_name,
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<ExtensionProperties>]]

    var vk_items : array<VkExtensionProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkEnumerateDeviceExtensionProperties(
            boost_value_to_vk(physical_device),
            layer_name,
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_queue_family_properties(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]]
) : array<QueueFamilyProperties>
    var count : uint
    vkGetPhysicalDeviceQueueFamilyProperties(
        boost_value_to_vk(physical_device),
        safe_addr(count),
        null
    )

    var vk_items : array<VkQueueFamilyProperties>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        vkGetPhysicalDeviceQueueFamilyProperties(
            boost_value_to_vk(physical_device),
            safe_addr(count),
            vk_p_items
        )

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_surface_formats_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<SurfaceFormatKHR>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<SurfaceFormatKHR>]]

    var vk_items : array<VkSurfaceFormatKHR>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkGetPhysicalDeviceSurfaceFormatsKHR(
            boost_value_to_vk(physical_device),
            boost_value_to_vk(surface),
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

def get_physical_device_surface_present_modes_khr(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    surface : SurfaceKHR = [[ SurfaceKHR ]];
    var result : VkResult? = [[VkResult?]]
) : array<VkPresentModeKHR>
    var count : uint
    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
        boost_value_to_vk(physical_device),
        boost_value_to_vk(surface),
        safe_addr(count),
        null
    )

    assert(result_ == VkResult VK_SUCCESS)
    if result ?? result_ != VkResult VK_SUCCESS
        return <- [[array<VkPresentModeKHR>]]

    var vk_items : array<VkPresentModeKHR>
    defer() <| ${ delete vk_items; }
    vk_items |> resize(int(count))
    vk_items |> lock_data() <| $(vk_p_items, count_)
        result ?? result_ = vkGetPhysicalDeviceSurfacePresentModesKHR(
            boost_value_to_vk(physical_device),
            boost_value_to_vk(surface),
            safe_addr(count),
            vk_p_items
        )
        assert(result_ == VkResult VK_SUCCESS)

    return <- [{for item in vk_items ; vk_value_to_boost(item)}]

//
// ApplicationInfo
//

struct ApplicationInfo
    application_name : string
    application_version : uint
    engine_name : string
    engine_version : uint
    api_version : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ApplicationInfo
) : VkApplicationInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkApplicationInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_APPLICATION_INFO,
        pApplicationName = boost_struct.application_name,
        applicationVersion = boost_struct.application_version,
        pEngineName = boost_struct.engine_name,
        engineVersion = boost_struct.engine_version,
        apiVersion = boost_struct.api_version
    ]]

def vk_view_destroy(var boost_struct : ApplicationInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// AttachmentDescription
//

struct AttachmentDescription
    flags : uint
    format : VkFormat
    samples : VkSampleCountFlagBits
    load_op : VkAttachmentLoadOp
    store_op : VkAttachmentStoreOp
    stencil_load_op : VkAttachmentLoadOp
    stencil_store_op : VkAttachmentStoreOp
    initial_layout : VkImageLayout
    final_layout : VkImageLayout
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : AttachmentDescription
) : VkAttachmentDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkAttachmentDescription
        flags = boost_struct.flags,
        format = boost_struct.format,
        samples = boost_struct.samples,
        loadOp = boost_struct.load_op,
        storeOp = boost_struct.store_op,
        stencilLoadOp = boost_struct.stencil_load_op,
        stencilStoreOp = boost_struct.stencil_store_op,
        initialLayout = boost_struct.initial_layout,
        finalLayout = boost_struct.final_layout
    ]]

def vk_view_destroy(var boost_struct : AttachmentDescription)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// AttachmentReference
//

struct AttachmentReference
    attachment : uint
    layout : VkImageLayout
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : AttachmentReference
) : VkAttachmentReference

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkAttachmentReference
        attachment = boost_struct.attachment,
        layout = boost_struct.layout
    ]]

def vk_view_destroy(var boost_struct : AttachmentReference)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// CommandPoolCreateInfo
//

struct CommandPoolCreateInfo
    flags : uint
    queue_family_index : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : CommandPoolCreateInfo
) : VkCommandPoolCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkCommandPoolCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        flags = boost_struct.flags,
        queueFamilyIndex = boost_struct.queue_family_index
    ]]

def vk_view_destroy(var boost_struct : CommandPoolCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// DescriptorSetLayoutBinding
//

struct DescriptorSetLayoutBinding
    binding : uint
    descriptor_type : VkDescriptorType
    descriptor_count : uint
    stage_flags : uint
    immutable_samplers : array<Sampler>
    _vk_view_immutable_samplers : array<VkSampler>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DescriptorSetLayoutBinding
) : VkDescriptorSetLayoutBinding

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_immutable_samplers <- [{
        for item in boost_struct.immutable_samplers ;
        item |> boost_value_to_vk()}]

    return <- [[ VkDescriptorSetLayoutBinding
        binding = boost_struct.binding,
        descriptorType = boost_struct.descriptor_type,
        descriptorCount = boost_struct.descriptor_count,
        stageFlags = boost_struct.stage_flags,
        pImmutableSamplers = array_addr_unsafe(boost_struct._vk_view_immutable_samplers)
    ]]

def vk_view_destroy(var boost_struct : DescriptorSetLayoutBinding)
    assert(boost_struct._vk_view__active)
    delete boost_struct._vk_view_immutable_samplers
    boost_struct._vk_view__active = false

//
// DescriptorSetLayoutCreateInfo
//

struct DescriptorSetLayoutCreateInfo
    flags : uint
    bindings : array<DescriptorSetLayoutBinding>
    _vk_view_bindings : array<VkDescriptorSetLayoutBinding>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DescriptorSetLayoutCreateInfo
) : VkDescriptorSetLayoutCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_bindings <- [{
        for item in boost_struct.bindings ;
        item |> vk_view_create_unsafe()}]

    return <- [[ VkDescriptorSetLayoutCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        flags = boost_struct.flags,
        bindingCount = uint(boost_struct.bindings |> length()),
        pBindings = array_addr_unsafe(boost_struct._vk_view_bindings)
    ]]

def vk_view_destroy(var boost_struct : DescriptorSetLayoutCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.bindings
        item |> vk_view_destroy()
    delete boost_struct._vk_view_bindings
    boost_struct._vk_view__active = false

//
// DeviceCreateInfo
//

struct DeviceCreateInfo
    flags : uint
    queue_create_infos : array<DeviceQueueCreateInfo>
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    p_enabled_features : PhysicalDeviceFeatures ?
    _vk_view_queue_create_infos : array<VkDeviceQueueCreateInfo>
    _vk_view_p_enabled_features : VkPhysicalDeviceFeatures ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DeviceCreateInfo
) : VkDeviceCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_queue_create_infos <- [{
        for item in boost_struct.queue_create_infos ;
        item |> vk_view_create_unsafe()}]

    let vk_p_enabled_layer_names = array_addr_unsafe(boost_struct.enabled_layer_names)

    let vk_p_enabled_extension_names = array_addr_unsafe(boost_struct.enabled_extension_names)

    if boost_struct.p_enabled_features != null
        boost_struct._vk_view_p_enabled_features = new VkPhysicalDeviceFeatures
        *(boost_struct._vk_view_p_enabled_features) <- (
            *(boost_struct.p_enabled_features) |> vk_view_create_unsafe())

    return <- [[ VkDeviceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        flags = boost_struct.flags,
        queueCreateInfoCount = uint(boost_struct.queue_create_infos |> length()),
        pQueueCreateInfos = array_addr_unsafe(boost_struct._vk_view_queue_create_infos),
        enabledLayerCount = uint(boost_struct.enabled_layer_names |> length()),
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = uint(boost_struct.enabled_extension_names |> length()),
        ppEnabledExtensionNames = vk_p_enabled_extension_names,
        pEnabledFeatures = boost_struct._vk_view_p_enabled_features
    ]]

def vk_view_destroy(var boost_struct : DeviceCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.queue_create_infos
        item |> vk_view_destroy()
    delete boost_struct._vk_view_queue_create_infos
    if boost_struct.p_enabled_features != null
        *(boost_struct.p_enabled_features) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_enabled_features
    boost_struct._vk_view__active = false

//
// DeviceQueueCreateInfo
//

struct DeviceQueueCreateInfo
    flags : uint
    queue_family_index : uint
    queue_priorities : array<float>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : DeviceQueueCreateInfo
) : VkDeviceQueueCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    let vk_p_queue_priorities = array_addr_unsafe(boost_struct.queue_priorities)

    return <- [[ VkDeviceQueueCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        flags = boost_struct.flags,
        queueFamilyIndex = boost_struct.queue_family_index,
        queueCount = uint(boost_struct.queue_priorities |> length()),
        pQueuePriorities = vk_p_queue_priorities
    ]]

def vk_view_destroy(var boost_struct : DeviceQueueCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// ExtensionProperties
//

struct ExtensionProperties
    extension_name : string
    spec_version : uint

def vk_value_to_boost(vk_struct : VkExtensionProperties) : ExtensionProperties
    return <- [[ExtensionProperties
        extension_name = vk_value_to_boost(vk_struct.extensionName),
        spec_version = vk_struct.specVersion
    ]]

//
// Extent3D
//

struct Extent3D
    width : uint
    height : uint
    depth : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : Extent3D
) : VkExtent3D

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkExtent3D
        width = boost_struct.width,
        height = boost_struct.height,
        depth = boost_struct.depth
    ]]

def vk_view_destroy(var boost_struct : Extent3D)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkExtent3D) : Extent3D
    return <- [[Extent3D
        width = vk_struct.width,
        height = vk_struct.height,
        depth = vk_struct.depth
    ]]

//
// InstanceCreateInfo
//

struct InstanceCreateInfo
    flags : uint
    p_application_info : ApplicationInfo ?
    enabled_layer_names : array<string>
    enabled_extension_names : array<string>
    _vk_view_p_application_info : VkApplicationInfo ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : InstanceCreateInfo
) : VkInstanceCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    if boost_struct.p_application_info != null
        boost_struct._vk_view_p_application_info = new VkApplicationInfo
        *(boost_struct._vk_view_p_application_info) <- (
            *(boost_struct.p_application_info) |> vk_view_create_unsafe())

    let vk_p_enabled_layer_names = array_addr_unsafe(boost_struct.enabled_layer_names)

    let vk_p_enabled_extension_names = array_addr_unsafe(boost_struct.enabled_extension_names)

    return <- [[ VkInstanceCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        flags = boost_struct.flags,
        pApplicationInfo = boost_struct._vk_view_p_application_info,
        enabledLayerCount = uint(boost_struct.enabled_layer_names |> length()),
        ppEnabledLayerNames = vk_p_enabled_layer_names,
        enabledExtensionCount = uint(boost_struct.enabled_extension_names |> length()),
        ppEnabledExtensionNames = vk_p_enabled_extension_names
    ]]

def vk_view_destroy(var boost_struct : InstanceCreateInfo)
    assert(boost_struct._vk_view__active)
    if boost_struct.p_application_info != null
        *(boost_struct.p_application_info) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_application_info
    boost_struct._vk_view__active = false

//
// PhysicalDeviceLimits
//

struct PhysicalDeviceLimits
    max_image_dimension_1d : uint
    max_image_dimension_2d : uint
    max_image_dimension_3d : uint
    max_image_dimension_cube : uint
    max_image_array_layers : uint
    max_texel_buffer_elements : uint
    max_uniform_buffer_range : uint
    max_storage_buffer_range : uint
    max_push_constants_size : uint
    max_memory_allocation_count : uint
    max_sampler_allocation_count : uint
    buffer_image_granularity : uint64
    sparse_address_space_size : uint64
    max_bound_descriptor_sets : uint
    max_per_stage_descriptor_samplers : uint
    max_per_stage_descriptor_uniform_buffers : uint
    max_per_stage_descriptor_storage_buffers : uint
    max_per_stage_descriptor_sampled_images : uint
    max_per_stage_descriptor_storage_images : uint
    max_per_stage_descriptor_input_attachments : uint
    max_per_stage_resources : uint
    max_descriptor_set_samplers : uint
    max_descriptor_set_uniform_buffers : uint
    max_descriptor_set_uniform_buffers_dynamic : uint
    max_descriptor_set_storage_buffers : uint
    max_descriptor_set_storage_buffers_dynamic : uint
    max_descriptor_set_sampled_images : uint
    max_descriptor_set_storage_images : uint
    max_descriptor_set_input_attachments : uint
    max_vertex_input_attributes : uint
    max_vertex_input_bindings : uint
    max_vertex_input_attribute_offset : uint
    max_vertex_input_binding_stride : uint
    max_vertex_output_components : uint
    max_tessellation_generation_level : uint
    max_tessellation_patch_size : uint
    max_tessellation_control_per_vertex_input_components : uint
    max_tessellation_control_per_vertex_output_components : uint
    max_tessellation_control_per_patch_output_components : uint
    max_tessellation_control_total_output_components : uint
    max_tessellation_evaluation_input_components : uint
    max_tessellation_evaluation_output_components : uint
    max_geometry_shader_invocations : uint
    max_geometry_input_components : uint
    max_geometry_output_components : uint
    max_geometry_output_vertices : uint
    max_geometry_total_output_components : uint
    max_fragment_input_components : uint
    max_fragment_output_attachments : uint
    max_fragment_dual_src_attachments : uint
    max_fragment_combined_output_resources : uint
    max_compute_shared_memory_size : uint
    max_compute_work_group_count : uint [3]
    max_compute_work_group_invocations : uint
    max_compute_work_group_size : uint [3]
    sub_pixel_precision_bits : uint
    sub_texel_precision_bits : uint
    mipmap_precision_bits : uint
    max_draw_indexed_index_value : uint
    max_draw_indirect_count : uint
    max_sampler_lod_bias : float
    max_sampler_anisotropy : float
    max_viewports : uint
    max_viewport_dimensions : uint [2]
    viewport_bounds_range : float [2]
    viewport_sub_pixel_bits : uint
    min_memory_map_alignment : uint64
    min_texel_buffer_offset_alignment : uint64
    min_uniform_buffer_offset_alignment : uint64
    min_storage_buffer_offset_alignment : uint64
    min_texel_offset : int
    max_texel_offset : uint
    min_texel_gather_offset : int
    max_texel_gather_offset : uint
    min_interpolation_offset : float
    max_interpolation_offset : float
    sub_pixel_interpolation_offset_bits : uint
    max_framebuffer_width : uint
    max_framebuffer_height : uint
    max_framebuffer_layers : uint
    framebuffer_color_sample_counts : uint
    framebuffer_depth_sample_counts : uint
    framebuffer_stencil_sample_counts : uint
    framebuffer_no_attachments_sample_counts : uint
    max_color_attachments : uint
    sampled_image_color_sample_counts : uint
    sampled_image_integer_sample_counts : uint
    sampled_image_depth_sample_counts : uint
    sampled_image_stencil_sample_counts : uint
    storage_image_sample_counts : uint
    max_sample_mask_words : uint
    timestamp_compute_and_graphics : uint
    timestamp_period : float
    max_clip_distances : uint
    max_cull_distances : uint
    max_combined_clip_and_cull_distances : uint
    discrete_queue_priorities : uint
    point_size_range : float [2]
    line_width_range : float [2]
    point_size_granularity : float
    line_width_granularity : float
    strict_lines : uint
    standard_sample_locations : uint
    optimal_buffer_copy_offset_alignment : uint64
    optimal_buffer_copy_row_pitch_alignment : uint64
    non_coherent_atom_size : uint64

def vk_value_to_boost(vk_struct : VkPhysicalDeviceLimits) : PhysicalDeviceLimits
    return <- [[PhysicalDeviceLimits
        max_image_dimension_1d = vk_struct.maxImageDimension1D,
        max_image_dimension_2d = vk_struct.maxImageDimension2D,
        max_image_dimension_3d = vk_struct.maxImageDimension3D,
        max_image_dimension_cube = vk_struct.maxImageDimensionCube,
        max_image_array_layers = vk_struct.maxImageArrayLayers,
        max_texel_buffer_elements = vk_struct.maxTexelBufferElements,
        max_uniform_buffer_range = vk_struct.maxUniformBufferRange,
        max_storage_buffer_range = vk_struct.maxStorageBufferRange,
        max_push_constants_size = vk_struct.maxPushConstantsSize,
        max_memory_allocation_count = vk_struct.maxMemoryAllocationCount,
        max_sampler_allocation_count = vk_struct.maxSamplerAllocationCount,
        buffer_image_granularity = vk_struct.bufferImageGranularity,
        sparse_address_space_size = vk_struct.sparseAddressSpaceSize,
        max_bound_descriptor_sets = vk_struct.maxBoundDescriptorSets,
        max_per_stage_descriptor_samplers = vk_struct.maxPerStageDescriptorSamplers,
        max_per_stage_descriptor_uniform_buffers = vk_struct.maxPerStageDescriptorUniformBuffers,
        max_per_stage_descriptor_storage_buffers = vk_struct.maxPerStageDescriptorStorageBuffers,
        max_per_stage_descriptor_sampled_images = vk_struct.maxPerStageDescriptorSampledImages,
        max_per_stage_descriptor_storage_images = vk_struct.maxPerStageDescriptorStorageImages,
        max_per_stage_descriptor_input_attachments = vk_struct.maxPerStageDescriptorInputAttachments,
        max_per_stage_resources = vk_struct.maxPerStageResources,
        max_descriptor_set_samplers = vk_struct.maxDescriptorSetSamplers,
        max_descriptor_set_uniform_buffers = vk_struct.maxDescriptorSetUniformBuffers,
        max_descriptor_set_uniform_buffers_dynamic = vk_struct.maxDescriptorSetUniformBuffersDynamic,
        max_descriptor_set_storage_buffers = vk_struct.maxDescriptorSetStorageBuffers,
        max_descriptor_set_storage_buffers_dynamic = vk_struct.maxDescriptorSetStorageBuffersDynamic,
        max_descriptor_set_sampled_images = vk_struct.maxDescriptorSetSampledImages,
        max_descriptor_set_storage_images = vk_struct.maxDescriptorSetStorageImages,
        max_descriptor_set_input_attachments = vk_struct.maxDescriptorSetInputAttachments,
        max_vertex_input_attributes = vk_struct.maxVertexInputAttributes,
        max_vertex_input_bindings = vk_struct.maxVertexInputBindings,
        max_vertex_input_attribute_offset = vk_struct.maxVertexInputAttributeOffset,
        max_vertex_input_binding_stride = vk_struct.maxVertexInputBindingStride,
        max_vertex_output_components = vk_struct.maxVertexOutputComponents,
        max_tessellation_generation_level = vk_struct.maxTessellationGenerationLevel,
        max_tessellation_patch_size = vk_struct.maxTessellationPatchSize,
        max_tessellation_control_per_vertex_input_components = vk_struct.maxTessellationControlPerVertexInputComponents,
        max_tessellation_control_per_vertex_output_components = vk_struct.maxTessellationControlPerVertexOutputComponents,
        max_tessellation_control_per_patch_output_components = vk_struct.maxTessellationControlPerPatchOutputComponents,
        max_tessellation_control_total_output_components = vk_struct.maxTessellationControlTotalOutputComponents,
        max_tessellation_evaluation_input_components = vk_struct.maxTessellationEvaluationInputComponents,
        max_tessellation_evaluation_output_components = vk_struct.maxTessellationEvaluationOutputComponents,
        max_geometry_shader_invocations = vk_struct.maxGeometryShaderInvocations,
        max_geometry_input_components = vk_struct.maxGeometryInputComponents,
        max_geometry_output_components = vk_struct.maxGeometryOutputComponents,
        max_geometry_output_vertices = vk_struct.maxGeometryOutputVertices,
        max_geometry_total_output_components = vk_struct.maxGeometryTotalOutputComponents,
        max_fragment_input_components = vk_struct.maxFragmentInputComponents,
        max_fragment_output_attachments = vk_struct.maxFragmentOutputAttachments,
        max_fragment_dual_src_attachments = vk_struct.maxFragmentDualSrcAttachments,
        max_fragment_combined_output_resources = vk_struct.maxFragmentCombinedOutputResources,
        max_compute_shared_memory_size = vk_struct.maxComputeSharedMemorySize,
        max_compute_work_group_count = vk_struct.maxComputeWorkGroupCount,
        max_compute_work_group_invocations = vk_struct.maxComputeWorkGroupInvocations,
        max_compute_work_group_size = vk_struct.maxComputeWorkGroupSize,
        sub_pixel_precision_bits = vk_struct.subPixelPrecisionBits,
        sub_texel_precision_bits = vk_struct.subTexelPrecisionBits,
        mipmap_precision_bits = vk_struct.mipmapPrecisionBits,
        max_draw_indexed_index_value = vk_struct.maxDrawIndexedIndexValue,
        max_draw_indirect_count = vk_struct.maxDrawIndirectCount,
        max_sampler_lod_bias = vk_struct.maxSamplerLodBias,
        max_sampler_anisotropy = vk_struct.maxSamplerAnisotropy,
        max_viewports = vk_struct.maxViewports,
        max_viewport_dimensions = vk_struct.maxViewportDimensions,
        viewport_bounds_range = vk_struct.viewportBoundsRange,
        viewport_sub_pixel_bits = vk_struct.viewportSubPixelBits,
        min_memory_map_alignment = vk_struct.minMemoryMapAlignment,
        min_texel_buffer_offset_alignment = vk_struct.minTexelBufferOffsetAlignment,
        min_uniform_buffer_offset_alignment = vk_struct.minUniformBufferOffsetAlignment,
        min_storage_buffer_offset_alignment = vk_struct.minStorageBufferOffsetAlignment,
        min_texel_offset = vk_struct.minTexelOffset,
        max_texel_offset = vk_struct.maxTexelOffset,
        min_texel_gather_offset = vk_struct.minTexelGatherOffset,
        max_texel_gather_offset = vk_struct.maxTexelGatherOffset,
        min_interpolation_offset = vk_struct.minInterpolationOffset,
        max_interpolation_offset = vk_struct.maxInterpolationOffset,
        sub_pixel_interpolation_offset_bits = vk_struct.subPixelInterpolationOffsetBits,
        max_framebuffer_width = vk_struct.maxFramebufferWidth,
        max_framebuffer_height = vk_struct.maxFramebufferHeight,
        max_framebuffer_layers = vk_struct.maxFramebufferLayers,
        framebuffer_color_sample_counts = vk_struct.framebufferColorSampleCounts,
        framebuffer_depth_sample_counts = vk_struct.framebufferDepthSampleCounts,
        framebuffer_stencil_sample_counts = vk_struct.framebufferStencilSampleCounts,
        framebuffer_no_attachments_sample_counts = vk_struct.framebufferNoAttachmentsSampleCounts,
        max_color_attachments = vk_struct.maxColorAttachments,
        sampled_image_color_sample_counts = vk_struct.sampledImageColorSampleCounts,
        sampled_image_integer_sample_counts = vk_struct.sampledImageIntegerSampleCounts,
        sampled_image_depth_sample_counts = vk_struct.sampledImageDepthSampleCounts,
        sampled_image_stencil_sample_counts = vk_struct.sampledImageStencilSampleCounts,
        storage_image_sample_counts = vk_struct.storageImageSampleCounts,
        max_sample_mask_words = vk_struct.maxSampleMaskWords,
        timestamp_compute_and_graphics = vk_struct.timestampComputeAndGraphics,
        timestamp_period = vk_struct.timestampPeriod,
        max_clip_distances = vk_struct.maxClipDistances,
        max_cull_distances = vk_struct.maxCullDistances,
        max_combined_clip_and_cull_distances = vk_struct.maxCombinedClipAndCullDistances,
        discrete_queue_priorities = vk_struct.discreteQueuePriorities,
        point_size_range = vk_struct.pointSizeRange,
        line_width_range = vk_struct.lineWidthRange,
        point_size_granularity = vk_struct.pointSizeGranularity,
        line_width_granularity = vk_struct.lineWidthGranularity,
        strict_lines = vk_struct.strictLines,
        standard_sample_locations = vk_struct.standardSampleLocations,
        optimal_buffer_copy_offset_alignment = vk_struct.optimalBufferCopyOffsetAlignment,
        optimal_buffer_copy_row_pitch_alignment = vk_struct.optimalBufferCopyRowPitchAlignment,
        non_coherent_atom_size = vk_struct.nonCoherentAtomSize
    ]]

//
// PhysicalDeviceProperties
//

struct PhysicalDeviceProperties
    api_version : uint
    driver_version : uint
    vendor_id : uint
    device_id : uint
    device_type : VkPhysicalDeviceType
    device_name : string
    pipeline_cache_uuid : uint8 [16]
    limits : PhysicalDeviceLimits
    sparse_properties : PhysicalDeviceSparseProperties

def vk_value_to_boost(vk_struct : VkPhysicalDeviceProperties) : PhysicalDeviceProperties
    return <- [[PhysicalDeviceProperties
        api_version = vk_struct.apiVersion,
        driver_version = vk_struct.driverVersion,
        vendor_id = vk_struct.vendorID,
        device_id = vk_struct.deviceID,
        device_type = vk_struct.deviceType,
        device_name = vk_value_to_boost(vk_struct.deviceName),
        pipeline_cache_uuid = vk_struct.pipelineCacheUUID,
        limits <- vk_value_to_boost(vk_struct.limits),
        sparse_properties <- vk_value_to_boost(vk_struct.sparseProperties)
    ]]

//
// PhysicalDeviceFeatures
//

struct PhysicalDeviceFeatures
    robust_buffer_access : uint
    full_draw_index_uint_32 : uint
    image_cube_array : uint
    independent_blend : uint
    geometry_shader : uint
    tessellation_shader : uint
    sample_rate_shading : uint
    dual_src_blend : uint
    logic_op : uint
    multi_draw_indirect : uint
    draw_indirect_first_instance : uint
    depth_clamp : uint
    depth_bias_clamp : uint
    fill_mode_non_solid : uint
    depth_bounds : uint
    wide_lines : uint
    large_points : uint
    alpha_to_one : uint
    multi_viewport : uint
    sampler_anisotropy : uint
    texture_compression_etc2 : uint
    texture_compression_astc_ldr : uint
    texture_compression_bc : uint
    occlusion_query_precise : uint
    pipeline_statistics_query : uint
    vertex_pipeline_stores_and_atomics : uint
    fragment_stores_and_atomics : uint
    shader_tessellation_and_geometry_point_size : uint
    shader_image_gather_extended : uint
    shader_storage_image_extended_formats : uint
    shader_storage_image_multisample : uint
    shader_storage_image_read_without_format : uint
    shader_storage_image_write_without_format : uint
    shader_uniform_buffer_array_dynamic_indexing : uint
    shader_sampled_image_array_dynamic_indexing : uint
    shader_storage_buffer_array_dynamic_indexing : uint
    shader_storage_image_array_dynamic_indexing : uint
    shader_clip_distance : uint
    shader_cull_distance : uint
    shader_float_64 : uint
    shader_int_64 : uint
    shader_int_16 : uint
    shader_resource_residency : uint
    shader_resource_min_lod : uint
    sparse_binding : uint
    sparse_residency_buffer : uint
    sparse_residency_image_2d : uint
    sparse_residency_image_3d : uint
    sparse_residency_2samples : uint
    sparse_residency_4samples : uint
    sparse_residency_8samples : uint
    sparse_residency_16samples : uint
    sparse_residency_aliased : uint
    variable_multisample_rate : uint
    inherited_queries : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PhysicalDeviceFeatures
) : VkPhysicalDeviceFeatures

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkPhysicalDeviceFeatures
        robustBufferAccess = boost_struct.robust_buffer_access,
        fullDrawIndexUint32 = boost_struct.full_draw_index_uint_32,
        imageCubeArray = boost_struct.image_cube_array,
        independentBlend = boost_struct.independent_blend,
        geometryShader = boost_struct.geometry_shader,
        tessellationShader = boost_struct.tessellation_shader,
        sampleRateShading = boost_struct.sample_rate_shading,
        dualSrcBlend = boost_struct.dual_src_blend,
        logicOp = boost_struct.logic_op,
        multiDrawIndirect = boost_struct.multi_draw_indirect,
        drawIndirectFirstInstance = boost_struct.draw_indirect_first_instance,
        depthClamp = boost_struct.depth_clamp,
        depthBiasClamp = boost_struct.depth_bias_clamp,
        fillModeNonSolid = boost_struct.fill_mode_non_solid,
        depthBounds = boost_struct.depth_bounds,
        wideLines = boost_struct.wide_lines,
        largePoints = boost_struct.large_points,
        alphaToOne = boost_struct.alpha_to_one,
        multiViewport = boost_struct.multi_viewport,
        samplerAnisotropy = boost_struct.sampler_anisotropy,
        textureCompressionETC2 = boost_struct.texture_compression_etc2,
        textureCompressionASTC_LDR = boost_struct.texture_compression_astc_ldr,
        textureCompressionBC = boost_struct.texture_compression_bc,
        occlusionQueryPrecise = boost_struct.occlusion_query_precise,
        pipelineStatisticsQuery = boost_struct.pipeline_statistics_query,
        vertexPipelineStoresAndAtomics = boost_struct.vertex_pipeline_stores_and_atomics,
        fragmentStoresAndAtomics = boost_struct.fragment_stores_and_atomics,
        shaderTessellationAndGeometryPointSize = boost_struct.shader_tessellation_and_geometry_point_size,
        shaderImageGatherExtended = boost_struct.shader_image_gather_extended,
        shaderStorageImageExtendedFormats = boost_struct.shader_storage_image_extended_formats,
        shaderStorageImageMultisample = boost_struct.shader_storage_image_multisample,
        shaderStorageImageReadWithoutFormat = boost_struct.shader_storage_image_read_without_format,
        shaderStorageImageWriteWithoutFormat = boost_struct.shader_storage_image_write_without_format,
        shaderUniformBufferArrayDynamicIndexing = boost_struct.shader_uniform_buffer_array_dynamic_indexing,
        shaderSampledImageArrayDynamicIndexing = boost_struct.shader_sampled_image_array_dynamic_indexing,
        shaderStorageBufferArrayDynamicIndexing = boost_struct.shader_storage_buffer_array_dynamic_indexing,
        shaderStorageImageArrayDynamicIndexing = boost_struct.shader_storage_image_array_dynamic_indexing,
        shaderClipDistance = boost_struct.shader_clip_distance,
        shaderCullDistance = boost_struct.shader_cull_distance,
        shaderFloat64 = boost_struct.shader_float_64,
        shaderInt64 = boost_struct.shader_int_64,
        shaderInt16 = boost_struct.shader_int_16,
        shaderResourceResidency = boost_struct.shader_resource_residency,
        shaderResourceMinLod = boost_struct.shader_resource_min_lod,
        sparseBinding = boost_struct.sparse_binding,
        sparseResidencyBuffer = boost_struct.sparse_residency_buffer,
        sparseResidencyImage2D = boost_struct.sparse_residency_image_2d,
        sparseResidencyImage3D = boost_struct.sparse_residency_image_3d,
        sparseResidency2Samples = boost_struct.sparse_residency_2samples,
        sparseResidency4Samples = boost_struct.sparse_residency_4samples,
        sparseResidency8Samples = boost_struct.sparse_residency_8samples,
        sparseResidency16Samples = boost_struct.sparse_residency_16samples,
        sparseResidencyAliased = boost_struct.sparse_residency_aliased,
        variableMultisampleRate = boost_struct.variable_multisample_rate,
        inheritedQueries = boost_struct.inherited_queries
    ]]

def vk_view_destroy(var boost_struct : PhysicalDeviceFeatures)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// PhysicalDeviceSparseProperties
//

struct PhysicalDeviceSparseProperties
    residency_standard_2d_block_shape : uint
    residency_standard_2d_multisample_block_shape : uint
    residency_standard_3d_block_shape : uint
    residency_aligned_mip_size : uint
    residency_non_resident_strict : uint

def vk_value_to_boost(vk_struct : VkPhysicalDeviceSparseProperties) : PhysicalDeviceSparseProperties
    return <- [[PhysicalDeviceSparseProperties
        residency_standard_2d_block_shape = vk_struct.residencyStandard2DBlockShape,
        residency_standard_2d_multisample_block_shape = vk_struct.residencyStandard2DMultisampleBlockShape,
        residency_standard_3d_block_shape = vk_struct.residencyStandard3DBlockShape,
        residency_aligned_mip_size = vk_struct.residencyAlignedMipSize,
        residency_non_resident_strict = vk_struct.residencyNonResidentStrict
    ]]

//
// PipelineLayoutCreateInfo
//

struct PipelineLayoutCreateInfo
    flags : uint
    set_layouts : array<DescriptorSetLayout>
    push_constant_ranges : array<PushConstantRange>
    _vk_view_set_layouts : array<VkDescriptorSetLayout>
    _vk_view_push_constant_ranges : array<VkPushConstantRange>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PipelineLayoutCreateInfo
) : VkPipelineLayoutCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_set_layouts <- [{
        for item in boost_struct.set_layouts ;
        item |> boost_value_to_vk()}]

    boost_struct._vk_view_push_constant_ranges <- [{
        for item in boost_struct.push_constant_ranges ;
        item |> vk_view_create_unsafe()}]

    return <- [[ VkPipelineLayoutCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        flags = boost_struct.flags,
        setLayoutCount = uint(boost_struct.set_layouts |> length()),
        pSetLayouts = array_addr_unsafe(boost_struct._vk_view_set_layouts),
        pushConstantRangeCount = uint(boost_struct.push_constant_ranges |> length()),
        pPushConstantRanges = array_addr_unsafe(boost_struct._vk_view_push_constant_ranges)
    ]]

def vk_view_destroy(var boost_struct : PipelineLayoutCreateInfo)
    assert(boost_struct._vk_view__active)
    delete boost_struct._vk_view_set_layouts
    for item in boost_struct.push_constant_ranges
        item |> vk_view_destroy()
    delete boost_struct._vk_view_push_constant_ranges
    boost_struct._vk_view__active = false

//
// PushConstantRange
//

struct PushConstantRange
    stage_flags : uint
    offset : uint
    size : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : PushConstantRange
) : VkPushConstantRange

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkPushConstantRange
        stageFlags = boost_struct.stage_flags,
        offset = boost_struct.offset,
        size = boost_struct.size
    ]]

def vk_view_destroy(var boost_struct : PushConstantRange)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// QueueFamilyProperties
//

struct QueueFamilyProperties
    queue_flags : uint
    queue_count : uint
    timestamp_valid_bits : uint
    min_image_transfer_granularity : Extent3D

def vk_value_to_boost(vk_struct : VkQueueFamilyProperties) : QueueFamilyProperties
    return <- [[QueueFamilyProperties
        queue_flags = vk_struct.queueFlags,
        queue_count = vk_struct.queueCount,
        timestamp_valid_bits = vk_struct.timestampValidBits,
        min_image_transfer_granularity <- vk_value_to_boost(vk_struct.minImageTransferGranularity)
    ]]

//
// RenderPassCreateInfo
//

struct RenderPassCreateInfo
    flags : uint
    attachments : array<AttachmentDescription>
    subpasses : array<SubpassDescription>
    dependencies : array<SubpassDependency>
    _vk_view_attachments : array<VkAttachmentDescription>
    _vk_view_subpasses : array<VkSubpassDescription>
    _vk_view_dependencies : array<VkSubpassDependency>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : RenderPassCreateInfo
) : VkRenderPassCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_attachments <- [{
        for item in boost_struct.attachments ;
        item |> vk_view_create_unsafe()}]

    boost_struct._vk_view_subpasses <- [{
        for item in boost_struct.subpasses ;
        item |> vk_view_create_unsafe()}]

    boost_struct._vk_view_dependencies <- [{
        for item in boost_struct.dependencies ;
        item |> vk_view_create_unsafe()}]

    return <- [[ VkRenderPassCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        flags = boost_struct.flags,
        attachmentCount = uint(boost_struct.attachments |> length()),
        pAttachments = array_addr_unsafe(boost_struct._vk_view_attachments),
        subpassCount = uint(boost_struct.subpasses |> length()),
        pSubpasses = array_addr_unsafe(boost_struct._vk_view_subpasses),
        dependencyCount = uint(boost_struct.dependencies |> length()),
        pDependencies = array_addr_unsafe(boost_struct._vk_view_dependencies)
    ]]

def vk_view_destroy(var boost_struct : RenderPassCreateInfo)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_attachments
    for item in boost_struct.subpasses
        item |> vk_view_destroy()
    delete boost_struct._vk_view_subpasses
    for item in boost_struct.dependencies
        item |> vk_view_destroy()
    delete boost_struct._vk_view_dependencies
    boost_struct._vk_view__active = false

//
// SamplerCreateInfo
//

struct SamplerCreateInfo
    flags : uint
    mag_filter : VkFilter
    min_filter : VkFilter
    mipmap_mode : VkSamplerMipmapMode
    address_mode_u : VkSamplerAddressMode
    address_mode_v : VkSamplerAddressMode
    address_mode_w : VkSamplerAddressMode
    mip_lod_bias : float
    anisotropy_enable : uint
    max_anisotropy : float
    compare_enable : uint
    compare_op : VkCompareOp
    min_lod : float
    max_lod : float
    border_color : VkBorderColor
    unnormalized_coordinates : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SamplerCreateInfo
) : VkSamplerCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkSamplerCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        flags = boost_struct.flags,
        magFilter = boost_struct.mag_filter,
        minFilter = boost_struct.min_filter,
        mipmapMode = boost_struct.mipmap_mode,
        addressModeU = boost_struct.address_mode_u,
        addressModeV = boost_struct.address_mode_v,
        addressModeW = boost_struct.address_mode_w,
        mipLodBias = boost_struct.mip_lod_bias,
        anisotropyEnable = boost_struct.anisotropy_enable,
        maxAnisotropy = boost_struct.max_anisotropy,
        compareEnable = boost_struct.compare_enable,
        compareOp = boost_struct.compare_op,
        minLod = boost_struct.min_lod,
        maxLod = boost_struct.max_lod,
        borderColor = boost_struct.border_color,
        unnormalizedCoordinates = boost_struct.unnormalized_coordinates
    ]]

def vk_view_destroy(var boost_struct : SamplerCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// ShaderModuleCreateInfo
//

struct ShaderModuleCreateInfo
    flags : uint
    code : array<uint8>
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : ShaderModuleCreateInfo
) : VkShaderModuleCreateInfo

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    var vk_p_code : uint ?
    unsafe
        vk_p_code = reinterpret<uint ?>(array_addr_unsafe(boost_struct.code))

    return <- [[ VkShaderModuleCreateInfo
        sType = VkStructureType VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        flags = boost_struct.flags,
        codeSize = uint64(boost_struct.code |> length()),
        pCode = vk_p_code
    ]]

def vk_view_destroy(var boost_struct : ShaderModuleCreateInfo)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SubpassDependency
//

struct SubpassDependency
    src_subpass : uint
    dst_subpass : uint
    src_stage_mask : uint
    dst_stage_mask : uint
    src_access_mask : uint
    dst_access_mask : uint
    dependency_flags : uint
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SubpassDependency
) : VkSubpassDependency

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkSubpassDependency
        srcSubpass = boost_struct.src_subpass,
        dstSubpass = boost_struct.dst_subpass,
        srcStageMask = boost_struct.src_stage_mask,
        dstStageMask = boost_struct.dst_stage_mask,
        srcAccessMask = boost_struct.src_access_mask,
        dstAccessMask = boost_struct.dst_access_mask,
        dependencyFlags = boost_struct.dependency_flags
    ]]

def vk_view_destroy(var boost_struct : SubpassDependency)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

//
// SubpassDescription
//

struct SubpassDescription
    flags : uint
    pipeline_bind_point : VkPipelineBindPoint
    input_attachments : array<AttachmentReference>
    color_attachments : array<AttachmentReference>
    resolve_attachments : array<AttachmentReference>
    p_depth_stencil_attachment : AttachmentReference ?
    preserve_attachments : array<uint>
    _vk_view_input_attachments : array<VkAttachmentReference>
    _vk_view_color_attachments : array<VkAttachmentReference>
    _vk_view_resolve_attachments : array<VkAttachmentReference>
    _vk_view_p_depth_stencil_attachment : VkAttachmentReference ?
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SubpassDescription
) : VkSubpassDescription

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    boost_struct._vk_view_input_attachments <- [{
        for item in boost_struct.input_attachments ;
        item |> vk_view_create_unsafe()}]

    boost_struct._vk_view_color_attachments <- [{
        for item in boost_struct.color_attachments ;
        item |> vk_view_create_unsafe()}]

    boost_struct._vk_view_resolve_attachments <- [{
        for item in boost_struct.resolve_attachments ;
        item |> vk_view_create_unsafe()}]

    if boost_struct.p_depth_stencil_attachment != null
        boost_struct._vk_view_p_depth_stencil_attachment = new VkAttachmentReference
        *(boost_struct._vk_view_p_depth_stencil_attachment) <- (
            *(boost_struct.p_depth_stencil_attachment) |> vk_view_create_unsafe())

    let vk_p_preserve_attachments = array_addr_unsafe(boost_struct.preserve_attachments)

    return <- [[ VkSubpassDescription
        flags = boost_struct.flags,
        pipelineBindPoint = boost_struct.pipeline_bind_point,
        inputAttachmentCount = uint(boost_struct.input_attachments |> length()),
        pInputAttachments = array_addr_unsafe(boost_struct._vk_view_input_attachments),
        colorAttachmentCount = uint(boost_struct.color_attachments |> length()),
        pColorAttachments = array_addr_unsafe(boost_struct._vk_view_color_attachments),
        pResolveAttachments = array_addr_unsafe(boost_struct._vk_view_resolve_attachments),
        pDepthStencilAttachment = boost_struct._vk_view_p_depth_stencil_attachment,
        preserveAttachmentCount = uint(boost_struct.preserve_attachments |> length()),
        pPreserveAttachments = vk_p_preserve_attachments
    ]]

def vk_view_destroy(var boost_struct : SubpassDescription)
    assert(boost_struct._vk_view__active)
    for item in boost_struct.input_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_input_attachments
    for item in boost_struct.color_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_color_attachments
    for item in boost_struct.resolve_attachments
        item |> vk_view_destroy()
    delete boost_struct._vk_view_resolve_attachments
    if boost_struct.p_depth_stencil_attachment != null
        *(boost_struct.p_depth_stencil_attachment) |> vk_view_destroy()
        unsafe
            delete boost_struct._vk_view_p_depth_stencil_attachment
    boost_struct._vk_view__active = false

//
// SurfaceFormatKHR
//

struct SurfaceFormatKHR
    format : VkFormat
    color_space : VkColorSpaceKHR
    _vk_view__active : bool

def vk_view_create_unsafe(var boost_struct : SurfaceFormatKHR
) : VkSurfaceFormatKHR

    assert(!boost_struct._vk_view__active)
    boost_struct._vk_view__active = true

    return <- [[ VkSurfaceFormatKHR
        format = boost_struct.format,
        colorSpace = boost_struct.color_space
    ]]

def vk_view_destroy(var boost_struct : SurfaceFormatKHR)
    assert(boost_struct._vk_view__active)
    boost_struct._vk_view__active = false

def vk_value_to_boost(vk_struct : VkSurfaceFormatKHR) : SurfaceFormatKHR
    return <- [[SurfaceFormatKHR
        format = vk_struct.format,
        color_space = vk_struct.colorSpace
    ]]

//
// Device
//

struct Device
    device : VkDevice

def boost_value_to_vk(b : Device) : VkDevice
    return b.device

def boost_value_to_vk(b : Device ?) : VkDevice ?
    return b?.device

def create_device(
    physical_device : PhysicalDevice = [[ PhysicalDevice ]];
    var create_info : DeviceCreateInfo = [[ DeviceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Device

    var device <- [[ Device
    ]]

    var vk_create_info : VkDeviceCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateDevice(
        boost_value_to_vk(physical_device),
        safe_addr(vk_create_info),
        null,
        safe_addr(device.device)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- device

def finalize(var device : Device explicit)
    vkDestroyDevice(
        boost_value_to_vk(device),
        null
    )
    memzero(device)

//
// CommandPool
//

struct CommandPool
    command_pool : VkCommandPool
    _device : VkDevice

def boost_value_to_vk(b : CommandPool) : VkCommandPool
    return b.command_pool

def boost_value_to_vk(b : CommandPool ?) : VkCommandPool ?
    return b?.command_pool

def create_command_pool(
    device : Device = [[ Device ]];
    var create_info : CommandPoolCreateInfo = [[ CommandPoolCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : CommandPool

    var command_pool <- [[ CommandPool
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkCommandPoolCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateCommandPool(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(command_pool.command_pool)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- command_pool

def finalize(var command_pool : CommandPool explicit)
    vkDestroyCommandPool(
        command_pool._device,
        boost_value_to_vk(command_pool),
        null
    )
    memzero(command_pool)

//
// DescriptorSetLayout
//

struct DescriptorSetLayout
    descriptor_set_layout : VkDescriptorSetLayout
    _device : VkDevice

def boost_value_to_vk(b : DescriptorSetLayout) : VkDescriptorSetLayout
    return b.descriptor_set_layout

def boost_value_to_vk(b : DescriptorSetLayout ?) : VkDescriptorSetLayout ?
    return b?.descriptor_set_layout

def create_descriptor_set_layout(
    device : Device = [[ Device ]];
    var create_info : DescriptorSetLayoutCreateInfo = [[ DescriptorSetLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : DescriptorSetLayout

    var descriptor_set_layout <- [[ DescriptorSetLayout
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkDescriptorSetLayoutCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateDescriptorSetLayout(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(descriptor_set_layout.descriptor_set_layout)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- descriptor_set_layout

def finalize(var descriptor_set_layout : DescriptorSetLayout explicit)
    vkDestroyDescriptorSetLayout(
        descriptor_set_layout._device,
        boost_value_to_vk(descriptor_set_layout),
        null
    )
    memzero(descriptor_set_layout)

//
// Instance
//

struct Instance
    instance : VkInstance

def boost_value_to_vk(b : Instance) : VkInstance
    return b.instance

def boost_value_to_vk(b : Instance ?) : VkInstance ?
    return b?.instance

def create_instance(
    var create_info : InstanceCreateInfo = [[ InstanceCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Instance

    var instance <- [[ Instance
    ]]

    var vk_create_info : VkInstanceCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateInstance(
        safe_addr(vk_create_info),
        null,
        safe_addr(instance.instance)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- instance

def finalize(var instance : Instance explicit)
    vkDestroyInstance(
        boost_value_to_vk(instance),
        null
    )
    memzero(instance)

//
// PhysicalDevice
//

struct PhysicalDevice
    physical_device : VkPhysicalDevice

def boost_value_to_vk(b : PhysicalDevice) : VkPhysicalDevice
    return b.physical_device

def boost_value_to_vk(b : PhysicalDevice ?) : VkPhysicalDevice ?
    return b?.physical_device

struct PhysicalDeviceBatch
    physical_device_batch : array<VkPhysicalDevice>

def split(batch : PhysicalDeviceBatch) : array<PhysicalDevice>
    return <- [{for h in batch.physical_device_batch ;
        [[PhysicalDevice physical_device=h]]}]

def enumerate_physical_devices(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
) : PhysicalDeviceBatch

    var count : uint
    var result_ = VkResult VK_SUCCESS

    result ?? result_ = vkEnumeratePhysicalDevices(
        boost_value_to_vk(instance),
        safe_addr(count),
        null
    )
    assert(result_ == VkResult VK_SUCCESS)

    var vk_handles : array<VkPhysicalDevice>
    if result ?? result_ == VkResult VK_SUCCESS && count > 0u
        vk_handles |> resize(int(count))
        vk_handles |> lock() <| $(thandles)
            result ?? result_ = vkEnumeratePhysicalDevices(
                boost_value_to_vk(instance),
                safe_addr(count),
                addr(thandles[0])
            )
            assert(result_ == VkResult VK_SUCCESS)

    return <- [[PhysicalDeviceBatch physical_device_batch <- vk_handles]]

def enumerate_physical_devices_no_batch(
    instance : Instance;
    var result : VkResult? = [[VkResult?]]
): array<PhysicalDevice>
    var handles <- enumerate_physical_devices(instance, result)
    defer() <| ${ delete handles; }
    return <- handles |> split()

//
// Queue
//

struct Queue
    queue : VkQueue

def boost_value_to_vk(b : Queue) : VkQueue
    return b.queue

def boost_value_to_vk(b : Queue ?) : VkQueue ?
    return b?.queue

def get_device_queue(
    device : Device = [[ Device ]];
    queue_family_index : uint = [[ uint ]];
    queue_index : uint = [[ uint ]]
) : Queue

    var queue <- [[ Queue
    ]]

    vkGetDeviceQueue(
        boost_value_to_vk(device),
        queue_family_index,
        queue_index,
        safe_addr(queue.queue)
    )
    return <- queue

//
// PipelineLayout
//

struct PipelineLayout
    pipeline_layout : VkPipelineLayout
    _device : VkDevice

def boost_value_to_vk(b : PipelineLayout) : VkPipelineLayout
    return b.pipeline_layout

def boost_value_to_vk(b : PipelineLayout ?) : VkPipelineLayout ?
    return b?.pipeline_layout

def create_pipeline_layout(
    device : Device = [[ Device ]];
    var create_info : PipelineLayoutCreateInfo = [[ PipelineLayoutCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : PipelineLayout

    var pipeline_layout <- [[ PipelineLayout
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkPipelineLayoutCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreatePipelineLayout(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(pipeline_layout.pipeline_layout)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- pipeline_layout

def finalize(var pipeline_layout : PipelineLayout explicit)
    vkDestroyPipelineLayout(
        pipeline_layout._device,
        boost_value_to_vk(pipeline_layout),
        null
    )
    memzero(pipeline_layout)

//
// RenderPass
//

struct RenderPass
    render_pass : VkRenderPass
    _device : VkDevice

def boost_value_to_vk(b : RenderPass) : VkRenderPass
    return b.render_pass

def boost_value_to_vk(b : RenderPass ?) : VkRenderPass ?
    return b?.render_pass

def create_render_pass(
    device : Device = [[ Device ]];
    var create_info : RenderPassCreateInfo = [[ RenderPassCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : RenderPass

    var render_pass <- [[ RenderPass
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkRenderPassCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateRenderPass(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(render_pass.render_pass)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- render_pass

def finalize(var render_pass : RenderPass explicit)
    vkDestroyRenderPass(
        render_pass._device,
        boost_value_to_vk(render_pass),
        null
    )
    memzero(render_pass)

//
// Sampler
//

struct Sampler
    sampler : VkSampler
    _device : VkDevice

def boost_value_to_vk(b : Sampler) : VkSampler
    return b.sampler

def boost_value_to_vk(b : Sampler ?) : VkSampler ?
    return b?.sampler

def create_sampler(
    device : Device = [[ Device ]];
    var create_info : SamplerCreateInfo = [[ SamplerCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : Sampler

    var sampler <- [[ Sampler
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkSamplerCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateSampler(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(sampler.sampler)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- sampler

def finalize(var sampler : Sampler explicit)
    vkDestroySampler(
        sampler._device,
        boost_value_to_vk(sampler),
        null
    )
    memzero(sampler)

//
// ShaderModule
//

struct ShaderModule
    shader_module : VkShaderModule
    _device : VkDevice

def boost_value_to_vk(b : ShaderModule) : VkShaderModule
    return b.shader_module

def boost_value_to_vk(b : ShaderModule ?) : VkShaderModule ?
    return b?.shader_module

def create_shader_module(
    device : Device = [[ Device ]];
    var create_info : ShaderModuleCreateInfo = [[ ShaderModuleCreateInfo ]];
    var result : VkResult? = [[VkResult?]]
) : ShaderModule

    var shader_module <- [[ ShaderModule
        _device = boost_value_to_vk(device)
    ]]

    var vk_create_info : VkShaderModuleCreateInfo
    unsafe
        vk_create_info <- create_info |> vk_view_create_unsafe()
    defer() <| ${ create_info |> vk_view_destroy(); }

    var result_ = VkResult VK_SUCCESS
    result ?? result_ = vkCreateShaderModule(
        boost_value_to_vk(device),
        safe_addr(vk_create_info),
        null,
        safe_addr(shader_module.shader_module)
    )
    assert(result_ == VkResult VK_SUCCESS)
    return <- shader_module

def finalize(var shader_module : ShaderModule explicit)
    vkDestroyShaderModule(
        shader_module._device,
        boost_value_to_vk(shader_module),
        null
    )
    memzero(shader_module)
